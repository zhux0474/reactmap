"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.MapUtil = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _Map = _interopRequireDefault(require("ol/Map"));

var _TileWMS = _interopRequireDefault(require("ol/source/TileWMS"));

var _ImageWMS = _interopRequireDefault(require("ol/source/ImageWMS"));

var _Group = _interopRequireDefault(require("ol/layer/Group"));

var _Base = _interopRequireDefault(require("ol/layer/Base"));

var _GeometryCollection = _interopRequireDefault(require("ol/geom/GeometryCollection"));

var _Units = require("ol/proj/Units");

var _UrlUtil = _interopRequireDefault(require("@terrestris/base-util/dist/UrlUtil/UrlUtil"));

var _Logger = _interopRequireDefault(require("@terrestris/base-util/dist/Logger"));

var _FeatureUtil = _interopRequireDefault(require("../FeatureUtil/FeatureUtil"));

var _findIndex = _interopRequireDefault(require("lodash/findIndex"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * Helper class for the OpenLayers map.
 *
 * @class
 */
var MapUtil = /*#__PURE__*/function () {
  function MapUtil() {
    (0, _classCallCheck2["default"])(this, MapUtil);
  }

  (0, _createClass2["default"])(MapUtil, null, [{
    key: "getInteractionsByName",
    value:
    /**
     * Returns all interactions by the given name of a map.
     *
     * @param {ol.Map} map The map to use for lookup.
     * @param {string} name The name of the interaction to look for.
     * @return {ol.interaction[]} The list of result interactions.
     */
    function getInteractionsByName(map, name) {
      var interactionCandidates = [];

      if (!(map instanceof _Map["default"])) {
        _Logger["default"].debug('Input parameter map must be from type `ol.Map`.');

        return interactionCandidates;
      }

      var interactions = map.getInteractions();
      interactions.forEach(function (interaction) {
        if (interaction.get('name') === name) {
          interactionCandidates.push(interaction);
        }
      });
      return interactionCandidates;
    }
    /**
     * Returns all interactions of the given class of the passed map.
     *
     * @param {ol.Map} map The map to use for lookup.
     * @param {ol.interaction} clazz The class of the interaction to look for.
     * @return {ol.interaction[]} The list of result interactions.
     */

  }, {
    key: "getInteractionsByClass",
    value: function getInteractionsByClass(map, clazz) {
      var interactionCandidates = [];

      if (!(map instanceof _Map["default"])) {
        _Logger["default"].debug('Input parameter map must be from type `ol.Map`.');

        return interactionCandidates;
      }

      var interactions = map.getInteractions();
      interactions.forEach(function (interaction) {
        if (interaction instanceof clazz) {
          interactionCandidates.push(interaction);
        }
      });
      return interactionCandidates;
    }
    /**
     * Calculates the appropriate map resolution for a given scale in the given
     * units.
     *
     * See: https://gis.stackexchange.com/questions/158435/
     * how-to-get-current-scale-in-openlayers-3
     *
     * @method
     * @param {number} scale The input scale to calculate the appropriate
     *                       resolution for.
     * @param {string} units The units to use for calculation (m or degrees).
     * @return {number} The calculated resolution.
     */

  }, {
    key: "getResolutionForScale",
    value: function getResolutionForScale(scale, units) {
      var dpi = 25.4 / 0.28;
      var mpu = _Units.METERS_PER_UNIT[units];
      var inchesPerMeter = 39.37;
      return parseFloat(scale) / (mpu * inchesPerMeter * dpi);
    }
    /**
     * Returns the appropriate scale for the given resolution and units.
     *
     * @method
     * @param {number} resolution The resolutions to calculate the scale for.
     * @param {string} units The units the resolution is based on, typically
     *                       either 'm' or 'degrees'.
     * @return {number} The appropriate scale.
     */

  }, {
    key: "getScaleForResolution",
    value: function getScaleForResolution(resolution, units) {
      var dpi = 25.4 / 0.28;
      var mpu = _Units.METERS_PER_UNIT[units];
      var inchesPerMeter = 39.37;
      return parseFloat(resolution) * mpu * inchesPerMeter * dpi;
    }
    /**
     * Returns all layers of a collection. Even the hidden ones.
     *
     * @param {ol.Map|ol.layer.Group} collection The collection to get the layers
     *                                           from. This can be an ol.layer.Group
     *                                           or an ol.Map.
     * @param {Function} [filter] A filter function that receives the layer.
     *                            If it returns true it will be included in the
     *                            returned layers.
     * @return {Array} An array of all Layers.
     */

  }, {
    key: "getAllLayers",
    value: function getAllLayers(collection) {
      var filter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
        return true;
      };

      if (!(collection instanceof _Map["default"]) && !(collection instanceof _Group["default"])) {
        _Logger["default"].error('Input parameter collection must be from type `ol.Map`' + 'or `ol.layer.Group`.');

        return [];
      }

      var layers = collection.getLayers().getArray();
      var allLayers = [];
      layers.forEach(function (layer) {
        if (layer instanceof _Group["default"]) {
          MapUtil.getAllLayers(layer).forEach(function (layeri) {
            if (filter(layeri)) {
              allLayers.push(layeri);
            }
          });
        }

        if (filter(layer)) {
          allLayers.push(layer);
        }
      });
      return allLayers;
    }
    /**
     * Get a layer by its key (ol_uid).
     *
     * @param {ol.Map} map The map to use for lookup.
     * @param {string} ol_uid The ol_uid of a layer.
     * @return {ol.layer.Layer} The layer.
     */

  }, {
    key: "getLayerByName",
    value:
    /**
     * Returns the layer from the provided map by the given name.
     *
     * @param {ol.Map} map The map to use for lookup.
     * @param {string} name The name to get the layer by.
     * @return {ol.Layer} The result layer or undefined if the layer could not
     *                    be found.
     */
    function getLayerByName(map, name) {
      var layers = MapUtil.getAllLayers(map);
      return layers.filter(function (layer) {
        return layer.get('name') === name;
      })[0];
    }
    /**
     * Returns the layer from the provided map by the given name
     * (parameter LAYERS).
     *
     * @param {ol.Map} map The map to use for lookup.
     * @param {string} name The name to get the layer by.
     * @return {ol.Layer} The result layer or undefined if the layer could not
     *                    be found.
     */

  }, {
    key: "getLayerByNameParam",
    value: function getLayerByNameParam(map, name) {
      var layers = MapUtil.getAllLayers(map);
      var layerCandidate;

      var _iterator = _createForOfIteratorHelper(layers),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var layer = _step.value;

          if (layer.getSource && layer.getSource().getParams && layer.getSource().getParams()['LAYERS'] === name) {
            layerCandidate = layer;
            break;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return layerCandidate;
    }
    /**
     * Returns the layer from the provided map by the given feature.
     *
     * @param {ol.Map} map The map to use for lookup.
     * @param {ol.Feature} feature The feature to get the layer by.
     * @param {Array} namespaces list of supported GeoServer namespaces.
     * @return {ol.Layer} The result layer or undefined if the layer could not
     *                    be found.
     */

  }, {
    key: "getLayerByFeature",
    value: function getLayerByFeature(map, feature, namespaces) {
      var featureTypeName = _FeatureUtil["default"].getFeatureTypeName(feature);

      var layerCandidate;

      var _iterator2 = _createForOfIteratorHelper(namespaces),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var namespace = _step2.value;
          var qualifiedFeatureTypeName = "".concat(namespace, ":").concat(featureTypeName);
          var layer = MapUtil.getLayerByNameParam(map, qualifiedFeatureTypeName);

          if (layer) {
            layerCandidate = layer;
            break;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return layerCandidate;
    }
    /**
     * Returns all layers of the specified layer group recursively.
     *
     * @param {ol.Map} map The map to use for lookup.
     * @param {ol.Layer.Group} layerGroup The group to flatten.
     * @return {Array} The (flattened) layers from the group
     */

  }, {
    key: "getLayersByGroup",
    value: function getLayersByGroup(map, layerGroup) {
      var layerCandidates = [];
      layerGroup.getLayers().forEach(function (layer) {
        if (layer instanceof _Group["default"]) {
          layerCandidates.push.apply(layerCandidates, (0, _toConsumableArray2["default"])(MapUtil.getLayersByGroup(map, layer)));
        } else {
          layerCandidates.push(layer);
        }
      });
      return layerCandidates;
    }
    /**
     * Returns the list of layers matching the given pair of properties.
     *
     * @param {ol.Map} map The map to use for lookup.
     * @param {string} key The property key.
     * @param {Object} value The property value.
     *
     * @return {ol.layer.Base[]} The array of matching layers.
     */

  }, {
    key: "getLayersByProperty",
    value: function getLayersByProperty(map, key, value) {
      if (!map || !key) {
        return;
      }

      var mapLayers = MapUtil.getAllLayers(map);
      return mapLayers.filter(function (l) {
        return l.get(key) === value;
      });
    }
    /**
     * Get information about the LayerPosition in the tree.
     *
     * @param {ol.layer.Layer} layer The layer to get the information.
     * @param {ol.layer.Group|ol.Map} [groupLayerOrMap] The groupLayer or map
     *                                                  containing the layer.
     * @return {Object} An object with these keys:
     *    {ol.layer.Group} groupLayer The groupLayer containing the layer.
     *    {Integer} position The position of the layer in the collection.
     */

  }, {
    key: "getLayerPositionInfo",
    value: function getLayerPositionInfo(layer, groupLayerOrMap) {
      var groupLayer = groupLayerOrMap instanceof _Group["default"] ? groupLayerOrMap : groupLayerOrMap.getLayerGroup();
      var layers = groupLayer.getLayers().getArray();
      var info = {};

      if (layers.indexOf(layer) < 0) {
        layers.forEach(function (childLayer) {
          if (childLayer instanceof _Group["default"] && !info.groupLayer) {
            info = MapUtil.getLayerPositionInfo(layer, childLayer);
          }
        });
      } else {
        info.position = layers.indexOf(layer);
        info.groupLayer = groupLayer;
      }

      return info;
    }
    /**
     * Get the getlegendGraphic url of a layer. Designed for geoserver.
     * Currently supported Sources:
     *  - ol.source.TileWms (with url configured)
     *  - ol.source.ImageWms (with url configured)
     *
     * @param {ol.layer.Layer} layer The layer that you want to have a legendUrlfor.
     * @return {string|undefined} The getLegendGraphicUrl.
     */

  }, {
    key: "getLegendGraphicUrl",
    value: function getLegendGraphicUrl(layer, extraParams) {
      if (!layer) {
        _Logger["default"].error('No layer passed to MapUtil.getLegendGraphicUrl.');

        return;
      }

      var source = layer.getSource();

      if (!(layer instanceof _Base["default"]) || !source) {
        _Logger["default"].error('Invalid layer passed to MapUtil.getLegendGraphicUrl.');

        return;
      }

      var isTiledWMS = source instanceof _TileWMS["default"];
      var isImageWMS = source instanceof _ImageWMS["default"];

      if (isTiledWMS || isImageWMS) {
        var _source = layer.getSource();

        var url = isTiledWMS ? _source.getUrls() ? _source.getUrls()[0] : '' : _source.getUrl();
        var params = {
          LAYER: _source.getParams().LAYERS,
          VERSION: '1.3.0',
          SERVICE: 'WMS',
          REQUEST: 'getLegendGraphic',
          FORMAT: 'image/png'
        };

        var queryString = _UrlUtil["default"].objectToRequestString(Object.assign(params, extraParams));

        return /\?/.test(url) ? "".concat(url, "&").concat(queryString) : "".concat(url, "?").concat(queryString);
      } else {
        _Logger["default"].warn("Source of \"".concat(layer.get('name'), "\" is currently not supported ") + "by MapUtil.getLegendGraphicUrl.");

        return;
      }
    }
    /**
     * Checks whether the resolution of the passed map's view lies inside of the
     * min- and max-resolution of the passed layer, e.g. whether the layer should
     * be displayed at the current map view resolution.
     *
     * @param {ol.layer.Layer} layer The layer to check.
     * @param {ol.Map} map The map to get the view resolution for comparison
     *     from.
     * @return {boolean} Whether the resolution of the passed map's view lies
     *     inside of the min- and max-resolution of the passed layer, e.g. whether
     *     the layer should be displayed at the current map view resolution. Will
     *     be `false` when no `layer` or no `map` is passed or if the view of the
     *     map is falsy or does not have a resolution (yet).
     */

  }, {
    key: "layerInResolutionRange",
    value: function layerInResolutionRange(layer, map) {
      var mapView = map && map.getView();
      var currentRes = mapView && mapView.getResolution();

      if (!layer || !mapView || !currentRes) {
        // It is questionable what we should return in this case, I opted for
        // false, since we cannot sanely determine a correct answer.
        return false;
      }

      var layerMinRes = layer.getMinResolution(); // default: 0 if unset

      var layerMaxRes = layer.getMaxResolution(); // default: Infinity if unset
      // minimum resolution is inclusive, maximum resolution exclusive

      var within = currentRes >= layerMinRes && currentRes < layerMaxRes;
      return within;
    }
    /**
     * Rounds a scalenumber in dependency to its size.
     *
     * @param  {number} scale The exact scale
     * @return {number} The roundedScale
     */

  }, {
    key: "roundScale",
    value: function roundScale(scale) {
      var roundScale;

      if (scale < 100) {
        roundScale = Math.round(scale, 10);
      }

      if (scale >= 100 && scale < 10000) {
        roundScale = Math.round(scale / 10) * 10;
      }

      if (scale >= 10000 && scale < 1000000) {
        roundScale = Math.round(scale / 100) * 100;
      }

      if (scale >= 1000000) {
        roundScale = Math.round(scale / 1000) * 1000;
      }

      return roundScale;
    }
    /**
     * Returns the appropriate zoom level for the given scale and units.
      * @method
     * @param {number} scale Map scale to get the zoom for.
     * @param {Array} resolutions Resolutions array.
     * @param {string} units The units the resolutions are based on, typically
     *                       either 'm' or 'degrees'. Default is 'm'.
     *
     * @return {number} Determined zoom level for the given scale.
     */

  }, {
    key: "getZoomForScale",
    value: function getZoomForScale(scale, resolutions) {
      var units = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'm';

      if (Number.isNaN(Number(scale))) {
        return 0;
      }

      if (scale < 0) {
        return 0;
      }

      var calculatedResolution = MapUtil.getResolutionForScale(scale, units);
      var closestVal = resolutions.reduce(function (prev, curr) {
        var res = Math.abs(curr - calculatedResolution) < Math.abs(prev - calculatedResolution) ? curr : prev;
        return res;
      });
      var zoom = (0, _findIndex["default"])(resolutions, function (o) {
        return Math.abs(o - closestVal) <= 1e-10;
      });
      return zoom;
    }
    /**
     * Fits the map's view to the extent of the passed features.
     *
     * @param {ol.Map} map The map to get the view from.
     * @param {ol.Feature[]} features The features to zoom to.
     */

  }, {
    key: "zoomToFeatures",
    value: function zoomToFeatures(map, features) {
      if (!(map instanceof _Map["default"])) {
        return;
      }

      var featGeometries = [];
      features.forEach(function (feature) {
        if (feature.getGeometry() !== null) {
          featGeometries.push(feature.getGeometry());
        }
      });

      if (featGeometries.length > 0) {
        var geomCollection = new _GeometryCollection["default"](featGeometries);
        map.getView().fit(geomCollection.getExtent());
      }
    }
    /**
     * Checks if the given layer is visible for the given resolution.
     *
     * @param {ol.layer.Base} layer The layer.
     * @param {number} resolution The resolution of the map
     */

  }, {
    key: "isInScaleRange",
    value: function isInScaleRange(layer, resolution) {
      return resolution >= layer.get('minResolution') && resolution < layer.get('maxResolution');
    }
  }]);
  return MapUtil;
}();

exports.MapUtil = MapUtil;
(0, _defineProperty2["default"])(MapUtil, "getLayerByOlUid", function (map, ol_uid) {
  var layers = MapUtil.getAllLayers(map);
  var layer = layers.find(function (l) {
    return ol_uid === l.ol_uid.toString();
  });
  return layer;
});
var _default = MapUtil;
exports["default"] = _default;