"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _Feature = _interopRequireDefault(require("ol/Feature"));

var _MultiPolygon = _interopRequireDefault(require("ol/geom/MultiPolygon"));

var _MultiPoint = _interopRequireDefault(require("ol/geom/MultiPoint"));

var _MultiLineString = _interopRequireDefault(require("ol/geom/MultiLineString"));

var _GeoJSON = _interopRequireDefault(require("ol/format/GeoJSON"));

var _buffer = _interopRequireDefault(require("@turf/buffer"));

var _difference2 = _interopRequireDefault(require("@turf/difference"));

var _intersect = _interopRequireDefault(require("@turf/intersect"));

var _union2 = _interopRequireDefault(require("@turf/union"));

var _polygonSplitter = _interopRequireDefault(require("polygon-splitter"));

var _turf = require("@turf/turf");

/**
 * Helper class for the geospatial analysis. Makes use of
 * [Turf.js](http://turfjs.org/).
 *
 * @class GeometryUtil
 */
var GeometryUtil = /*#__PURE__*/function () {
  function GeometryUtil() {
    (0, _classCallCheck2["default"])(this, GeometryUtil);
  }

  (0, _createClass2["default"])(GeometryUtil, null, [{
    key: "splitByLine",
    value:
    /**
     * The prefix used to detect multi geometries.
     * @ignore
     */

    /**
     * Splits an ol.feature with/or ol.geom.Polygon by an ol.feature with/or ol.geom.LineString
     * into an array of instances of ol.feature with/or ol.geom.Polygon.
     * If the target polygon (first param) is of type ol.Feature it will return an
     * array with ol.Feature. If the target polygon (first param) is of type
     * ol.geom.Geometry it will return an array with ol.geom.Geometry.
     *
     * @param {ol.Feature | ol.geom.Polygon} polygon The polygon geometry to split.
     * @param {ol.Feature | ol.geom.LineString} line The line geometry to split the polygon
     *  geometry with.
     * @param {ol.ProjectionLike} projection The EPSG code of the input features.
     *  Default is to EPSG:3857.
     * @returns {ol.Feature[] | ol.geom.Polygon[]} An array of instances of ol.feature
     *  with/or ol.geom.Polygon
     */
    function splitByLine(polygon, line) {
      var projection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'EPSG:3857';
      var geoJsonFormat = new _GeoJSON["default"]({
        dataProjection: 'EPSG:4326',
        featureProjection: projection
      });
      var polygonFeat = polygon instanceof _Feature["default"] ? polygon : new _Feature["default"]({
        geometry: polygon
      });
      var lineFeat = line instanceof _Feature["default"] ? line : new _Feature["default"]({
        geometry: line
      });
      var polyJson = geoJsonFormat.writeGeometryObject(polygonFeat.getGeometry());
      var lineJson = geoJsonFormat.writeGeometryObject(lineFeat.getGeometry());
      var result = (0, _polygonSplitter["default"])(polyJson, lineJson);
      var list = [];
      (0, _turf.flattenReduce)(result, function (acc, feature) {
        if (polygon instanceof _Feature["default"]) {
          acc.push(geoJsonFormat.readFeature(feature));
        } else {
          acc.push(geoJsonFormat.readGeometry(feature.geometry));
        }

        return list;
      }, list);
      return list;
    }
    /**
     * Adds a buffer to a given geometry.
     *
     * If the target is of type ol.Feature it will return an ol.Feature.
     * If the target is of type ol.geom.Geometry it will return ol.geom.Geometry.
     *
     * @param {ol.geom.Geometry | ol.Feature} geometry The geometry.
     * @param {number} radius The buffer to add in meters.
     * @param {string} projection The projection of the input geometry as EPSG code.
     *  Default is to EPSG:3857.
     *
     * @returns {ol.geom.Geometry | ol.Feature} The geometry or feature with the added buffer.
     */

  }, {
    key: "addBuffer",
    value: function addBuffer(geometry) {
      var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var projection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'EPSG:3857';

      if (radius === 0) {
        return geometry;
      }

      var geoJsonFormat = new _GeoJSON["default"]({
        dataProjection: 'EPSG:4326',
        featureProjection: projection
      });
      var geoJson = geometry instanceof _Feature["default"] ? geoJsonFormat.writeFeatureObject(geometry) : geoJsonFormat.writeGeometryObject(geometry);
      var buffered = (0, _buffer["default"])(geoJson, radius, {
        units: 'meters'
      });

      if (geometry instanceof _Feature["default"]) {
        return geoJsonFormat.readFeature(buffered);
      } else {
        return geoJsonFormat.readGeometry(buffered.geometry);
      }
    }
    /**
     * Merges multiple geometries into one MultiGeometry.
     *
     * @param {ol.geom.Geometry[]} geometries An array of ol.geom.geometries;
     * @returns {ol.geom.MultiPoint|ol.geom.MultiPolygon|ol.geom.MultiLineString} A Multigeometry.
     */

  }, {
    key: "mergeGeometries",
    value: function mergeGeometries(geometries) {
      var multiPrefix = GeometryUtil.MULTI_GEOM_PREFIX;
      var geomType = geometries[0].getType();
      var mixedGeometryTypes = false;
      geometries.forEach(function (geometry) {
        if (geomType.replace(multiPrefix, '') !== geometry.getType().replace(multiPrefix, '')) {
          mixedGeometryTypes = true;
        }
      });

      if (mixedGeometryTypes) {
        // Logger.warn('Can not merge mixed geometries into one multigeometry.');
        return undefined;
      } // split all multi-geometries to simple ones if passed geometries are
      // multigeometries


      if (geomType.startsWith(multiPrefix)) {
        var multiGeomPartType = geomType.substring(multiPrefix.length);
        geometries = GeometryUtil.separateGeometries(geometries);
        geomType = multiGeomPartType;
      }

      var multiGeom;
      var append;

      switch (geomType) {
        case 'Polygon':
          multiGeom = new _MultiPolygon["default"]([]);
          append = multiGeom.appendPolygon.bind(multiGeom);
          break;

        case 'Point':
          multiGeom = new _MultiPoint["default"]([]);
          append = multiGeom.appendPoint.bind(multiGeom);
          break;

        case 'LineString':
          multiGeom = new _MultiLineString["default"]([]);
          append = multiGeom.appendLineString.bind(multiGeom);
          break;

        default:
          return undefined;
      }

      geometries.forEach(function (geom) {
        return append(geom);
      });
      return multiGeom;
    }
    /**
     * Splits an array of geometries (and multi geometries) or a single MultiGeom
     * into an array of single geometries.
     *
     * Attention: ol.geom.Circle and ol.geom.LinearRing are not supported.
     *
     * @param {ol.geom.SimpleGeometry|ol.geom.SimpleGeometry[]} geometries An (array of) ol.geom.geometries;
     * @returns {ol.geom.Point[]|ol.geom.Polygon[]|ol.geom.LineString[]} An array of geometries.
     */

  }, {
    key: "separateGeometries",
    value: function separateGeometries(geometries) {
      var separatedGeometries = [];
      geometries = Array.isArray(geometries) ? geometries : [geometries];
      geometries.forEach(function (geometry) {
        var geomType = geometry.getType();

        if (geomType.startsWith(GeometryUtil.MULTI_GEOM_PREFIX)) {
          var multiGeomPartType = geomType.substring(GeometryUtil.MULTI_GEOM_PREFIX.length);

          switch (multiGeomPartType) {
            case 'Polygon':
              separatedGeometries.push.apply(separatedGeometries, (0, _toConsumableArray2["default"])(geometry.getPolygons()));
              break;

            case 'LineString':
              separatedGeometries.push.apply(separatedGeometries, (0, _toConsumableArray2["default"])(geometry.getLineStrings()));
              break;

            case 'Point':
              separatedGeometries.push.apply(separatedGeometries, (0, _toConsumableArray2["default"])(geometry.getPoints()));
              break;

            default:
              break;
          }
        } else {
          separatedGeometries.push(geometry);
        }
      });
      return separatedGeometries;
    }
    /**
     * Takes two or more polygons and returns a combined (Multi-)polygon.
     *
     * @param {ol.geom.Geometry[] | ol.Feature[]} polygons An array of ol.Feature
     *  or ol.geom.Geometry instances of type (Multi-)polygon.
     * @param {string} projection The projection of the input polygons as EPSG code.
     *  Default is to EPSG:3857.
     * @returns {ol.geom.Geometry | ol.Feature} A Feature or Geometry with the
     * combined area of the (Multi-)polygons.
     */

  }, {
    key: "union",
    value: function union(polygons) {
      var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'EPSG:3857';
      var geoJsonFormat = new _GeoJSON["default"]({
        dataProjection: 'EPSG:4326',
        featureProjection: projection
      });
      var invalid = false;
      var geoJsonsFeatures = polygons.map(function (geometry) {
        var feature = geometry instanceof _Feature["default"] ? geometry : new _Feature["default"]({
          geometry: geometry
        });

        if (!['Polygon', 'MultiPolygon'].includes(feature.getGeometry().getType())) {
          invalid = true;
        }

        return geoJsonFormat.writeFeatureObject(feature);
      });

      if (invalid) {
        // Logger.warn('Can only create union of polygons.');
        return undefined;
      }

      var unioned = _union2["default"].apply(void 0, (0, _toConsumableArray2["default"])(geoJsonsFeatures));

      var feature = geoJsonFormat.readFeature(unioned);

      if (polygons[0] instanceof _Feature["default"]) {
        return feature;
      } else {
        return feature.getGeometry();
      }
    }
    /**
     * Finds the difference between two polygons by clipping the second polygon from the first.
     *
     * @param {ol.geom.Geometry | ol.Feature} polygon1 An ol.geom.Geometry or ol.Feature
     * @param {ol.geom.Geometry | ol.Feature} polygon2 An ol.geom.Geometry or ol.Feature
     * @param {string} projection The projection of the input polygons as EPSG code.
     *  Default is to EPSG:3857.
     *
     * @returns {ol.geom.Geometry | ol.Feature} A Feature or Geometry with the area
     *  of polygon1 excluding the area of polygon2. The type of the first polygon
     *  (geometry or feature) determines the return type.
     */

  }, {
    key: "difference",
    value: function difference(polygon1, polygon2) {
      var projection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'EPSG:3857';
      var geoJsonFormat = new _GeoJSON["default"]({
        dataProjection: 'EPSG:4326',
        featureProjection: projection
      });
      var feat1 = polygon1 instanceof _Feature["default"] ? polygon1 : new _Feature["default"]({
        geometry: polygon1
      });
      var feat2 = polygon2 instanceof _Feature["default"] ? polygon2 : new _Feature["default"]({
        geometry: polygon2
      });
      var geojson1 = geoJsonFormat.writeFeatureObject(feat1);
      var geojson2 = geoJsonFormat.writeFeatureObject(feat2);
      var intersection = (0, _difference2["default"])(geojson1, geojson2);
      var feature = geoJsonFormat.readFeature(intersection);

      if (polygon1 instanceof _Feature["default"] && polygon2 instanceof _Feature["default"]) {
        return feature;
      } else {
        return feature.getGeometry();
      }
    }
    /**
     * Takes two polygons and finds their intersection.
     *
     * If the polygons are of type ol.Feature it will return an ol.Feature.
     * If the polygons are of type ol.geom.Geometry it will return an ol.geom.Geometry.
     *
     * @param {ol.geom.Geometry | ol.Feature} polygon1 An ol.geom.Geometry or ol.Feature
     * @param {ol.geom.Geometry | ol.Feature} polygon2 An ol.geom.Geometry or ol.Feature
     * @param {string} projection The projection of the input polygons as EPSG code.
     *  Default is to EPSG:3857.
     *
     * @returns {ol.geom.Geometry | ol.Feature} A Feature or Geometry with the
     * shared area of the two polygons or null if the polygons don't intersect.
     */

  }, {
    key: "intersection",
    value: function intersection(polygon1, polygon2) {
      var projection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'EPSG:3857';
      var geoJsonFormat = new _GeoJSON["default"]({
        dataProjection: 'EPSG:4326',
        featureProjection: projection
      });
      var feat1 = polygon1 instanceof _Feature["default"] ? polygon1 : new _Feature["default"]({
        geometry: polygon1
      });
      var feat2 = polygon2 instanceof _Feature["default"] ? polygon2 : new _Feature["default"]({
        geometry: polygon2
      });
      var geojson1 = geoJsonFormat.writeFeatureObject(feat1);
      var geojson2 = geoJsonFormat.writeFeatureObject(feat2);
      var intersection = (0, _intersect["default"])(geojson1, geojson2);

      if (!intersection) {
        return null;
      }

      var feature = geoJsonFormat.readFeature(intersection);

      if (polygon1 instanceof _Feature["default"] && polygon2 instanceof _Feature["default"]) {
        return feature;
      } else {
        return feature.getGeometry();
      }
    }
  }]);
  return GeometryUtil;
}();

(0, _defineProperty2["default"])(GeometryUtil, "MULTI_GEOM_PREFIX", 'Multi');
var _default = GeometryUtil;
exports["default"] = _default;