(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.polygonsplitter = factory());
})(this, (function () { 'use strict';

    /**
     * Returns a cloned copy of the passed GeoJSON Object, including possible 'Foreign Members'.
     * ~3-5x faster than the common JSON.parse + JSON.stringify combo method.
     *
     * @name clone
     * @param {GeoJSON} geojson GeoJSON Object
     * @returns {GeoJSON} cloned GeoJSON Object
     * @example
     * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]], {color: 'red'});
     *
     * var lineCloned = turf.clone(line);
     */
    function clone(geojson) {
        if (!geojson) {
            throw new Error("geojson is required");
        }
        switch (geojson.type) {
            case "Feature":
                return cloneFeature(geojson);
            case "FeatureCollection":
                return cloneFeatureCollection(geojson);
            case "Point":
            case "LineString":
            case "Polygon":
            case "MultiPoint":
            case "MultiLineString":
            case "MultiPolygon":
            case "GeometryCollection":
                return cloneGeometry(geojson);
            default:
                throw new Error("unknown GeoJSON type");
        }
    }
    /**
     * Clone Feature
     *
     * @private
     * @param {Feature<any>} geojson GeoJSON Feature
     * @returns {Feature<any>} cloned Feature
     */
    function cloneFeature(geojson) {
        var cloned = { type: "Feature" };
        // Preserve Foreign Members
        Object.keys(geojson).forEach(function (key) {
            switch (key) {
                case "type":
                case "properties":
                case "geometry":
                    return;
                default:
                    cloned[key] = geojson[key];
            }
        });
        // Add properties & geometry last
        cloned.properties = cloneProperties(geojson.properties);
        cloned.geometry = cloneGeometry(geojson.geometry);
        return cloned;
    }
    /**
     * Clone Properties
     *
     * @private
     * @param {Object} properties GeoJSON Properties
     * @returns {Object} cloned Properties
     */
    function cloneProperties(properties) {
        var cloned = {};
        if (!properties) {
            return cloned;
        }
        Object.keys(properties).forEach(function (key) {
            var value = properties[key];
            if (typeof value === "object") {
                if (value === null) {
                    // handle null
                    cloned[key] = null;
                }
                else if (Array.isArray(value)) {
                    // handle Array
                    cloned[key] = value.map(function (item) {
                        return item;
                    });
                }
                else {
                    // handle generic Object
                    cloned[key] = cloneProperties(value);
                }
            }
            else {
                cloned[key] = value;
            }
        });
        return cloned;
    }
    /**
     * Clone Feature Collection
     *
     * @private
     * @param {FeatureCollection<any>} geojson GeoJSON Feature Collection
     * @returns {FeatureCollection<any>} cloned Feature Collection
     */
    function cloneFeatureCollection(geojson) {
        var cloned = { type: "FeatureCollection" };
        // Preserve Foreign Members
        Object.keys(geojson).forEach(function (key) {
            switch (key) {
                case "type":
                case "features":
                    return;
                default:
                    cloned[key] = geojson[key];
            }
        });
        // Add features
        cloned.features = geojson.features.map(function (feature) {
            return cloneFeature(feature);
        });
        return cloned;
    }
    /**
     * Clone Geometry
     *
     * @private
     * @param {Geometry<any>} geometry GeoJSON Geometry
     * @returns {Geometry<any>} cloned Geometry
     */
    function cloneGeometry(geometry) {
        var geom = { type: geometry.type };
        if (geometry.bbox) {
            geom.bbox = geometry.bbox;
        }
        if (geometry.type === "GeometryCollection") {
            geom.geometries = geometry.geometries.map(function (g) {
                return cloneGeometry(g);
            });
            return geom;
        }
        geom.coordinates = deepSlice(geometry.coordinates);
        return geom;
    }
    /**
     * Deep Slice coordinates
     *
     * @private
     * @param {Coordinates} coords Coordinates
     * @returns {Coordinates} all coordinates sliced
     */
    function deepSlice(coords) {
        var cloned = coords;
        if (typeof cloned[0] !== "object") {
            return cloned.slice();
        }
        return cloned.map(function (coord) {
            return deepSlice(coord);
        });
    }

    /**
     * @module helpers
     */
    /**
     * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
     *
     * @name featureCollection
     * @param {Feature[]} features input features
     * @param {Object} [options={}] Optional Parameters
     * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
     * @param {string|number} [options.id] Identifier associated with the Feature
     * @returns {FeatureCollection} FeatureCollection of Features
     * @example
     * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});
     * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});
     * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});
     *
     * var collection = turf.featureCollection([
     *   locationA,
     *   locationB,
     *   locationC
     * ]);
     *
     * //=collection
     */
    function featureCollection(features, options) {
        if (options === void 0) { options = {}; }
        var fc = { type: "FeatureCollection" };
        if (options.id) {
            fc.id = options.id;
        }
        if (options.bbox) {
            fc.bbox = options.bbox;
        }
        fc.features = features;
        return fc;
    }
    /**
     * isObject
     *
     * @param {*} input variable to validate
     * @returns {boolean} true/false
     * @example
     * turf.isObject({elevation: 10})
     * //=true
     * turf.isObject('foo')
     * //=false
     */
    function isObject(input) {
        return !!input && input.constructor === Object;
    }

    /**
     * Unwrap coordinates from a Feature, Geometry Object or an Array
     *
     * @name getCoords
     * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array
     * @returns {Array<any>} coordinates
     * @example
     * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);
     *
     * var coords = turf.getCoords(poly);
     * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]
     */
    function getCoords(coords) {
        if (Array.isArray(coords)) {
            return coords;
        }
        // Feature
        if (coords.type === "Feature") {
            if (coords.geometry !== null) {
                return coords.geometry.coordinates;
            }
        }
        else {
            // Geometry
            if (coords.coordinates) {
                return coords.coordinates;
            }
        }
        throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
    }

    /**
     * Takes a ring and return true or false whether or not the ring is clockwise or counter-clockwise.
     *
     * @name booleanClockwise
     * @param {Feature<LineString>|LineString|Array<Array<number>>} line to be evaluated
     * @returns {boolean} true/false
     * @example
     * var clockwiseRing = turf.lineString([[0,0],[1,1],[1,0],[0,0]]);
     * var counterClockwiseRing = turf.lineString([[0,0],[1,0],[1,1],[0,0]]);
     *
     * turf.booleanClockwise(clockwiseRing)
     * //=true
     * turf.booleanClockwise(counterClockwiseRing)
     * //=false
     */
    function booleanClockwise(line) {
        var ring = getCoords(line);
        var sum = 0;
        var i = 1;
        var prev;
        var cur;
        while (i < ring.length) {
            prev = cur || ring[0];
            cur = ring[i];
            sum += (cur[0] - prev[0]) * (cur[1] + prev[1]);
            i++;
        }
        return sum > 0;
    }

    /**
     * Callback for featureEach
     *
     * @callback featureEachCallback
     * @param {Feature<any>} currentFeature The current Feature being processed.
     * @param {number} featureIndex The current index of the Feature being processed.
     */

    /**
     * Iterate over features in any GeoJSON object, similar to
     * Array.forEach.
     *
     * @name featureEach
     * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
     * @param {Function} callback a method that takes (currentFeature, featureIndex)
     * @returns {void}
     * @example
     * var features = turf.featureCollection([
     *   turf.point([26, 37], {foo: 'bar'}),
     *   turf.point([36, 53], {hello: 'world'})
     * ]);
     *
     * turf.featureEach(features, function (currentFeature, featureIndex) {
     *   //=currentFeature
     *   //=featureIndex
     * });
     */
    function featureEach(geojson, callback) {
      if (geojson.type === "Feature") {
        callback(geojson, 0);
      } else if (geojson.type === "FeatureCollection") {
        for (var i = 0; i < geojson.features.length; i++) {
          if (callback(geojson.features[i], i) === false) { break; }
        }
      }
    }

    /**
     * Callback for geomEach
     *
     * @callback geomEachCallback
     * @param {Geometry} currentGeometry The current Geometry being processed.
     * @param {number} featureIndex The current index of the Feature being processed.
     * @param {Object} featureProperties The current Feature Properties being processed.
     * @param {Array<number>} featureBBox The current Feature BBox being processed.
     * @param {number|string} featureId The current Feature Id being processed.
     */

    /**
     * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()
     *
     * @name geomEach
     * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
     * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)
     * @returns {void}
     * @example
     * var features = turf.featureCollection([
     *     turf.point([26, 37], {foo: 'bar'}),
     *     turf.point([36, 53], {hello: 'world'})
     * ]);
     *
     * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
     *   //=currentGeometry
     *   //=featureIndex
     *   //=featureProperties
     *   //=featureBBox
     *   //=featureId
     * });
     */
    function geomEach(geojson, callback) {
      var i,
        j,
        g,
        geometry,
        stopG,
        geometryMaybeCollection,
        isGeometryCollection,
        featureProperties,
        featureBBox,
        featureId,
        featureIndex = 0,
        isFeatureCollection = geojson.type === "FeatureCollection",
        isFeature = geojson.type === "Feature",
        stop = isFeatureCollection ? geojson.features.length : 1;

      // This logic may look a little weird. The reason why it is that way
      // is because it's trying to be fast. GeoJSON supports multiple kinds
      // of objects at its root: FeatureCollection, Features, Geometries.
      // This function has the responsibility of handling all of them, and that
      // means that some of the `for` loops you see below actually just don't apply
      // to certain inputs. For instance, if you give this just a
      // Point geometry, then both loops are short-circuited and all we do
      // is gradually rename the input until it's called 'geometry'.
      //
      // This also aims to allocate as few resources as possible: just a
      // few numbers and booleans, rather than any temporary arrays as would
      // be required with the normalization approach.
      for (i = 0; i < stop; i++) {
        geometryMaybeCollection = isFeatureCollection
          ? geojson.features[i].geometry
          : isFeature
          ? geojson.geometry
          : geojson;
        featureProperties = isFeatureCollection
          ? geojson.features[i].properties
          : isFeature
          ? geojson.properties
          : {};
        featureBBox = isFeatureCollection
          ? geojson.features[i].bbox
          : isFeature
          ? geojson.bbox
          : undefined;
        featureId = isFeatureCollection
          ? geojson.features[i].id
          : isFeature
          ? geojson.id
          : undefined;
        isGeometryCollection = geometryMaybeCollection
          ? geometryMaybeCollection.type === "GeometryCollection"
          : false;
        stopG = isGeometryCollection
          ? geometryMaybeCollection.geometries.length
          : 1;

        for (g = 0; g < stopG; g++) {
          geometry = isGeometryCollection
            ? geometryMaybeCollection.geometries[g]
            : geometryMaybeCollection;

          // Handle null Geometry
          if (geometry === null) {
            if (
              callback(
                null,
                featureIndex,
                featureProperties,
                featureBBox,
                featureId
              ) === false
            )
              { return false; }
            continue;
          }
          switch (geometry.type) {
            case "Point":
            case "LineString":
            case "MultiPoint":
            case "Polygon":
            case "MultiLineString":
            case "MultiPolygon": {
              if (
                callback(
                  geometry,
                  featureIndex,
                  featureProperties,
                  featureBBox,
                  featureId
                ) === false
              )
                { return false; }
              break;
            }
            case "GeometryCollection": {
              for (j = 0; j < geometry.geometries.length; j++) {
                if (
                  callback(
                    geometry.geometries[j],
                    featureIndex,
                    featureProperties,
                    featureBBox,
                    featureId
                  ) === false
                )
                  { return false; }
              }
              break;
            }
            default:
              throw new Error("Unknown Geometry Type");
          }
        }
        // Only increase `featureIndex` per each feature
        featureIndex++;
      }
    }

    /**
     * Rewind {@link LineString|(Multi)LineString} or {@link Polygon|(Multi)Polygon} outer ring counterclockwise and inner rings clockwise (Uses {@link http://en.wikipedia.org/wiki/Shoelace_formula|Shoelace Formula}).
     *
     * @name rewind
     * @param {GeoJSON} geojson input GeoJSON Polygon
     * @param {Object} [options={}] Optional parameters
     * @param {boolean} [options.reverse=false] enable reverse winding
     * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)
     * @returns {GeoJSON} rewind Polygon
     * @example
     * var polygon = turf.polygon([[[121, -29], [138, -29], [138, -18], [121, -18], [121, -29]]]);
     *
     * var rewind = turf.rewind(polygon);
     *
     * //addToMap
     * var addToMap = [rewind];
     */
    function rewind(geojson, options) {
      // Optional parameters
      options = options || {};
      if (!isObject(options)) { throw new Error("options is invalid"); }
      var reverse = options.reverse || false;
      var mutate = options.mutate || false;

      // validation
      if (!geojson) { throw new Error("<geojson> is required"); }
      if (typeof reverse !== "boolean")
        { throw new Error("<reverse> must be a boolean"); }
      if (typeof mutate !== "boolean")
        { throw new Error("<mutate> must be a boolean"); }

      // prevent input mutation
      if (mutate === false) { geojson = clone(geojson); }

      // Support Feature Collection or Geometry Collection
      var results = [];
      switch (geojson.type) {
        case "GeometryCollection":
          geomEach(geojson, function (geometry) {
            rewindFeature(geometry, reverse);
          });
          return geojson;
        case "FeatureCollection":
          featureEach(geojson, function (feature) {
            featureEach(rewindFeature(feature, reverse), function (result) {
              results.push(result);
            });
          });
          return featureCollection(results);
      }
      // Support Feature or Geometry Objects
      return rewindFeature(geojson, reverse);
    }

    /**
     * Rewind
     *
     * @private
     * @param {Geometry|Feature<any>} geojson Geometry or Feature
     * @param {Boolean} [reverse=false] enable reverse winding
     * @returns {Geometry|Feature<any>} rewind Geometry or Feature
     */
    function rewindFeature(geojson, reverse) {
      var type = geojson.type === "Feature" ? geojson.geometry.type : geojson.type;

      // Support all GeoJSON Geometry Objects
      switch (type) {
        case "GeometryCollection":
          geomEach(geojson, function (geometry) {
            rewindFeature(geometry, reverse);
          });
          return geojson;
        case "LineString":
          rewindLineString(getCoords(geojson), reverse);
          return geojson;
        case "Polygon":
          rewindPolygon(getCoords(geojson), reverse);
          return geojson;
        case "MultiLineString":
          getCoords(geojson).forEach(function (lineCoords) {
            rewindLineString(lineCoords, reverse);
          });
          return geojson;
        case "MultiPolygon":
          getCoords(geojson).forEach(function (lineCoords) {
            rewindPolygon(lineCoords, reverse);
          });
          return geojson;
        case "Point":
        case "MultiPoint":
          return geojson;
      }
    }

    /**
     * Rewind LineString - outer ring clockwise
     *
     * @private
     * @param {Array<Array<number>>} coords GeoJSON LineString geometry coordinates
     * @param {Boolean} [reverse=false] enable reverse winding
     * @returns {void} mutates coordinates
     */
    function rewindLineString(coords, reverse) {
      if (booleanClockwise(coords) === reverse) { coords.reverse(); }
    }

    /**
     * Rewind Polygon - outer ring counterclockwise and inner rings clockwise.
     *
     * @private
     * @param {Array<Array<Array<number>>>} coords GeoJSON Polygon geometry coordinates
     * @param {Boolean} [reverse=false] enable reverse winding
     * @returns {void} mutates coordinates
     */
    function rewindPolygon(coords, reverse) {
      // outer ring
      if (booleanClockwise(coords[0]) !== reverse) {
        coords[0].reverse();
      }
      // inner rings
      for (var i = 1; i < coords.length; i++) {
        if (booleanClockwise(coords[i]) === reverse) {
          coords[i].reverse();
        }
      }
    }

    var Edge = function Edge(p1, p2, edgeType, index) {
      this.p1 = p1;
      this.p2 = p2;
      this.edgeType = edgeType;
      this.originalIndex = index;

      this.interiorRing = false;

      this.minX = Math.min(p1.p[0], p2.p[0]);
      this.minY = Math.min(p1.p[1], p2.p[1]);

      this.maxX = Math.max(p1.p[0], p2.p[0]);
      this.maxY = Math.max(p1.p[1], p2.p[1]);

      this.intersectionPoints = [];
      this.nextEdge = null;
    };

    var Point = function Point(p) {
      this.p = p;
    };

    function fillQueue(polygon, line, polyEdges, lineEdges, polylineBbox) {

      var linegeom = line.type === 'Feature' ? line.geometry : line;
      var linecoords = linegeom.type === 'LineString' ? [linegeom.coordinates] : linegeom.coordinates;

      var edgeCount = 0;

      for (var i = 0; i < linecoords.length; i++) {

        var lineLength = linecoords[i].length - 1;
        var p1 = new Point(linecoords[i][0]);
        var p2 = null;
        var prevEdge = {nextEdge: null};

        for (var ii = 0; ii < lineLength; ii++) {
          p2 = new Point(linecoords[i][ii + 1]);
          p1.nextPoint = p2;
          p2.prevPoint = p1;
          var e = new Edge(p1, p2, 'polyline', edgeCount);
          lineEdges.push(e);
          prevEdge.nextEdge = e;
          e.prevEdge = prevEdge;
          polylineBbox[0] = Math.min(polylineBbox[0], p1.p[0]);
          polylineBbox[1] = Math.min(polylineBbox[1], p1.p[1]);
          polylineBbox[2] = Math.max(polylineBbox[2], p1.p[0]);
          polylineBbox[3] = Math.max(polylineBbox[3], p1.p[1]);

          p1 = p2;
          edgeCount = edgeCount + 1;
          prevEdge = e;
        }
        polylineBbox[0] = Math.min(polylineBbox[0], linecoords[i][lineLength][0]);
        polylineBbox[1] = Math.min(polylineBbox[1], linecoords[i][lineLength][1]);
        polylineBbox[2] = Math.max(polylineBbox[2], linecoords[i][lineLength][0]);
        polylineBbox[3] = Math.max(polylineBbox[3], linecoords[i][lineLength][1]);
      }

      var polygeom = polygon.type === 'Feature' ? polygon.geometry : polygon;
      var polycoords = polygeom.type === 'Polygon' ? [polygeom.coordinates] : polygeom.coordinates;

      var polyLength = polycoords.length;

      for (var i$1 = 0; i$1 < polyLength; i$1++) {

        var polyLenth2 = polycoords[i$1].length;

        for (var ii$1 = 0; ii$1 < polyLenth2; ii$1++) {
          var polygonSet = polycoords[i$1][ii$1];
          var polyLenth3 = polygonSet.length;

          var firstPoint = new Point(polygonSet[0]);
          var p1$1 = firstPoint;
          var p2$1 = (void 0), e$1 = null;
          var prevEdge$1 = {nextEdge: null, prevEdge: null};
          var firstEdge = null;

          for (var iii = 1; iii < polyLenth3; iii++) {
            p2$1 = new Point(polygonSet[iii]);
            p1$1.nextPoint = p2$1;
            p2$1.prevPoint = p1$1;

            e$1 = new Edge(p1$1, p2$1, 'polygon', edgeCount);
            prevEdge$1.nextEdge = e$1;
            e$1.prevEdge = prevEdge$1;
            if (iii === 1) { firstEdge = e$1; }

            if (ii$1 > 0) { e$1.interiorRing = true; }
            e$1.intersectPolylineBbox = edgeIntersectsBbox(e$1, polylineBbox);
            polyEdges.push(e$1);

            p1$1 = p2$1;
            edgeCount = edgeCount + 1;
            prevEdge$1 = e$1;
          }

          e$1.nextEdge = firstEdge;
          firstEdge.prevEdge = e$1;
          p2$1.nextPoint = firstPoint.nextPoint;
          firstPoint.prevPoint = p2$1.prevPoint;
        }
      }
    }

    function edgeIntersectsBbox(edge, bbox) {
      if (edge.maxX < bbox[0]) { return false }
      if (edge.minX > bbox[2]) { return false }
      if (edge.maxY < bbox[1]) { return false }
      if (edge.minY > bbox[3]) { return false }
      return true
    }

    var IntersectionPoint = function IntersectionPoint(p, edge1, edge2, isHeadingIn) {
      this.p = p;
      this.polylineEdge = edge1;
      this.polygonEdge = edge2;
      this.isHeadingIn = isHeadingIn;

      this.distanceFromPolylineEdgeStart = distance(this.polylineEdge.p1.p, this.p);
      this.distanceFromPolygonEdgeStart = distance(this.polygonEdge.p1.p, this.p);

      this.polygonEdge.intersectionPoints.push(this);
      this.polylineEdge.intersectionPoints.push(this);

      this.visitCount = 0;
    };

    IntersectionPoint.prototype.incrementVisitCount = function incrementVisitCount () {
      this.visitCount = this.visitCount + 1;
    };

    function distance(p1, p2) {
      var xs = p2[0] - p1[0];
      var ys = p2[1] - p1[1];
      xs *= xs;
      ys *= ys;

      return Math.sqrt(xs + ys)
    }

    var epsilon = 1.1102230246251565e-16;
    var splitter = 134217729;
    var resulterrbound = (3 + 8 * epsilon) * epsilon;

    // fast_expansion_sum_zeroelim routine from oritinal code
    function sum(elen, e, flen, f, h) {
        var Q, Qnew, hh, bvirt;
        var enow = e[0];
        var fnow = f[0];
        var eindex = 0;
        var findex = 0;
        if ((fnow > enow) === (fnow > -enow)) {
            Q = enow;
            enow = e[++eindex];
        } else {
            Q = fnow;
            fnow = f[++findex];
        }
        var hindex = 0;
        if (eindex < elen && findex < flen) {
            if ((fnow > enow) === (fnow > -enow)) {
                Qnew = enow + Q;
                hh = Q - (Qnew - enow);
                enow = e[++eindex];
            } else {
                Qnew = fnow + Q;
                hh = Q - (Qnew - fnow);
                fnow = f[++findex];
            }
            Q = Qnew;
            if (hh !== 0) {
                h[hindex++] = hh;
            }
            while (eindex < elen && findex < flen) {
                if ((fnow > enow) === (fnow > -enow)) {
                    Qnew = Q + enow;
                    bvirt = Qnew - Q;
                    hh = Q - (Qnew - bvirt) + (enow - bvirt);
                    enow = e[++eindex];
                } else {
                    Qnew = Q + fnow;
                    bvirt = Qnew - Q;
                    hh = Q - (Qnew - bvirt) + (fnow - bvirt);
                    fnow = f[++findex];
                }
                Q = Qnew;
                if (hh !== 0) {
                    h[hindex++] = hh;
                }
            }
        }
        while (eindex < elen) {
            Qnew = Q + enow;
            bvirt = Qnew - Q;
            hh = Q - (Qnew - bvirt) + (enow - bvirt);
            enow = e[++eindex];
            Q = Qnew;
            if (hh !== 0) {
                h[hindex++] = hh;
            }
        }
        while (findex < flen) {
            Qnew = Q + fnow;
            bvirt = Qnew - Q;
            hh = Q - (Qnew - bvirt) + (fnow - bvirt);
            fnow = f[++findex];
            Q = Qnew;
            if (hh !== 0) {
                h[hindex++] = hh;
            }
        }
        if (Q !== 0 || hindex === 0) {
            h[hindex++] = Q;
        }
        return hindex;
    }

    function estimate(elen, e) {
        var Q = e[0];
        for (var i = 1; i < elen; i++) { Q += e[i]; }
        return Q;
    }

    function vec(n) {
        return new Float64Array(n);
    }

    var ccwerrboundA = (3 + 16 * epsilon) * epsilon;
    var ccwerrboundB = (2 + 12 * epsilon) * epsilon;
    var ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;

    var B = vec(4);
    var C1 = vec(8);
    var C2 = vec(12);
    var D = vec(16);
    var u = vec(4);

    function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
        var acxtail, acytail, bcxtail, bcytail;
        var bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;

        var acx = ax - cx;
        var bcx = bx - cx;
        var acy = ay - cy;
        var bcy = by - cy;

        s1 = acx * bcy;
        c = splitter * acx;
        ahi = c - (c - acx);
        alo = acx - ahi;
        c = splitter * bcy;
        bhi = c - (c - bcy);
        blo = bcy - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acy * bcx;
        c = splitter * acy;
        ahi = c - (c - acy);
        alo = acy - ahi;
        c = splitter * bcx;
        bhi = c - (c - bcx);
        blo = bcx - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        B[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        B[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        B[2] = _j - (u3 - bvirt) + (_i - bvirt);
        B[3] = u3;

        var det = estimate(4, B);
        var errbound = ccwerrboundB * detsum;
        if (det >= errbound || -det >= errbound) {
            return det;
        }

        bvirt = ax - acx;
        acxtail = ax - (acx + bvirt) + (bvirt - cx);
        bvirt = bx - bcx;
        bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
        bvirt = ay - acy;
        acytail = ay - (acy + bvirt) + (bvirt - cy);
        bvirt = by - bcy;
        bcytail = by - (bcy + bvirt) + (bvirt - cy);

        if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
            return det;
        }

        errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
        det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);
        if (det >= errbound || -det >= errbound) { return det; }

        s1 = acxtail * bcy;
        c = splitter * acxtail;
        ahi = c - (c - acxtail);
        alo = acxtail - ahi;
        c = splitter * bcy;
        bhi = c - (c - bcy);
        blo = bcy - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acytail * bcx;
        c = splitter * acytail;
        ahi = c - (c - acytail);
        alo = acytail - ahi;
        c = splitter * bcx;
        bhi = c - (c - bcx);
        blo = bcx - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        u[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        u[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        u[2] = _j - (u3 - bvirt) + (_i - bvirt);
        u[3] = u3;
        var C1len = sum(4, B, 4, u, C1);

        s1 = acx * bcytail;
        c = splitter * acx;
        ahi = c - (c - acx);
        alo = acx - ahi;
        c = splitter * bcytail;
        bhi = c - (c - bcytail);
        blo = bcytail - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acy * bcxtail;
        c = splitter * acy;
        ahi = c - (c - acy);
        alo = acy - ahi;
        c = splitter * bcxtail;
        bhi = c - (c - bcxtail);
        blo = bcxtail - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        u[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        u[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        u[2] = _j - (u3 - bvirt) + (_i - bvirt);
        u[3] = u3;
        var C2len = sum(C1len, C1, 4, u, C2);

        s1 = acxtail * bcytail;
        c = splitter * acxtail;
        ahi = c - (c - acxtail);
        alo = acxtail - ahi;
        c = splitter * bcytail;
        bhi = c - (c - bcytail);
        blo = bcytail - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acytail * bcxtail;
        c = splitter * acytail;
        ahi = c - (c - acytail);
        alo = acytail - ahi;
        c = splitter * bcxtail;
        bhi = c - (c - bcxtail);
        blo = bcxtail - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        u[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        u[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        u[2] = _j - (u3 - bvirt) + (_i - bvirt);
        u[3] = u3;
        var Dlen = sum(C2len, C2, 4, u, D);

        return D[Dlen - 1];
    }

    function orient2d(ax, ay, bx, by, cx, cy) {
        var detleft = (ay - cy) * (bx - cx);
        var detright = (ax - cx) * (by - cy);
        var det = detleft - detright;

        if (detleft === 0 || detright === 0 || (detleft > 0) !== (detright > 0)) { return det; }

        var detsum = Math.abs(detleft + detright);
        if (Math.abs(det) >= ccwerrboundA * detsum) { return det; }

        return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
    }

    function findIntersectionPoints(polygonEdges, lineEdges, intersectingPoints) {
      var i, ii, iii;
      var count = lineEdges.length;
      var polyCount = polygonEdges.length;
      for (i = 0; i < count; i++) {
        var lineEdge = lineEdges[i];

        for (ii = 0; ii < polyCount; ii++) {
          var polygonEdge = polygonEdges[ii];
          if (!polygonEdge.intersectPolylineBbox) { continue }

          if (polygonEdge.maxX < lineEdge.minX || polygonEdge.minX > lineEdge.maxX) { continue }
          if (polygonEdge.maxY < lineEdge.minY || polygonEdge.minY > lineEdge.maxY) { continue }
          var intersection = getEdgeIntersection(lineEdge, polygonEdge);
          if (intersection !== null) {
            for (iii = 0; iii < intersection.length; iii++) {
              var isHeadingIn = orient2d(polygonEdge.p1.p[0], polygonEdge.p1.p[1], polygonEdge.p2.p[0], polygonEdge.p2.p[1], lineEdge.p1.p[0], lineEdge.p1.p[1]);
              var ip = new IntersectionPoint(intersection[iii], lineEdge, polygonEdge, isHeadingIn > 0);
              intersectingPoints.push(ip);
            }
          }
        }
      }
      lineEdges.forEach(function (edge) {
        edge.intersectionPoints.sort(function (a, b) {
          return a.distanceFromPolylineEdgeStart - b.distanceFromPolylineEdgeStart
        });
      });

      polygonEdges.forEach(function (edge) {
        edge.intersectionPoints.sort(function (a, b) {
          return a.distanceFromPolygonEdgeStart - b.distanceFromPolygonEdgeStart
        });
      });
    }

    var EPSILON = 1e-9;

    function crossProduct(a, b) {
      return (a[0] * b[1]) - (a[1] * b[0])
    }

    function dotProduct(a, b) {
      return (a[0] * b[0]) + (a[1] * b[1])
    }

    function toPoint(p, s, d) {
      return [
        p[0] + s * d[0],
        p[1] + s * d[1]
      ]
    }

    function getEdgeIntersection(lineEdge, potentialEdge, noEndpointTouch) {
      var va = [lineEdge.p2.p[0] - lineEdge.p1.p[0], lineEdge.p2.p[1] - lineEdge.p1.p[1]];
      var vb = [potentialEdge.p2.p[0] - potentialEdge.p1.p[0], potentialEdge.p2.p[1] - potentialEdge.p1.p[1]];

      var e = [potentialEdge.p1.p[0] - lineEdge.p1.p[0], potentialEdge.p1.p[1] - lineEdge.p1.p[1]];
      var kross = crossProduct(va, vb);
      var sqrKross = kross * kross;
      var sqrLenA  = dotProduct(va, va);

      if (sqrKross > 0) {

        var s = crossProduct(e, vb) / kross;
        if (s < 0 || s > 1) { return null }
        var t = crossProduct(e, va) / kross;
        if (t < 0 || t > 1) { return null }
        if (s === 0 || s === 1) {
          // on an endpoint of line segment a
          return noEndpointTouch ? null : [toPoint(lineEdge.p1.p, s, va)]
        }
        if (t === 0 || t === 1) {
          // on an endpoint of line segment b
          return noEndpointTouch ? null : [toPoint(potentialEdge.p1.p, t, vb)]
        }
        return [toPoint(lineEdge.p1.p, s, va)]
      }

      var sqrLenE = dotProduct(e, e);
      kross = crossProduct(e, va);
      sqrKross = kross * kross;

      if (sqrKross > EPSILON * sqrLenA * sqrLenE) { return null }

      var sa = dotProduct(va, e) / sqrLenA;
      var sb = sa + dotProduct(va, vb) / sqrLenA;
      var smin = Math.min(sa, sb);
      var smax = Math.max(sa, sb);

      if (smin <= 1 && smax >= 0) {

        if (smin === 1) { return noEndpointTouch ? null : [toPoint(lineEdge.p1.p, smin > 0 ? smin : 0, va)] }

        if (smax === 0) { return noEndpointTouch ? null : [toPoint(lineEdge.p1.p, smax < 1 ? smax : 1, va)] }

        if (noEndpointTouch && smin === 0 && smax === 1) { return null }

        return [
          toPoint(lineEdge.p1.p, smin > 0 ? smin : 0, va),
          toPoint(lineEdge.p1.p, smax < 1 ? smax : 1, va)
        ]
      }

      return null
    }

    // import { _debugCandidatePoly, _debugIntersectionPoint, _debugLinePoints, _debugIntersectionPoints, _debugPolyStart } from './debug'

    function index (polygon, line) {
      var poly = rewind(polygon);

      var intersections = [];
      var polygonEdges = [];
      var polylineEdges = [];
      var polylineBbox = [Infinity, Infinity, Infinity, Infinity];

      fillQueue(poly, line, polygonEdges, polylineEdges, polylineBbox);

      findIntersectionPoints(polygonEdges, polylineEdges, intersections);

      if (intersections.length === 0) {
        return polygon
      }
      var outPolys = [];
      // _debugIntersectionPoints(intersections)
      // Start the rewiring of the outputs from the first intersection point along the polyline line
      // This step makes a difference (eg see the another.geojson harness file)
      var firstPolyStart = null;
      for (var index = 0; index < polylineEdges.length; index++) {
        var pe = polylineEdges[index];
        if (pe.intersectionPoints) {
          firstPolyStart = pe.intersectionPoints[0];
          break
        }
      }

      var polyStart = firstPolyStart;
      var nextPolyStart = {visitCount: 1};
      // Basically we're going to walk our way around the outside of the polygon
      // to find new output polygons until we get back to the beginning
      while (firstPolyStart !== nextPolyStart) {

        // If we've already visited this intersection point a couple of times we've
        // already used it in it's two output polygons
        // _debugPolyStart(polyStart)

        if (nextPolyStart.visitCount >= 2) {
          var unvisitedPolyFound = false;
          for (var index$1 = 0; index$1 < intersections.length; index$1++) {
            var intersection = intersections[index$1];
            if (intersection.visitCount < 2) {
              polyStart = intersection;
              unvisitedPolyFound = true;
              break
            }
          }
          if (!unvisitedPolyFound) { break }
        }

        polyStart.visitCount = polyStart.visitCount + 1;
        var outPoly = [];
        outPolys.push(outPoly);
        outPoly.push(polyStart.p);

        polyStart.visitCount = polyStart.visitCount + 1;
        var nextIntersection = walkPolygonForwards(polyStart, outPoly);
        // _debugCandidatePoly(outPolys)

        // After we've walked the first stretch of the polygon we now have the
        // starting point for our next output polygon
        nextPolyStart = nextIntersection;


        var methodForPolyline = nextIntersection.isHeadingIn ? walkPolylineForwards : walkPolylineBackwards;

        // An ouput polygon has to contain at least 1 stretch from the original polygon
        // and one stretch from the polyline
        // However it can contain many stretches of each
        // So we walk continually from polyline to polygon collecting the output
        while (nextIntersection !== polyStart) {
          nextIntersection = methodForPolyline(nextIntersection, outPoly);
          // _debugCandidatePoly(outPolys)

          if (nextIntersection !== polyStart) {
            nextIntersection = walkPolygonForwards(nextIntersection, outPoly);
            // _debugCandidatePoly(outPolys)
          }
        }

        if (nextPolyStart.visitCount >= 2) {
          var unvisitedPolyFound$1 = false;
          for (var index$2 = 0; index$2 < intersections.length; index$2++) {
            var intersection$1 = intersections[index$2];
            if (intersection$1.visitCount < 2) {
              polyStart = intersection$1;
              unvisitedPolyFound$1 = true;
              break
            }
          }
          if (unvisitedPolyFound$1) {
            nextPolyStart = polyStart;
          }
        }

        // Finally we set the next start point based on what we found earlier
        polyStart = nextPolyStart;
      }


      return {
        type: 'Feature',
        properties: {},
        geometry: {
          type: 'MultiPolygon',
          coordinates: outPolys.map(function (poly) { return [poly]; })
        }
      }
    }

    // Walk around the polygon collecting vertices
    function walkPolygonForwards(intersectionPoint, outPoly) {
      var nextEdge = intersectionPoint.polygonEdge;
      if (nextEdge.intersectionPoints.length > 1) {
        // _debugIntersectionPoint(intersectionPoint)
        var lastPointOnEdge = nextEdge.intersectionPoints[nextEdge.intersectionPoints.length - 1];
        if (lastPointOnEdge !== intersectionPoint) {
          var currentIndex = findIndexOfIntersectionPoint(intersectionPoint, nextEdge.intersectionPoints);
          var nextIp = nextEdge.intersectionPoints[currentIndex + 1];
          outPoly.push(nextIp.p);
          nextIp.incrementVisitCount();
          return nextIp
        }
      }
      var condition = true;
      while (condition) {
        outPoly.push(nextEdge.p2.p);
        nextEdge = nextEdge.nextEdge;
        if (nextEdge === null) { return intersectionPoint }
        else if (nextEdge.intersectionPoints.length > 0) { condition = false; }
      }
      nextEdge.intersectionPoints[0].incrementVisitCount();
      outPoly.push(nextEdge.intersectionPoints[0].p);
      return nextEdge.intersectionPoints[0]
    }

    // Given a set of intersections find the next one
    function findIndexOfIntersectionPoint(intersection, intersections) {
      for (var index = 0; index < intersections.length; index++) {
        var int = intersections[index];
        if (int === intersection) { return index }
      }
      return null
    }


    function walkPolylineBackwards(intersectionPoint, outPoly) {
      var nextEdge = intersectionPoint.polylineEdge;
      if (nextEdge.intersectionPoints.length === 2) {
        var lastPointOnEdge = nextEdge.intersectionPoints[nextEdge.intersectionPoints.length - 1];
        // debugger
        if (lastPointOnEdge === intersectionPoint) {
          var nextIntersection = nextEdge.intersectionPoints[0];
          outPoly.push(nextIntersection.p);
          nextIntersection.incrementVisitCount();
          return nextIntersection
        } else {
          outPoly.push(lastPointOnEdge.p);
          lastPointOnEdge.incrementVisitCount();
          return lastPointOnEdge
        }
      } else if (nextEdge.intersectionPoints.length > 2) {
        // _debugIntersectionPoint(intersectionPoint)

        var lastPointOnEdge$1 = nextEdge.intersectionPoints[0];
        if (lastPointOnEdge$1 !== intersectionPoint) {
          var currentIndex = findIndexOfIntersectionPoint(intersectionPoint, nextEdge.intersectionPoints);
          var nextIntersection$1 = nextEdge.intersectionPoints[currentIndex - 1];
          outPoly.push(nextIntersection$1.p);
          nextIntersection$1.incrementVisitCount();
          return nextIntersection$1
        }
      }
      var condition = true;
      while (condition) {
        outPoly.push(nextEdge.p1.p);
        nextEdge = nextEdge.prevEdge;
        if (nextEdge.originalIndex === undefined) { return intersectionPoint }
        else if (nextEdge.intersectionPoints.length > 0) {
          condition = false;
        }
      }
      if (nextEdge.originalIndex === undefined) { return intersectionPoint }
      var lastIntersection = nextEdge.intersectionPoints[nextEdge.intersectionPoints.length - 1];
      lastIntersection.incrementVisitCount();
      outPoly.push(lastIntersection.p);
      return lastIntersection
    }

    function walkPolylineForwards(intersectionPoint, outPoly) {
      var nextEdge = intersectionPoint.polylineEdge;
      if (nextEdge.intersectionPoints.length === 2) {
        var lastPointOnEdge = nextEdge.intersectionPoints[nextEdge.intersectionPoints.length - 1];
        if (lastPointOnEdge === intersectionPoint) {
          var nextIntersection = nextEdge.intersectionPoints[0];
          outPoly.push(nextIntersection.p);
          nextIntersection.incrementVisitCount();
          return nextIntersection
        } else {
          outPoly.push(lastPointOnEdge.p);
          lastPointOnEdge.incrementVisitCount();
          return lastPointOnEdge
        }
      } else if (nextEdge.intersectionPoints.length > 2) {
        var lastPointOnEdge$1 = nextEdge.intersectionPoints[nextEdge.intersectionPoints.length - 1];
        if (lastPointOnEdge$1 !== intersectionPoint) {
          var currentIndex = findIndexOfIntersectionPoint(intersectionPoint, nextEdge.intersectionPoints);
          var nextPointOnEdge = nextEdge.intersectionPoints[currentIndex + 1];
          outPoly.push(nextPointOnEdge.p);
          nextPointOnEdge.incrementVisitCount();
          return nextPointOnEdge
        }
      }
      var condition = true;
      while (condition) {
        outPoly.push(nextEdge.p2.p);
        nextEdge = nextEdge.nextEdge;
        if (nextEdge === null) { return intersectionPoint }
        else if (nextEdge.intersectionPoints.length > 0) { condition = false; }
      }
      if (nextEdge === undefined) { return intersectionPoint }
      var lastIntersection = nextEdge.intersectionPoints[0];
      lastIntersection.incrementVisitCount();
      outPoly.push(lastIntersection.p);
      return lastIntersection
    }

    return index;

}));
