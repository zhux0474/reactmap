{"ast":null,"code":"/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v26.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { Autowired, Bean, Optional, PostConstruct } from \"../context/context\";\nimport { BeanStub } from \"../context/beanStub\";\nimport { exists, missing } from \"../utils/generic\";\nimport { last } from \"../utils/array\";\nimport { KeyCode } from '../constants/keyCode';\nimport { CellCtrl } from \"../rendering/cell/cellCtrl\";\nimport { RowCtrl } from \"../rendering/row/rowCtrl\";\nimport { doOnce } from \"../utils/function\";\nimport { Constants } from \"../constants/constants\";\n\nvar NavigationService =\n/** @class */\nfunction (_super) {\n  __extends(NavigationService, _super);\n\n  function NavigationService() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.timeLastPageEventProcessed = 0;\n    return _this;\n  }\n\n  NavigationService.prototype.postConstruct = function () {\n    var _this = this;\n\n    this.ctrlsService.whenReady(function (p) {\n      _this.gridBodyCon = p.gridBodyCtrl;\n    });\n  };\n\n  NavigationService.prototype.handlePageScrollingKey = function (event) {\n    var key = event.which || event.keyCode;\n    var alt = event.altKey;\n    var ctrl = event.ctrlKey || event.metaKey;\n    var currentCell = this.mouseEventService.getCellPositionForEvent(event);\n\n    if (!currentCell) {\n      return false;\n    }\n\n    var processed = false;\n\n    switch (key) {\n      case KeyCode.PAGE_HOME:\n      case KeyCode.PAGE_END:\n        // handle home and end when ctrl & alt are NOT pressed\n        if (!ctrl && !alt) {\n          this.onHomeOrEndKey(key);\n          processed = true;\n        }\n\n        break;\n\n      case KeyCode.LEFT:\n      case KeyCode.RIGHT:\n        // handle left and right when ctrl is pressed only\n        if (ctrl && !alt) {\n          this.onCtrlLeftOrRight(key, currentCell);\n          processed = true;\n        }\n\n        break;\n\n      case KeyCode.UP:\n      case KeyCode.DOWN:\n        // handle up and down when ctrl is pressed only\n        if (ctrl && !alt) {\n          this.onCtrlUpOrDown(key, currentCell);\n          processed = true;\n        }\n\n        break;\n\n      case KeyCode.PAGE_DOWN:\n        // handle page up and page down when ctrl & alt are NOT pressed\n        if (!ctrl && !alt) {\n          this.onPageDown(currentCell);\n          processed = true;\n        }\n\n        break;\n\n      case KeyCode.PAGE_UP:\n        // handle page up and page down when ctrl & alt are NOT pressed\n        if (!ctrl && !alt) {\n          this.onPageUp(currentCell);\n          processed = true;\n        }\n\n        break;\n    }\n\n    if (processed) {\n      event.preventDefault();\n    }\n\n    return processed;\n  }; // the page up/down keys caused a problem, in that if the user\n  // held the page up/down key down, lots of events got generated,\n  // which clogged up the event queue (as they take time to process)\n  // which in turn froze the grid. Logic below makes sure we wait 100ms\n  // between processing the page up/down events, so when user has finger\n  // held down on key, we ignore page up/down events until 100ms has passed,\n  // which effectively empties the queue of page up/down events.\n\n\n  NavigationService.prototype.isTimeSinceLastPageEventToRecent = function () {\n    var now = new Date().getTime();\n    var diff = now - this.timeLastPageEventProcessed;\n    return diff < 100;\n  };\n\n  NavigationService.prototype.setTimeLastPageEventProcessed = function () {\n    this.timeLastPageEventProcessed = new Date().getTime();\n  };\n\n  NavigationService.prototype.navigateTo = function (navigateParams) {\n    var scrollIndex = navigateParams.scrollIndex,\n        scrollType = navigateParams.scrollType,\n        scrollColumn = navigateParams.scrollColumn,\n        focusIndex = navigateParams.focusIndex,\n        focusColumn = navigateParams.focusColumn;\n\n    if (exists(scrollColumn) && !scrollColumn.isPinned()) {\n      this.gridBodyCon.getScrollFeature().ensureColumnVisible(scrollColumn);\n    }\n\n    if (exists(scrollIndex)) {\n      this.gridBodyCon.getScrollFeature().ensureIndexVisible(scrollIndex, scrollType);\n    } // make sure the cell is rendered, needed if we are to focus\n\n\n    this.animationFrameService.flushAllFrames(); // if we don't do this, the range will be left on the last cell, which will leave the last focused cell\n    // highlighted.\n\n    this.focusService.setFocusedCell(focusIndex, focusColumn, null, true);\n\n    if (this.rangeService) {\n      var cellPosition = {\n        rowIndex: focusIndex,\n        rowPinned: null,\n        column: focusColumn\n      };\n      this.rangeService.setRangeToCell(cellPosition);\n    }\n  };\n\n  NavigationService.prototype.onPageDown = function (gridCell) {\n    if (this.isTimeSinceLastPageEventToRecent()) {\n      return;\n    }\n\n    var gridBodyCon = this.ctrlsService.getGridBodyCtrl();\n    var scrollPosition = gridBodyCon.getScrollFeature().getVScrollPosition();\n    var scrollbarWidth = this.gridOptionsWrapper.getScrollbarWidth();\n    var pixelsInOnePage = scrollPosition.bottom - scrollPosition.top;\n\n    if (this.ctrlsService.getCenterRowContainerCtrl().isHorizontalScrollShowing()) {\n      pixelsInOnePage -= scrollbarWidth;\n    }\n\n    var pagingPixelOffset = this.paginationProxy.getPixelOffset();\n    var currentPageBottomPixel = scrollPosition.top + pixelsInOnePage;\n    var currentPageBottomRow = this.paginationProxy.getRowIndexAtPixel(currentPageBottomPixel + pagingPixelOffset);\n    var scrollIndex = currentPageBottomRow;\n    var currentCellPixel = this.paginationProxy.getRow(gridCell.rowIndex).rowTop;\n    var nextCellPixel = currentCellPixel + pixelsInOnePage - pagingPixelOffset;\n    var focusIndex = this.paginationProxy.getRowIndexAtPixel(nextCellPixel + pagingPixelOffset);\n    var pageLastRow = this.paginationProxy.getPageLastRow();\n\n    if (focusIndex > pageLastRow) {\n      focusIndex = pageLastRow;\n    }\n\n    if (scrollIndex > pageLastRow) {\n      scrollIndex = pageLastRow;\n    }\n\n    this.navigateTo({\n      scrollIndex: scrollIndex,\n      scrollType: 'top',\n      scrollColumn: null,\n      focusIndex: focusIndex,\n      focusColumn: gridCell.column\n    });\n    this.setTimeLastPageEventProcessed();\n  };\n\n  NavigationService.prototype.onPageUp = function (gridCell) {\n    if (this.isTimeSinceLastPageEventToRecent()) {\n      return;\n    }\n\n    var gridBodyCon = this.ctrlsService.getGridBodyCtrl();\n    var scrollPosition = gridBodyCon.getScrollFeature().getVScrollPosition();\n    var scrollbarWidth = this.gridOptionsWrapper.getScrollbarWidth();\n    var pixelsInOnePage = scrollPosition.bottom - scrollPosition.top;\n\n    if (this.ctrlsService.getCenterRowContainerCtrl().isHorizontalScrollShowing()) {\n      pixelsInOnePage -= scrollbarWidth;\n    }\n\n    var pagingPixelOffset = this.paginationProxy.getPixelOffset();\n    var currentPageTopPixel = scrollPosition.top;\n    var currentPageTopRow = this.paginationProxy.getRowIndexAtPixel(currentPageTopPixel + pagingPixelOffset);\n    var scrollIndex = currentPageTopRow;\n    var currentRowNode = this.paginationProxy.getRow(gridCell.rowIndex);\n    var nextCellPixel = currentRowNode.rowTop + currentRowNode.rowHeight - pixelsInOnePage - pagingPixelOffset;\n    var focusIndex = this.paginationProxy.getRowIndexAtPixel(nextCellPixel + pagingPixelOffset);\n    var firstRow = this.paginationProxy.getPageFirstRow();\n\n    if (focusIndex < firstRow) {\n      focusIndex = firstRow;\n    }\n\n    if (scrollIndex < firstRow) {\n      scrollIndex = firstRow;\n    }\n\n    this.navigateTo({\n      scrollIndex: scrollIndex,\n      scrollType: 'bottom',\n      scrollColumn: null,\n      focusIndex: focusIndex,\n      focusColumn: gridCell.column\n    });\n    this.setTimeLastPageEventProcessed();\n  };\n\n  NavigationService.prototype.getIndexToFocus = function (indexToScrollTo, isDown) {\n    var indexToFocus = indexToScrollTo; // for SSRM, when user hits ctrl+down, we can end up trying to focus the loading row.\n    // instead we focus the last row with data instead.\n\n    if (isDown) {\n      var node = this.paginationProxy.getRow(indexToScrollTo);\n\n      if (node && node.stub) {\n        indexToFocus -= 1;\n      }\n    }\n\n    return indexToFocus;\n  }; // ctrl + up/down will bring focus to same column, first/last row. no horizontal scrolling.\n\n\n  NavigationService.prototype.onCtrlUpOrDown = function (key, gridCell) {\n    var upKey = key === KeyCode.UP;\n    var rowIndexToScrollTo = upKey ? this.paginationProxy.getPageFirstRow() : this.paginationProxy.getPageLastRow();\n    this.navigateTo({\n      scrollIndex: rowIndexToScrollTo,\n      scrollType: null,\n      scrollColumn: gridCell.column,\n      focusIndex: this.getIndexToFocus(rowIndexToScrollTo, !upKey),\n      focusColumn: gridCell.column\n    });\n  }; // ctrl + left/right will bring focus to same row, first/last cell. no vertical scrolling.\n\n\n  NavigationService.prototype.onCtrlLeftOrRight = function (key, gridCell) {\n    var leftKey = key === KeyCode.LEFT;\n    var allColumns = this.columnModel.getAllDisplayedColumns();\n    var isRtl = this.gridOptionsWrapper.isEnableRtl();\n    var columnToSelect = leftKey !== isRtl ? allColumns[0] : last(allColumns);\n    this.navigateTo({\n      scrollIndex: gridCell.rowIndex,\n      scrollType: null,\n      scrollColumn: columnToSelect,\n      focusIndex: gridCell.rowIndex,\n      focusColumn: columnToSelect\n    });\n  }; // home brings focus to top left cell, end brings focus to bottom right, grid scrolled to bring\n  // same cell into view (which means either scroll all the way up, or all the way down).\n\n\n  NavigationService.prototype.onHomeOrEndKey = function (key) {\n    var homeKey = key === KeyCode.PAGE_HOME;\n    var allColumns = this.columnModel.getAllDisplayedColumns();\n    var columnToSelect = homeKey ? allColumns[0] : last(allColumns);\n    var scrollIndex = homeKey ? this.paginationProxy.getPageFirstRow() : this.paginationProxy.getPageLastRow();\n    this.navigateTo({\n      scrollIndex: scrollIndex,\n      scrollType: null,\n      scrollColumn: columnToSelect,\n      focusIndex: this.getIndexToFocus(scrollIndex, !homeKey),\n      focusColumn: columnToSelect\n    });\n  }; // result of keyboard event\n\n\n  NavigationService.prototype.onTabKeyDown = function (previous, keyboardEvent) {\n    var backwards = keyboardEvent.shiftKey;\n    var movedToNextCell = this.tabToNextCellCommon(previous, backwards);\n\n    if (movedToNextCell) {\n      // only prevent default if we found a cell. so if user is on last cell and hits tab, then we default\n      // to the normal tabbing so user can exit the grid.\n      keyboardEvent.preventDefault();\n      return;\n    } // if we didn't move to next cell, then need to tab out of the cells, ie to the header (if going\n    // backwards)\n\n\n    if (backwards) {\n      var _a = previous.getRowPosition(),\n          rowIndex = _a.rowIndex,\n          rowPinned = _a.rowPinned;\n\n      var firstRow = rowPinned ? rowIndex === 0 : rowIndex === this.paginationProxy.getPageFirstRow();\n\n      if (firstRow) {\n        keyboardEvent.preventDefault();\n        var headerRowIndex = this.headerNavigationService.getHeaderRowCount() - 1;\n        var column = last(this.columnModel.getAllDisplayedColumns());\n        this.focusService.focusHeaderPosition({\n          headerPosition: {\n            headerRowIndex: headerRowIndex,\n            column: column\n          },\n          event: keyboardEvent\n        });\n      }\n    } else {\n      // if the case it's a popup editor, the focus is on the editor and not the previous cell.\n      // in order for the tab navigation to work, we need to focus the browser back onto the\n      // previous cell.\n      if (previous instanceof CellCtrl) {\n        previous.focusCell(true);\n      }\n\n      if (this.focusService.focusNextGridCoreContainer(false)) {\n        keyboardEvent.preventDefault();\n      }\n    }\n  }; // comes from API\n\n\n  NavigationService.prototype.tabToNextCell = function (backwards) {\n    var focusedCell = this.focusService.getFocusedCell(); // if no focus, then cannot navigate\n\n    if (!focusedCell) {\n      return false;\n    }\n\n    var cellOrRow = this.getCellByPosition(focusedCell); // if cell is not rendered, means user has scrolled away from the cell\n    // or that the focusedCell is a Full Width Row\n\n    if (!cellOrRow) {\n      cellOrRow = this.rowRenderer.getRowByPosition(focusedCell);\n\n      if (!cellOrRow || !cellOrRow.isFullWidth()) {\n        return false;\n      }\n    }\n\n    return this.tabToNextCellCommon(cellOrRow, backwards);\n  };\n\n  NavigationService.prototype.tabToNextCellCommon = function (previous, backwards) {\n    var editing = previous.isEditing(); // if cell is not editing, there is still chance row is editing if it's Full Row Editing\n\n    if (!editing && previous instanceof CellCtrl) {\n      var cell = previous;\n      var row = cell.getRowCtrl();\n\n      if (row) {\n        editing = row.isEditing();\n      }\n    }\n\n    var res;\n\n    if (editing) {\n      // if we are editing, we know it's not a Full Width Row (RowComp)\n      if (this.gridOptionsWrapper.isFullRowEdit()) {\n        res = this.moveToNextEditingRow(previous, backwards);\n      } else {\n        res = this.moveToNextEditingCell(previous, backwards);\n      }\n    } else {\n      res = this.moveToNextCellNotEditing(previous, backwards);\n    } // if a cell wasn't found, it's possible that focus was moved to the header\n\n\n    return res || !!this.focusService.getFocusedHeader();\n  };\n\n  NavigationService.prototype.moveToNextEditingCell = function (previousCell, backwards) {\n    var previousPos = previousCell.getCellPosition(); // need to do this before getting next cell to edit, in case the next cell\n    // has editable function (eg colDef.editable=func() ) and it depends on the\n    // result of this cell, so need to save updates from the first edit, in case\n    // the value is referenced in the function.\n\n    previousCell.stopEditing(); // find the next cell to start editing\n\n    var nextCell = this.findNextCellToFocusOn(previousPos, backwards, true);\n\n    if (nextCell == null) {\n      return false;\n    } // only prevent default if we found a cell. so if user is on last cell and hits tab, then we default\n    // to the normal tabbing so user can exit the grid.\n\n\n    nextCell.startEditing(null, null, true);\n    nextCell.focusCell(false);\n    return true;\n  };\n\n  NavigationService.prototype.moveToNextEditingRow = function (previousCell, backwards) {\n    var previousPos = previousCell.getCellPosition(); // find the next cell to start editing\n\n    var nextCell = this.findNextCellToFocusOn(previousPos, backwards, true);\n\n    if (nextCell == null) {\n      return false;\n    }\n\n    var nextPos = nextCell.getCellPosition();\n    var previousEditable = this.isCellEditable(previousPos);\n    var nextEditable = this.isCellEditable(nextPos);\n    var rowsMatch = nextPos && previousPos.rowIndex === nextPos.rowIndex && previousPos.rowPinned === nextPos.rowPinned;\n\n    if (previousEditable) {\n      previousCell.setFocusOutOnEditor();\n    }\n\n    if (!rowsMatch) {\n      var pRow = previousCell.getRowCtrl();\n      pRow.stopEditing();\n      var nRow = nextCell.getRowCtrl();\n      nRow.startRowEditing();\n    }\n\n    if (nextEditable) {\n      nextCell.setFocusInOnEditor();\n      nextCell.focusCell();\n    } else {\n      nextCell.focusCell(true);\n    }\n\n    return true;\n  };\n\n  NavigationService.prototype.moveToNextCellNotEditing = function (previousCell, backwards) {\n    var displayedColumns = this.columnModel.getAllDisplayedColumns();\n    var cellPos;\n\n    if (previousCell instanceof RowCtrl) {\n      cellPos = __assign(__assign({}, previousCell.getRowPosition()), {\n        column: backwards ? displayedColumns[0] : last(displayedColumns)\n      });\n    } else {\n      cellPos = previousCell.getCellPosition();\n    } // find the next cell to start editing\n\n\n    var nextCell = this.findNextCellToFocusOn(cellPos, backwards, false); // only prevent default if we found a cell. so if user is on last cell and hits tab, then we default\n    // to the normal tabbing so user can exit the grid.\n\n    if (nextCell instanceof CellCtrl) {\n      nextCell.focusCell(true);\n    } else if (nextCell) {\n      return this.tryToFocusFullWidthRow(nextCell.getRowPosition(), backwards);\n    }\n\n    return exists(nextCell);\n  }; // called by the cell, when tab is pressed while editing.\n  // @return: RenderedCell when navigation successful, otherwise null\n\n\n  NavigationService.prototype.findNextCellToFocusOn = function (previousPosition, backwards, startEditing) {\n    var nextPosition = previousPosition;\n\n    while (true) {\n      if (!backwards) {\n        nextPosition = this.getLastCellOfColSpan(nextPosition);\n      }\n\n      nextPosition = this.cellNavigationService.getNextTabbedCell(nextPosition, backwards); // allow user to override what cell to go to next\n\n      var userFunc = this.gridOptionsWrapper.getTabToNextCellFunc();\n\n      if (exists(userFunc)) {\n        var params = {\n          backwards: backwards,\n          editing: startEditing,\n          previousCellPosition: previousPosition,\n          nextCellPosition: nextPosition ? nextPosition : null,\n          api: this.gridOptionsWrapper.getApi(),\n          columnApi: this.gridOptionsWrapper.getColumnApi()\n        };\n        var userCell = userFunc(params);\n\n        if (exists(userCell)) {\n          if (userCell.floating) {\n            doOnce(function () {\n              console.warn(\"AG Grid: tabToNextCellFunc return type should have attributes: rowIndex, rowPinned, column. However you had 'floating', maybe you meant 'rowPinned'?\");\n            }, 'no floating in userCell');\n            userCell.rowPinned = userCell.floating;\n          }\n\n          nextPosition = {\n            rowIndex: userCell.rowIndex,\n            column: userCell.column,\n            rowPinned: userCell.rowPinned\n          };\n        } else {\n          nextPosition = null;\n        }\n      } // if no 'next cell', means we have got to last cell of grid, so nothing to move to,\n      // so bottom right cell going forwards, or top left going backwards\n\n\n      if (!nextPosition) {\n        return null;\n      }\n\n      if (nextPosition.rowIndex < 0) {\n        var headerLen = this.headerNavigationService.getHeaderRowCount();\n        this.focusService.focusHeaderPosition({\n          headerPosition: {\n            headerRowIndex: headerLen + nextPosition.rowIndex,\n            column: nextPosition.column\n          }\n        });\n        return null;\n      } // if editing, but cell not editable, skip cell. we do this before we do all of\n      // the 'ensure index visible' and 'flush all frames', otherwise if we are skipping\n      // a bunch of cells (eg 10 rows) then all the work on ensuring cell visible is useless\n      // (except for the last one) which causes grid to stall for a while.\n      // note - for full row edit, we do focus non-editable cells, as the row stays in edit mode.\n\n\n      var fullRowEdit = this.gridOptionsWrapper.isFullRowEdit();\n\n      if (startEditing && !fullRowEdit) {\n        var cellIsEditable = this.isCellEditable(nextPosition);\n\n        if (!cellIsEditable) {\n          continue;\n        }\n      }\n\n      this.ensureCellVisible(nextPosition); // we have to call this after ensureColumnVisible - otherwise it could be a virtual column\n      // or row that is not currently in view, hence the renderedCell would not exist\n\n      var nextCell = this.getCellByPosition(nextPosition); // if next cell is fullWidth row, then no rendered cell,\n      // as fullWidth rows have no cells, so we skip it\n\n      if (!nextCell) {\n        var row = this.rowRenderer.getRowByPosition(nextPosition);\n\n        if (!row || !row.isFullWidth()) {\n          continue;\n        } else {\n          return row;\n        }\n      }\n\n      if (nextCell.isSuppressNavigable()) {\n        continue;\n      } // by default, when we click a cell, it gets selected into a range, so to keep keyboard navigation\n      // consistent, we set into range here also.\n\n\n      if (this.rangeService) {\n        this.rangeService.setRangeToCell(nextPosition);\n      } // we successfully tabbed onto a grid cell, so return true\n\n\n      return nextCell;\n    }\n  };\n\n  NavigationService.prototype.isCellEditable = function (cell) {\n    var rowNode = this.lookupRowNodeForCell(cell);\n\n    if (rowNode) {\n      return cell.column.isCellEditable(rowNode);\n    }\n\n    return false;\n  };\n\n  NavigationService.prototype.getCellByPosition = function (cellPosition) {\n    var rowCtrl = this.rowRenderer.getRowByPosition(cellPosition);\n\n    if (!rowCtrl) {\n      return null;\n    }\n\n    return rowCtrl.getCellCtrl(cellPosition.column);\n  };\n\n  NavigationService.prototype.lookupRowNodeForCell = function (cell) {\n    if (cell.rowPinned === Constants.PINNED_TOP) {\n      return this.pinnedRowModel.getPinnedTopRow(cell.rowIndex);\n    }\n\n    if (cell.rowPinned === Constants.PINNED_BOTTOM) {\n      return this.pinnedRowModel.getPinnedBottomRow(cell.rowIndex);\n    }\n\n    return this.paginationProxy.getRow(cell.rowIndex);\n  }; // we use index for rows, but column object for columns, as the next column (by index) might not\n  // be visible (header grouping) so it's not reliable, so using the column object instead.\n\n\n  NavigationService.prototype.navigateToNextCell = function (event, key, currentCell, allowUserOverride) {\n    // we keep searching for a next cell until we find one. this is how the group rows get skipped\n    var nextCell = currentCell;\n    var hitEdgeOfGrid = false;\n\n    while (nextCell && (nextCell === currentCell || !this.isValidNavigateCell(nextCell))) {\n      // if the current cell is spanning across multiple columns, we need to move\n      // our current position to be the last cell on the right before finding the\n      // the next target.\n      if (this.gridOptionsWrapper.isEnableRtl()) {\n        if (key === KeyCode.LEFT) {\n          nextCell = this.getLastCellOfColSpan(nextCell);\n        }\n      } else if (key === KeyCode.RIGHT) {\n        nextCell = this.getLastCellOfColSpan(nextCell);\n      }\n\n      nextCell = this.cellNavigationService.getNextCellToFocus(key, nextCell); // eg if going down, and nextCell=undefined, means we are gone past the last row\n\n      hitEdgeOfGrid = missing(nextCell);\n    }\n\n    if (hitEdgeOfGrid && event && event.keyCode === KeyCode.UP) {\n      nextCell = {\n        rowIndex: -1,\n        rowPinned: null,\n        column: currentCell.column\n      };\n    } // allow user to override what cell to go to next. when doing normal cell navigation (with keys)\n    // we allow this, however if processing 'enter after edit' we don't allow override\n\n\n    if (allowUserOverride) {\n      var userFunc = this.gridOptionsWrapper.getNavigateToNextCellFunc();\n\n      if (exists(userFunc)) {\n        var params = {\n          key: key,\n          previousCellPosition: currentCell,\n          nextCellPosition: nextCell ? nextCell : null,\n          event: event,\n          api: this.gridOptionsWrapper.getApi(),\n          columnApi: this.gridOptionsWrapper.getColumnApi()\n        };\n        var userCell = userFunc(params);\n\n        if (exists(userCell)) {\n          if (userCell.floating) {\n            doOnce(function () {\n              console.warn(\"AG Grid: tabToNextCellFunc return type should have attributes: rowIndex, rowPinned, column. However you had 'floating', maybe you meant 'rowPinned'?\");\n            }, 'no floating in userCell');\n            userCell.rowPinned = userCell.floating;\n          }\n\n          nextCell = {\n            rowPinned: userCell.rowPinned,\n            rowIndex: userCell.rowIndex,\n            column: userCell.column\n          };\n        } else {\n          nextCell = null;\n        }\n      }\n    } // no next cell means we have reached a grid boundary, eg left, right, top or bottom of grid\n\n\n    if (!nextCell) {\n      return;\n    }\n\n    if (nextCell.rowIndex < 0) {\n      var headerLen = this.headerNavigationService.getHeaderRowCount();\n      this.focusService.focusHeaderPosition({\n        headerPosition: {\n          headerRowIndex: headerLen + nextCell.rowIndex,\n          column: currentCell.column\n        },\n        event: event || undefined\n      });\n      return;\n    } // in case we have col spanning we get the cellComp and use it to get the\n    // position. This was we always focus the first cell inside the spanning.\n\n\n    var normalisedPosition = this.getNormalisedPosition(nextCell);\n\n    if (normalisedPosition) {\n      this.focusPosition(normalisedPosition);\n    } else {\n      this.tryToFocusFullWidthRow(nextCell);\n    }\n  };\n\n  NavigationService.prototype.getNormalisedPosition = function (cellPosition) {\n    // ensureCellVisible first, to make sure cell at position is rendered.\n    this.ensureCellVisible(cellPosition);\n    var cellComp = this.getCellByPosition(cellPosition); // not guaranteed to have a cellComp when using the SSRM as blocks are loading.\n\n    if (!cellComp) {\n      return null;\n    }\n\n    cellPosition = cellComp.getCellPosition(); // we call this again, as nextCell can be different to it's previous value due to Column Spanning\n    // (ie if cursor moving from right to left, and cell is spanning columns, then nextCell was the\n    // last column in the group, however now it's the first column in the group). if we didn't do\n    // ensureCellVisible again, then we could only be showing the last portion (last column) of the\n    // merged cells.\n\n    this.ensureCellVisible(cellPosition);\n    return cellPosition;\n  };\n\n  NavigationService.prototype.tryToFocusFullWidthRow = function (position, backwards) {\n    if (backwards === void 0) {\n      backwards = false;\n    }\n\n    var displayedColumns = this.columnModel.getAllDisplayedColumns();\n    var rowComp = this.rowRenderer.getRowByPosition(position);\n\n    if (!rowComp || !rowComp.isFullWidth()) {\n      return false;\n    }\n\n    var cellPosition = {\n      rowIndex: position.rowIndex,\n      rowPinned: position.rowPinned,\n      column: position.column || (backwards ? last(displayedColumns) : displayedColumns[0])\n    };\n    this.focusPosition(cellPosition);\n    return true;\n  };\n\n  NavigationService.prototype.focusPosition = function (cellPosition) {\n    this.focusService.setFocusedCell(cellPosition.rowIndex, cellPosition.column, cellPosition.rowPinned, true);\n\n    if (this.rangeService) {\n      this.rangeService.setRangeToCell(cellPosition);\n    }\n  };\n\n  NavigationService.prototype.isValidNavigateCell = function (cell) {\n    var rowNode = this.rowPositionUtils.getRowNode(cell); // we do not allow focusing on detail rows and full width rows\n\n    return !!rowNode;\n  };\n\n  NavigationService.prototype.getLastCellOfColSpan = function (cell) {\n    var cellCtrl = this.getCellByPosition(cell);\n\n    if (!cellCtrl) {\n      return cell;\n    }\n\n    var colSpanningList = cellCtrl.getColSpanningList();\n\n    if (colSpanningList.length === 1) {\n      return cell;\n    }\n\n    return {\n      rowIndex: cell.rowIndex,\n      column: last(colSpanningList),\n      rowPinned: cell.rowPinned\n    };\n  };\n\n  NavigationService.prototype.ensureCellVisible = function (gridCell) {\n    // this scrolls the row into view\n    if (missing(gridCell.rowPinned)) {\n      this.gridBodyCon.getScrollFeature().ensureIndexVisible(gridCell.rowIndex);\n    }\n\n    if (!gridCell.column.isPinned()) {\n      this.gridBodyCon.getScrollFeature().ensureColumnVisible(gridCell.column);\n    } // need to nudge the scrolls for the floating items. otherwise when we set focus on a non-visible\n    // floating cell, the scrolls get out of sync\n\n\n    this.gridBodyCon.getScrollFeature().horizontallyScrollHeaderCenterAndFloatingCenter(); // need to flush frames, to make sure the correct cells are rendered\n\n    this.animationFrameService.flushAllFrames();\n  };\n\n  __decorate([Autowired('mouseEventService')], NavigationService.prototype, \"mouseEventService\", void 0);\n\n  __decorate([Autowired('paginationProxy')], NavigationService.prototype, \"paginationProxy\", void 0);\n\n  __decorate([Autowired('focusService')], NavigationService.prototype, \"focusService\", void 0);\n\n  __decorate([Autowired('animationFrameService')], NavigationService.prototype, \"animationFrameService\", void 0);\n\n  __decorate([Optional('rangeService')], NavigationService.prototype, \"rangeService\", void 0);\n\n  __decorate([Autowired('columnModel')], NavigationService.prototype, \"columnModel\", void 0);\n\n  __decorate([Autowired('ctrlsService')], NavigationService.prototype, \"ctrlsService\", void 0);\n\n  __decorate([Autowired('rowRenderer')], NavigationService.prototype, \"rowRenderer\", void 0);\n\n  __decorate([Autowired('headerNavigationService')], NavigationService.prototype, \"headerNavigationService\", void 0);\n\n  __decorate([Autowired(\"rowPositionUtils\")], NavigationService.prototype, \"rowPositionUtils\", void 0);\n\n  __decorate([Autowired(\"cellNavigationService\")], NavigationService.prototype, \"cellNavigationService\", void 0);\n\n  __decorate([Autowired(\"pinnedRowModel\")], NavigationService.prototype, \"pinnedRowModel\", void 0);\n\n  __decorate([PostConstruct], NavigationService.prototype, \"postConstruct\", null);\n\n  NavigationService = __decorate([Bean('navigationService')], NavigationService);\n  return NavigationService;\n}(BeanStub);\n\nexport { NavigationService };","map":{"version":3,"sources":["/Users/rongxuan/Desktop/reactmap/reactmap/node_modules/@ag-grid-community/core/dist/es6/gridBodyComp/navigationService.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","__assign","assign","t","s","i","n","arguments","length","call","apply","__decorate","decorators","target","key","desc","c","r","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","Autowired","Bean","Optional","PostConstruct","BeanStub","exists","missing","last","KeyCode","CellCtrl","RowCtrl","doOnce","Constants","NavigationService","_super","_this","timeLastPageEventProcessed","postConstruct","ctrlsService","whenReady","gridBodyCon","gridBodyCtrl","handlePageScrollingKey","event","which","keyCode","alt","altKey","ctrl","ctrlKey","metaKey","currentCell","mouseEventService","getCellPositionForEvent","processed","PAGE_HOME","PAGE_END","onHomeOrEndKey","LEFT","RIGHT","onCtrlLeftOrRight","UP","DOWN","onCtrlUpOrDown","PAGE_DOWN","onPageDown","PAGE_UP","onPageUp","preventDefault","isTimeSinceLastPageEventToRecent","now","Date","getTime","diff","setTimeLastPageEventProcessed","navigateTo","navigateParams","scrollIndex","scrollType","scrollColumn","focusIndex","focusColumn","isPinned","getScrollFeature","ensureColumnVisible","ensureIndexVisible","animationFrameService","flushAllFrames","focusService","setFocusedCell","rangeService","cellPosition","rowIndex","rowPinned","column","setRangeToCell","gridCell","getGridBodyCtrl","scrollPosition","getVScrollPosition","scrollbarWidth","gridOptionsWrapper","getScrollbarWidth","pixelsInOnePage","bottom","top","getCenterRowContainerCtrl","isHorizontalScrollShowing","pagingPixelOffset","paginationProxy","getPixelOffset","currentPageBottomPixel","currentPageBottomRow","getRowIndexAtPixel","currentCellPixel","getRow","rowTop","nextCellPixel","pageLastRow","getPageLastRow","currentPageTopPixel","currentPageTopRow","currentRowNode","rowHeight","firstRow","getPageFirstRow","getIndexToFocus","indexToScrollTo","isDown","indexToFocus","node","stub","upKey","rowIndexToScrollTo","leftKey","allColumns","columnModel","getAllDisplayedColumns","isRtl","isEnableRtl","columnToSelect","homeKey","onTabKeyDown","previous","keyboardEvent","backwards","shiftKey","movedToNextCell","tabToNextCellCommon","_a","getRowPosition","headerRowIndex","headerNavigationService","getHeaderRowCount","focusHeaderPosition","headerPosition","focusCell","focusNextGridCoreContainer","tabToNextCell","focusedCell","getFocusedCell","cellOrRow","getCellByPosition","rowRenderer","getRowByPosition","isFullWidth","editing","isEditing","cell","row","getRowCtrl","res","isFullRowEdit","moveToNextEditingRow","moveToNextEditingCell","moveToNextCellNotEditing","getFocusedHeader","previousCell","previousPos","getCellPosition","stopEditing","nextCell","findNextCellToFocusOn","startEditing","nextPos","previousEditable","isCellEditable","nextEditable","rowsMatch","setFocusOutOnEditor","pRow","nRow","startRowEditing","setFocusInOnEditor","displayedColumns","cellPos","tryToFocusFullWidthRow","previousPosition","nextPosition","getLastCellOfColSpan","cellNavigationService","getNextTabbedCell","userFunc","getTabToNextCellFunc","params","previousCellPosition","nextCellPosition","api","getApi","columnApi","getColumnApi","userCell","floating","console","warn","headerLen","fullRowEdit","cellIsEditable","ensureCellVisible","isSuppressNavigable","rowNode","lookupRowNodeForCell","rowCtrl","getCellCtrl","PINNED_TOP","pinnedRowModel","getPinnedTopRow","PINNED_BOTTOM","getPinnedBottomRow","navigateToNextCell","allowUserOverride","hitEdgeOfGrid","isValidNavigateCell","getNextCellToFocus","getNavigateToNextCellFunc","undefined","normalisedPosition","getNormalisedPosition","focusPosition","cellComp","position","rowComp","rowPositionUtils","getRowNode","cellCtrl","colSpanningList","getColSpanningList","horizontallyScrollHeaderCenterAndFloatingCenter"],"mappings":"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","sourcesContent":["/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v26.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Autowired, Bean, Optional, PostConstruct } from \"../context/context\";\nimport { BeanStub } from \"../context/beanStub\";\nimport { exists, missing } from \"../utils/generic\";\nimport { last } from \"../utils/array\";\nimport { KeyCode } from '../constants/keyCode';\nimport { CellCtrl } from \"../rendering/cell/cellCtrl\";\nimport { RowCtrl } from \"../rendering/row/rowCtrl\";\nimport { doOnce } from \"../utils/function\";\nimport { Constants } from \"../constants/constants\";\nvar NavigationService = /** @class */ (function (_super) {\n    __extends(NavigationService, _super);\n    function NavigationService() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.timeLastPageEventProcessed = 0;\n        return _this;\n    }\n    NavigationService.prototype.postConstruct = function () {\n        var _this = this;\n        this.ctrlsService.whenReady(function (p) {\n            _this.gridBodyCon = p.gridBodyCtrl;\n        });\n    };\n    NavigationService.prototype.handlePageScrollingKey = function (event) {\n        var key = event.which || event.keyCode;\n        var alt = event.altKey;\n        var ctrl = event.ctrlKey || event.metaKey;\n        var currentCell = this.mouseEventService.getCellPositionForEvent(event);\n        if (!currentCell) {\n            return false;\n        }\n        var processed = false;\n        switch (key) {\n            case KeyCode.PAGE_HOME:\n            case KeyCode.PAGE_END:\n                // handle home and end when ctrl & alt are NOT pressed\n                if (!ctrl && !alt) {\n                    this.onHomeOrEndKey(key);\n                    processed = true;\n                }\n                break;\n            case KeyCode.LEFT:\n            case KeyCode.RIGHT:\n                // handle left and right when ctrl is pressed only\n                if (ctrl && !alt) {\n                    this.onCtrlLeftOrRight(key, currentCell);\n                    processed = true;\n                }\n                break;\n            case KeyCode.UP:\n            case KeyCode.DOWN:\n                // handle up and down when ctrl is pressed only\n                if (ctrl && !alt) {\n                    this.onCtrlUpOrDown(key, currentCell);\n                    processed = true;\n                }\n                break;\n            case KeyCode.PAGE_DOWN:\n                // handle page up and page down when ctrl & alt are NOT pressed\n                if (!ctrl && !alt) {\n                    this.onPageDown(currentCell);\n                    processed = true;\n                }\n                break;\n            case KeyCode.PAGE_UP:\n                // handle page up and page down when ctrl & alt are NOT pressed\n                if (!ctrl && !alt) {\n                    this.onPageUp(currentCell);\n                    processed = true;\n                }\n                break;\n        }\n        if (processed) {\n            event.preventDefault();\n        }\n        return processed;\n    };\n    // the page up/down keys caused a problem, in that if the user\n    // held the page up/down key down, lots of events got generated,\n    // which clogged up the event queue (as they take time to process)\n    // which in turn froze the grid. Logic below makes sure we wait 100ms\n    // between processing the page up/down events, so when user has finger\n    // held down on key, we ignore page up/down events until 100ms has passed,\n    // which effectively empties the queue of page up/down events.\n    NavigationService.prototype.isTimeSinceLastPageEventToRecent = function () {\n        var now = new Date().getTime();\n        var diff = now - this.timeLastPageEventProcessed;\n        return (diff < 100);\n    };\n    NavigationService.prototype.setTimeLastPageEventProcessed = function () {\n        this.timeLastPageEventProcessed = new Date().getTime();\n    };\n    NavigationService.prototype.navigateTo = function (navigateParams) {\n        var scrollIndex = navigateParams.scrollIndex, scrollType = navigateParams.scrollType, scrollColumn = navigateParams.scrollColumn, focusIndex = navigateParams.focusIndex, focusColumn = navigateParams.focusColumn;\n        if (exists(scrollColumn) && !scrollColumn.isPinned()) {\n            this.gridBodyCon.getScrollFeature().ensureColumnVisible(scrollColumn);\n        }\n        if (exists(scrollIndex)) {\n            this.gridBodyCon.getScrollFeature().ensureIndexVisible(scrollIndex, scrollType);\n        }\n        // make sure the cell is rendered, needed if we are to focus\n        this.animationFrameService.flushAllFrames();\n        // if we don't do this, the range will be left on the last cell, which will leave the last focused cell\n        // highlighted.\n        this.focusService.setFocusedCell(focusIndex, focusColumn, null, true);\n        if (this.rangeService) {\n            var cellPosition = { rowIndex: focusIndex, rowPinned: null, column: focusColumn };\n            this.rangeService.setRangeToCell(cellPosition);\n        }\n    };\n    NavigationService.prototype.onPageDown = function (gridCell) {\n        if (this.isTimeSinceLastPageEventToRecent()) {\n            return;\n        }\n        var gridBodyCon = this.ctrlsService.getGridBodyCtrl();\n        var scrollPosition = gridBodyCon.getScrollFeature().getVScrollPosition();\n        var scrollbarWidth = this.gridOptionsWrapper.getScrollbarWidth();\n        var pixelsInOnePage = scrollPosition.bottom - scrollPosition.top;\n        if (this.ctrlsService.getCenterRowContainerCtrl().isHorizontalScrollShowing()) {\n            pixelsInOnePage -= scrollbarWidth;\n        }\n        var pagingPixelOffset = this.paginationProxy.getPixelOffset();\n        var currentPageBottomPixel = scrollPosition.top + pixelsInOnePage;\n        var currentPageBottomRow = this.paginationProxy.getRowIndexAtPixel(currentPageBottomPixel + pagingPixelOffset);\n        var scrollIndex = currentPageBottomRow;\n        var currentCellPixel = this.paginationProxy.getRow(gridCell.rowIndex).rowTop;\n        var nextCellPixel = currentCellPixel + pixelsInOnePage - pagingPixelOffset;\n        var focusIndex = this.paginationProxy.getRowIndexAtPixel(nextCellPixel + pagingPixelOffset);\n        var pageLastRow = this.paginationProxy.getPageLastRow();\n        if (focusIndex > pageLastRow) {\n            focusIndex = pageLastRow;\n        }\n        if (scrollIndex > pageLastRow) {\n            scrollIndex = pageLastRow;\n        }\n        this.navigateTo({\n            scrollIndex: scrollIndex,\n            scrollType: 'top',\n            scrollColumn: null,\n            focusIndex: focusIndex,\n            focusColumn: gridCell.column\n        });\n        this.setTimeLastPageEventProcessed();\n    };\n    NavigationService.prototype.onPageUp = function (gridCell) {\n        if (this.isTimeSinceLastPageEventToRecent()) {\n            return;\n        }\n        var gridBodyCon = this.ctrlsService.getGridBodyCtrl();\n        var scrollPosition = gridBodyCon.getScrollFeature().getVScrollPosition();\n        var scrollbarWidth = this.gridOptionsWrapper.getScrollbarWidth();\n        var pixelsInOnePage = scrollPosition.bottom - scrollPosition.top;\n        if (this.ctrlsService.getCenterRowContainerCtrl().isHorizontalScrollShowing()) {\n            pixelsInOnePage -= scrollbarWidth;\n        }\n        var pagingPixelOffset = this.paginationProxy.getPixelOffset();\n        var currentPageTopPixel = scrollPosition.top;\n        var currentPageTopRow = this.paginationProxy.getRowIndexAtPixel(currentPageTopPixel + pagingPixelOffset);\n        var scrollIndex = currentPageTopRow;\n        var currentRowNode = this.paginationProxy.getRow(gridCell.rowIndex);\n        var nextCellPixel = currentRowNode.rowTop + currentRowNode.rowHeight - pixelsInOnePage - pagingPixelOffset;\n        var focusIndex = this.paginationProxy.getRowIndexAtPixel(nextCellPixel + pagingPixelOffset);\n        var firstRow = this.paginationProxy.getPageFirstRow();\n        if (focusIndex < firstRow) {\n            focusIndex = firstRow;\n        }\n        if (scrollIndex < firstRow) {\n            scrollIndex = firstRow;\n        }\n        this.navigateTo({\n            scrollIndex: scrollIndex,\n            scrollType: 'bottom',\n            scrollColumn: null,\n            focusIndex: focusIndex,\n            focusColumn: gridCell.column\n        });\n        this.setTimeLastPageEventProcessed();\n    };\n    NavigationService.prototype.getIndexToFocus = function (indexToScrollTo, isDown) {\n        var indexToFocus = indexToScrollTo;\n        // for SSRM, when user hits ctrl+down, we can end up trying to focus the loading row.\n        // instead we focus the last row with data instead.\n        if (isDown) {\n            var node = this.paginationProxy.getRow(indexToScrollTo);\n            if (node && node.stub) {\n                indexToFocus -= 1;\n            }\n        }\n        return indexToFocus;\n    };\n    // ctrl + up/down will bring focus to same column, first/last row. no horizontal scrolling.\n    NavigationService.prototype.onCtrlUpOrDown = function (key, gridCell) {\n        var upKey = key === KeyCode.UP;\n        var rowIndexToScrollTo = upKey ? this.paginationProxy.getPageFirstRow() : this.paginationProxy.getPageLastRow();\n        this.navigateTo({\n            scrollIndex: rowIndexToScrollTo,\n            scrollType: null,\n            scrollColumn: gridCell.column,\n            focusIndex: this.getIndexToFocus(rowIndexToScrollTo, !upKey),\n            focusColumn: gridCell.column\n        });\n    };\n    // ctrl + left/right will bring focus to same row, first/last cell. no vertical scrolling.\n    NavigationService.prototype.onCtrlLeftOrRight = function (key, gridCell) {\n        var leftKey = key === KeyCode.LEFT;\n        var allColumns = this.columnModel.getAllDisplayedColumns();\n        var isRtl = this.gridOptionsWrapper.isEnableRtl();\n        var columnToSelect = leftKey !== isRtl ? allColumns[0] : last(allColumns);\n        this.navigateTo({\n            scrollIndex: gridCell.rowIndex,\n            scrollType: null,\n            scrollColumn: columnToSelect,\n            focusIndex: gridCell.rowIndex,\n            focusColumn: columnToSelect\n        });\n    };\n    // home brings focus to top left cell, end brings focus to bottom right, grid scrolled to bring\n    // same cell into view (which means either scroll all the way up, or all the way down).\n    NavigationService.prototype.onHomeOrEndKey = function (key) {\n        var homeKey = key === KeyCode.PAGE_HOME;\n        var allColumns = this.columnModel.getAllDisplayedColumns();\n        var columnToSelect = homeKey ? allColumns[0] : last(allColumns);\n        var scrollIndex = homeKey ? this.paginationProxy.getPageFirstRow() : this.paginationProxy.getPageLastRow();\n        this.navigateTo({\n            scrollIndex: scrollIndex,\n            scrollType: null,\n            scrollColumn: columnToSelect,\n            focusIndex: this.getIndexToFocus(scrollIndex, !homeKey),\n            focusColumn: columnToSelect\n        });\n    };\n    // result of keyboard event\n    NavigationService.prototype.onTabKeyDown = function (previous, keyboardEvent) {\n        var backwards = keyboardEvent.shiftKey;\n        var movedToNextCell = this.tabToNextCellCommon(previous, backwards);\n        if (movedToNextCell) {\n            // only prevent default if we found a cell. so if user is on last cell and hits tab, then we default\n            // to the normal tabbing so user can exit the grid.\n            keyboardEvent.preventDefault();\n            return;\n        }\n        // if we didn't move to next cell, then need to tab out of the cells, ie to the header (if going\n        // backwards)\n        if (backwards) {\n            var _a = previous.getRowPosition(), rowIndex = _a.rowIndex, rowPinned = _a.rowPinned;\n            var firstRow = rowPinned ? rowIndex === 0 : rowIndex === this.paginationProxy.getPageFirstRow();\n            if (firstRow) {\n                keyboardEvent.preventDefault();\n                var headerRowIndex = this.headerNavigationService.getHeaderRowCount() - 1;\n                var column = last(this.columnModel.getAllDisplayedColumns());\n                this.focusService.focusHeaderPosition({\n                    headerPosition: { headerRowIndex: headerRowIndex, column: column },\n                    event: keyboardEvent\n                });\n            }\n        }\n        else {\n            // if the case it's a popup editor, the focus is on the editor and not the previous cell.\n            // in order for the tab navigation to work, we need to focus the browser back onto the\n            // previous cell.\n            if (previous instanceof CellCtrl) {\n                previous.focusCell(true);\n            }\n            if (this.focusService.focusNextGridCoreContainer(false)) {\n                keyboardEvent.preventDefault();\n            }\n        }\n    };\n    // comes from API\n    NavigationService.prototype.tabToNextCell = function (backwards) {\n        var focusedCell = this.focusService.getFocusedCell();\n        // if no focus, then cannot navigate\n        if (!focusedCell) {\n            return false;\n        }\n        var cellOrRow = this.getCellByPosition(focusedCell);\n        // if cell is not rendered, means user has scrolled away from the cell\n        // or that the focusedCell is a Full Width Row\n        if (!cellOrRow) {\n            cellOrRow = this.rowRenderer.getRowByPosition(focusedCell);\n            if (!cellOrRow || !cellOrRow.isFullWidth()) {\n                return false;\n            }\n        }\n        return this.tabToNextCellCommon(cellOrRow, backwards);\n    };\n    NavigationService.prototype.tabToNextCellCommon = function (previous, backwards) {\n        var editing = previous.isEditing();\n        // if cell is not editing, there is still chance row is editing if it's Full Row Editing\n        if (!editing && previous instanceof CellCtrl) {\n            var cell = previous;\n            var row = cell.getRowCtrl();\n            if (row) {\n                editing = row.isEditing();\n            }\n        }\n        var res;\n        if (editing) {\n            // if we are editing, we know it's not a Full Width Row (RowComp)\n            if (this.gridOptionsWrapper.isFullRowEdit()) {\n                res = this.moveToNextEditingRow(previous, backwards);\n            }\n            else {\n                res = this.moveToNextEditingCell(previous, backwards);\n            }\n        }\n        else {\n            res = this.moveToNextCellNotEditing(previous, backwards);\n        }\n        // if a cell wasn't found, it's possible that focus was moved to the header\n        return res || !!this.focusService.getFocusedHeader();\n    };\n    NavigationService.prototype.moveToNextEditingCell = function (previousCell, backwards) {\n        var previousPos = previousCell.getCellPosition();\n        // need to do this before getting next cell to edit, in case the next cell\n        // has editable function (eg colDef.editable=func() ) and it depends on the\n        // result of this cell, so need to save updates from the first edit, in case\n        // the value is referenced in the function.\n        previousCell.stopEditing();\n        // find the next cell to start editing\n        var nextCell = this.findNextCellToFocusOn(previousPos, backwards, true);\n        if (nextCell == null) {\n            return false;\n        }\n        // only prevent default if we found a cell. so if user is on last cell and hits tab, then we default\n        // to the normal tabbing so user can exit the grid.\n        nextCell.startEditing(null, null, true);\n        nextCell.focusCell(false);\n        return true;\n    };\n    NavigationService.prototype.moveToNextEditingRow = function (previousCell, backwards) {\n        var previousPos = previousCell.getCellPosition();\n        // find the next cell to start editing\n        var nextCell = this.findNextCellToFocusOn(previousPos, backwards, true);\n        if (nextCell == null) {\n            return false;\n        }\n        var nextPos = nextCell.getCellPosition();\n        var previousEditable = this.isCellEditable(previousPos);\n        var nextEditable = this.isCellEditable(nextPos);\n        var rowsMatch = nextPos && previousPos.rowIndex === nextPos.rowIndex && previousPos.rowPinned === nextPos.rowPinned;\n        if (previousEditable) {\n            previousCell.setFocusOutOnEditor();\n        }\n        if (!rowsMatch) {\n            var pRow = previousCell.getRowCtrl();\n            pRow.stopEditing();\n            var nRow = nextCell.getRowCtrl();\n            nRow.startRowEditing();\n        }\n        if (nextEditable) {\n            nextCell.setFocusInOnEditor();\n            nextCell.focusCell();\n        }\n        else {\n            nextCell.focusCell(true);\n        }\n        return true;\n    };\n    NavigationService.prototype.moveToNextCellNotEditing = function (previousCell, backwards) {\n        var displayedColumns = this.columnModel.getAllDisplayedColumns();\n        var cellPos;\n        if (previousCell instanceof RowCtrl) {\n            cellPos = __assign(__assign({}, previousCell.getRowPosition()), { column: backwards ? displayedColumns[0] : last(displayedColumns) });\n        }\n        else {\n            cellPos = previousCell.getCellPosition();\n        }\n        // find the next cell to start editing\n        var nextCell = this.findNextCellToFocusOn(cellPos, backwards, false);\n        // only prevent default if we found a cell. so if user is on last cell and hits tab, then we default\n        // to the normal tabbing so user can exit the grid.\n        if (nextCell instanceof CellCtrl) {\n            nextCell.focusCell(true);\n        }\n        else if (nextCell) {\n            return this.tryToFocusFullWidthRow(nextCell.getRowPosition(), backwards);\n        }\n        return exists(nextCell);\n    };\n    // called by the cell, when tab is pressed while editing.\n    // @return: RenderedCell when navigation successful, otherwise null\n    NavigationService.prototype.findNextCellToFocusOn = function (previousPosition, backwards, startEditing) {\n        var nextPosition = previousPosition;\n        while (true) {\n            if (!backwards) {\n                nextPosition = this.getLastCellOfColSpan(nextPosition);\n            }\n            nextPosition = this.cellNavigationService.getNextTabbedCell(nextPosition, backwards);\n            // allow user to override what cell to go to next\n            var userFunc = this.gridOptionsWrapper.getTabToNextCellFunc();\n            if (exists(userFunc)) {\n                var params = {\n                    backwards: backwards,\n                    editing: startEditing,\n                    previousCellPosition: previousPosition,\n                    nextCellPosition: nextPosition ? nextPosition : null,\n                    api: this.gridOptionsWrapper.getApi(),\n                    columnApi: this.gridOptionsWrapper.getColumnApi()\n                };\n                var userCell = userFunc(params);\n                if (exists(userCell)) {\n                    if (userCell.floating) {\n                        doOnce(function () { console.warn(\"AG Grid: tabToNextCellFunc return type should have attributes: rowIndex, rowPinned, column. However you had 'floating', maybe you meant 'rowPinned'?\"); }, 'no floating in userCell');\n                        userCell.rowPinned = userCell.floating;\n                    }\n                    nextPosition = {\n                        rowIndex: userCell.rowIndex,\n                        column: userCell.column,\n                        rowPinned: userCell.rowPinned\n                    };\n                }\n                else {\n                    nextPosition = null;\n                }\n            }\n            // if no 'next cell', means we have got to last cell of grid, so nothing to move to,\n            // so bottom right cell going forwards, or top left going backwards\n            if (!nextPosition) {\n                return null;\n            }\n            if (nextPosition.rowIndex < 0) {\n                var headerLen = this.headerNavigationService.getHeaderRowCount();\n                this.focusService.focusHeaderPosition({\n                    headerPosition: {\n                        headerRowIndex: headerLen + (nextPosition.rowIndex),\n                        column: nextPosition.column\n                    }\n                });\n                return null;\n            }\n            // if editing, but cell not editable, skip cell. we do this before we do all of\n            // the 'ensure index visible' and 'flush all frames', otherwise if we are skipping\n            // a bunch of cells (eg 10 rows) then all the work on ensuring cell visible is useless\n            // (except for the last one) which causes grid to stall for a while.\n            // note - for full row edit, we do focus non-editable cells, as the row stays in edit mode.\n            var fullRowEdit = this.gridOptionsWrapper.isFullRowEdit();\n            if (startEditing && !fullRowEdit) {\n                var cellIsEditable = this.isCellEditable(nextPosition);\n                if (!cellIsEditable) {\n                    continue;\n                }\n            }\n            this.ensureCellVisible(nextPosition);\n            // we have to call this after ensureColumnVisible - otherwise it could be a virtual column\n            // or row that is not currently in view, hence the renderedCell would not exist\n            var nextCell = this.getCellByPosition(nextPosition);\n            // if next cell is fullWidth row, then no rendered cell,\n            // as fullWidth rows have no cells, so we skip it\n            if (!nextCell) {\n                var row = this.rowRenderer.getRowByPosition(nextPosition);\n                if (!row || !row.isFullWidth()) {\n                    continue;\n                }\n                else {\n                    return row;\n                }\n            }\n            if (nextCell.isSuppressNavigable()) {\n                continue;\n            }\n            // by default, when we click a cell, it gets selected into a range, so to keep keyboard navigation\n            // consistent, we set into range here also.\n            if (this.rangeService) {\n                this.rangeService.setRangeToCell(nextPosition);\n            }\n            // we successfully tabbed onto a grid cell, so return true\n            return nextCell;\n        }\n    };\n    NavigationService.prototype.isCellEditable = function (cell) {\n        var rowNode = this.lookupRowNodeForCell(cell);\n        if (rowNode) {\n            return cell.column.isCellEditable(rowNode);\n        }\n        return false;\n    };\n    NavigationService.prototype.getCellByPosition = function (cellPosition) {\n        var rowCtrl = this.rowRenderer.getRowByPosition(cellPosition);\n        if (!rowCtrl) {\n            return null;\n        }\n        return rowCtrl.getCellCtrl(cellPosition.column);\n    };\n    NavigationService.prototype.lookupRowNodeForCell = function (cell) {\n        if (cell.rowPinned === Constants.PINNED_TOP) {\n            return this.pinnedRowModel.getPinnedTopRow(cell.rowIndex);\n        }\n        if (cell.rowPinned === Constants.PINNED_BOTTOM) {\n            return this.pinnedRowModel.getPinnedBottomRow(cell.rowIndex);\n        }\n        return this.paginationProxy.getRow(cell.rowIndex);\n    };\n    // we use index for rows, but column object for columns, as the next column (by index) might not\n    // be visible (header grouping) so it's not reliable, so using the column object instead.\n    NavigationService.prototype.navigateToNextCell = function (event, key, currentCell, allowUserOverride) {\n        // we keep searching for a next cell until we find one. this is how the group rows get skipped\n        var nextCell = currentCell;\n        var hitEdgeOfGrid = false;\n        while (nextCell && (nextCell === currentCell || !this.isValidNavigateCell(nextCell))) {\n            // if the current cell is spanning across multiple columns, we need to move\n            // our current position to be the last cell on the right before finding the\n            // the next target.\n            if (this.gridOptionsWrapper.isEnableRtl()) {\n                if (key === KeyCode.LEFT) {\n                    nextCell = this.getLastCellOfColSpan(nextCell);\n                }\n            }\n            else if (key === KeyCode.RIGHT) {\n                nextCell = this.getLastCellOfColSpan(nextCell);\n            }\n            nextCell = this.cellNavigationService.getNextCellToFocus(key, nextCell);\n            // eg if going down, and nextCell=undefined, means we are gone past the last row\n            hitEdgeOfGrid = missing(nextCell);\n        }\n        if (hitEdgeOfGrid && event && event.keyCode === KeyCode.UP) {\n            nextCell = {\n                rowIndex: -1,\n                rowPinned: null,\n                column: currentCell.column\n            };\n        }\n        // allow user to override what cell to go to next. when doing normal cell navigation (with keys)\n        // we allow this, however if processing 'enter after edit' we don't allow override\n        if (allowUserOverride) {\n            var userFunc = this.gridOptionsWrapper.getNavigateToNextCellFunc();\n            if (exists(userFunc)) {\n                var params = {\n                    key: key,\n                    previousCellPosition: currentCell,\n                    nextCellPosition: nextCell ? nextCell : null,\n                    event: event,\n                    api: this.gridOptionsWrapper.getApi(),\n                    columnApi: this.gridOptionsWrapper.getColumnApi()\n                };\n                var userCell = userFunc(params);\n                if (exists(userCell)) {\n                    if (userCell.floating) {\n                        doOnce(function () { console.warn(\"AG Grid: tabToNextCellFunc return type should have attributes: rowIndex, rowPinned, column. However you had 'floating', maybe you meant 'rowPinned'?\"); }, 'no floating in userCell');\n                        userCell.rowPinned = userCell.floating;\n                    }\n                    nextCell = {\n                        rowPinned: userCell.rowPinned,\n                        rowIndex: userCell.rowIndex,\n                        column: userCell.column\n                    };\n                }\n                else {\n                    nextCell = null;\n                }\n            }\n        }\n        // no next cell means we have reached a grid boundary, eg left, right, top or bottom of grid\n        if (!nextCell) {\n            return;\n        }\n        if (nextCell.rowIndex < 0) {\n            var headerLen = this.headerNavigationService.getHeaderRowCount();\n            this.focusService.focusHeaderPosition({\n                headerPosition: { headerRowIndex: headerLen + (nextCell.rowIndex), column: currentCell.column },\n                event: event || undefined\n            });\n            return;\n        }\n        // in case we have col spanning we get the cellComp and use it to get the\n        // position. This was we always focus the first cell inside the spanning.\n        var normalisedPosition = this.getNormalisedPosition(nextCell);\n        if (normalisedPosition) {\n            this.focusPosition(normalisedPosition);\n        }\n        else {\n            this.tryToFocusFullWidthRow(nextCell);\n        }\n    };\n    NavigationService.prototype.getNormalisedPosition = function (cellPosition) {\n        // ensureCellVisible first, to make sure cell at position is rendered.\n        this.ensureCellVisible(cellPosition);\n        var cellComp = this.getCellByPosition(cellPosition);\n        // not guaranteed to have a cellComp when using the SSRM as blocks are loading.\n        if (!cellComp) {\n            return null;\n        }\n        cellPosition = cellComp.getCellPosition();\n        // we call this again, as nextCell can be different to it's previous value due to Column Spanning\n        // (ie if cursor moving from right to left, and cell is spanning columns, then nextCell was the\n        // last column in the group, however now it's the first column in the group). if we didn't do\n        // ensureCellVisible again, then we could only be showing the last portion (last column) of the\n        // merged cells.\n        this.ensureCellVisible(cellPosition);\n        return cellPosition;\n    };\n    NavigationService.prototype.tryToFocusFullWidthRow = function (position, backwards) {\n        if (backwards === void 0) { backwards = false; }\n        var displayedColumns = this.columnModel.getAllDisplayedColumns();\n        var rowComp = this.rowRenderer.getRowByPosition(position);\n        if (!rowComp || !rowComp.isFullWidth()) {\n            return false;\n        }\n        var cellPosition = {\n            rowIndex: position.rowIndex,\n            rowPinned: position.rowPinned,\n            column: position.column || (backwards ? last(displayedColumns) : displayedColumns[0])\n        };\n        this.focusPosition(cellPosition);\n        return true;\n    };\n    NavigationService.prototype.focusPosition = function (cellPosition) {\n        this.focusService.setFocusedCell(cellPosition.rowIndex, cellPosition.column, cellPosition.rowPinned, true);\n        if (this.rangeService) {\n            this.rangeService.setRangeToCell(cellPosition);\n        }\n    };\n    NavigationService.prototype.isValidNavigateCell = function (cell) {\n        var rowNode = this.rowPositionUtils.getRowNode(cell);\n        // we do not allow focusing on detail rows and full width rows\n        return !!rowNode;\n    };\n    NavigationService.prototype.getLastCellOfColSpan = function (cell) {\n        var cellCtrl = this.getCellByPosition(cell);\n        if (!cellCtrl) {\n            return cell;\n        }\n        var colSpanningList = cellCtrl.getColSpanningList();\n        if (colSpanningList.length === 1) {\n            return cell;\n        }\n        return {\n            rowIndex: cell.rowIndex,\n            column: last(colSpanningList),\n            rowPinned: cell.rowPinned\n        };\n    };\n    NavigationService.prototype.ensureCellVisible = function (gridCell) {\n        // this scrolls the row into view\n        if (missing(gridCell.rowPinned)) {\n            this.gridBodyCon.getScrollFeature().ensureIndexVisible(gridCell.rowIndex);\n        }\n        if (!gridCell.column.isPinned()) {\n            this.gridBodyCon.getScrollFeature().ensureColumnVisible(gridCell.column);\n        }\n        // need to nudge the scrolls for the floating items. otherwise when we set focus on a non-visible\n        // floating cell, the scrolls get out of sync\n        this.gridBodyCon.getScrollFeature().horizontallyScrollHeaderCenterAndFloatingCenter();\n        // need to flush frames, to make sure the correct cells are rendered\n        this.animationFrameService.flushAllFrames();\n    };\n    __decorate([\n        Autowired('mouseEventService')\n    ], NavigationService.prototype, \"mouseEventService\", void 0);\n    __decorate([\n        Autowired('paginationProxy')\n    ], NavigationService.prototype, \"paginationProxy\", void 0);\n    __decorate([\n        Autowired('focusService')\n    ], NavigationService.prototype, \"focusService\", void 0);\n    __decorate([\n        Autowired('animationFrameService')\n    ], NavigationService.prototype, \"animationFrameService\", void 0);\n    __decorate([\n        Optional('rangeService')\n    ], NavigationService.prototype, \"rangeService\", void 0);\n    __decorate([\n        Autowired('columnModel')\n    ], NavigationService.prototype, \"columnModel\", void 0);\n    __decorate([\n        Autowired('ctrlsService')\n    ], NavigationService.prototype, \"ctrlsService\", void 0);\n    __decorate([\n        Autowired('rowRenderer')\n    ], NavigationService.prototype, \"rowRenderer\", void 0);\n    __decorate([\n        Autowired('headerNavigationService')\n    ], NavigationService.prototype, \"headerNavigationService\", void 0);\n    __decorate([\n        Autowired(\"rowPositionUtils\")\n    ], NavigationService.prototype, \"rowPositionUtils\", void 0);\n    __decorate([\n        Autowired(\"cellNavigationService\")\n    ], NavigationService.prototype, \"cellNavigationService\", void 0);\n    __decorate([\n        Autowired(\"pinnedRowModel\")\n    ], NavigationService.prototype, \"pinnedRowModel\", void 0);\n    __decorate([\n        PostConstruct\n    ], NavigationService.prototype, \"postConstruct\", null);\n    NavigationService = __decorate([\n        Bean('navigationService')\n    ], NavigationService);\n    return NavigationService;\n}(BeanStub));\nexport { NavigationService };\n"]},"metadata":{},"sourceType":"module"}