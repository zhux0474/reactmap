{"ast":null,"code":"'use strict';\n\nfunction isClockWise(array) {\n  let sum = 0;\n  let i = 1;\n  const len = array.length;\n  let prev, cur;\n\n  while (i < len) {\n    prev = cur || array[0];\n    cur = array[i];\n    sum += (cur[0] - prev[0]) * (cur[1] + prev[1]);\n    i++;\n  }\n\n  return sum > 0;\n}\n\nfunction polyReduce(a, b) {\n  if (isClockWise(b) || !a.length) {\n    a.push([b]);\n  } else {\n    a[a.length - 1].push(b);\n  }\n\n  return a;\n}\n\nParseShp.prototype.parsePoint = function (data) {\n  return {\n    type: 'Point',\n    coordinates: this.parseCoord(data, 0)\n  };\n};\n\nParseShp.prototype.parseZPoint = function (data) {\n  const pointXY = this.parsePoint(data);\n  pointXY.coordinates.push(data.readDoubleLE(16));\n  return pointXY;\n};\n\nParseShp.prototype.parsePointArray = function (data, offset, num) {\n  const out = [];\n  let done = 0;\n\n  while (done < num) {\n    out.push(this.parseCoord(data, offset));\n    offset += 16;\n    done++;\n  }\n\n  return out;\n};\n\nParseShp.prototype.parseZPointArray = function (data, zOffset, num, coordinates) {\n  let i = 0;\n\n  while (i < num) {\n    coordinates[i].push(data.readDoubleLE(zOffset));\n    i++;\n    zOffset += 8;\n  }\n\n  return coordinates;\n};\n\nParseShp.prototype.parseArrayGroup = function (data, offset, partOffset, num, tot) {\n  const out = [];\n  let done = 0;\n  let curNum;\n  let nextNum = 0;\n  let pointNumber;\n\n  while (done < num) {\n    done++;\n    partOffset += 4;\n    curNum = nextNum;\n\n    if (done === num) {\n      nextNum = tot;\n    } else {\n      nextNum = data.readInt32LE(partOffset);\n    }\n\n    pointNumber = nextNum - curNum;\n\n    if (!pointNumber) {\n      continue;\n    }\n\n    out.push(this.parsePointArray(data, offset, pointNumber));\n    offset += pointNumber << 4;\n  }\n\n  return out;\n};\n\nParseShp.prototype.parseZArrayGroup = function (data, zOffset, num, coordinates) {\n  let i = 0;\n\n  while (i < num) {\n    coordinates[i] = this.parseZPointArray(data, zOffset, coordinates[i].length, coordinates[i]);\n    zOffset += coordinates[i].length << 3;\n    i++;\n  }\n\n  return coordinates;\n};\n\nParseShp.prototype.parseMultiPoint = function (data) {\n  const out = {};\n  const mins = this.parseCoord(data, 0);\n  const maxs = this.parseCoord(data, 16);\n  out.bbox = [mins[0], mins[1], maxs[0], maxs[1]];\n  const num = data.readInt32LE(32, true);\n  const offset = 36;\n\n  if (num === 1) {\n    out.type = 'Point';\n    out.coordinates = this.parseCoord(data, offset);\n  } else {\n    out.type = 'MultiPoint';\n    out.coordinates = this.parsePointArray(data, offset, num);\n  }\n\n  return out;\n};\n\nParseShp.prototype.parseZMultiPoint = function (data) {\n  const geoJson = this.parseMultiPoint(data);\n  let num;\n\n  if (geoJson.type === 'Point') {\n    geoJson.coordinates.push(data.readDoubleLE(72));\n    return geoJson;\n  } else {\n    num = geoJson.coordinates.length;\n  }\n\n  const zOffset = 52 + (num << 4);\n  geoJson.coordinates = this.parseZPointArray(data, zOffset, num, geoJson.coordinates);\n  return geoJson;\n};\n\nParseShp.prototype.parsePolyline = function (data) {\n  const out = {};\n  const mins = this.parseCoord(data, 0);\n  const maxs = this.parseCoord(data, 16);\n  out.bbox = [mins[0], mins[1], maxs[0], maxs[1]];\n  const numParts = data.readInt32LE(32);\n  const num = data.readInt32LE(36);\n  let offset, partOffset;\n\n  if (numParts === 1) {\n    out.type = 'LineString';\n    offset = 44;\n    out.coordinates = this.parsePointArray(data, offset, num);\n  } else {\n    out.type = 'MultiLineString';\n    offset = 40 + (numParts << 2);\n    partOffset = 40;\n    out.coordinates = this.parseArrayGroup(data, offset, partOffset, numParts, num);\n  }\n\n  return out;\n};\n\nParseShp.prototype.parseZPolyline = function (data) {\n  const geoJson = this.parsePolyline(data);\n  const num = geoJson.coordinates.length;\n  let zOffset;\n\n  if (geoJson.type === 'LineString') {\n    zOffset = 60 + (num << 4);\n    geoJson.coordinates = this.parseZPointArray(data, zOffset, num, geoJson.coordinates);\n    return geoJson;\n  } else {\n    const totalPoints = geoJson.coordinates.reduce(function (a, v) {\n      return a + v.length;\n    }, 0);\n    zOffset = 56 + (totalPoints << 4) + (num << 2);\n    geoJson.coordinates = this.parseZArrayGroup(data, zOffset, num, geoJson.coordinates);\n    return geoJson;\n  }\n};\n\nParseShp.prototype.polyFuncs = function (out) {\n  if (out.type === 'LineString') {\n    out.type = 'Polygon';\n    out.coordinates = [out.coordinates];\n    return out;\n  } else {\n    out.coordinates = out.coordinates.reduce(polyReduce, []);\n\n    if (out.coordinates.length === 1) {\n      out.type = 'Polygon';\n      out.coordinates = out.coordinates[0];\n      return out;\n    } else {\n      out.type = 'MultiPolygon';\n      return out;\n    }\n  }\n};\n\nParseShp.prototype.parsePolygon = function (data) {\n  return this.polyFuncs(this.parsePolyline(data));\n};\n\nParseShp.prototype.parseZPolygon = function (data) {\n  return this.polyFuncs(this.parseZPolyline(data));\n};\n\nconst shpFuncObj = {\n  1: 'parsePoint',\n  3: 'parsePolyline',\n  5: 'parsePolygon',\n  8: 'parseMultiPoint',\n  11: 'parseZPoint',\n  13: 'parseZPolyline',\n  15: 'parseZPolygon',\n  18: 'parseZMultiPoint'\n};\n\nfunction makeParseCoord(trans) {\n  if (trans) {\n    return function (data, offset) {\n      return trans.inverse([data.readDoubleLE(offset), data.readDoubleLE(offset + 8)]);\n    };\n  } else {\n    return function (data, offset) {\n      return [data.readDoubleLE(offset), data.readDoubleLE(offset + 8)];\n    };\n  }\n}\n\nfunction ParseShp(buffer, trans) {\n  if (!(this instanceof ParseShp)) {\n    return new ParseShp(buffer, trans);\n  }\n\n  this.buffer = buffer;\n  this.headers = this.parseHeader();\n\n  if (this.headers.length < this.buffer.byteLength) {\n    this.buffer = this.buffer.slice(0, this.headers.length);\n  }\n\n  this.shpFuncs(trans);\n  this.rows = this.getRows();\n}\n\nParseShp.prototype.shpFuncs = function (tran) {\n  let num = this.headers.shpCode;\n\n  if (num > 20) {\n    num -= 20;\n  }\n\n  if (!(num in shpFuncObj)) {\n    throw new Error('I don\\'t know that shp type');\n  }\n\n  this.parseFunc = this[shpFuncObj[num]];\n  this.parseCoord = makeParseCoord(tran);\n};\n\nParseShp.prototype.getShpCode = function () {\n  return this.parseHeader().shpCode;\n};\n\nParseShp.prototype.parseHeader = function () {\n  const view = this.buffer.slice(0, 100);\n  return {\n    length: view.readInt32BE(6 << 2) << 1,\n    version: view.readInt32LE(7 << 2),\n    shpCode: view.readInt32LE(8 << 2),\n    bbox: [view.readDoubleLE(9 << 2), view.readDoubleLE(11 << 2), view.readDoubleLE(13 << 2), view.readDoubleLE(13 << 2)]\n  };\n};\n\nParseShp.prototype.getRows = function () {\n  let offset = 100;\n  const len = this.buffer.byteLength;\n  const out = [];\n  let current;\n\n  while (offset < len) {\n    current = this.getRow(offset);\n\n    if (!current) {\n      break;\n    }\n\n    offset += 8;\n    offset += current.len;\n\n    if (current.type) {\n      out.push(this.parseFunc(current.data));\n    } else {\n      out.push(null);\n    }\n  }\n\n  return out;\n};\n\nParseShp.prototype.getRow = function (offset) {\n  const view = this.buffer.slice(offset, offset + 12);\n  const len = view.readInt32BE(4) << 1;\n  const id = view.readInt32BE(0);\n\n  if (len === 0) {\n    return {\n      id: id,\n      len: len,\n      type: 0\n    };\n  }\n\n  return {\n    id: id,\n    len: len,\n    data: this.buffer.slice(offset + 12, offset + len + 8),\n    type: view.readInt32LE(8)\n  };\n};\n\nmodule.exports = function (buffer, trans) {\n  return new ParseShp(buffer, trans).rows;\n};","map":{"version":3,"sources":["/Users/rongxuan/Desktop/reactmap/reactmap/node_modules/shpjs/lib/parseShp.js"],"names":["isClockWise","array","sum","i","len","length","prev","cur","polyReduce","a","b","push","ParseShp","prototype","parsePoint","data","type","coordinates","parseCoord","parseZPoint","pointXY","readDoubleLE","parsePointArray","offset","num","out","done","parseZPointArray","zOffset","parseArrayGroup","partOffset","tot","curNum","nextNum","pointNumber","readInt32LE","parseZArrayGroup","parseMultiPoint","mins","maxs","bbox","parseZMultiPoint","geoJson","parsePolyline","numParts","parseZPolyline","totalPoints","reduce","v","polyFuncs","parsePolygon","parseZPolygon","shpFuncObj","makeParseCoord","trans","inverse","buffer","headers","parseHeader","byteLength","slice","shpFuncs","rows","getRows","tran","shpCode","Error","parseFunc","getShpCode","view","readInt32BE","version","current","getRow","id","module","exports"],"mappings":"AAAA;;AAEA,SAASA,WAAT,CAAsBC,KAAtB,EAA6B;AAC3B,MAAIC,GAAG,GAAG,CAAV;AACA,MAAIC,CAAC,GAAG,CAAR;AACA,QAAMC,GAAG,GAAGH,KAAK,CAACI,MAAlB;AACA,MAAIC,IAAJ,EAAUC,GAAV;;AACA,SAAOJ,CAAC,GAAGC,GAAX,EAAgB;AACdE,IAAAA,IAAI,GAAGC,GAAG,IAAIN,KAAK,CAAC,CAAD,CAAnB;AACAM,IAAAA,GAAG,GAAGN,KAAK,CAACE,CAAD,CAAX;AACAD,IAAAA,GAAG,IAAK,CAACK,GAAG,CAAC,CAAD,CAAH,GAASD,IAAI,CAAC,CAAD,CAAd,KAAsBC,GAAG,CAAC,CAAD,CAAH,GAASD,IAAI,CAAC,CAAD,CAAnC,CAAR;AACAH,IAAAA,CAAC;AACF;;AACD,SAAOD,GAAG,GAAG,CAAb;AACD;;AAED,SAASM,UAAT,CAAqBC,CAArB,EAAwBC,CAAxB,EAA2B;AACzB,MAAIV,WAAW,CAACU,CAAD,CAAX,IAAkB,CAACD,CAAC,CAACJ,MAAzB,EAAiC;AAC/BI,IAAAA,CAAC,CAACE,IAAF,CAAO,CAACD,CAAD,CAAP;AACD,GAFD,MAEO;AACLD,IAAAA,CAAC,CAACA,CAAC,CAACJ,MAAF,GAAW,CAAZ,CAAD,CAAgBM,IAAhB,CAAqBD,CAArB;AACD;;AACD,SAAOD,CAAP;AACD;;AACDG,QAAQ,CAACC,SAAT,CAAmBC,UAAnB,GAAgC,UAAUC,IAAV,EAAgB;AAC9C,SAAO;AACLC,IAAAA,IAAI,EAAE,OADD;AAELC,IAAAA,WAAW,EAAE,KAAKC,UAAL,CAAgBH,IAAhB,EAAsB,CAAtB;AAFR,GAAP;AAID,CALD;;AAMAH,QAAQ,CAACC,SAAT,CAAmBM,WAAnB,GAAiC,UAAUJ,IAAV,EAAgB;AAC/C,QAAMK,OAAO,GAAG,KAAKN,UAAL,CAAgBC,IAAhB,CAAhB;AACAK,EAAAA,OAAO,CAACH,WAAR,CAAoBN,IAApB,CAAyBI,IAAI,CAACM,YAAL,CAAkB,EAAlB,CAAzB;AACA,SAAOD,OAAP;AACD,CAJD;;AAKAR,QAAQ,CAACC,SAAT,CAAmBS,eAAnB,GAAqC,UAAUP,IAAV,EAAgBQ,MAAhB,EAAwBC,GAAxB,EAA6B;AAChE,QAAMC,GAAG,GAAG,EAAZ;AACA,MAAIC,IAAI,GAAG,CAAX;;AACA,SAAOA,IAAI,GAAGF,GAAd,EAAmB;AACjBC,IAAAA,GAAG,CAACd,IAAJ,CAAS,KAAKO,UAAL,CAAgBH,IAAhB,EAAsBQ,MAAtB,CAAT;AACAA,IAAAA,MAAM,IAAI,EAAV;AACAG,IAAAA,IAAI;AACL;;AACD,SAAOD,GAAP;AACD,CATD;;AAUAb,QAAQ,CAACC,SAAT,CAAmBc,gBAAnB,GAAsC,UAAUZ,IAAV,EAAgBa,OAAhB,EAAyBJ,GAAzB,EAA8BP,WAA9B,EAA2C;AAC/E,MAAId,CAAC,GAAG,CAAR;;AACA,SAAOA,CAAC,GAAGqB,GAAX,EAAgB;AACdP,IAAAA,WAAW,CAACd,CAAD,CAAX,CAAeQ,IAAf,CAAoBI,IAAI,CAACM,YAAL,CAAkBO,OAAlB,CAApB;AACAzB,IAAAA,CAAC;AACDyB,IAAAA,OAAO,IAAI,CAAX;AACD;;AACD,SAAOX,WAAP;AACD,CARD;;AASAL,QAAQ,CAACC,SAAT,CAAmBgB,eAAnB,GAAqC,UAAUd,IAAV,EAAgBQ,MAAhB,EAAwBO,UAAxB,EAAoCN,GAApC,EAAyCO,GAAzC,EAA8C;AACjF,QAAMN,GAAG,GAAG,EAAZ;AACA,MAAIC,IAAI,GAAG,CAAX;AACA,MAAIM,MAAJ;AAAY,MAAIC,OAAO,GAAG,CAAd;AACZ,MAAIC,WAAJ;;AACA,SAAOR,IAAI,GAAGF,GAAd,EAAmB;AACjBE,IAAAA,IAAI;AACJI,IAAAA,UAAU,IAAI,CAAd;AACAE,IAAAA,MAAM,GAAGC,OAAT;;AACA,QAAIP,IAAI,KAAKF,GAAb,EAAkB;AAChBS,MAAAA,OAAO,GAAGF,GAAV;AACD,KAFD,MAEO;AACLE,MAAAA,OAAO,GAAGlB,IAAI,CAACoB,WAAL,CAAiBL,UAAjB,CAAV;AACD;;AACDI,IAAAA,WAAW,GAAGD,OAAO,GAAGD,MAAxB;;AACA,QAAI,CAACE,WAAL,EAAkB;AAChB;AACD;;AACDT,IAAAA,GAAG,CAACd,IAAJ,CAAS,KAAKW,eAAL,CAAqBP,IAArB,EAA2BQ,MAA3B,EAAmCW,WAAnC,CAAT;AACAX,IAAAA,MAAM,IAAKW,WAAW,IAAI,CAA1B;AACD;;AACD,SAAOT,GAAP;AACD,CAtBD;;AAuBAb,QAAQ,CAACC,SAAT,CAAmBuB,gBAAnB,GAAsC,UAAUrB,IAAV,EAAgBa,OAAhB,EAAyBJ,GAAzB,EAA8BP,WAA9B,EAA2C;AAC/E,MAAId,CAAC,GAAG,CAAR;;AACA,SAAOA,CAAC,GAAGqB,GAAX,EAAgB;AACdP,IAAAA,WAAW,CAACd,CAAD,CAAX,GAAiB,KAAKwB,gBAAL,CAAsBZ,IAAtB,EAA4Ba,OAA5B,EAAqCX,WAAW,CAACd,CAAD,CAAX,CAAeE,MAApD,EAA4DY,WAAW,CAACd,CAAD,CAAvE,CAAjB;AACAyB,IAAAA,OAAO,IAAKX,WAAW,CAACd,CAAD,CAAX,CAAeE,MAAf,IAAyB,CAArC;AACAF,IAAAA,CAAC;AACF;;AACD,SAAOc,WAAP;AACD,CARD;;AASAL,QAAQ,CAACC,SAAT,CAAmBwB,eAAnB,GAAqC,UAAUtB,IAAV,EAAgB;AACnD,QAAMU,GAAG,GAAG,EAAZ;AACA,QAAMa,IAAI,GAAG,KAAKpB,UAAL,CAAgBH,IAAhB,EAAsB,CAAtB,CAAb;AACA,QAAMwB,IAAI,GAAG,KAAKrB,UAAL,CAAgBH,IAAhB,EAAsB,EAAtB,CAAb;AACAU,EAAAA,GAAG,CAACe,IAAJ,GAAW,CACTF,IAAI,CAAC,CAAD,CADK,EAETA,IAAI,CAAC,CAAD,CAFK,EAGTC,IAAI,CAAC,CAAD,CAHK,EAITA,IAAI,CAAC,CAAD,CAJK,CAAX;AAMA,QAAMf,GAAG,GAAGT,IAAI,CAACoB,WAAL,CAAiB,EAAjB,EAAqB,IAArB,CAAZ;AACA,QAAMZ,MAAM,GAAG,EAAf;;AACA,MAAIC,GAAG,KAAK,CAAZ,EAAe;AACbC,IAAAA,GAAG,CAACT,IAAJ,GAAW,OAAX;AACAS,IAAAA,GAAG,CAACR,WAAJ,GAAkB,KAAKC,UAAL,CAAgBH,IAAhB,EAAsBQ,MAAtB,CAAlB;AACD,GAHD,MAGO;AACLE,IAAAA,GAAG,CAACT,IAAJ,GAAW,YAAX;AACAS,IAAAA,GAAG,CAACR,WAAJ,GAAkB,KAAKK,eAAL,CAAqBP,IAArB,EAA2BQ,MAA3B,EAAmCC,GAAnC,CAAlB;AACD;;AACD,SAAOC,GAAP;AACD,CApBD;;AAqBAb,QAAQ,CAACC,SAAT,CAAmB4B,gBAAnB,GAAsC,UAAU1B,IAAV,EAAgB;AACpD,QAAM2B,OAAO,GAAG,KAAKL,eAAL,CAAqBtB,IAArB,CAAhB;AACA,MAAIS,GAAJ;;AACA,MAAIkB,OAAO,CAAC1B,IAAR,KAAiB,OAArB,EAA8B;AAC5B0B,IAAAA,OAAO,CAACzB,WAAR,CAAoBN,IAApB,CAAyBI,IAAI,CAACM,YAAL,CAAkB,EAAlB,CAAzB;AACA,WAAOqB,OAAP;AACD,GAHD,MAGO;AACLlB,IAAAA,GAAG,GAAGkB,OAAO,CAACzB,WAAR,CAAoBZ,MAA1B;AACD;;AACD,QAAMuB,OAAO,GAAG,MAAMJ,GAAG,IAAI,CAAb,CAAhB;AACAkB,EAAAA,OAAO,CAACzB,WAAR,GAAsB,KAAKU,gBAAL,CAAsBZ,IAAtB,EAA4Ba,OAA5B,EAAqCJ,GAArC,EAA0CkB,OAAO,CAACzB,WAAlD,CAAtB;AACA,SAAOyB,OAAP;AACD,CAZD;;AAaA9B,QAAQ,CAACC,SAAT,CAAmB8B,aAAnB,GAAmC,UAAU5B,IAAV,EAAgB;AACjD,QAAMU,GAAG,GAAG,EAAZ;AACA,QAAMa,IAAI,GAAG,KAAKpB,UAAL,CAAgBH,IAAhB,EAAsB,CAAtB,CAAb;AACA,QAAMwB,IAAI,GAAG,KAAKrB,UAAL,CAAgBH,IAAhB,EAAsB,EAAtB,CAAb;AACAU,EAAAA,GAAG,CAACe,IAAJ,GAAW,CACTF,IAAI,CAAC,CAAD,CADK,EAETA,IAAI,CAAC,CAAD,CAFK,EAGTC,IAAI,CAAC,CAAD,CAHK,EAITA,IAAI,CAAC,CAAD,CAJK,CAAX;AAMA,QAAMK,QAAQ,GAAG7B,IAAI,CAACoB,WAAL,CAAiB,EAAjB,CAAjB;AACA,QAAMX,GAAG,GAAGT,IAAI,CAACoB,WAAL,CAAiB,EAAjB,CAAZ;AACA,MAAIZ,MAAJ,EAAYO,UAAZ;;AACA,MAAIc,QAAQ,KAAK,CAAjB,EAAoB;AAClBnB,IAAAA,GAAG,CAACT,IAAJ,GAAW,YAAX;AACAO,IAAAA,MAAM,GAAG,EAAT;AACAE,IAAAA,GAAG,CAACR,WAAJ,GAAkB,KAAKK,eAAL,CAAqBP,IAArB,EAA2BQ,MAA3B,EAAmCC,GAAnC,CAAlB;AACD,GAJD,MAIO;AACLC,IAAAA,GAAG,CAACT,IAAJ,GAAW,iBAAX;AACAO,IAAAA,MAAM,GAAG,MAAMqB,QAAQ,IAAI,CAAlB,CAAT;AACAd,IAAAA,UAAU,GAAG,EAAb;AACAL,IAAAA,GAAG,CAACR,WAAJ,GAAkB,KAAKY,eAAL,CAAqBd,IAArB,EAA2BQ,MAA3B,EAAmCO,UAAnC,EAA+Cc,QAA/C,EAAyDpB,GAAzD,CAAlB;AACD;;AACD,SAAOC,GAAP;AACD,CAxBD;;AAyBAb,QAAQ,CAACC,SAAT,CAAmBgC,cAAnB,GAAoC,UAAU9B,IAAV,EAAgB;AAClD,QAAM2B,OAAO,GAAG,KAAKC,aAAL,CAAmB5B,IAAnB,CAAhB;AACA,QAAMS,GAAG,GAAGkB,OAAO,CAACzB,WAAR,CAAoBZ,MAAhC;AACA,MAAIuB,OAAJ;;AACA,MAAIc,OAAO,CAAC1B,IAAR,KAAiB,YAArB,EAAmC;AACjCY,IAAAA,OAAO,GAAG,MAAMJ,GAAG,IAAI,CAAb,CAAV;AACAkB,IAAAA,OAAO,CAACzB,WAAR,GAAsB,KAAKU,gBAAL,CAAsBZ,IAAtB,EAA4Ba,OAA5B,EAAqCJ,GAArC,EAA0CkB,OAAO,CAACzB,WAAlD,CAAtB;AACA,WAAOyB,OAAP;AACD,GAJD,MAIO;AACL,UAAMI,WAAW,GAAGJ,OAAO,CAACzB,WAAR,CAAoB8B,MAApB,CAA2B,UAAUtC,CAAV,EAAauC,CAAb,EAAgB;AAC7D,aAAOvC,CAAC,GAAGuC,CAAC,CAAC3C,MAAb;AACD,KAFmB,EAEjB,CAFiB,CAApB;AAGAuB,IAAAA,OAAO,GAAG,MAAMkB,WAAW,IAAI,CAArB,KAA2BtB,GAAG,IAAI,CAAlC,CAAV;AACAkB,IAAAA,OAAO,CAACzB,WAAR,GAAsB,KAAKmB,gBAAL,CAAsBrB,IAAtB,EAA4Ba,OAA5B,EAAqCJ,GAArC,EAA0CkB,OAAO,CAACzB,WAAlD,CAAtB;AACA,WAAOyB,OAAP;AACD;AACF,CAhBD;;AAiBA9B,QAAQ,CAACC,SAAT,CAAmBoC,SAAnB,GAA+B,UAAUxB,GAAV,EAAe;AAC5C,MAAIA,GAAG,CAACT,IAAJ,KAAa,YAAjB,EAA+B;AAC7BS,IAAAA,GAAG,CAACT,IAAJ,GAAW,SAAX;AACAS,IAAAA,GAAG,CAACR,WAAJ,GAAkB,CAACQ,GAAG,CAACR,WAAL,CAAlB;AACA,WAAOQ,GAAP;AACD,GAJD,MAIO;AACLA,IAAAA,GAAG,CAACR,WAAJ,GAAkBQ,GAAG,CAACR,WAAJ,CAAgB8B,MAAhB,CAAuBvC,UAAvB,EAAmC,EAAnC,CAAlB;;AACA,QAAIiB,GAAG,CAACR,WAAJ,CAAgBZ,MAAhB,KAA2B,CAA/B,EAAkC;AAChCoB,MAAAA,GAAG,CAACT,IAAJ,GAAW,SAAX;AACAS,MAAAA,GAAG,CAACR,WAAJ,GAAkBQ,GAAG,CAACR,WAAJ,CAAgB,CAAhB,CAAlB;AACA,aAAOQ,GAAP;AACD,KAJD,MAIO;AACLA,MAAAA,GAAG,CAACT,IAAJ,GAAW,cAAX;AACA,aAAOS,GAAP;AACD;AACF;AACF,CAhBD;;AAiBAb,QAAQ,CAACC,SAAT,CAAmBqC,YAAnB,GAAkC,UAAUnC,IAAV,EAAgB;AAChD,SAAO,KAAKkC,SAAL,CAAe,KAAKN,aAAL,CAAmB5B,IAAnB,CAAf,CAAP;AACD,CAFD;;AAGAH,QAAQ,CAACC,SAAT,CAAmBsC,aAAnB,GAAmC,UAAUpC,IAAV,EAAgB;AACjD,SAAO,KAAKkC,SAAL,CAAe,KAAKJ,cAAL,CAAoB9B,IAApB,CAAf,CAAP;AACD,CAFD;;AAGA,MAAMqC,UAAU,GAAG;AACjB,KAAG,YADc;AAEjB,KAAG,eAFc;AAGjB,KAAG,cAHc;AAIjB,KAAG,iBAJc;AAKjB,MAAI,aALa;AAMjB,MAAI,gBANa;AAOjB,MAAI,eAPa;AAQjB,MAAI;AARa,CAAnB;;AAWA,SAASC,cAAT,CAAyBC,KAAzB,EAAgC;AAC9B,MAAIA,KAAJ,EAAW;AACT,WAAO,UAAUvC,IAAV,EAAgBQ,MAAhB,EAAwB;AAC7B,aAAO+B,KAAK,CAACC,OAAN,CAAc,CAACxC,IAAI,CAACM,YAAL,CAAkBE,MAAlB,CAAD,EAA4BR,IAAI,CAACM,YAAL,CAAkBE,MAAM,GAAG,CAA3B,CAA5B,CAAd,CAAP;AACD,KAFD;AAGD,GAJD,MAIO;AACL,WAAO,UAAUR,IAAV,EAAgBQ,MAAhB,EAAwB;AAC7B,aAAO,CAACR,IAAI,CAACM,YAAL,CAAkBE,MAAlB,CAAD,EAA4BR,IAAI,CAACM,YAAL,CAAkBE,MAAM,GAAG,CAA3B,CAA5B,CAAP;AACD,KAFD;AAGD;AACF;;AAED,SAASX,QAAT,CAAmB4C,MAAnB,EAA2BF,KAA3B,EAAkC;AAChC,MAAI,EAAE,gBAAgB1C,QAAlB,CAAJ,EAAiC;AAC/B,WAAO,IAAIA,QAAJ,CAAa4C,MAAb,EAAqBF,KAArB,CAAP;AACD;;AACD,OAAKE,MAAL,GAAcA,MAAd;AACA,OAAKC,OAAL,GAAe,KAAKC,WAAL,EAAf;;AACA,MAAI,KAAKD,OAAL,CAAapD,MAAb,GAAsB,KAAKmD,MAAL,CAAYG,UAAtC,EAAkD;AAChD,SAAKH,MAAL,GAAc,KAAKA,MAAL,CAAYI,KAAZ,CAAkB,CAAlB,EAAqB,KAAKH,OAAL,CAAapD,MAAlC,CAAd;AACD;;AACD,OAAKwD,QAAL,CAAcP,KAAd;AACA,OAAKQ,IAAL,GAAY,KAAKC,OAAL,EAAZ;AACD;;AACDnD,QAAQ,CAACC,SAAT,CAAmBgD,QAAnB,GAA8B,UAAUG,IAAV,EAAgB;AAC5C,MAAIxC,GAAG,GAAG,KAAKiC,OAAL,CAAaQ,OAAvB;;AACA,MAAIzC,GAAG,GAAG,EAAV,EAAc;AACZA,IAAAA,GAAG,IAAI,EAAP;AACD;;AACD,MAAI,EAAEA,GAAG,IAAI4B,UAAT,CAAJ,EAA0B;AACxB,UAAM,IAAIc,KAAJ,CAAU,6BAAV,CAAN;AACD;;AACD,OAAKC,SAAL,GAAiB,KAAKf,UAAU,CAAC5B,GAAD,CAAf,CAAjB;AACA,OAAKN,UAAL,GAAkBmC,cAAc,CAACW,IAAD,CAAhC;AACD,CAVD;;AAWApD,QAAQ,CAACC,SAAT,CAAmBuD,UAAnB,GAAgC,YAAY;AAC1C,SAAO,KAAKV,WAAL,GAAmBO,OAA1B;AACD,CAFD;;AAGArD,QAAQ,CAACC,SAAT,CAAmB6C,WAAnB,GAAiC,YAAY;AAC3C,QAAMW,IAAI,GAAG,KAAKb,MAAL,CAAYI,KAAZ,CAAkB,CAAlB,EAAqB,GAArB,CAAb;AACA,SAAO;AACLvD,IAAAA,MAAM,EAAEgE,IAAI,CAACC,WAAL,CAAiB,KAAK,CAAtB,KAA4B,CAD/B;AAELC,IAAAA,OAAO,EAAEF,IAAI,CAAClC,WAAL,CAAiB,KAAK,CAAtB,CAFJ;AAGL8B,IAAAA,OAAO,EAAEI,IAAI,CAAClC,WAAL,CAAiB,KAAK,CAAtB,CAHJ;AAILK,IAAAA,IAAI,EAAE,CACJ6B,IAAI,CAAChD,YAAL,CAAkB,KAAK,CAAvB,CADI,EAEJgD,IAAI,CAAChD,YAAL,CAAkB,MAAM,CAAxB,CAFI,EAGJgD,IAAI,CAAChD,YAAL,CAAkB,MAAM,CAAxB,CAHI,EAIJgD,IAAI,CAAChD,YAAL,CAAkB,MAAM,CAAxB,CAJI;AAJD,GAAP;AAWD,CAbD;;AAcAT,QAAQ,CAACC,SAAT,CAAmBkD,OAAnB,GAA6B,YAAY;AACvC,MAAIxC,MAAM,GAAG,GAAb;AACA,QAAMnB,GAAG,GAAG,KAAKoD,MAAL,CAAYG,UAAxB;AACA,QAAMlC,GAAG,GAAG,EAAZ;AACA,MAAI+C,OAAJ;;AACA,SAAOjD,MAAM,GAAGnB,GAAhB,EAAqB;AACnBoE,IAAAA,OAAO,GAAG,KAAKC,MAAL,CAAYlD,MAAZ,CAAV;;AACA,QAAI,CAACiD,OAAL,EAAc;AACZ;AACD;;AACDjD,IAAAA,MAAM,IAAI,CAAV;AACAA,IAAAA,MAAM,IAAIiD,OAAO,CAACpE,GAAlB;;AACA,QAAIoE,OAAO,CAACxD,IAAZ,EAAkB;AAChBS,MAAAA,GAAG,CAACd,IAAJ,CAAS,KAAKwD,SAAL,CAAeK,OAAO,CAACzD,IAAvB,CAAT;AACD,KAFD,MAEO;AACLU,MAAAA,GAAG,CAACd,IAAJ,CAAS,IAAT;AACD;AACF;;AACD,SAAOc,GAAP;AACD,CAnBD;;AAoBAb,QAAQ,CAACC,SAAT,CAAmB4D,MAAnB,GAA4B,UAAUlD,MAAV,EAAkB;AAC5C,QAAM8C,IAAI,GAAG,KAAKb,MAAL,CAAYI,KAAZ,CAAkBrC,MAAlB,EAA0BA,MAAM,GAAG,EAAnC,CAAb;AACA,QAAMnB,GAAG,GAAGiE,IAAI,CAACC,WAAL,CAAiB,CAAjB,KAAuB,CAAnC;AACA,QAAMI,EAAE,GAAGL,IAAI,CAACC,WAAL,CAAiB,CAAjB,CAAX;;AACA,MAAIlE,GAAG,KAAK,CAAZ,EAAe;AACb,WAAO;AACLsE,MAAAA,EAAE,EAAEA,EADC;AAELtE,MAAAA,GAAG,EAAEA,GAFA;AAGLY,MAAAA,IAAI,EAAE;AAHD,KAAP;AAKD;;AACD,SAAO;AACL0D,IAAAA,EAAE,EAAEA,EADC;AAELtE,IAAAA,GAAG,EAAEA,GAFA;AAGLW,IAAAA,IAAI,EAAE,KAAKyC,MAAL,CAAYI,KAAZ,CAAkBrC,MAAM,GAAG,EAA3B,EAA+BA,MAAM,GAAGnB,GAAT,GAAe,CAA9C,CAHD;AAILY,IAAAA,IAAI,EAAEqD,IAAI,CAAClC,WAAL,CAAiB,CAAjB;AAJD,GAAP;AAMD,CAjBD;;AAkBAwC,MAAM,CAACC,OAAP,GAAiB,UAAUpB,MAAV,EAAkBF,KAAlB,EAAyB;AACxC,SAAO,IAAI1C,QAAJ,CAAa4C,MAAb,EAAqBF,KAArB,EAA4BQ,IAAnC;AACD,CAFD","sourcesContent":["'use strict';\n\nfunction isClockWise (array) {\n  let sum = 0;\n  let i = 1;\n  const len = array.length;\n  let prev, cur;\n  while (i < len) {\n    prev = cur || array[0];\n    cur = array[i];\n    sum += ((cur[0] - prev[0]) * (cur[1] + prev[1]));\n    i++;\n  }\n  return sum > 0;\n}\n\nfunction polyReduce (a, b) {\n  if (isClockWise(b) || !a.length) {\n    a.push([b]);\n  } else {\n    a[a.length - 1].push(b);\n  }\n  return a;\n}\nParseShp.prototype.parsePoint = function (data) {\n  return {\n    type: 'Point',\n    coordinates: this.parseCoord(data, 0)\n  };\n};\nParseShp.prototype.parseZPoint = function (data) {\n  const pointXY = this.parsePoint(data);\n  pointXY.coordinates.push(data.readDoubleLE(16));\n  return pointXY;\n};\nParseShp.prototype.parsePointArray = function (data, offset, num) {\n  const out = [];\n  let done = 0;\n  while (done < num) {\n    out.push(this.parseCoord(data, offset));\n    offset += 16;\n    done++;\n  }\n  return out;\n};\nParseShp.prototype.parseZPointArray = function (data, zOffset, num, coordinates) {\n  let i = 0;\n  while (i < num) {\n    coordinates[i].push(data.readDoubleLE(zOffset));\n    i++;\n    zOffset += 8;\n  }\n  return coordinates;\n};\nParseShp.prototype.parseArrayGroup = function (data, offset, partOffset, num, tot) {\n  const out = [];\n  let done = 0;\n  let curNum; let nextNum = 0;\n  let pointNumber;\n  while (done < num) {\n    done++;\n    partOffset += 4;\n    curNum = nextNum;\n    if (done === num) {\n      nextNum = tot;\n    } else {\n      nextNum = data.readInt32LE(partOffset);\n    }\n    pointNumber = nextNum - curNum;\n    if (!pointNumber) {\n      continue;\n    }\n    out.push(this.parsePointArray(data, offset, pointNumber));\n    offset += (pointNumber << 4);\n  }\n  return out;\n};\nParseShp.prototype.parseZArrayGroup = function (data, zOffset, num, coordinates) {\n  let i = 0;\n  while (i < num) {\n    coordinates[i] = this.parseZPointArray(data, zOffset, coordinates[i].length, coordinates[i]);\n    zOffset += (coordinates[i].length << 3);\n    i++;\n  }\n  return coordinates;\n};\nParseShp.prototype.parseMultiPoint = function (data) {\n  const out = {};\n  const mins = this.parseCoord(data, 0);\n  const maxs = this.parseCoord(data, 16);\n  out.bbox = [\n    mins[0],\n    mins[1],\n    maxs[0],\n    maxs[1]\n  ];\n  const num = data.readInt32LE(32, true);\n  const offset = 36;\n  if (num === 1) {\n    out.type = 'Point';\n    out.coordinates = this.parseCoord(data, offset);\n  } else {\n    out.type = 'MultiPoint';\n    out.coordinates = this.parsePointArray(data, offset, num);\n  }\n  return out;\n};\nParseShp.prototype.parseZMultiPoint = function (data) {\n  const geoJson = this.parseMultiPoint(data);\n  let num;\n  if (geoJson.type === 'Point') {\n    geoJson.coordinates.push(data.readDoubleLE(72));\n    return geoJson;\n  } else {\n    num = geoJson.coordinates.length;\n  }\n  const zOffset = 52 + (num << 4);\n  geoJson.coordinates = this.parseZPointArray(data, zOffset, num, geoJson.coordinates);\n  return geoJson;\n};\nParseShp.prototype.parsePolyline = function (data) {\n  const out = {};\n  const mins = this.parseCoord(data, 0);\n  const maxs = this.parseCoord(data, 16);\n  out.bbox = [\n    mins[0],\n    mins[1],\n    maxs[0],\n    maxs[1]\n  ];\n  const numParts = data.readInt32LE(32);\n  const num = data.readInt32LE(36);\n  let offset, partOffset;\n  if (numParts === 1) {\n    out.type = 'LineString';\n    offset = 44;\n    out.coordinates = this.parsePointArray(data, offset, num);\n  } else {\n    out.type = 'MultiLineString';\n    offset = 40 + (numParts << 2);\n    partOffset = 40;\n    out.coordinates = this.parseArrayGroup(data, offset, partOffset, numParts, num);\n  }\n  return out;\n};\nParseShp.prototype.parseZPolyline = function (data) {\n  const geoJson = this.parsePolyline(data);\n  const num = geoJson.coordinates.length;\n  let zOffset;\n  if (geoJson.type === 'LineString') {\n    zOffset = 60 + (num << 4);\n    geoJson.coordinates = this.parseZPointArray(data, zOffset, num, geoJson.coordinates);\n    return geoJson;\n  } else {\n    const totalPoints = geoJson.coordinates.reduce(function (a, v) {\n      return a + v.length;\n    }, 0);\n    zOffset = 56 + (totalPoints << 4) + (num << 2);\n    geoJson.coordinates = this.parseZArrayGroup(data, zOffset, num, geoJson.coordinates);\n    return geoJson;\n  }\n};\nParseShp.prototype.polyFuncs = function (out) {\n  if (out.type === 'LineString') {\n    out.type = 'Polygon';\n    out.coordinates = [out.coordinates];\n    return out;\n  } else {\n    out.coordinates = out.coordinates.reduce(polyReduce, []);\n    if (out.coordinates.length === 1) {\n      out.type = 'Polygon';\n      out.coordinates = out.coordinates[0];\n      return out;\n    } else {\n      out.type = 'MultiPolygon';\n      return out;\n    }\n  }\n};\nParseShp.prototype.parsePolygon = function (data) {\n  return this.polyFuncs(this.parsePolyline(data));\n};\nParseShp.prototype.parseZPolygon = function (data) {\n  return this.polyFuncs(this.parseZPolyline(data));\n};\nconst shpFuncObj = {\n  1: 'parsePoint',\n  3: 'parsePolyline',\n  5: 'parsePolygon',\n  8: 'parseMultiPoint',\n  11: 'parseZPoint',\n  13: 'parseZPolyline',\n  15: 'parseZPolygon',\n  18: 'parseZMultiPoint'\n};\n\nfunction makeParseCoord (trans) {\n  if (trans) {\n    return function (data, offset) {\n      return trans.inverse([data.readDoubleLE(offset), data.readDoubleLE(offset + 8)]);\n    };\n  } else {\n    return function (data, offset) {\n      return [data.readDoubleLE(offset), data.readDoubleLE(offset + 8)];\n    };\n  }\n}\n\nfunction ParseShp (buffer, trans) {\n  if (!(this instanceof ParseShp)) {\n    return new ParseShp(buffer, trans);\n  }\n  this.buffer = buffer;\n  this.headers = this.parseHeader();\n  if (this.headers.length < this.buffer.byteLength) {\n    this.buffer = this.buffer.slice(0, this.headers.length);\n  }\n  this.shpFuncs(trans);\n  this.rows = this.getRows();\n}\nParseShp.prototype.shpFuncs = function (tran) {\n  let num = this.headers.shpCode;\n  if (num > 20) {\n    num -= 20;\n  }\n  if (!(num in shpFuncObj)) {\n    throw new Error('I don\\'t know that shp type');\n  }\n  this.parseFunc = this[shpFuncObj[num]];\n  this.parseCoord = makeParseCoord(tran);\n};\nParseShp.prototype.getShpCode = function () {\n  return this.parseHeader().shpCode;\n};\nParseShp.prototype.parseHeader = function () {\n  const view = this.buffer.slice(0, 100);\n  return {\n    length: view.readInt32BE(6 << 2) << 1,\n    version: view.readInt32LE(7 << 2),\n    shpCode: view.readInt32LE(8 << 2),\n    bbox: [\n      view.readDoubleLE(9 << 2),\n      view.readDoubleLE(11 << 2),\n      view.readDoubleLE(13 << 2),\n      view.readDoubleLE(13 << 2)\n    ]\n  };\n};\nParseShp.prototype.getRows = function () {\n  let offset = 100;\n  const len = this.buffer.byteLength;\n  const out = [];\n  let current;\n  while (offset < len) {\n    current = this.getRow(offset);\n    if (!current) {\n      break;\n    }\n    offset += 8;\n    offset += current.len;\n    if (current.type) {\n      out.push(this.parseFunc(current.data));\n    } else {\n      out.push(null);\n    }\n  }\n  return out;\n};\nParseShp.prototype.getRow = function (offset) {\n  const view = this.buffer.slice(offset, offset + 12);\n  const len = view.readInt32BE(4) << 1;\n  const id = view.readInt32BE(0);\n  if (len === 0) {\n    return {\n      id: id,\n      len: len,\n      type: 0\n    };\n  }\n  return {\n    id: id,\n    len: len,\n    data: this.buffer.slice(offset + 12, offset + len + 8),\n    type: view.readInt32LE(8)\n  };\n};\nmodule.exports = function (buffer, trans) {\n  return new ParseShp(buffer, trans).rows;\n};\n"]},"metadata":{},"sourceType":"script"}