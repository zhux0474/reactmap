{"ast":null,"code":"/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v26.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\n\nimport { ColumnKeyCreator } from \"./columnKeyCreator\";\nimport { ProvidedColumnGroup } from \"../entities/providedColumnGroup\";\nimport { Column } from \"../entities/column\";\nimport { Autowired, Bean, Qualifier } from \"../context/context\";\nimport { DefaultColumnTypes } from \"../entities/defaultColumnTypes\";\nimport { BeanStub } from \"../context/beanStub\";\nimport { Constants } from \"../constants/constants\";\nimport { assign, iterateObject, mergeDeep } from '../utils/object';\nimport { attrToNumber, attrToBoolean, find } from '../utils/generic';\nimport { removeFromArray } from '../utils/array'; // takes ColDefs and ColGroupDefs and turns them into Columns and OriginalGroups\n\nvar ColumnFactory =\n/** @class */\nfunction (_super) {\n  __extends(ColumnFactory, _super);\n\n  function ColumnFactory() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  ColumnFactory.prototype.setBeans = function (loggerFactory) {\n    this.logger = loggerFactory.create('ColumnFactory');\n  };\n\n  ColumnFactory.prototype.createColumnTree = function (defs, primaryColumns, existingTree) {\n    // column key creator dishes out unique column id's in a deterministic way,\n    // so if we have two grids (that could be master/slave) with same column definitions,\n    // then this ensures the two grids use identical id's.\n    var columnKeyCreator = new ColumnKeyCreator();\n\n    var _a = this.extractExistingTreeData(existingTree),\n        existingCols = _a.existingCols,\n        existingGroups = _a.existingGroups,\n        existingColKeys = _a.existingColKeys;\n\n    columnKeyCreator.addExistingKeys(existingColKeys); // create am unbalanced tree that maps the provided definitions\n\n    var unbalancedTree = this.recursivelyCreateColumns(defs, 0, primaryColumns, existingCols, columnKeyCreator, existingGroups);\n    var treeDept = this.findMaxDept(unbalancedTree, 0);\n    this.logger.log('Number of levels for grouped columns is ' + treeDept);\n    var columnTree = this.balanceColumnTree(unbalancedTree, 0, treeDept, columnKeyCreator);\n\n    var deptFirstCallback = function (child, parent) {\n      if (child instanceof ProvidedColumnGroup) {\n        child.setupExpandable();\n      } // we set the original parents at the end, rather than when we go along, as balancing the tree\n      // adds extra levels into the tree. so we can only set parents when balancing is done.\n\n\n      child.setOriginalParent(parent);\n    };\n\n    this.columnUtils.depthFirstOriginalTreeSearch(null, columnTree, deptFirstCallback);\n    return {\n      columnTree: columnTree,\n      treeDept: treeDept\n    };\n  };\n\n  ColumnFactory.prototype.extractExistingTreeData = function (existingTree) {\n    var existingCols = [];\n    var existingGroups = [];\n    var existingColKeys = [];\n\n    if (existingTree) {\n      this.columnUtils.depthFirstOriginalTreeSearch(null, existingTree, function (item) {\n        if (item instanceof ProvidedColumnGroup) {\n          var group = item;\n          existingGroups.push(group);\n        } else {\n          var col = item;\n          existingColKeys.push(col.getId());\n          existingCols.push(col);\n        }\n      });\n    }\n\n    return {\n      existingCols: existingCols,\n      existingGroups: existingGroups,\n      existingColKeys: existingColKeys\n    };\n  };\n\n  ColumnFactory.prototype.createForAutoGroups = function (autoGroupCols, gridBalancedTree) {\n    var _this = this;\n\n    var autoColBalancedTree = [];\n    autoGroupCols.forEach(function (col) {\n      var fakeTreeItem = _this.createAutoGroupTreeItem(gridBalancedTree, col);\n\n      autoColBalancedTree.push(fakeTreeItem);\n    });\n    return autoColBalancedTree;\n  };\n\n  ColumnFactory.prototype.createAutoGroupTreeItem = function (balancedColumnTree, column) {\n    var dept = this.findDepth(balancedColumnTree); // at the end, this will be the top of the tree item.\n\n    var nextChild = column;\n\n    for (var i = dept - 1; i >= 0; i--) {\n      var autoGroup = new ProvidedColumnGroup(null, \"FAKE_PATH_\" + column.getId() + \"}_\" + i, true, i);\n      this.context.createBean(autoGroup);\n      autoGroup.setChildren([nextChild]);\n      nextChild.setOriginalParent(autoGroup);\n      nextChild = autoGroup;\n    } // at this point, the nextChild is the top most item in the tree\n\n\n    return nextChild;\n  };\n\n  ColumnFactory.prototype.findDepth = function (balancedColumnTree) {\n    var dept = 0;\n    var pointer = balancedColumnTree;\n\n    while (pointer && pointer[0] && pointer[0] instanceof ProvidedColumnGroup) {\n      dept++;\n      pointer = pointer[0].getChildren();\n    }\n\n    return dept;\n  };\n\n  ColumnFactory.prototype.balanceColumnTree = function (unbalancedTree, currentDept, columnDept, columnKeyCreator) {\n    var result = []; // go through each child, for groups, recurse a level deeper,\n    // for columns we need to pad\n\n    for (var i = 0; i < unbalancedTree.length; i++) {\n      var child = unbalancedTree[i];\n\n      if (child instanceof ProvidedColumnGroup) {\n        // child is a group, all we do is go to the next level of recursion\n        var originalGroup = child;\n        var newChildren = this.balanceColumnTree(originalGroup.getChildren(), currentDept + 1, columnDept, columnKeyCreator);\n        originalGroup.setChildren(newChildren);\n        result.push(originalGroup);\n      } else {\n        // child is a column - so here we add in the padded column groups if needed\n        var firstPaddedGroup = void 0;\n        var currentPaddedGroup = void 0; // this for loop will NOT run any loops if no padded column groups are needed\n\n        for (var j = columnDept - 1; j >= currentDept; j--) {\n          var newColId = columnKeyCreator.getUniqueKey(null, null);\n          var colGroupDefMerged = this.createMergedColGroupDef(null);\n          var paddedGroup = new ProvidedColumnGroup(colGroupDefMerged, newColId, true, currentDept);\n          this.context.createBean(paddedGroup);\n\n          if (currentPaddedGroup) {\n            currentPaddedGroup.setChildren([paddedGroup]);\n          }\n\n          currentPaddedGroup = paddedGroup;\n\n          if (!firstPaddedGroup) {\n            firstPaddedGroup = currentPaddedGroup;\n          }\n        } // likewise this if statement will not run if no padded groups\n\n\n        if (firstPaddedGroup && currentPaddedGroup) {\n          result.push(firstPaddedGroup);\n          var hasGroups = unbalancedTree.some(function (leaf) {\n            return leaf instanceof ProvidedColumnGroup;\n          });\n\n          if (hasGroups) {\n            currentPaddedGroup.setChildren([child]);\n            continue;\n          } else {\n            currentPaddedGroup.setChildren(unbalancedTree);\n            break;\n          }\n        }\n\n        result.push(child);\n      }\n    }\n\n    return result;\n  };\n\n  ColumnFactory.prototype.findMaxDept = function (treeChildren, dept) {\n    var maxDeptThisLevel = dept;\n\n    for (var i = 0; i < treeChildren.length; i++) {\n      var abstractColumn = treeChildren[i];\n\n      if (abstractColumn instanceof ProvidedColumnGroup) {\n        var originalGroup = abstractColumn;\n        var newDept = this.findMaxDept(originalGroup.getChildren(), dept + 1);\n\n        if (maxDeptThisLevel < newDept) {\n          maxDeptThisLevel = newDept;\n        }\n      }\n    }\n\n    return maxDeptThisLevel;\n  };\n\n  ColumnFactory.prototype.recursivelyCreateColumns = function (defs, level, primaryColumns, existingColsCopy, columnKeyCreator, existingGroups) {\n    var _this = this;\n\n    var result = [];\n\n    if (!defs) {\n      return result;\n    }\n\n    defs.forEach(function (def) {\n      var newGroupOrColumn;\n\n      if (_this.isColumnGroup(def)) {\n        newGroupOrColumn = _this.createColumnGroup(primaryColumns, def, level, existingColsCopy, columnKeyCreator, existingGroups);\n      } else {\n        newGroupOrColumn = _this.createColumn(primaryColumns, def, existingColsCopy, columnKeyCreator);\n      }\n\n      result.push(newGroupOrColumn);\n    });\n    return result;\n  };\n\n  ColumnFactory.prototype.createColumnGroup = function (primaryColumns, colGroupDef, level, existingColumns, columnKeyCreator, existingGroups) {\n    var colGroupDefMerged = this.createMergedColGroupDef(colGroupDef);\n    var groupId = columnKeyCreator.getUniqueKey(colGroupDefMerged.groupId || null, null);\n    var originalGroup = new ProvidedColumnGroup(colGroupDefMerged, groupId, false, level);\n    this.context.createBean(originalGroup);\n    var existingGroup = this.findExistingGroup(colGroupDef, existingGroups);\n\n    if (existingGroup && existingGroup.isExpanded()) {\n      originalGroup.setExpanded(true);\n    }\n\n    var children = this.recursivelyCreateColumns(colGroupDefMerged.children, level + 1, primaryColumns, existingColumns, columnKeyCreator, existingGroups);\n    originalGroup.setChildren(children);\n    return originalGroup;\n  };\n\n  ColumnFactory.prototype.createMergedColGroupDef = function (colGroupDef) {\n    var colGroupDefMerged = {};\n    assign(colGroupDefMerged, this.gridOptionsWrapper.getDefaultColGroupDef());\n    assign(colGroupDefMerged, colGroupDef);\n    this.checkForDeprecatedItems(colGroupDefMerged);\n    return colGroupDefMerged;\n  };\n\n  ColumnFactory.prototype.createColumn = function (primaryColumns, colDef, existingColsCopy, columnKeyCreator) {\n    var colDefMerged = this.mergeColDefs(colDef);\n    this.checkForDeprecatedItems(colDefMerged); // see if column already exists\n\n    var column = this.findExistingColumn(colDef, existingColsCopy);\n\n    if (!column) {\n      // no existing column, need to create one\n      var colId = columnKeyCreator.getUniqueKey(colDefMerged.colId, colDefMerged.field);\n      column = new Column(colDefMerged, colDef, colId, primaryColumns);\n      this.context.createBean(column);\n    } else {\n      column.setColDef(colDefMerged, colDef);\n      this.applyColumnState(column, colDefMerged);\n    }\n\n    return column;\n  };\n\n  ColumnFactory.prototype.applyColumnState = function (column, colDef) {\n    // flex\n    var flex = attrToNumber(colDef.flex);\n\n    if (flex !== undefined) {\n      column.setFlex(flex);\n    } // width - we only set width if column is not flexing\n\n\n    var noFlexThisCol = column.getFlex() <= 0;\n\n    if (noFlexThisCol) {\n      // both null and undefined means we skip, as it's not possible to 'clear' width (a column must have a width)\n      var width = attrToNumber(colDef.width);\n\n      if (width != null) {\n        column.setActualWidth(width);\n      } else {\n        // otherwise set the width again, in case min or max width has changed,\n        // and width needs to be adjusted.\n        var widthBeforeUpdate = column.getActualWidth();\n        column.setActualWidth(widthBeforeUpdate);\n      }\n    } // sort - anything but undefined will set sort, thus null or empty string will clear the sort\n\n\n    if (colDef.sort !== undefined) {\n      if (colDef.sort == Constants.SORT_ASC || colDef.sort == Constants.SORT_DESC) {\n        column.setSort(colDef.sort);\n      } else {\n        column.setSort(undefined);\n      }\n    } // sorted at - anything but undefined, thus null will clear the sortIndex\n\n\n    var sortIndex = attrToNumber(colDef.sortIndex);\n\n    if (sortIndex !== undefined) {\n      column.setSortIndex(sortIndex);\n    } // hide - anything but undefined, thus null will clear the hide\n\n\n    var hide = attrToBoolean(colDef.hide);\n\n    if (hide !== undefined) {\n      column.setVisible(!hide);\n    } // pinned - anything but undefined, thus null or empty string will remove pinned\n\n\n    if (colDef.pinned !== undefined) {\n      column.setPinned(colDef.pinned);\n    }\n  };\n\n  ColumnFactory.prototype.findExistingColumn = function (newColDef, existingColsCopy) {\n    var res = find(existingColsCopy, function (existingCol) {\n      var existingColDef = existingCol.getUserProvidedColDef();\n\n      if (!existingColDef) {\n        return false;\n      }\n\n      var newHasId = newColDef.colId != null;\n      var newHasField = newColDef.field != null;\n\n      if (newHasId) {\n        return existingCol.getId() === newColDef.colId;\n      }\n\n      if (newHasField) {\n        return existingColDef.field === newColDef.field;\n      } // if no id or field present, then try object equivalence.\n\n\n      if (existingColDef === newColDef) {\n        return true;\n      }\n\n      return false;\n    }); // make sure we remove, so if user provided duplicate id, then we don't have more than\n    // one column instance for colDef with common id\n\n    if (existingColsCopy && res) {\n      removeFromArray(existingColsCopy, res);\n    }\n\n    return res;\n  };\n\n  ColumnFactory.prototype.findExistingGroup = function (newGroupDef, existingGroups) {\n    var res = find(existingGroups, function (existingGroup) {\n      var existingDef = existingGroup.getColGroupDef();\n\n      if (!existingDef) {\n        return false;\n      }\n\n      var newHasId = newGroupDef.groupId != null;\n\n      if (newHasId) {\n        return existingGroup.getId() === newGroupDef.groupId;\n      }\n\n      return false;\n    }); // make sure we remove, so if user provided duplicate id, then we don't have more than\n    // one column instance for colDef with common id\n\n    if (res) {\n      removeFromArray(existingGroups, res);\n    }\n\n    return res;\n  };\n\n  ColumnFactory.prototype.mergeColDefs = function (colDef) {\n    // start with empty merged definition\n    var colDefMerged = {}; // merge properties from default column definitions\n\n    var defaultColDef = this.gridOptionsWrapper.getDefaultColDef();\n    mergeDeep(colDefMerged, defaultColDef, false, true); // merge properties from column type properties\n\n    var columnType = colDef.type;\n\n    if (!columnType) {\n      columnType = defaultColDef && defaultColDef.type;\n    } // if type of both colDef and defaultColDef, then colDef gets preference\n\n\n    if (columnType) {\n      this.assignColumnTypes(columnType, colDefMerged);\n    } // merge properties from column definitions\n\n\n    mergeDeep(colDefMerged, colDef, false, true);\n    return colDefMerged;\n  };\n\n  ColumnFactory.prototype.assignColumnTypes = function (type, colDefMerged) {\n    var typeKeys = [];\n\n    if (type instanceof Array) {\n      var invalidArray = type.some(function (a) {\n        return typeof a !== 'string';\n      });\n\n      if (invalidArray) {\n        console.warn(\"ag-grid: if colDef.type is supplied an array it should be of type 'string[]'\");\n      } else {\n        typeKeys = type;\n      }\n    } else if (typeof type === 'string') {\n      typeKeys = type.split(',');\n    } else {\n      console.warn(\"ag-grid: colDef.type should be of type 'string' | 'string[]'\");\n      return;\n    } // merge user defined with default column types\n\n\n    var allColumnTypes = assign({}, DefaultColumnTypes);\n    var userTypes = this.gridOptionsWrapper.getColumnTypes() || {};\n    iterateObject(userTypes, function (key, value) {\n      if (key in allColumnTypes) {\n        console.warn(\"AG Grid: the column type '\" + key + \"' is a default column type and cannot be overridden.\");\n      } else {\n        allColumnTypes[key] = value;\n      }\n    });\n    typeKeys.forEach(function (t) {\n      var typeColDef = allColumnTypes[t.trim()];\n\n      if (typeColDef) {\n        mergeDeep(colDefMerged, typeColDef, false, true);\n      } else {\n        console.warn(\"ag-grid: colDef.type '\" + t + \"' does not correspond to defined gridOptions.columnTypes\");\n      }\n    });\n  };\n\n  ColumnFactory.prototype.checkForDeprecatedItems = function (colDef) {\n    if (colDef) {\n      var colDefNoType = colDef; // take out the type, so we can access attributes not defined in the type\n\n      if (colDefNoType.group !== undefined) {\n        console.warn('ag-grid: colDef.group is invalid, please check documentation on how to do grouping as it changed in version 3');\n      }\n\n      if (colDefNoType.headerGroup !== undefined) {\n        console.warn('ag-grid: colDef.headerGroup is invalid, please check documentation on how to do grouping as it changed in version 3');\n      }\n\n      if (colDefNoType.headerGroupShow !== undefined) {\n        console.warn('ag-grid: colDef.headerGroupShow is invalid, should be columnGroupShow, please check documentation on how to do grouping as it changed in version 3');\n      }\n\n      if (colDefNoType.suppressRowGroup !== undefined) {\n        console.warn('ag-grid: colDef.suppressRowGroup is deprecated, please use colDef.type instead');\n      }\n\n      if (colDefNoType.suppressAggregation !== undefined) {\n        console.warn('ag-grid: colDef.suppressAggregation is deprecated, please use colDef.type instead');\n      }\n\n      if (colDefNoType.suppressRowGroup || colDefNoType.suppressAggregation) {\n        console.warn('ag-grid: colDef.suppressAggregation and colDef.suppressRowGroup are deprecated, use allowRowGroup, allowPivot and allowValue instead');\n      }\n\n      if (colDefNoType.displayName) {\n        console.warn(\"ag-grid: Found displayName \" + colDefNoType.displayName + \", please use headerName instead, displayName is deprecated.\");\n        colDefNoType.headerName = colDefNoType.displayName;\n      }\n    }\n  }; // if object has children, we assume it's a group\n\n\n  ColumnFactory.prototype.isColumnGroup = function (abstractColDef) {\n    return abstractColDef.children !== undefined;\n  };\n\n  __decorate([Autowired('columnUtils')], ColumnFactory.prototype, \"columnUtils\", void 0);\n\n  __decorate([__param(0, Qualifier('loggerFactory'))], ColumnFactory.prototype, \"setBeans\", null);\n\n  ColumnFactory = __decorate([Bean('columnFactory')], ColumnFactory);\n  return ColumnFactory;\n}(BeanStub);\n\nexport { ColumnFactory };","map":{"version":3,"sources":["/Users/rongxuan/Desktop/reactmap/reactmap/node_modules/@ag-grid-community/core/dist/es6/columns/columnFactory.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","ColumnKeyCreator","ProvidedColumnGroup","Column","Autowired","Bean","Qualifier","DefaultColumnTypes","BeanStub","Constants","assign","iterateObject","mergeDeep","attrToNumber","attrToBoolean","find","removeFromArray","ColumnFactory","_super","apply","setBeans","loggerFactory","logger","createColumnTree","defs","primaryColumns","existingTree","columnKeyCreator","_a","extractExistingTreeData","existingCols","existingGroups","existingColKeys","addExistingKeys","unbalancedTree","recursivelyCreateColumns","treeDept","findMaxDept","log","columnTree","balanceColumnTree","deptFirstCallback","child","parent","setupExpandable","setOriginalParent","columnUtils","depthFirstOriginalTreeSearch","item","group","push","col","getId","createForAutoGroups","autoGroupCols","gridBalancedTree","_this","autoColBalancedTree","forEach","fakeTreeItem","createAutoGroupTreeItem","balancedColumnTree","column","dept","findDepth","nextChild","autoGroup","context","createBean","setChildren","pointer","getChildren","currentDept","columnDept","result","originalGroup","newChildren","firstPaddedGroup","currentPaddedGroup","j","newColId","getUniqueKey","colGroupDefMerged","createMergedColGroupDef","paddedGroup","hasGroups","some","leaf","treeChildren","maxDeptThisLevel","abstractColumn","newDept","level","existingColsCopy","def","newGroupOrColumn","isColumnGroup","createColumnGroup","createColumn","colGroupDef","existingColumns","groupId","existingGroup","findExistingGroup","isExpanded","setExpanded","children","gridOptionsWrapper","getDefaultColGroupDef","checkForDeprecatedItems","colDef","colDefMerged","mergeColDefs","findExistingColumn","colId","field","setColDef","applyColumnState","flex","undefined","setFlex","noFlexThisCol","getFlex","width","setActualWidth","widthBeforeUpdate","getActualWidth","sort","SORT_ASC","SORT_DESC","setSort","sortIndex","setSortIndex","hide","setVisible","pinned","setPinned","newColDef","res","existingCol","existingColDef","getUserProvidedColDef","newHasId","newHasField","newGroupDef","existingDef","getColGroupDef","defaultColDef","getDefaultColDef","columnType","type","assignColumnTypes","typeKeys","invalidArray","a","console","warn","split","allColumnTypes","userTypes","getColumnTypes","value","t","typeColDef","trim","colDefNoType","headerGroup","headerGroupShow","suppressRowGroup","suppressAggregation","displayName","headerName","abstractColDef"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIA,SAAS,GAAI,QAAQ,KAAKA,SAAd,IAA6B,YAAY;AACrD,MAAIC,aAAa,GAAG,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AAChCF,IAAAA,aAAa,GAAGG,MAAM,CAACC,cAAP,IACX;AAAEC,MAAAA,SAAS,EAAE;AAAb,iBAA6BC,KAA7B,IAAsC,UAAUL,CAAV,EAAaC,CAAb,EAAgB;AAAED,MAAAA,CAAC,CAACI,SAAF,GAAcH,CAAd;AAAkB,KAD/D,IAEZ,UAAUD,CAAV,EAAaC,CAAb,EAAgB;AAAE,WAAK,IAAIK,CAAT,IAAcL,CAAd,EAAiB,IAAIA,CAAC,CAACM,cAAF,CAAiBD,CAAjB,CAAJ,EAAyBN,CAAC,CAACM,CAAD,CAAD,GAAOL,CAAC,CAACK,CAAD,CAAR;AAAc,KAF9E;;AAGA,WAAOP,aAAa,CAACC,CAAD,EAAIC,CAAJ,CAApB;AACH,GALD;;AAMA,SAAO,UAAUD,CAAV,EAAaC,CAAb,EAAgB;AACnBF,IAAAA,aAAa,CAACC,CAAD,EAAIC,CAAJ,CAAb;;AACA,aAASO,EAAT,GAAc;AAAE,WAAKC,WAAL,GAAmBT,CAAnB;AAAuB;;AACvCA,IAAAA,CAAC,CAACU,SAAF,GAAcT,CAAC,KAAK,IAAN,GAAaC,MAAM,CAACS,MAAP,CAAcV,CAAd,CAAb,IAAiCO,EAAE,CAACE,SAAH,GAAeT,CAAC,CAACS,SAAjB,EAA4B,IAAIF,EAAJ,EAA7D,CAAd;AACH,GAJD;AAKH,CAZ2C,EAA5C;;AAaA,IAAII,UAAU,GAAI,QAAQ,KAAKA,UAAd,IAA6B,UAAUC,UAAV,EAAsBC,MAAtB,EAA8BC,GAA9B,EAAmCC,IAAnC,EAAyC;AACnF,MAAIC,CAAC,GAAGC,SAAS,CAACC,MAAlB;AAAA,MAA0BC,CAAC,GAAGH,CAAC,GAAG,CAAJ,GAAQH,MAAR,GAAiBE,IAAI,KAAK,IAAT,GAAgBA,IAAI,GAAGd,MAAM,CAACmB,wBAAP,CAAgCP,MAAhC,EAAwCC,GAAxC,CAAvB,GAAsEC,IAArH;AAAA,MAA2HhB,CAA3H;AACA,MAAI,OAAOsB,OAAP,KAAmB,QAAnB,IAA+B,OAAOA,OAAO,CAACC,QAAf,KAA4B,UAA/D,EAA2EH,CAAC,GAAGE,OAAO,CAACC,QAAR,CAAiBV,UAAjB,EAA6BC,MAA7B,EAAqCC,GAArC,EAA0CC,IAA1C,CAAJ,CAA3E,KACK,KAAK,IAAIQ,CAAC,GAAGX,UAAU,CAACM,MAAX,GAAoB,CAAjC,EAAoCK,CAAC,IAAI,CAAzC,EAA4CA,CAAC,EAA7C,EAAiD,IAAIxB,CAAC,GAAGa,UAAU,CAACW,CAAD,CAAlB,EAAuBJ,CAAC,GAAG,CAACH,CAAC,GAAG,CAAJ,GAAQjB,CAAC,CAACoB,CAAD,CAAT,GAAeH,CAAC,GAAG,CAAJ,GAAQjB,CAAC,CAACc,MAAD,EAASC,GAAT,EAAcK,CAAd,CAAT,GAA4BpB,CAAC,CAACc,MAAD,EAASC,GAAT,CAA7C,KAA+DK,CAAnE;AAC7E,SAAOH,CAAC,GAAG,CAAJ,IAASG,CAAT,IAAclB,MAAM,CAACuB,cAAP,CAAsBX,MAAtB,EAA8BC,GAA9B,EAAmCK,CAAnC,CAAd,EAAqDA,CAA5D;AACH,CALD;;AAMA,IAAIM,OAAO,GAAI,QAAQ,KAAKA,OAAd,IAA0B,UAAUC,UAAV,EAAsBC,SAAtB,EAAiC;AACrE,SAAO,UAAUd,MAAV,EAAkBC,GAAlB,EAAuB;AAAEa,IAAAA,SAAS,CAACd,MAAD,EAASC,GAAT,EAAcY,UAAd,CAAT;AAAqC,GAArE;AACH,CAFD;;AAGA,SAASE,gBAAT,QAAiC,oBAAjC;AACA,SAASC,mBAAT,QAAoC,iCAApC;AACA,SAASC,MAAT,QAAuB,oBAAvB;AACA,SAASC,SAAT,EAAoBC,IAApB,EAA0BC,SAA1B,QAA2C,oBAA3C;AACA,SAASC,kBAAT,QAAmC,gCAAnC;AACA,SAASC,QAAT,QAAyB,qBAAzB;AACA,SAASC,SAAT,QAA0B,wBAA1B;AACA,SAASC,MAAT,EAAiBC,aAAjB,EAAgCC,SAAhC,QAAiD,iBAAjD;AACA,SAASC,YAAT,EAAuBC,aAAvB,EAAsCC,IAAtC,QAAkD,kBAAlD;AACA,SAASC,eAAT,QAAgC,gBAAhC,C,CACA;;AACA,IAAIC,aAAa;AAAG;AAAe,UAAUC,MAAV,EAAkB;AACjDhD,EAAAA,SAAS,CAAC+C,aAAD,EAAgBC,MAAhB,CAAT;;AACA,WAASD,aAAT,GAAyB;AACrB,WAAOC,MAAM,KAAK,IAAX,IAAmBA,MAAM,CAACC,KAAP,CAAa,IAAb,EAAmB7B,SAAnB,CAAnB,IAAoD,IAA3D;AACH;;AACD2B,EAAAA,aAAa,CAACnC,SAAd,CAAwBsC,QAAxB,GAAmC,UAAUC,aAAV,EAAyB;AACxD,SAAKC,MAAL,GAAcD,aAAa,CAACtC,MAAd,CAAqB,eAArB,CAAd;AACH,GAFD;;AAGAkC,EAAAA,aAAa,CAACnC,SAAd,CAAwByC,gBAAxB,GAA2C,UAAUC,IAAV,EAAgBC,cAAhB,EAAgCC,YAAhC,EAA8C;AACrF;AACA;AACA;AACA,QAAIC,gBAAgB,GAAG,IAAI1B,gBAAJ,EAAvB;;AACA,QAAI2B,EAAE,GAAG,KAAKC,uBAAL,CAA6BH,YAA7B,CAAT;AAAA,QAAqDI,YAAY,GAAGF,EAAE,CAACE,YAAvE;AAAA,QAAqFC,cAAc,GAAGH,EAAE,CAACG,cAAzG;AAAA,QAAyHC,eAAe,GAAGJ,EAAE,CAACI,eAA9I;;AACAL,IAAAA,gBAAgB,CAACM,eAAjB,CAAiCD,eAAjC,EANqF,CAOrF;;AACA,QAAIE,cAAc,GAAG,KAAKC,wBAAL,CAA8BX,IAA9B,EAAoC,CAApC,EAAuCC,cAAvC,EAAuDK,YAAvD,EAAqEH,gBAArE,EAAuFI,cAAvF,CAArB;AACA,QAAIK,QAAQ,GAAG,KAAKC,WAAL,CAAiBH,cAAjB,EAAiC,CAAjC,CAAf;AACA,SAAKZ,MAAL,CAAYgB,GAAZ,CAAgB,6CAA6CF,QAA7D;AACA,QAAIG,UAAU,GAAG,KAAKC,iBAAL,CAAuBN,cAAvB,EAAuC,CAAvC,EAA0CE,QAA1C,EAAoDT,gBAApD,CAAjB;;AACA,QAAIc,iBAAiB,GAAG,UAAUC,KAAV,EAAiBC,MAAjB,EAAyB;AAC7C,UAAID,KAAK,YAAYxC,mBAArB,EAA0C;AACtCwC,QAAAA,KAAK,CAACE,eAAN;AACH,OAH4C,CAI7C;AACA;;;AACAF,MAAAA,KAAK,CAACG,iBAAN,CAAwBF,MAAxB;AACH,KAPD;;AAQA,SAAKG,WAAL,CAAiBC,4BAAjB,CAA8C,IAA9C,EAAoDR,UAApD,EAAgEE,iBAAhE;AACA,WAAO;AACHF,MAAAA,UAAU,EAAEA,UADT;AAEHH,MAAAA,QAAQ,EAAEA;AAFP,KAAP;AAIH,GAzBD;;AA0BAnB,EAAAA,aAAa,CAACnC,SAAd,CAAwB+C,uBAAxB,GAAkD,UAAUH,YAAV,EAAwB;AACtE,QAAII,YAAY,GAAG,EAAnB;AACA,QAAIC,cAAc,GAAG,EAArB;AACA,QAAIC,eAAe,GAAG,EAAtB;;AACA,QAAIN,YAAJ,EAAkB;AACd,WAAKoB,WAAL,CAAiBC,4BAAjB,CAA8C,IAA9C,EAAoDrB,YAApD,EAAkE,UAAUsB,IAAV,EAAgB;AAC9E,YAAIA,IAAI,YAAY9C,mBAApB,EAAyC;AACrC,cAAI+C,KAAK,GAAGD,IAAZ;AACAjB,UAAAA,cAAc,CAACmB,IAAf,CAAoBD,KAApB;AACH,SAHD,MAIK;AACD,cAAIE,GAAG,GAAGH,IAAV;AACAhB,UAAAA,eAAe,CAACkB,IAAhB,CAAqBC,GAAG,CAACC,KAAJ,EAArB;AACAtB,UAAAA,YAAY,CAACoB,IAAb,CAAkBC,GAAlB;AACH;AACJ,OAVD;AAWH;;AACD,WAAO;AAAErB,MAAAA,YAAY,EAAEA,YAAhB;AAA8BC,MAAAA,cAAc,EAAEA,cAA9C;AAA8DC,MAAAA,eAAe,EAAEA;AAA/E,KAAP;AACH,GAlBD;;AAmBAf,EAAAA,aAAa,CAACnC,SAAd,CAAwBuE,mBAAxB,GAA8C,UAAUC,aAAV,EAAyBC,gBAAzB,EAA2C;AACrF,QAAIC,KAAK,GAAG,IAAZ;;AACA,QAAIC,mBAAmB,GAAG,EAA1B;AACAH,IAAAA,aAAa,CAACI,OAAd,CAAsB,UAAUP,GAAV,EAAe;AACjC,UAAIQ,YAAY,GAAGH,KAAK,CAACI,uBAAN,CAA8BL,gBAA9B,EAAgDJ,GAAhD,CAAnB;;AACAM,MAAAA,mBAAmB,CAACP,IAApB,CAAyBS,YAAzB;AACH,KAHD;AAIA,WAAOF,mBAAP;AACH,GARD;;AASAxC,EAAAA,aAAa,CAACnC,SAAd,CAAwB8E,uBAAxB,GAAkD,UAAUC,kBAAV,EAA8BC,MAA9B,EAAsC;AACpF,QAAIC,IAAI,GAAG,KAAKC,SAAL,CAAeH,kBAAf,CAAX,CADoF,CAEpF;;AACA,QAAII,SAAS,GAAGH,MAAhB;;AACA,SAAK,IAAIlE,CAAC,GAAGmE,IAAI,GAAG,CAApB,EAAuBnE,CAAC,IAAI,CAA5B,EAA+BA,CAAC,EAAhC,EAAoC;AAChC,UAAIsE,SAAS,GAAG,IAAIhE,mBAAJ,CAAwB,IAAxB,EAA8B,eAAe4D,MAAM,CAACV,KAAP,EAAf,GAAgC,IAAhC,GAAuCxD,CAArE,EAAwE,IAAxE,EAA8EA,CAA9E,CAAhB;AACA,WAAKuE,OAAL,CAAaC,UAAb,CAAwBF,SAAxB;AACAA,MAAAA,SAAS,CAACG,WAAV,CAAsB,CAACJ,SAAD,CAAtB;AACAA,MAAAA,SAAS,CAACpB,iBAAV,CAA4BqB,SAA5B;AACAD,MAAAA,SAAS,GAAGC,SAAZ;AACH,KAVmF,CAWpF;;;AACA,WAAOD,SAAP;AACH,GAbD;;AAcAhD,EAAAA,aAAa,CAACnC,SAAd,CAAwBkF,SAAxB,GAAoC,UAAUH,kBAAV,EAA8B;AAC9D,QAAIE,IAAI,GAAG,CAAX;AACA,QAAIO,OAAO,GAAGT,kBAAd;;AACA,WAAOS,OAAO,IAAIA,OAAO,CAAC,CAAD,CAAlB,IAAyBA,OAAO,CAAC,CAAD,CAAP,YAAsBpE,mBAAtD,EAA2E;AACvE6D,MAAAA,IAAI;AACJO,MAAAA,OAAO,GAAGA,OAAO,CAAC,CAAD,CAAP,CAAWC,WAAX,EAAV;AACH;;AACD,WAAOR,IAAP;AACH,GARD;;AASA9C,EAAAA,aAAa,CAACnC,SAAd,CAAwB0D,iBAAxB,GAA4C,UAAUN,cAAV,EAA0BsC,WAA1B,EAAuCC,UAAvC,EAAmD9C,gBAAnD,EAAqE;AAC7G,QAAI+C,MAAM,GAAG,EAAb,CAD6G,CAE7G;AACA;;AACA,SAAK,IAAI9E,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGsC,cAAc,CAAC3C,MAAnC,EAA2CK,CAAC,EAA5C,EAAgD;AAC5C,UAAI8C,KAAK,GAAGR,cAAc,CAACtC,CAAD,CAA1B;;AACA,UAAI8C,KAAK,YAAYxC,mBAArB,EAA0C;AACtC;AACA,YAAIyE,aAAa,GAAGjC,KAApB;AACA,YAAIkC,WAAW,GAAG,KAAKpC,iBAAL,CAAuBmC,aAAa,CAACJ,WAAd,EAAvB,EAAoDC,WAAW,GAAG,CAAlE,EAAqEC,UAArE,EAAiF9C,gBAAjF,CAAlB;AACAgD,QAAAA,aAAa,CAACN,WAAd,CAA0BO,WAA1B;AACAF,QAAAA,MAAM,CAACxB,IAAP,CAAYyB,aAAZ;AACH,OAND,MAOK;AACD;AACA,YAAIE,gBAAgB,GAAG,KAAK,CAA5B;AACA,YAAIC,kBAAkB,GAAG,KAAK,CAA9B,CAHC,CAID;;AACA,aAAK,IAAIC,CAAC,GAAGN,UAAU,GAAG,CAA1B,EAA6BM,CAAC,IAAIP,WAAlC,EAA+CO,CAAC,EAAhD,EAAoD;AAChD,cAAIC,QAAQ,GAAGrD,gBAAgB,CAACsD,YAAjB,CAA8B,IAA9B,EAAoC,IAApC,CAAf;AACA,cAAIC,iBAAiB,GAAG,KAAKC,uBAAL,CAA6B,IAA7B,CAAxB;AACA,cAAIC,WAAW,GAAG,IAAIlF,mBAAJ,CAAwBgF,iBAAxB,EAA2CF,QAA3C,EAAqD,IAArD,EAA2DR,WAA3D,CAAlB;AACA,eAAKL,OAAL,CAAaC,UAAb,CAAwBgB,WAAxB;;AACA,cAAIN,kBAAJ,EAAwB;AACpBA,YAAAA,kBAAkB,CAACT,WAAnB,CAA+B,CAACe,WAAD,CAA/B;AACH;;AACDN,UAAAA,kBAAkB,GAAGM,WAArB;;AACA,cAAI,CAACP,gBAAL,EAAuB;AACnBA,YAAAA,gBAAgB,GAAGC,kBAAnB;AACH;AACJ,SAjBA,CAkBD;;;AACA,YAAID,gBAAgB,IAAIC,kBAAxB,EAA4C;AACxCJ,UAAAA,MAAM,CAACxB,IAAP,CAAY2B,gBAAZ;AACA,cAAIQ,SAAS,GAAGnD,cAAc,CAACoD,IAAf,CAAoB,UAAUC,IAAV,EAAgB;AAAE,mBAAOA,IAAI,YAAYrF,mBAAvB;AAA6C,WAAnF,CAAhB;;AACA,cAAImF,SAAJ,EAAe;AACXP,YAAAA,kBAAkB,CAACT,WAAnB,CAA+B,CAAC3B,KAAD,CAA/B;AACA;AACH,WAHD,MAIK;AACDoC,YAAAA,kBAAkB,CAACT,WAAnB,CAA+BnC,cAA/B;AACA;AACH;AACJ;;AACDwC,QAAAA,MAAM,CAACxB,IAAP,CAAYR,KAAZ;AACH;AACJ;;AACD,WAAOgC,MAAP;AACH,GAhDD;;AAiDAzD,EAAAA,aAAa,CAACnC,SAAd,CAAwBuD,WAAxB,GAAsC,UAAUmD,YAAV,EAAwBzB,IAAxB,EAA8B;AAChE,QAAI0B,gBAAgB,GAAG1B,IAAvB;;AACA,SAAK,IAAInE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4F,YAAY,CAACjG,MAAjC,EAAyCK,CAAC,EAA1C,EAA8C;AAC1C,UAAI8F,cAAc,GAAGF,YAAY,CAAC5F,CAAD,CAAjC;;AACA,UAAI8F,cAAc,YAAYxF,mBAA9B,EAAmD;AAC/C,YAAIyE,aAAa,GAAGe,cAApB;AACA,YAAIC,OAAO,GAAG,KAAKtD,WAAL,CAAiBsC,aAAa,CAACJ,WAAd,EAAjB,EAA8CR,IAAI,GAAG,CAArD,CAAd;;AACA,YAAI0B,gBAAgB,GAAGE,OAAvB,EAAgC;AAC5BF,UAAAA,gBAAgB,GAAGE,OAAnB;AACH;AACJ;AACJ;;AACD,WAAOF,gBAAP;AACH,GAbD;;AAcAxE,EAAAA,aAAa,CAACnC,SAAd,CAAwBqD,wBAAxB,GAAmD,UAAUX,IAAV,EAAgBoE,KAAhB,EAAuBnE,cAAvB,EAAuCoE,gBAAvC,EAAyDlE,gBAAzD,EAA2EI,cAA3E,EAA2F;AAC1I,QAAIyB,KAAK,GAAG,IAAZ;;AACA,QAAIkB,MAAM,GAAG,EAAb;;AACA,QAAI,CAAClD,IAAL,EAAW;AACP,aAAOkD,MAAP;AACH;;AACDlD,IAAAA,IAAI,CAACkC,OAAL,CAAa,UAAUoC,GAAV,EAAe;AACxB,UAAIC,gBAAJ;;AACA,UAAIvC,KAAK,CAACwC,aAAN,CAAoBF,GAApB,CAAJ,EAA8B;AAC1BC,QAAAA,gBAAgB,GAAGvC,KAAK,CAACyC,iBAAN,CAAwBxE,cAAxB,EAAwCqE,GAAxC,EAA6CF,KAA7C,EAAoDC,gBAApD,EAAsElE,gBAAtE,EAAwFI,cAAxF,CAAnB;AACH,OAFD,MAGK;AACDgE,QAAAA,gBAAgB,GAAGvC,KAAK,CAAC0C,YAAN,CAAmBzE,cAAnB,EAAmCqE,GAAnC,EAAwCD,gBAAxC,EAA0DlE,gBAA1D,CAAnB;AACH;;AACD+C,MAAAA,MAAM,CAACxB,IAAP,CAAY6C,gBAAZ;AACH,KATD;AAUA,WAAOrB,MAAP;AACH,GAjBD;;AAkBAzD,EAAAA,aAAa,CAACnC,SAAd,CAAwBmH,iBAAxB,GAA4C,UAAUxE,cAAV,EAA0B0E,WAA1B,EAAuCP,KAAvC,EAA8CQ,eAA9C,EAA+DzE,gBAA/D,EAAiFI,cAAjF,EAAiG;AACzI,QAAImD,iBAAiB,GAAG,KAAKC,uBAAL,CAA6BgB,WAA7B,CAAxB;AACA,QAAIE,OAAO,GAAG1E,gBAAgB,CAACsD,YAAjB,CAA8BC,iBAAiB,CAACmB,OAAlB,IAA6B,IAA3D,EAAiE,IAAjE,CAAd;AACA,QAAI1B,aAAa,GAAG,IAAIzE,mBAAJ,CAAwBgF,iBAAxB,EAA2CmB,OAA3C,EAAoD,KAApD,EAA2DT,KAA3D,CAApB;AACA,SAAKzB,OAAL,CAAaC,UAAb,CAAwBO,aAAxB;AACA,QAAI2B,aAAa,GAAG,KAAKC,iBAAL,CAAuBJ,WAAvB,EAAoCpE,cAApC,CAApB;;AACA,QAAIuE,aAAa,IAAIA,aAAa,CAACE,UAAd,EAArB,EAAiD;AAC7C7B,MAAAA,aAAa,CAAC8B,WAAd,CAA0B,IAA1B;AACH;;AACD,QAAIC,QAAQ,GAAG,KAAKvE,wBAAL,CAA8B+C,iBAAiB,CAACwB,QAAhD,EAA0Dd,KAAK,GAAG,CAAlE,EAAqEnE,cAArE,EAAqF2E,eAArF,EAAsGzE,gBAAtG,EAAwHI,cAAxH,CAAf;AACA4C,IAAAA,aAAa,CAACN,WAAd,CAA0BqC,QAA1B;AACA,WAAO/B,aAAP;AACH,GAZD;;AAaA1D,EAAAA,aAAa,CAACnC,SAAd,CAAwBqG,uBAAxB,GAAkD,UAAUgB,WAAV,EAAuB;AACrE,QAAIjB,iBAAiB,GAAG,EAAxB;AACAxE,IAAAA,MAAM,CAACwE,iBAAD,EAAoB,KAAKyB,kBAAL,CAAwBC,qBAAxB,EAApB,CAAN;AACAlG,IAAAA,MAAM,CAACwE,iBAAD,EAAoBiB,WAApB,CAAN;AACA,SAAKU,uBAAL,CAA6B3B,iBAA7B;AACA,WAAOA,iBAAP;AACH,GAND;;AAOAjE,EAAAA,aAAa,CAACnC,SAAd,CAAwBoH,YAAxB,GAAuC,UAAUzE,cAAV,EAA0BqF,MAA1B,EAAkCjB,gBAAlC,EAAoDlE,gBAApD,EAAsE;AACzG,QAAIoF,YAAY,GAAG,KAAKC,YAAL,CAAkBF,MAAlB,CAAnB;AACA,SAAKD,uBAAL,CAA6BE,YAA7B,EAFyG,CAGzG;;AACA,QAAIjD,MAAM,GAAG,KAAKmD,kBAAL,CAAwBH,MAAxB,EAAgCjB,gBAAhC,CAAb;;AACA,QAAI,CAAC/B,MAAL,EAAa;AACT;AACA,UAAIoD,KAAK,GAAGvF,gBAAgB,CAACsD,YAAjB,CAA8B8B,YAAY,CAACG,KAA3C,EAAkDH,YAAY,CAACI,KAA/D,CAAZ;AACArD,MAAAA,MAAM,GAAG,IAAI3D,MAAJ,CAAW4G,YAAX,EAAyBD,MAAzB,EAAiCI,KAAjC,EAAwCzF,cAAxC,CAAT;AACA,WAAK0C,OAAL,CAAaC,UAAb,CAAwBN,MAAxB;AACH,KALD,MAMK;AACDA,MAAAA,MAAM,CAACsD,SAAP,CAAiBL,YAAjB,EAA+BD,MAA/B;AACA,WAAKO,gBAAL,CAAsBvD,MAAtB,EAA8BiD,YAA9B;AACH;;AACD,WAAOjD,MAAP;AACH,GAhBD;;AAiBA7C,EAAAA,aAAa,CAACnC,SAAd,CAAwBuI,gBAAxB,GAA2C,UAAUvD,MAAV,EAAkBgD,MAAlB,EAA0B;AACjE;AACA,QAAIQ,IAAI,GAAGzG,YAAY,CAACiG,MAAM,CAACQ,IAAR,CAAvB;;AACA,QAAIA,IAAI,KAAKC,SAAb,EAAwB;AACpBzD,MAAAA,MAAM,CAAC0D,OAAP,CAAeF,IAAf;AACH,KALgE,CAMjE;;;AACA,QAAIG,aAAa,GAAG3D,MAAM,CAAC4D,OAAP,MAAoB,CAAxC;;AACA,QAAID,aAAJ,EAAmB;AACf;AACA,UAAIE,KAAK,GAAG9G,YAAY,CAACiG,MAAM,CAACa,KAAR,CAAxB;;AACA,UAAIA,KAAK,IAAI,IAAb,EAAmB;AACf7D,QAAAA,MAAM,CAAC8D,cAAP,CAAsBD,KAAtB;AACH,OAFD,MAGK;AACD;AACA;AACA,YAAIE,iBAAiB,GAAG/D,MAAM,CAACgE,cAAP,EAAxB;AACAhE,QAAAA,MAAM,CAAC8D,cAAP,CAAsBC,iBAAtB;AACH;AACJ,KApBgE,CAqBjE;;;AACA,QAAIf,MAAM,CAACiB,IAAP,KAAgBR,SAApB,EAA+B;AAC3B,UAAIT,MAAM,CAACiB,IAAP,IAAetH,SAAS,CAACuH,QAAzB,IAAqClB,MAAM,CAACiB,IAAP,IAAetH,SAAS,CAACwH,SAAlE,EAA6E;AACzEnE,QAAAA,MAAM,CAACoE,OAAP,CAAepB,MAAM,CAACiB,IAAtB;AACH,OAFD,MAGK;AACDjE,QAAAA,MAAM,CAACoE,OAAP,CAAeX,SAAf;AACH;AACJ,KA7BgE,CA8BjE;;;AACA,QAAIY,SAAS,GAAGtH,YAAY,CAACiG,MAAM,CAACqB,SAAR,CAA5B;;AACA,QAAIA,SAAS,KAAKZ,SAAlB,EAA6B;AACzBzD,MAAAA,MAAM,CAACsE,YAAP,CAAoBD,SAApB;AACH,KAlCgE,CAmCjE;;;AACA,QAAIE,IAAI,GAAGvH,aAAa,CAACgG,MAAM,CAACuB,IAAR,CAAxB;;AACA,QAAIA,IAAI,KAAKd,SAAb,EAAwB;AACpBzD,MAAAA,MAAM,CAACwE,UAAP,CAAkB,CAACD,IAAnB;AACH,KAvCgE,CAwCjE;;;AACA,QAAIvB,MAAM,CAACyB,MAAP,KAAkBhB,SAAtB,EAAiC;AAC7BzD,MAAAA,MAAM,CAAC0E,SAAP,CAAiB1B,MAAM,CAACyB,MAAxB;AACH;AACJ,GA5CD;;AA6CAtH,EAAAA,aAAa,CAACnC,SAAd,CAAwBmI,kBAAxB,GAA6C,UAAUwB,SAAV,EAAqB5C,gBAArB,EAAuC;AAChF,QAAI6C,GAAG,GAAG3H,IAAI,CAAC8E,gBAAD,EAAmB,UAAU8C,WAAV,EAAuB;AACpD,UAAIC,cAAc,GAAGD,WAAW,CAACE,qBAAZ,EAArB;;AACA,UAAI,CAACD,cAAL,EAAqB;AACjB,eAAO,KAAP;AACH;;AACD,UAAIE,QAAQ,GAAGL,SAAS,CAACvB,KAAV,IAAmB,IAAlC;AACA,UAAI6B,WAAW,GAAGN,SAAS,CAACtB,KAAV,IAAmB,IAArC;;AACA,UAAI2B,QAAJ,EAAc;AACV,eAAOH,WAAW,CAACvF,KAAZ,OAAwBqF,SAAS,CAACvB,KAAzC;AACH;;AACD,UAAI6B,WAAJ,EAAiB;AACb,eAAOH,cAAc,CAACzB,KAAf,KAAyBsB,SAAS,CAACtB,KAA1C;AACH,OAZmD,CAapD;;;AACA,UAAIyB,cAAc,KAAKH,SAAvB,EAAkC;AAC9B,eAAO,IAAP;AACH;;AACD,aAAO,KAAP;AACH,KAlBa,CAAd,CADgF,CAoBhF;AACA;;AACA,QAAI5C,gBAAgB,IAAI6C,GAAxB,EAA6B;AACzB1H,MAAAA,eAAe,CAAC6E,gBAAD,EAAmB6C,GAAnB,CAAf;AACH;;AACD,WAAOA,GAAP;AACH,GA1BD;;AA2BAzH,EAAAA,aAAa,CAACnC,SAAd,CAAwByH,iBAAxB,GAA4C,UAAUyC,WAAV,EAAuBjH,cAAvB,EAAuC;AAC/E,QAAI2G,GAAG,GAAG3H,IAAI,CAACgB,cAAD,EAAiB,UAAUuE,aAAV,EAAyB;AACpD,UAAI2C,WAAW,GAAG3C,aAAa,CAAC4C,cAAd,EAAlB;;AACA,UAAI,CAACD,WAAL,EAAkB;AACd,eAAO,KAAP;AACH;;AACD,UAAIH,QAAQ,GAAGE,WAAW,CAAC3C,OAAZ,IAAuB,IAAtC;;AACA,UAAIyC,QAAJ,EAAc;AACV,eAAOxC,aAAa,CAAClD,KAAd,OAA0B4F,WAAW,CAAC3C,OAA7C;AACH;;AACD,aAAO,KAAP;AACH,KAVa,CAAd,CAD+E,CAY/E;AACA;;AACA,QAAIqC,GAAJ,EAAS;AACL1H,MAAAA,eAAe,CAACe,cAAD,EAAiB2G,GAAjB,CAAf;AACH;;AACD,WAAOA,GAAP;AACH,GAlBD;;AAmBAzH,EAAAA,aAAa,CAACnC,SAAd,CAAwBkI,YAAxB,GAAuC,UAAUF,MAAV,EAAkB;AACrD;AACA,QAAIC,YAAY,GAAG,EAAnB,CAFqD,CAGrD;;AACA,QAAIoC,aAAa,GAAG,KAAKxC,kBAAL,CAAwByC,gBAAxB,EAApB;AACAxI,IAAAA,SAAS,CAACmG,YAAD,EAAeoC,aAAf,EAA8B,KAA9B,EAAqC,IAArC,CAAT,CALqD,CAMrD;;AACA,QAAIE,UAAU,GAAGvC,MAAM,CAACwC,IAAxB;;AACA,QAAI,CAACD,UAAL,EAAiB;AACbA,MAAAA,UAAU,GAAGF,aAAa,IAAIA,aAAa,CAACG,IAA5C;AACH,KAVoD,CAWrD;;;AACA,QAAID,UAAJ,EAAgB;AACZ,WAAKE,iBAAL,CAAuBF,UAAvB,EAAmCtC,YAAnC;AACH,KAdoD,CAerD;;;AACAnG,IAAAA,SAAS,CAACmG,YAAD,EAAeD,MAAf,EAAuB,KAAvB,EAA8B,IAA9B,CAAT;AACA,WAAOC,YAAP;AACH,GAlBD;;AAmBA9F,EAAAA,aAAa,CAACnC,SAAd,CAAwByK,iBAAxB,GAA4C,UAAUD,IAAV,EAAgBvC,YAAhB,EAA8B;AACtE,QAAIyC,QAAQ,GAAG,EAAf;;AACA,QAAIF,IAAI,YAAY7K,KAApB,EAA2B;AACvB,UAAIgL,YAAY,GAAGH,IAAI,CAAChE,IAAL,CAAU,UAAUoE,CAAV,EAAa;AAAE,eAAO,OAAOA,CAAP,KAAa,QAApB;AAA+B,OAAxD,CAAnB;;AACA,UAAID,YAAJ,EAAkB;AACdE,QAAAA,OAAO,CAACC,IAAR,CAAa,8EAAb;AACH,OAFD,MAGK;AACDJ,QAAAA,QAAQ,GAAGF,IAAX;AACH;AACJ,KARD,MASK,IAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;AAC/BE,MAAAA,QAAQ,GAAGF,IAAI,CAACO,KAAL,CAAW,GAAX,CAAX;AACH,KAFI,MAGA;AACDF,MAAAA,OAAO,CAACC,IAAR,CAAa,8DAAb;AACA;AACH,KAjBqE,CAkBtE;;;AACA,QAAIE,cAAc,GAAGpJ,MAAM,CAAC,EAAD,EAAKH,kBAAL,CAA3B;AACA,QAAIwJ,SAAS,GAAG,KAAKpD,kBAAL,CAAwBqD,cAAxB,MAA4C,EAA5D;AACArJ,IAAAA,aAAa,CAACoJ,SAAD,EAAY,UAAU5K,GAAV,EAAe8K,KAAf,EAAsB;AAC3C,UAAI9K,GAAG,IAAI2K,cAAX,EAA2B;AACvBH,QAAAA,OAAO,CAACC,IAAR,CAAa,+BAA+BzK,GAA/B,GAAqC,sDAAlD;AACH,OAFD,MAGK;AACD2K,QAAAA,cAAc,CAAC3K,GAAD,CAAd,GAAsB8K,KAAtB;AACH;AACJ,KAPY,CAAb;AAQAT,IAAAA,QAAQ,CAAC9F,OAAT,CAAiB,UAAUwG,CAAV,EAAa;AAC1B,UAAIC,UAAU,GAAGL,cAAc,CAACI,CAAC,CAACE,IAAF,EAAD,CAA/B;;AACA,UAAID,UAAJ,EAAgB;AACZvJ,QAAAA,SAAS,CAACmG,YAAD,EAAeoD,UAAf,EAA2B,KAA3B,EAAkC,IAAlC,CAAT;AACH,OAFD,MAGK;AACDR,QAAAA,OAAO,CAACC,IAAR,CAAa,2BAA2BM,CAA3B,GAA+B,0DAA5C;AACH;AACJ,KARD;AASH,GAtCD;;AAuCAjJ,EAAAA,aAAa,CAACnC,SAAd,CAAwB+H,uBAAxB,GAAkD,UAAUC,MAAV,EAAkB;AAChE,QAAIA,MAAJ,EAAY;AACR,UAAIuD,YAAY,GAAGvD,MAAnB,CADQ,CACmB;;AAC3B,UAAIuD,YAAY,CAACpH,KAAb,KAAuBsE,SAA3B,EAAsC;AAClCoC,QAAAA,OAAO,CAACC,IAAR,CAAa,+GAAb;AACH;;AACD,UAAIS,YAAY,CAACC,WAAb,KAA6B/C,SAAjC,EAA4C;AACxCoC,QAAAA,OAAO,CAACC,IAAR,CAAa,qHAAb;AACH;;AACD,UAAIS,YAAY,CAACE,eAAb,KAAiChD,SAArC,EAAgD;AAC5CoC,QAAAA,OAAO,CAACC,IAAR,CAAa,oJAAb;AACH;;AACD,UAAIS,YAAY,CAACG,gBAAb,KAAkCjD,SAAtC,EAAiD;AAC7CoC,QAAAA,OAAO,CAACC,IAAR,CAAa,gFAAb;AACH;;AACD,UAAIS,YAAY,CAACI,mBAAb,KAAqClD,SAAzC,EAAoD;AAChDoC,QAAAA,OAAO,CAACC,IAAR,CAAa,mFAAb;AACH;;AACD,UAAIS,YAAY,CAACG,gBAAb,IAAiCH,YAAY,CAACI,mBAAlD,EAAuE;AACnEd,QAAAA,OAAO,CAACC,IAAR,CAAa,sIAAb;AACH;;AACD,UAAIS,YAAY,CAACK,WAAjB,EAA8B;AAC1Bf,QAAAA,OAAO,CAACC,IAAR,CAAa,gCAAgCS,YAAY,CAACK,WAA7C,GAA2D,6DAAxE;AACAL,QAAAA,YAAY,CAACM,UAAb,GAA0BN,YAAY,CAACK,WAAvC;AACH;AACJ;AACJ,GA1BD,CAhWiD,CA2XjD;;;AACAzJ,EAAAA,aAAa,CAACnC,SAAd,CAAwBkH,aAAxB,GAAwC,UAAU4E,cAAV,EAA0B;AAC9D,WAAOA,cAAc,CAAClE,QAAf,KAA4Ba,SAAnC;AACH,GAFD;;AAGAvI,EAAAA,UAAU,CAAC,CACPoB,SAAS,CAAC,aAAD,CADF,CAAD,EAEPa,aAAa,CAACnC,SAFP,EAEkB,aAFlB,EAEiC,KAAK,CAFtC,CAAV;;AAGAE,EAAAA,UAAU,CAAC,CACPc,OAAO,CAAC,CAAD,EAAIQ,SAAS,CAAC,eAAD,CAAb,CADA,CAAD,EAEPW,aAAa,CAACnC,SAFP,EAEkB,UAFlB,EAE8B,IAF9B,CAAV;;AAGAmC,EAAAA,aAAa,GAAGjC,UAAU,CAAC,CACvBqB,IAAI,CAAC,eAAD,CADmB,CAAD,EAEvBY,aAFuB,CAA1B;AAGA,SAAOA,aAAP;AACH,CAzYkC,CAyYjCT,QAzYiC,CAAnC;;AA0YA,SAASS,aAAT","sourcesContent":["/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v26.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { ColumnKeyCreator } from \"./columnKeyCreator\";\nimport { ProvidedColumnGroup } from \"../entities/providedColumnGroup\";\nimport { Column } from \"../entities/column\";\nimport { Autowired, Bean, Qualifier } from \"../context/context\";\nimport { DefaultColumnTypes } from \"../entities/defaultColumnTypes\";\nimport { BeanStub } from \"../context/beanStub\";\nimport { Constants } from \"../constants/constants\";\nimport { assign, iterateObject, mergeDeep } from '../utils/object';\nimport { attrToNumber, attrToBoolean, find } from '../utils/generic';\nimport { removeFromArray } from '../utils/array';\n// takes ColDefs and ColGroupDefs and turns them into Columns and OriginalGroups\nvar ColumnFactory = /** @class */ (function (_super) {\n    __extends(ColumnFactory, _super);\n    function ColumnFactory() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ColumnFactory.prototype.setBeans = function (loggerFactory) {\n        this.logger = loggerFactory.create('ColumnFactory');\n    };\n    ColumnFactory.prototype.createColumnTree = function (defs, primaryColumns, existingTree) {\n        // column key creator dishes out unique column id's in a deterministic way,\n        // so if we have two grids (that could be master/slave) with same column definitions,\n        // then this ensures the two grids use identical id's.\n        var columnKeyCreator = new ColumnKeyCreator();\n        var _a = this.extractExistingTreeData(existingTree), existingCols = _a.existingCols, existingGroups = _a.existingGroups, existingColKeys = _a.existingColKeys;\n        columnKeyCreator.addExistingKeys(existingColKeys);\n        // create am unbalanced tree that maps the provided definitions\n        var unbalancedTree = this.recursivelyCreateColumns(defs, 0, primaryColumns, existingCols, columnKeyCreator, existingGroups);\n        var treeDept = this.findMaxDept(unbalancedTree, 0);\n        this.logger.log('Number of levels for grouped columns is ' + treeDept);\n        var columnTree = this.balanceColumnTree(unbalancedTree, 0, treeDept, columnKeyCreator);\n        var deptFirstCallback = function (child, parent) {\n            if (child instanceof ProvidedColumnGroup) {\n                child.setupExpandable();\n            }\n            // we set the original parents at the end, rather than when we go along, as balancing the tree\n            // adds extra levels into the tree. so we can only set parents when balancing is done.\n            child.setOriginalParent(parent);\n        };\n        this.columnUtils.depthFirstOriginalTreeSearch(null, columnTree, deptFirstCallback);\n        return {\n            columnTree: columnTree,\n            treeDept: treeDept\n        };\n    };\n    ColumnFactory.prototype.extractExistingTreeData = function (existingTree) {\n        var existingCols = [];\n        var existingGroups = [];\n        var existingColKeys = [];\n        if (existingTree) {\n            this.columnUtils.depthFirstOriginalTreeSearch(null, existingTree, function (item) {\n                if (item instanceof ProvidedColumnGroup) {\n                    var group = item;\n                    existingGroups.push(group);\n                }\n                else {\n                    var col = item;\n                    existingColKeys.push(col.getId());\n                    existingCols.push(col);\n                }\n            });\n        }\n        return { existingCols: existingCols, existingGroups: existingGroups, existingColKeys: existingColKeys };\n    };\n    ColumnFactory.prototype.createForAutoGroups = function (autoGroupCols, gridBalancedTree) {\n        var _this = this;\n        var autoColBalancedTree = [];\n        autoGroupCols.forEach(function (col) {\n            var fakeTreeItem = _this.createAutoGroupTreeItem(gridBalancedTree, col);\n            autoColBalancedTree.push(fakeTreeItem);\n        });\n        return autoColBalancedTree;\n    };\n    ColumnFactory.prototype.createAutoGroupTreeItem = function (balancedColumnTree, column) {\n        var dept = this.findDepth(balancedColumnTree);\n        // at the end, this will be the top of the tree item.\n        var nextChild = column;\n        for (var i = dept - 1; i >= 0; i--) {\n            var autoGroup = new ProvidedColumnGroup(null, \"FAKE_PATH_\" + column.getId() + \"}_\" + i, true, i);\n            this.context.createBean(autoGroup);\n            autoGroup.setChildren([nextChild]);\n            nextChild.setOriginalParent(autoGroup);\n            nextChild = autoGroup;\n        }\n        // at this point, the nextChild is the top most item in the tree\n        return nextChild;\n    };\n    ColumnFactory.prototype.findDepth = function (balancedColumnTree) {\n        var dept = 0;\n        var pointer = balancedColumnTree;\n        while (pointer && pointer[0] && pointer[0] instanceof ProvidedColumnGroup) {\n            dept++;\n            pointer = pointer[0].getChildren();\n        }\n        return dept;\n    };\n    ColumnFactory.prototype.balanceColumnTree = function (unbalancedTree, currentDept, columnDept, columnKeyCreator) {\n        var result = [];\n        // go through each child, for groups, recurse a level deeper,\n        // for columns we need to pad\n        for (var i = 0; i < unbalancedTree.length; i++) {\n            var child = unbalancedTree[i];\n            if (child instanceof ProvidedColumnGroup) {\n                // child is a group, all we do is go to the next level of recursion\n                var originalGroup = child;\n                var newChildren = this.balanceColumnTree(originalGroup.getChildren(), currentDept + 1, columnDept, columnKeyCreator);\n                originalGroup.setChildren(newChildren);\n                result.push(originalGroup);\n            }\n            else {\n                // child is a column - so here we add in the padded column groups if needed\n                var firstPaddedGroup = void 0;\n                var currentPaddedGroup = void 0;\n                // this for loop will NOT run any loops if no padded column groups are needed\n                for (var j = columnDept - 1; j >= currentDept; j--) {\n                    var newColId = columnKeyCreator.getUniqueKey(null, null);\n                    var colGroupDefMerged = this.createMergedColGroupDef(null);\n                    var paddedGroup = new ProvidedColumnGroup(colGroupDefMerged, newColId, true, currentDept);\n                    this.context.createBean(paddedGroup);\n                    if (currentPaddedGroup) {\n                        currentPaddedGroup.setChildren([paddedGroup]);\n                    }\n                    currentPaddedGroup = paddedGroup;\n                    if (!firstPaddedGroup) {\n                        firstPaddedGroup = currentPaddedGroup;\n                    }\n                }\n                // likewise this if statement will not run if no padded groups\n                if (firstPaddedGroup && currentPaddedGroup) {\n                    result.push(firstPaddedGroup);\n                    var hasGroups = unbalancedTree.some(function (leaf) { return leaf instanceof ProvidedColumnGroup; });\n                    if (hasGroups) {\n                        currentPaddedGroup.setChildren([child]);\n                        continue;\n                    }\n                    else {\n                        currentPaddedGroup.setChildren(unbalancedTree);\n                        break;\n                    }\n                }\n                result.push(child);\n            }\n        }\n        return result;\n    };\n    ColumnFactory.prototype.findMaxDept = function (treeChildren, dept) {\n        var maxDeptThisLevel = dept;\n        for (var i = 0; i < treeChildren.length; i++) {\n            var abstractColumn = treeChildren[i];\n            if (abstractColumn instanceof ProvidedColumnGroup) {\n                var originalGroup = abstractColumn;\n                var newDept = this.findMaxDept(originalGroup.getChildren(), dept + 1);\n                if (maxDeptThisLevel < newDept) {\n                    maxDeptThisLevel = newDept;\n                }\n            }\n        }\n        return maxDeptThisLevel;\n    };\n    ColumnFactory.prototype.recursivelyCreateColumns = function (defs, level, primaryColumns, existingColsCopy, columnKeyCreator, existingGroups) {\n        var _this = this;\n        var result = [];\n        if (!defs) {\n            return result;\n        }\n        defs.forEach(function (def) {\n            var newGroupOrColumn;\n            if (_this.isColumnGroup(def)) {\n                newGroupOrColumn = _this.createColumnGroup(primaryColumns, def, level, existingColsCopy, columnKeyCreator, existingGroups);\n            }\n            else {\n                newGroupOrColumn = _this.createColumn(primaryColumns, def, existingColsCopy, columnKeyCreator);\n            }\n            result.push(newGroupOrColumn);\n        });\n        return result;\n    };\n    ColumnFactory.prototype.createColumnGroup = function (primaryColumns, colGroupDef, level, existingColumns, columnKeyCreator, existingGroups) {\n        var colGroupDefMerged = this.createMergedColGroupDef(colGroupDef);\n        var groupId = columnKeyCreator.getUniqueKey(colGroupDefMerged.groupId || null, null);\n        var originalGroup = new ProvidedColumnGroup(colGroupDefMerged, groupId, false, level);\n        this.context.createBean(originalGroup);\n        var existingGroup = this.findExistingGroup(colGroupDef, existingGroups);\n        if (existingGroup && existingGroup.isExpanded()) {\n            originalGroup.setExpanded(true);\n        }\n        var children = this.recursivelyCreateColumns(colGroupDefMerged.children, level + 1, primaryColumns, existingColumns, columnKeyCreator, existingGroups);\n        originalGroup.setChildren(children);\n        return originalGroup;\n    };\n    ColumnFactory.prototype.createMergedColGroupDef = function (colGroupDef) {\n        var colGroupDefMerged = {};\n        assign(colGroupDefMerged, this.gridOptionsWrapper.getDefaultColGroupDef());\n        assign(colGroupDefMerged, colGroupDef);\n        this.checkForDeprecatedItems(colGroupDefMerged);\n        return colGroupDefMerged;\n    };\n    ColumnFactory.prototype.createColumn = function (primaryColumns, colDef, existingColsCopy, columnKeyCreator) {\n        var colDefMerged = this.mergeColDefs(colDef);\n        this.checkForDeprecatedItems(colDefMerged);\n        // see if column already exists\n        var column = this.findExistingColumn(colDef, existingColsCopy);\n        if (!column) {\n            // no existing column, need to create one\n            var colId = columnKeyCreator.getUniqueKey(colDefMerged.colId, colDefMerged.field);\n            column = new Column(colDefMerged, colDef, colId, primaryColumns);\n            this.context.createBean(column);\n        }\n        else {\n            column.setColDef(colDefMerged, colDef);\n            this.applyColumnState(column, colDefMerged);\n        }\n        return column;\n    };\n    ColumnFactory.prototype.applyColumnState = function (column, colDef) {\n        // flex\n        var flex = attrToNumber(colDef.flex);\n        if (flex !== undefined) {\n            column.setFlex(flex);\n        }\n        // width - we only set width if column is not flexing\n        var noFlexThisCol = column.getFlex() <= 0;\n        if (noFlexThisCol) {\n            // both null and undefined means we skip, as it's not possible to 'clear' width (a column must have a width)\n            var width = attrToNumber(colDef.width);\n            if (width != null) {\n                column.setActualWidth(width);\n            }\n            else {\n                // otherwise set the width again, in case min or max width has changed,\n                // and width needs to be adjusted.\n                var widthBeforeUpdate = column.getActualWidth();\n                column.setActualWidth(widthBeforeUpdate);\n            }\n        }\n        // sort - anything but undefined will set sort, thus null or empty string will clear the sort\n        if (colDef.sort !== undefined) {\n            if (colDef.sort == Constants.SORT_ASC || colDef.sort == Constants.SORT_DESC) {\n                column.setSort(colDef.sort);\n            }\n            else {\n                column.setSort(undefined);\n            }\n        }\n        // sorted at - anything but undefined, thus null will clear the sortIndex\n        var sortIndex = attrToNumber(colDef.sortIndex);\n        if (sortIndex !== undefined) {\n            column.setSortIndex(sortIndex);\n        }\n        // hide - anything but undefined, thus null will clear the hide\n        var hide = attrToBoolean(colDef.hide);\n        if (hide !== undefined) {\n            column.setVisible(!hide);\n        }\n        // pinned - anything but undefined, thus null or empty string will remove pinned\n        if (colDef.pinned !== undefined) {\n            column.setPinned(colDef.pinned);\n        }\n    };\n    ColumnFactory.prototype.findExistingColumn = function (newColDef, existingColsCopy) {\n        var res = find(existingColsCopy, function (existingCol) {\n            var existingColDef = existingCol.getUserProvidedColDef();\n            if (!existingColDef) {\n                return false;\n            }\n            var newHasId = newColDef.colId != null;\n            var newHasField = newColDef.field != null;\n            if (newHasId) {\n                return existingCol.getId() === newColDef.colId;\n            }\n            if (newHasField) {\n                return existingColDef.field === newColDef.field;\n            }\n            // if no id or field present, then try object equivalence.\n            if (existingColDef === newColDef) {\n                return true;\n            }\n            return false;\n        });\n        // make sure we remove, so if user provided duplicate id, then we don't have more than\n        // one column instance for colDef with common id\n        if (existingColsCopy && res) {\n            removeFromArray(existingColsCopy, res);\n        }\n        return res;\n    };\n    ColumnFactory.prototype.findExistingGroup = function (newGroupDef, existingGroups) {\n        var res = find(existingGroups, function (existingGroup) {\n            var existingDef = existingGroup.getColGroupDef();\n            if (!existingDef) {\n                return false;\n            }\n            var newHasId = newGroupDef.groupId != null;\n            if (newHasId) {\n                return existingGroup.getId() === newGroupDef.groupId;\n            }\n            return false;\n        });\n        // make sure we remove, so if user provided duplicate id, then we don't have more than\n        // one column instance for colDef with common id\n        if (res) {\n            removeFromArray(existingGroups, res);\n        }\n        return res;\n    };\n    ColumnFactory.prototype.mergeColDefs = function (colDef) {\n        // start with empty merged definition\n        var colDefMerged = {};\n        // merge properties from default column definitions\n        var defaultColDef = this.gridOptionsWrapper.getDefaultColDef();\n        mergeDeep(colDefMerged, defaultColDef, false, true);\n        // merge properties from column type properties\n        var columnType = colDef.type;\n        if (!columnType) {\n            columnType = defaultColDef && defaultColDef.type;\n        }\n        // if type of both colDef and defaultColDef, then colDef gets preference\n        if (columnType) {\n            this.assignColumnTypes(columnType, colDefMerged);\n        }\n        // merge properties from column definitions\n        mergeDeep(colDefMerged, colDef, false, true);\n        return colDefMerged;\n    };\n    ColumnFactory.prototype.assignColumnTypes = function (type, colDefMerged) {\n        var typeKeys = [];\n        if (type instanceof Array) {\n            var invalidArray = type.some(function (a) { return typeof a !== 'string'; });\n            if (invalidArray) {\n                console.warn(\"ag-grid: if colDef.type is supplied an array it should be of type 'string[]'\");\n            }\n            else {\n                typeKeys = type;\n            }\n        }\n        else if (typeof type === 'string') {\n            typeKeys = type.split(',');\n        }\n        else {\n            console.warn(\"ag-grid: colDef.type should be of type 'string' | 'string[]'\");\n            return;\n        }\n        // merge user defined with default column types\n        var allColumnTypes = assign({}, DefaultColumnTypes);\n        var userTypes = this.gridOptionsWrapper.getColumnTypes() || {};\n        iterateObject(userTypes, function (key, value) {\n            if (key in allColumnTypes) {\n                console.warn(\"AG Grid: the column type '\" + key + \"' is a default column type and cannot be overridden.\");\n            }\n            else {\n                allColumnTypes[key] = value;\n            }\n        });\n        typeKeys.forEach(function (t) {\n            var typeColDef = allColumnTypes[t.trim()];\n            if (typeColDef) {\n                mergeDeep(colDefMerged, typeColDef, false, true);\n            }\n            else {\n                console.warn(\"ag-grid: colDef.type '\" + t + \"' does not correspond to defined gridOptions.columnTypes\");\n            }\n        });\n    };\n    ColumnFactory.prototype.checkForDeprecatedItems = function (colDef) {\n        if (colDef) {\n            var colDefNoType = colDef; // take out the type, so we can access attributes not defined in the type\n            if (colDefNoType.group !== undefined) {\n                console.warn('ag-grid: colDef.group is invalid, please check documentation on how to do grouping as it changed in version 3');\n            }\n            if (colDefNoType.headerGroup !== undefined) {\n                console.warn('ag-grid: colDef.headerGroup is invalid, please check documentation on how to do grouping as it changed in version 3');\n            }\n            if (colDefNoType.headerGroupShow !== undefined) {\n                console.warn('ag-grid: colDef.headerGroupShow is invalid, should be columnGroupShow, please check documentation on how to do grouping as it changed in version 3');\n            }\n            if (colDefNoType.suppressRowGroup !== undefined) {\n                console.warn('ag-grid: colDef.suppressRowGroup is deprecated, please use colDef.type instead');\n            }\n            if (colDefNoType.suppressAggregation !== undefined) {\n                console.warn('ag-grid: colDef.suppressAggregation is deprecated, please use colDef.type instead');\n            }\n            if (colDefNoType.suppressRowGroup || colDefNoType.suppressAggregation) {\n                console.warn('ag-grid: colDef.suppressAggregation and colDef.suppressRowGroup are deprecated, use allowRowGroup, allowPivot and allowValue instead');\n            }\n            if (colDefNoType.displayName) {\n                console.warn(\"ag-grid: Found displayName \" + colDefNoType.displayName + \", please use headerName instead, displayName is deprecated.\");\n                colDefNoType.headerName = colDefNoType.displayName;\n            }\n        }\n    };\n    // if object has children, we assume it's a group\n    ColumnFactory.prototype.isColumnGroup = function (abstractColDef) {\n        return abstractColDef.children !== undefined;\n    };\n    __decorate([\n        Autowired('columnUtils')\n    ], ColumnFactory.prototype, \"columnUtils\", void 0);\n    __decorate([\n        __param(0, Qualifier('loggerFactory'))\n    ], ColumnFactory.prototype, \"setBeans\", null);\n    ColumnFactory = __decorate([\n        Bean('columnFactory')\n    ], ColumnFactory);\n    return ColumnFactory;\n}(BeanStub));\nexport { ColumnFactory };\n"]},"metadata":{},"sourceType":"module"}