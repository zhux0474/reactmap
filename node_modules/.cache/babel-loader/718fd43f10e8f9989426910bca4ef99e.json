{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { _, Autowired, Bean, BeanStub, RowNode } from \"@ag-grid-community/core\";\n\nvar FlattenStage =\n/** @class */\nfunction (_super) {\n  __extends(FlattenStage, _super);\n\n  function FlattenStage() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  FlattenStage.prototype.execute = function (params) {\n    var rootNode = params.rowNode; // even if not doing grouping, we do the mapping, as the client might\n    // of passed in data that already has a grouping in it somewhere\n\n    var result = []; // putting value into a wrapper so it's passed by reference\n\n    var nextRowTop = {\n      value: 0\n    };\n    var skipLeafNodes = this.columnModel.isPivotMode(); // if we are reducing, and not grouping, then we want to show the root node, as that\n    // is where the pivot values are\n\n    var showRootNode = skipLeafNodes && rootNode.leafGroup;\n    var topList = showRootNode ? [rootNode] : rootNode.childrenAfterSort;\n    this.recursivelyAddToRowsToDisplay(topList, result, nextRowTop, skipLeafNodes, 0); // we do not want the footer total if the gris is empty\n\n    var atLeastOneRowPresent = result.length > 0;\n    var includeGroupTotalFooter = !showRootNode // don't show total footer when showRootNode is true (i.e. in pivot mode and no groups)\n    && atLeastOneRowPresent && this.gridOptionsWrapper.isGroupIncludeTotalFooter();\n\n    if (includeGroupTotalFooter) {\n      this.ensureFooterNodeExists(rootNode);\n      this.addRowNodeToRowsToDisplay(rootNode.sibling, result, nextRowTop, 0);\n    }\n\n    return result;\n  };\n\n  FlattenStage.prototype.recursivelyAddToRowsToDisplay = function (rowsToFlatten, result, nextRowTop, skipLeafNodes, uiLevel) {\n    if (_.missingOrEmpty(rowsToFlatten)) {\n      return;\n    }\n\n    var hideOpenParents = this.gridOptionsWrapper.isGroupHideOpenParents(); // these two are mutually exclusive, so if first set, we don't set the second\n\n    var groupRemoveSingleChildren = this.gridOptionsWrapper.isGroupRemoveSingleChildren();\n    var groupRemoveLowestSingleChildren = !groupRemoveSingleChildren && this.gridOptionsWrapper.isGroupRemoveLowestSingleChildren();\n\n    for (var i = 0; i < rowsToFlatten.length; i++) {\n      var rowNode = rowsToFlatten[i]; // check all these cases, for working out if this row should be included in the final mapped list\n\n      var isParent = rowNode.hasChildren();\n      var isSkippedLeafNode = skipLeafNodes && !isParent;\n      var isRemovedSingleChildrenGroup = groupRemoveSingleChildren && isParent && rowNode.childrenAfterGroup.length === 1;\n      var isRemovedLowestSingleChildrenGroup = groupRemoveLowestSingleChildren && isParent && rowNode.leafGroup && rowNode.childrenAfterGroup.length === 1; // hide open parents means when group is open, we don't show it. we also need to make sure the\n      // group is expandable in the first place (as leaf groups are not expandable if pivot mode is on).\n      // the UI will never allow expanding leaf  groups, however the user might via the API (or menu option 'expand all')\n\n      var neverAllowToExpand = skipLeafNodes && rowNode.leafGroup;\n      var isHiddenOpenParent = hideOpenParents && rowNode.expanded && !neverAllowToExpand;\n      var thisRowShouldBeRendered = !isSkippedLeafNode && !isHiddenOpenParent && !isRemovedSingleChildrenGroup && !isRemovedLowestSingleChildrenGroup;\n\n      if (thisRowShouldBeRendered) {\n        this.addRowNodeToRowsToDisplay(rowNode, result, nextRowTop, uiLevel);\n      } // if we are pivoting, we never map below the leaf group\n\n\n      if (skipLeafNodes && rowNode.leafGroup) {\n        continue;\n      }\n\n      if (isParent) {\n        var excludedParent = isRemovedSingleChildrenGroup || isRemovedLowestSingleChildrenGroup; // we traverse the group if it is expended, however we always traverse if the parent node\n        // was removed (as the group will never be opened if it is not displayed, we show the children instead)\n\n        if (rowNode.expanded || excludedParent) {\n          // if the parent was excluded, then ui level is that of the parent\n          var uiLevelForChildren = excludedParent ? uiLevel : uiLevel + 1;\n          this.recursivelyAddToRowsToDisplay(rowNode.childrenAfterSort, result, nextRowTop, skipLeafNodes, uiLevelForChildren); // put a footer in if user is looking for it\n\n          if (this.gridOptionsWrapper.isGroupIncludeFooter()) {\n            this.ensureFooterNodeExists(rowNode);\n            this.addRowNodeToRowsToDisplay(rowNode.sibling, result, nextRowTop, uiLevel);\n          }\n        }\n      } else if (rowNode.master && rowNode.expanded) {\n        var detailNode = this.createDetailNode(rowNode);\n        this.addRowNodeToRowsToDisplay(detailNode, result, nextRowTop, uiLevel);\n      }\n    }\n  }; // duplicated method, it's also in floatingRowModel\n\n\n  FlattenStage.prototype.addRowNodeToRowsToDisplay = function (rowNode, result, nextRowTop, uiLevel) {\n    var isGroupMultiAutoColumn = this.gridOptionsWrapper.isGroupMultiAutoColumn();\n    result.push(rowNode);\n    rowNode.setUiLevel(isGroupMultiAutoColumn ? 0 : uiLevel);\n  };\n\n  FlattenStage.prototype.ensureFooterNodeExists = function (groupNode) {\n    // only create footer node once, otherwise we have daemons and\n    // the animate screws up with the daemons hanging around\n    if (_.exists(groupNode.sibling)) {\n      return;\n    }\n\n    var footerNode = new RowNode(this.beans);\n    Object.keys(groupNode).forEach(function (key) {\n      footerNode[key] = groupNode[key];\n    });\n    footerNode.footer = true;\n    footerNode.setRowTop(null);\n    footerNode.setRowIndex(null); // manually set oldRowTop to null so we discard any\n    // previous information about its position.\n\n    footerNode.oldRowTop = null;\n\n    if (_.exists(footerNode.id)) {\n      footerNode.id = 'rowGroupFooter_' + footerNode.id;\n    } // get both header and footer to reference each other as siblings. this is never undone,\n    // only overwritten. so if a group is expanded, then contracted, it will have a ghost\n    // sibling - but that's fine, as we can ignore this if the header is contracted.\n\n\n    footerNode.sibling = groupNode;\n    groupNode.sibling = footerNode;\n  };\n\n  FlattenStage.prototype.createDetailNode = function (masterNode) {\n    if (_.exists(masterNode.detailNode)) {\n      return masterNode.detailNode;\n    }\n\n    var detailNode = new RowNode(this.beans);\n    detailNode.detail = true;\n    detailNode.selectable = false;\n    detailNode.parent = masterNode;\n\n    if (_.exists(masterNode.id)) {\n      detailNode.id = 'detail_' + masterNode.id;\n    }\n\n    detailNode.data = masterNode.data;\n    detailNode.level = masterNode.level + 1;\n    masterNode.detailNode = detailNode;\n    return detailNode;\n  };\n\n  __decorate([Autowired('columnModel')], FlattenStage.prototype, \"columnModel\", void 0);\n\n  __decorate([Autowired('beans')], FlattenStage.prototype, \"beans\", void 0);\n\n  FlattenStage = __decorate([Bean('flattenStage')], FlattenStage);\n  return FlattenStage;\n}(BeanStub);\n\nexport { FlattenStage };","map":{"version":3,"sources":["/Users/rongxuan/Desktop/reactmap/reactmap/node_modules/@ag-grid-community/client-side-row-model/dist/es6/clientSideRowModel/flattenStage.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","_","Autowired","Bean","BeanStub","RowNode","FlattenStage","_super","apply","execute","params","rootNode","rowNode","result","nextRowTop","value","skipLeafNodes","columnModel","isPivotMode","showRootNode","leafGroup","topList","childrenAfterSort","recursivelyAddToRowsToDisplay","atLeastOneRowPresent","includeGroupTotalFooter","gridOptionsWrapper","isGroupIncludeTotalFooter","ensureFooterNodeExists","addRowNodeToRowsToDisplay","sibling","rowsToFlatten","uiLevel","missingOrEmpty","hideOpenParents","isGroupHideOpenParents","groupRemoveSingleChildren","isGroupRemoveSingleChildren","groupRemoveLowestSingleChildren","isGroupRemoveLowestSingleChildren","isParent","hasChildren","isSkippedLeafNode","isRemovedSingleChildrenGroup","childrenAfterGroup","isRemovedLowestSingleChildrenGroup","neverAllowToExpand","isHiddenOpenParent","expanded","thisRowShouldBeRendered","excludedParent","uiLevelForChildren","isGroupIncludeFooter","master","detailNode","createDetailNode","isGroupMultiAutoColumn","push","setUiLevel","groupNode","exists","footerNode","beans","keys","forEach","footer","setRowTop","setRowIndex","oldRowTop","id","masterNode","detail","selectable","parent","data","level"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { _, Autowired, Bean, BeanStub, RowNode } from \"@ag-grid-community/core\";\nvar FlattenStage = /** @class */ (function (_super) {\n    __extends(FlattenStage, _super);\n    function FlattenStage() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    FlattenStage.prototype.execute = function (params) {\n        var rootNode = params.rowNode;\n        // even if not doing grouping, we do the mapping, as the client might\n        // of passed in data that already has a grouping in it somewhere\n        var result = [];\n        // putting value into a wrapper so it's passed by reference\n        var nextRowTop = { value: 0 };\n        var skipLeafNodes = this.columnModel.isPivotMode();\n        // if we are reducing, and not grouping, then we want to show the root node, as that\n        // is where the pivot values are\n        var showRootNode = skipLeafNodes && rootNode.leafGroup;\n        var topList = showRootNode ? [rootNode] : rootNode.childrenAfterSort;\n        this.recursivelyAddToRowsToDisplay(topList, result, nextRowTop, skipLeafNodes, 0);\n        // we do not want the footer total if the gris is empty\n        var atLeastOneRowPresent = result.length > 0;\n        var includeGroupTotalFooter = !showRootNode\n            // don't show total footer when showRootNode is true (i.e. in pivot mode and no groups)\n            && atLeastOneRowPresent\n            && this.gridOptionsWrapper.isGroupIncludeTotalFooter();\n        if (includeGroupTotalFooter) {\n            this.ensureFooterNodeExists(rootNode);\n            this.addRowNodeToRowsToDisplay(rootNode.sibling, result, nextRowTop, 0);\n        }\n        return result;\n    };\n    FlattenStage.prototype.recursivelyAddToRowsToDisplay = function (rowsToFlatten, result, nextRowTop, skipLeafNodes, uiLevel) {\n        if (_.missingOrEmpty(rowsToFlatten)) {\n            return;\n        }\n        var hideOpenParents = this.gridOptionsWrapper.isGroupHideOpenParents();\n        // these two are mutually exclusive, so if first set, we don't set the second\n        var groupRemoveSingleChildren = this.gridOptionsWrapper.isGroupRemoveSingleChildren();\n        var groupRemoveLowestSingleChildren = !groupRemoveSingleChildren && this.gridOptionsWrapper.isGroupRemoveLowestSingleChildren();\n        for (var i = 0; i < rowsToFlatten.length; i++) {\n            var rowNode = rowsToFlatten[i];\n            // check all these cases, for working out if this row should be included in the final mapped list\n            var isParent = rowNode.hasChildren();\n            var isSkippedLeafNode = skipLeafNodes && !isParent;\n            var isRemovedSingleChildrenGroup = groupRemoveSingleChildren &&\n                isParent &&\n                rowNode.childrenAfterGroup.length === 1;\n            var isRemovedLowestSingleChildrenGroup = groupRemoveLowestSingleChildren &&\n                isParent &&\n                rowNode.leafGroup &&\n                rowNode.childrenAfterGroup.length === 1;\n            // hide open parents means when group is open, we don't show it. we also need to make sure the\n            // group is expandable in the first place (as leaf groups are not expandable if pivot mode is on).\n            // the UI will never allow expanding leaf  groups, however the user might via the API (or menu option 'expand all')\n            var neverAllowToExpand = skipLeafNodes && rowNode.leafGroup;\n            var isHiddenOpenParent = hideOpenParents && rowNode.expanded && (!neverAllowToExpand);\n            var thisRowShouldBeRendered = !isSkippedLeafNode && !isHiddenOpenParent &&\n                !isRemovedSingleChildrenGroup && !isRemovedLowestSingleChildrenGroup;\n            if (thisRowShouldBeRendered) {\n                this.addRowNodeToRowsToDisplay(rowNode, result, nextRowTop, uiLevel);\n            }\n            // if we are pivoting, we never map below the leaf group\n            if (skipLeafNodes && rowNode.leafGroup) {\n                continue;\n            }\n            if (isParent) {\n                var excludedParent = isRemovedSingleChildrenGroup || isRemovedLowestSingleChildrenGroup;\n                // we traverse the group if it is expended, however we always traverse if the parent node\n                // was removed (as the group will never be opened if it is not displayed, we show the children instead)\n                if (rowNode.expanded || excludedParent) {\n                    // if the parent was excluded, then ui level is that of the parent\n                    var uiLevelForChildren = excludedParent ? uiLevel : uiLevel + 1;\n                    this.recursivelyAddToRowsToDisplay(rowNode.childrenAfterSort, result, nextRowTop, skipLeafNodes, uiLevelForChildren);\n                    // put a footer in if user is looking for it\n                    if (this.gridOptionsWrapper.isGroupIncludeFooter()) {\n                        this.ensureFooterNodeExists(rowNode);\n                        this.addRowNodeToRowsToDisplay(rowNode.sibling, result, nextRowTop, uiLevel);\n                    }\n                }\n            }\n            else if (rowNode.master && rowNode.expanded) {\n                var detailNode = this.createDetailNode(rowNode);\n                this.addRowNodeToRowsToDisplay(detailNode, result, nextRowTop, uiLevel);\n            }\n        }\n    };\n    // duplicated method, it's also in floatingRowModel\n    FlattenStage.prototype.addRowNodeToRowsToDisplay = function (rowNode, result, nextRowTop, uiLevel) {\n        var isGroupMultiAutoColumn = this.gridOptionsWrapper.isGroupMultiAutoColumn();\n        result.push(rowNode);\n        rowNode.setUiLevel(isGroupMultiAutoColumn ? 0 : uiLevel);\n    };\n    FlattenStage.prototype.ensureFooterNodeExists = function (groupNode) {\n        // only create footer node once, otherwise we have daemons and\n        // the animate screws up with the daemons hanging around\n        if (_.exists(groupNode.sibling)) {\n            return;\n        }\n        var footerNode = new RowNode(this.beans);\n        Object.keys(groupNode).forEach(function (key) {\n            footerNode[key] = groupNode[key];\n        });\n        footerNode.footer = true;\n        footerNode.setRowTop(null);\n        footerNode.setRowIndex(null);\n        // manually set oldRowTop to null so we discard any\n        // previous information about its position.\n        footerNode.oldRowTop = null;\n        if (_.exists(footerNode.id)) {\n            footerNode.id = 'rowGroupFooter_' + footerNode.id;\n        }\n        // get both header and footer to reference each other as siblings. this is never undone,\n        // only overwritten. so if a group is expanded, then contracted, it will have a ghost\n        // sibling - but that's fine, as we can ignore this if the header is contracted.\n        footerNode.sibling = groupNode;\n        groupNode.sibling = footerNode;\n    };\n    FlattenStage.prototype.createDetailNode = function (masterNode) {\n        if (_.exists(masterNode.detailNode)) {\n            return masterNode.detailNode;\n        }\n        var detailNode = new RowNode(this.beans);\n        detailNode.detail = true;\n        detailNode.selectable = false;\n        detailNode.parent = masterNode;\n        if (_.exists(masterNode.id)) {\n            detailNode.id = 'detail_' + masterNode.id;\n        }\n        detailNode.data = masterNode.data;\n        detailNode.level = masterNode.level + 1;\n        masterNode.detailNode = detailNode;\n        return detailNode;\n    };\n    __decorate([\n        Autowired('columnModel')\n    ], FlattenStage.prototype, \"columnModel\", void 0);\n    __decorate([\n        Autowired('beans')\n    ], FlattenStage.prototype, \"beans\", void 0);\n    FlattenStage = __decorate([\n        Bean('flattenStage')\n    ], FlattenStage);\n    return FlattenStage;\n}(BeanStub));\nexport { FlattenStage };\n"]},"metadata":{},"sourceType":"module"}