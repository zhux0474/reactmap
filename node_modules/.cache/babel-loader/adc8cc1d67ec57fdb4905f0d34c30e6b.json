{"ast":null,"code":"'use strict';\n\nlet proj4 = require('proj4');\n\nif (proj4.default) {\n  proj4 = proj4.default;\n}\n\nconst unzip = require('./unzip');\n\nconst binaryAjax = require('./binaryajax');\n\nconst parseShp = require('./parseShp');\n\nconst parseDbf = require('parsedbf');\n\nconst Promise = require('lie');\n\nconst Cache = require('lru-cache');\n\nconst Buffer = require('buffer').Buffer;\n\nconst URL = global.URL;\nconst cache = new Cache({\n  max: 20\n});\n\nfunction toBuffer(b) {\n  if (!b) {\n    throw new Error('forgot to pass buffer');\n  }\n\n  if (Buffer.isBuffer(b)) {\n    return b;\n  }\n\n  if (b instanceof global.ArrayBuffer) {\n    return Buffer.from(b);\n  }\n\n  if (b.buffer instanceof global.ArrayBuffer) {\n    if (b.BYTES_PER_ELEMENT === 1) {\n      return Buffer.from(b);\n    }\n\n    return Buffer.from(b.buffer);\n  }\n}\n\nfunction shp(base, whiteList) {\n  if (typeof base === 'string' && cache.has(base)) {\n    return Promise.resolve(cache.get(base));\n  }\n\n  return shp.getShapefile(base, whiteList).then(function (resp) {\n    if (typeof base === 'string') {\n      cache.set(base, resp);\n    }\n\n    return resp;\n  });\n}\n\nshp.combine = function (arr) {\n  const out = {};\n  out.type = 'FeatureCollection';\n  out.features = [];\n  let i = 0;\n  const len = arr[0].length;\n\n  while (i < len) {\n    out.features.push({\n      type: 'Feature',\n      geometry: arr[0][i],\n      properties: arr[1][i]\n    });\n    i++;\n  }\n\n  return out;\n};\n\nshp.parseZip = async function (buffer, whiteList) {\n  let key;\n  buffer = toBuffer(buffer);\n  const zip = await unzip(buffer);\n  const names = [];\n  whiteList = whiteList || [];\n\n  for (key in zip) {\n    if (key.indexOf('__MACOSX') !== -1) {\n      continue;\n    }\n\n    if (key.slice(-3).toLowerCase() === 'shp') {\n      names.push(key.slice(0, -4));\n      zip[key.slice(0, -3) + key.slice(-3).toLowerCase()] = zip[key];\n    } else if (key.slice(-3).toLowerCase() === 'prj') {\n      zip[key.slice(0, -3) + key.slice(-3).toLowerCase()] = proj4(zip[key]);\n    } else if (key.slice(-4).toLowerCase() === 'json' || whiteList.indexOf(key.split('.').pop()) > -1) {\n      names.push(key.slice(0, -3) + key.slice(-3).toLowerCase());\n    } else if (key.slice(-3).toLowerCase() === 'dbf' || key.slice(-3).toLowerCase() === 'cpg') {\n      zip[key.slice(0, -3) + key.slice(-3).toLowerCase()] = zip[key];\n    }\n  }\n\n  if (!names.length) {\n    throw new Error('no layers founds');\n  }\n\n  const geojson = names.map(function (name) {\n    let parsed, dbf;\n    const lastDotIdx = name.lastIndexOf('.');\n\n    if (lastDotIdx > -1 && name.slice(lastDotIdx).indexOf('json') > -1) {\n      parsed = JSON.parse(zip[name]);\n      parsed.fileName = name.slice(0, lastDotIdx);\n    } else if (whiteList.indexOf(name.slice(lastDotIdx + 1)) > -1) {\n      parsed = zip[name];\n      parsed.fileName = name;\n    } else {\n      if (zip[name + '.dbf']) {\n        dbf = parseDbf(zip[name + '.dbf'], zip[name + '.cpg']);\n      }\n\n      parsed = shp.combine([parseShp(zip[name + '.shp'], zip[name + '.prj']), dbf]);\n      parsed.fileName = name;\n    }\n\n    return parsed;\n  });\n\n  if (geojson.length === 1) {\n    return geojson[0];\n  } else {\n    return geojson;\n  }\n};\n\nasync function getZip(base, whiteList) {\n  const a = await binaryAjax(base);\n  return shp.parseZip(a, whiteList);\n}\n\nconst handleShp = async base => {\n  const args = await Promise.all([binaryAjax(base, 'shp'), binaryAjax(base, 'prj')]);\n  let prj = false;\n\n  try {\n    if (args[1]) {\n      prj = proj4(args[1]);\n    }\n  } catch (e) {\n    prj = false;\n  }\n\n  return parseShp(args[0], prj);\n};\n\nconst handleDbf = async base => {\n  const [dbf, cpg] = await Promise.all([binaryAjax(base, 'dbf'), binaryAjax(base, 'cpg')]);\n  return parseDbf(dbf, cpg);\n};\n\nconst checkSuffix = (base, suffix) => {\n  const url = new URL(base);\n  return url.pathname.slice(-4).toLowerCase() === suffix;\n};\n\nshp.getShapefile = async function (base, whiteList) {\n  if (typeof base !== 'string') {\n    return shp.parseZip(base);\n  }\n\n  if (checkSuffix(base, '.zip')) {\n    return getZip(base, whiteList);\n  }\n\n  const results = await Promise.all([handleShp(base), handleDbf(base)]);\n  return shp.combine(results);\n};\n\nshp.parseShp = function (shp, prj) {\n  shp = toBuffer(shp);\n\n  if (Buffer.isBuffer(prj)) {\n    prj = prj.toString();\n  }\n\n  if (typeof prj === 'string') {\n    try {\n      prj = proj4(prj);\n    } catch (e) {\n      prj = false;\n    }\n  }\n\n  return parseShp(shp, prj);\n};\n\nshp.parseDbf = function (dbf, cpg) {\n  dbf = toBuffer(dbf);\n  return parseDbf(dbf, cpg);\n};\n\nmodule.exports = shp;","map":{"version":3,"sources":["/Users/rongxuan/Desktop/reactmap/reactmap/node_modules/shpjs/lib/index.js"],"names":["proj4","require","default","unzip","binaryAjax","parseShp","parseDbf","Promise","Cache","Buffer","URL","global","cache","max","toBuffer","b","Error","isBuffer","ArrayBuffer","from","buffer","BYTES_PER_ELEMENT","shp","base","whiteList","has","resolve","get","getShapefile","then","resp","set","combine","arr","out","type","features","i","len","length","push","geometry","properties","parseZip","key","zip","names","indexOf","slice","toLowerCase","split","pop","geojson","map","name","parsed","dbf","lastDotIdx","lastIndexOf","JSON","parse","fileName","getZip","a","handleShp","args","all","prj","e","handleDbf","cpg","checkSuffix","suffix","url","pathname","results","toString","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nlet proj4 = require('proj4');\nif (proj4.default) {\n  proj4 = proj4.default;\n}\nconst unzip = require('./unzip');\nconst binaryAjax = require('./binaryajax');\nconst parseShp = require('./parseShp');\nconst parseDbf = require('parsedbf');\nconst Promise = require('lie');\nconst Cache = require('lru-cache');\nconst Buffer = require('buffer').Buffer;\nconst URL = global.URL;\n\nconst cache = new Cache({\n  max: 20\n});\n\nfunction toBuffer (b) {\n  if (!b) {\n    throw new Error('forgot to pass buffer');\n  }\n  if (Buffer.isBuffer(b)) {\n    return b;\n  }\n  if (b instanceof global.ArrayBuffer) {\n    return Buffer.from(b);\n  }\n  if (b.buffer instanceof global.ArrayBuffer) {\n    if (b.BYTES_PER_ELEMENT === 1) {\n      return Buffer.from(b);\n    }\n    return Buffer.from(b.buffer);\n  }\n}\n\nfunction shp (base, whiteList) {\n  if (typeof base === 'string' && cache.has(base)) {\n    return Promise.resolve(cache.get(base));\n  }\n  return shp.getShapefile(base, whiteList).then(function (resp) {\n    if (typeof base === 'string') {\n      cache.set(base, resp);\n    }\n    return resp;\n  });\n}\nshp.combine = function (arr) {\n  const out = {};\n  out.type = 'FeatureCollection';\n  out.features = [];\n  let i = 0;\n  const len = arr[0].length;\n  while (i < len) {\n    out.features.push({\n      type: 'Feature',\n      geometry: arr[0][i],\n      properties: arr[1][i]\n    });\n    i++;\n  }\n  return out;\n};\nshp.parseZip = async function (buffer, whiteList) {\n  let key;\n  buffer = toBuffer(buffer);\n  const zip = await unzip(buffer);\n  const names = [];\n  whiteList = whiteList || [];\n  for (key in zip) {\n    if (key.indexOf('__MACOSX') !== -1) {\n      continue;\n    }\n    if (key.slice(-3).toLowerCase() === 'shp') {\n      names.push(key.slice(0, -4));\n      zip[key.slice(0, -3) + key.slice(-3).toLowerCase()] = zip[key];\n    } else if (key.slice(-3).toLowerCase() === 'prj') {\n      zip[key.slice(0, -3) + key.slice(-3).toLowerCase()] = proj4(zip[key]);\n    } else if (key.slice(-4).toLowerCase() === 'json' || whiteList.indexOf(key.split('.').pop()) > -1) {\n      names.push(key.slice(0, -3) + key.slice(-3).toLowerCase());\n    } else if (key.slice(-3).toLowerCase() === 'dbf' || key.slice(-3).toLowerCase() === 'cpg') {\n      zip[key.slice(0, -3) + key.slice(-3).toLowerCase()] = zip[key];\n    }\n  }\n  if (!names.length) {\n    throw new Error('no layers founds');\n  }\n  const geojson = names.map(function (name) {\n    let parsed, dbf;\n    const lastDotIdx = name.lastIndexOf('.');\n    if (lastDotIdx > -1 && name.slice(lastDotIdx).indexOf('json') > -1) {\n      parsed = JSON.parse(zip[name]);\n      parsed.fileName = name.slice(0, lastDotIdx);\n    } else if (whiteList.indexOf(name.slice(lastDotIdx + 1)) > -1) {\n      parsed = zip[name];\n      parsed.fileName = name;\n    } else {\n      if (zip[name + '.dbf']) {\n        dbf = parseDbf(zip[name + '.dbf'], zip[name + '.cpg']);\n      }\n      parsed = shp.combine([parseShp(zip[name + '.shp'], zip[name + '.prj']), dbf]);\n      parsed.fileName = name;\n    }\n    return parsed;\n  });\n  if (geojson.length === 1) {\n    return geojson[0];\n  } else {\n    return geojson;\n  }\n};\n\nasync function getZip (base, whiteList) {\n  const a = await binaryAjax(base);\n  return shp.parseZip(a, whiteList);\n}\nconst handleShp = async (base) => {\n  const args = await Promise.all([\n    binaryAjax(base, 'shp'),\n    binaryAjax(base, 'prj')\n  ]);\n  let prj = false;\n  try {\n    if (args[1]) {\n      prj = proj4(args[1]);\n    }\n  } catch (e) {\n    prj = false;\n  }\n  return parseShp(args[0], prj);\n};\nconst handleDbf = async (base) => {\n  const [dbf, cpg] = await Promise.all([\n    binaryAjax(base, 'dbf'),\n    binaryAjax(base, 'cpg')\n  ]);\n  return parseDbf(dbf, cpg);\n};\nconst checkSuffix = (base, suffix) => {\n  const url = new URL(base);\n  return url.pathname.slice(-4).toLowerCase() === suffix;\n};\nshp.getShapefile = async function (base, whiteList) {\n  if (typeof base !== 'string') {\n    return shp.parseZip(base);\n  }\n  if (checkSuffix(base, '.zip')) {\n    return getZip(base, whiteList);\n  }\n  const results = await Promise.all([\n    handleShp(base),\n    handleDbf(base)\n  ]);\n  return shp.combine(results);\n};\nshp.parseShp = function (shp, prj) {\n  shp = toBuffer(shp);\n  if (Buffer.isBuffer(prj)) {\n    prj = prj.toString();\n  }\n  if (typeof prj === 'string') {\n    try {\n      prj = proj4(prj);\n    } catch (e) {\n      prj = false;\n    }\n  }\n  return parseShp(shp, prj);\n};\nshp.parseDbf = function (dbf, cpg) {\n  dbf = toBuffer(dbf);\n  return parseDbf(dbf, cpg);\n};\nmodule.exports = shp;\n"]},"metadata":{},"sourceType":"script"}