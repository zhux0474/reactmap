{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { _, Autowired, Bean, BeanStub, ChangedPath, Constants, Events, GridOptionsWrapper, Optional, PostConstruct, ClientSideRowModelSteps, RowNode, RowHighlightPosition } from \"@ag-grid-community/core\";\nimport { ClientSideNodeManager } from \"./clientSideNodeManager\";\nvar RecursionType;\n\n(function (RecursionType) {\n  RecursionType[RecursionType[\"Normal\"] = 0] = \"Normal\";\n  RecursionType[RecursionType[\"AfterFilter\"] = 1] = \"AfterFilter\";\n  RecursionType[RecursionType[\"AfterFilterAndSort\"] = 2] = \"AfterFilterAndSort\";\n  RecursionType[RecursionType[\"PivotNodes\"] = 3] = \"PivotNodes\";\n})(RecursionType || (RecursionType = {}));\n\nvar ClientSideRowModel =\n/** @class */\nfunction (_super) {\n  __extends(ClientSideRowModel, _super);\n\n  function ClientSideRowModel() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  ClientSideRowModel.prototype.init = function () {\n    var refreshEverythingFunc = this.refreshModel.bind(this, {\n      step: ClientSideRowModelSteps.EVERYTHING\n    });\n    var refreshEverythingAfterColsChangedFunc = this.refreshModel.bind(this, {\n      step: ClientSideRowModelSteps.EVERYTHING,\n      afterColumnsChanged: true,\n      keepRenderedRows: true,\n      animate: true\n    });\n    this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, refreshEverythingAfterColsChangedFunc);\n    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, refreshEverythingFunc);\n    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_VALUE_CHANGED, this.onValueChanged.bind(this));\n    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_CHANGED, this.refreshModel.bind(this, {\n      step: ClientSideRowModelSteps.PIVOT\n    }));\n    this.addManagedListener(this.eventService, Events.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this));\n    this.addManagedListener(this.eventService, Events.EVENT_SORT_CHANGED, this.onSortChanged.bind(this));\n    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, refreshEverythingFunc);\n    var refreshMapListener = this.refreshModel.bind(this, {\n      step: ClientSideRowModelSteps.MAP,\n      keepRenderedRows: true,\n      animate: true\n    });\n    this.addManagedListener(this.gridOptionsWrapper, GridOptionsWrapper.PROP_GROUP_REMOVE_SINGLE_CHILDREN, refreshMapListener);\n    this.addManagedListener(this.gridOptionsWrapper, GridOptionsWrapper.PROP_GROUP_REMOVE_LOWEST_SINGLE_CHILDREN, refreshMapListener);\n    this.rootNode = new RowNode(this.beans);\n    this.nodeManager = new ClientSideNodeManager(this.rootNode, this.gridOptionsWrapper, this.eventService, this.columnModel, this.gridApi, this.columnApi, this.selectionService, this.beans);\n  };\n\n  ClientSideRowModel.prototype.start = function () {\n    var rowData = this.gridOptionsWrapper.getRowData();\n\n    if (rowData) {\n      this.setRowData(rowData);\n    }\n  };\n\n  ClientSideRowModel.prototype.ensureRowHeightsValid = function (startPixel, endPixel, startLimitIndex, endLimitIndex) {\n    var atLeastOneChange;\n    var res = false; // we do this multiple times as changing the row heights can also change the first and last rows,\n    // so the first pass can make lots of rows smaller, which means the second pass we end up changing\n    // more rows.\n\n    do {\n      atLeastOneChange = false;\n      var rowAtStartPixel = this.getRowIndexAtPixel(startPixel);\n      var rowAtEndPixel = this.getRowIndexAtPixel(endPixel); // keep check to current page if doing pagination\n\n      var firstRow = Math.max(rowAtStartPixel, startLimitIndex);\n      var lastRow = Math.min(rowAtEndPixel, endLimitIndex);\n\n      for (var rowIndex = firstRow; rowIndex <= lastRow; rowIndex++) {\n        var rowNode = this.getRow(rowIndex);\n\n        if (rowNode.rowHeightEstimated) {\n          var rowHeight = this.gridOptionsWrapper.getRowHeightForNode(rowNode);\n          rowNode.setRowHeight(rowHeight.height);\n          atLeastOneChange = true;\n          res = true;\n        }\n      }\n\n      if (atLeastOneChange) {\n        this.setRowTopAndRowIndex();\n      }\n    } while (atLeastOneChange);\n\n    return res;\n  };\n\n  ClientSideRowModel.prototype.setRowTopAndRowIndex = function () {\n    var defaultRowHeight = this.gridOptionsWrapper.getDefaultRowHeight();\n    var nextRowTop = 0; // mapping displayed rows is not needed for this method, however it's used in\n    // clearRowTopAndRowIndex(), and given we are looping through this.rowsToDisplay here,\n    // we create the map here for performance reasons, so we don't loop a second time\n    // in clearRowTopAndRowIndex()\n\n    var displayedRowsMapped = new Set(); // we don't estimate if doing fullHeight or autoHeight, as all rows get rendered all the time\n    // with these two layouts.\n\n    var allowEstimate = this.gridOptionsWrapper.getDomLayout() === Constants.DOM_LAYOUT_NORMAL;\n\n    for (var i = 0; i < this.rowsToDisplay.length; i++) {\n      var rowNode = this.rowsToDisplay[i];\n\n      if (rowNode.id != null) {\n        displayedRowsMapped.add(rowNode.id);\n      }\n\n      if (rowNode.rowHeight == null) {\n        var rowHeight = this.gridOptionsWrapper.getRowHeightForNode(rowNode, allowEstimate, defaultRowHeight);\n        rowNode.setRowHeight(rowHeight.height, rowHeight.estimated);\n      }\n\n      rowNode.setRowTop(nextRowTop);\n      rowNode.setRowIndex(i);\n      nextRowTop += rowNode.rowHeight;\n    }\n\n    return displayedRowsMapped;\n  };\n\n  ClientSideRowModel.prototype.clearRowTopAndRowIndex = function (changedPath, displayedRowsMapped) {\n    var changedPathActive = changedPath.isActive();\n\n    var clearIfNotDisplayed = function (rowNode) {\n      if (rowNode && rowNode.id != null && !displayedRowsMapped.has(rowNode.id)) {\n        rowNode.clearRowTopAndRowIndex();\n      }\n    };\n\n    var recurse = function (rowNode) {\n      clearIfNotDisplayed(rowNode);\n      clearIfNotDisplayed(rowNode.detailNode);\n      clearIfNotDisplayed(rowNode.sibling);\n\n      if (rowNode.hasChildren()) {\n        if (rowNode.childrenAfterGroup) {\n          // if a changedPath is active, it means we are here because of a transaction update or\n          // a change detection. neither of these impacts the open/closed state of groups. so if\n          // a group is not open this time, it was not open last time. so we know all closed groups\n          // already have their top positions cleared. so there is no need to traverse all the way\n          // when changedPath is active and the rowNode is not expanded.\n          var isRootNode = rowNode.level == -1; // we need to give special consideration for root node,\n          // as expanded=undefined for root node\n\n          var skipChildren = changedPathActive && !isRootNode && !rowNode.expanded;\n\n          if (!skipChildren) {\n            rowNode.childrenAfterGroup.forEach(recurse);\n          }\n        }\n      }\n    };\n\n    recurse(this.rootNode);\n  }; // returns false if row was moved, otherwise true\n\n\n  ClientSideRowModel.prototype.ensureRowsAtPixel = function (rowNodes, pixel, increment) {\n    var _this = this;\n\n    if (increment === void 0) {\n      increment = 0;\n    }\n\n    var indexAtPixelNow = this.getRowIndexAtPixel(pixel);\n    var rowNodeAtPixelNow = this.getRow(indexAtPixelNow);\n\n    if (rowNodeAtPixelNow === rowNodes[0]) {\n      return false;\n    }\n\n    rowNodes.forEach(function (rowNode) {\n      _.removeFromArray(_this.rootNode.allLeafChildren, rowNode);\n    });\n    rowNodes.forEach(function (rowNode, idx) {\n      _.insertIntoArray(_this.rootNode.allLeafChildren, rowNode, Math.max(indexAtPixelNow + increment, 0) + idx);\n    });\n    this.refreshModel({\n      step: ClientSideRowModelSteps.EVERYTHING,\n      keepRenderedRows: true,\n      animate: true,\n      keepEditingRows: true\n    });\n    return true;\n  };\n\n  ClientSideRowModel.prototype.highlightRowAtPixel = function (rowNode, pixel) {\n    var indexAtPixelNow = pixel != null ? this.getRowIndexAtPixel(pixel) : null;\n    var rowNodeAtPixelNow = indexAtPixelNow != null ? this.getRow(indexAtPixelNow) : null;\n\n    if (!rowNodeAtPixelNow || !rowNode || rowNodeAtPixelNow === rowNode || pixel == null) {\n      if (this.lastHighlightedRow) {\n        this.lastHighlightedRow.setHighlighted(null);\n        this.lastHighlightedRow = null;\n      }\n\n      return;\n    }\n\n    var highlight = this.getHighlightPosition(pixel, rowNodeAtPixelNow);\n\n    if (this.lastHighlightedRow && this.lastHighlightedRow !== rowNodeAtPixelNow) {\n      this.lastHighlightedRow.setHighlighted(null);\n      this.lastHighlightedRow = null;\n    }\n\n    rowNodeAtPixelNow.setHighlighted(highlight);\n    this.lastHighlightedRow = rowNodeAtPixelNow;\n  };\n\n  ClientSideRowModel.prototype.getHighlightPosition = function (pixel, rowNode) {\n    if (!rowNode) {\n      var index = this.getRowIndexAtPixel(pixel);\n      rowNode = this.getRow(index || 0);\n\n      if (!rowNode) {\n        return RowHighlightPosition.Below;\n      }\n    }\n\n    var rowTop = rowNode.rowTop,\n        rowHeight = rowNode.rowHeight;\n    return pixel - rowTop < rowHeight / 2 ? RowHighlightPosition.Above : RowHighlightPosition.Below;\n  };\n\n  ClientSideRowModel.prototype.getLastHighlightedRowNode = function () {\n    return this.lastHighlightedRow;\n  };\n\n  ClientSideRowModel.prototype.isLastRowIndexKnown = function () {\n    return true;\n  };\n\n  ClientSideRowModel.prototype.getRowCount = function () {\n    if (this.rowsToDisplay) {\n      return this.rowsToDisplay.length;\n    }\n\n    return 0;\n  };\n\n  ClientSideRowModel.prototype.getTopLevelRowCount = function () {\n    var showingRootNode = this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode;\n\n    if (showingRootNode) {\n      return 1;\n    }\n\n    return this.rootNode.childrenAfterFilter ? this.rootNode.childrenAfterFilter.length : 0;\n  };\n\n  ClientSideRowModel.prototype.getTopLevelRowDisplayedIndex = function (topLevelIndex) {\n    var showingRootNode = this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode;\n\n    if (showingRootNode) {\n      return topLevelIndex;\n    }\n\n    var rowNode = this.rootNode.childrenAfterSort[topLevelIndex];\n\n    if (this.gridOptionsWrapper.isGroupHideOpenParents()) {\n      // if hideOpenParents, and this row open, then this row is now displayed at this index, first child is\n      while (rowNode.expanded && rowNode.childrenAfterSort && rowNode.childrenAfterSort.length > 0) {\n        rowNode = rowNode.childrenAfterSort[0];\n      }\n    }\n\n    return rowNode.rowIndex;\n  };\n\n  ClientSideRowModel.prototype.getRowBounds = function (index) {\n    if (_.missing(this.rowsToDisplay)) {\n      return null;\n    }\n\n    var rowNode = this.rowsToDisplay[index];\n\n    if (rowNode) {\n      return {\n        rowTop: rowNode.rowTop,\n        rowHeight: rowNode.rowHeight\n      };\n    }\n\n    return null;\n  };\n\n  ClientSideRowModel.prototype.onRowGroupOpened = function () {\n    var animate = this.gridOptionsWrapper.isAnimateRows();\n    this.refreshModel({\n      step: ClientSideRowModelSteps.MAP,\n      keepRenderedRows: true,\n      animate: animate\n    });\n  };\n\n  ClientSideRowModel.prototype.onFilterChanged = function (event) {\n    if (event.afterDataChange) {\n      return;\n    }\n\n    var animate = this.gridOptionsWrapper.isAnimateRows();\n    this.refreshModel({\n      step: ClientSideRowModelSteps.FILTER,\n      keepRenderedRows: true,\n      animate: animate\n    });\n  };\n\n  ClientSideRowModel.prototype.onSortChanged = function () {\n    var animate = this.gridOptionsWrapper.isAnimateRows();\n    this.refreshModel({\n      step: ClientSideRowModelSteps.SORT,\n      keepRenderedRows: true,\n      animate: animate,\n      keepEditingRows: true\n    });\n  };\n\n  ClientSideRowModel.prototype.getType = function () {\n    return Constants.ROW_MODEL_TYPE_CLIENT_SIDE;\n  };\n\n  ClientSideRowModel.prototype.onValueChanged = function () {\n    if (this.columnModel.isPivotActive()) {\n      this.refreshModel({\n        step: ClientSideRowModelSteps.PIVOT\n      });\n    } else {\n      this.refreshModel({\n        step: ClientSideRowModelSteps.AGGREGATE\n      });\n    }\n  };\n\n  ClientSideRowModel.prototype.createChangePath = function (rowNodeTransactions) {\n    // for updates, if the row is updated at all, then we re-calc all the values\n    // in that row. we could compare each value to each old value, however if we\n    // did this, we would be calling the valueService twice, once on the old value\n    // and once on the new value. so it's less valueGetter calls if we just assume\n    // each column is different. that way the changedPath is used so that only\n    // the impacted parent rows are recalculated, parents who's children have\n    // not changed are not impacted.\n    var noTransactions = _.missingOrEmpty(rowNodeTransactions);\n\n    var changedPath = new ChangedPath(false, this.rootNode);\n\n    if (noTransactions || this.gridOptionsWrapper.isTreeData()) {\n      changedPath.setInactive();\n    }\n\n    return changedPath;\n  };\n\n  ClientSideRowModel.prototype.isSuppressModelUpdateAfterUpdateTransaction = function (params) {\n    if (!this.gridOptionsWrapper.isSuppressModelUpdateAfterUpdateTransaction()) {\n      return false;\n    } // return true if we are only doing update transactions\n\n\n    if (params.rowNodeTransactions == null) {\n      return false;\n    }\n\n    var transWithAddsOrDeletes = _.filter(params.rowNodeTransactions, function (tx) {\n      return tx.add != null && tx.add.length > 0 || tx.remove != null && tx.remove.length > 0;\n    });\n\n    var transactionsContainUpdatesOnly = transWithAddsOrDeletes == null || transWithAddsOrDeletes.length == 0;\n    return transactionsContainUpdatesOnly;\n  };\n\n  ClientSideRowModel.prototype.refreshModel = function (params) {\n    var _this = this;\n\n    if (this.isSuppressModelUpdateAfterUpdateTransaction(params)) {\n      return;\n    } // this goes through the pipeline of stages. what's in my head is similar\n    // to the diagram on this page:\n    // http://commons.apache.org/sandbox/commons-pipeline/pipeline_basics.html\n    // however we want to keep the results of each stage, hence we manually call\n    // each step rather than have them chain each other.\n    // fallthrough in below switch is on purpose,\n    // eg if STEP_FILTER, then all steps below this\n    // step get done\n    // let start: number;\n    // console.log('======= start =======');\n\n\n    var changedPath = this.createChangePath(params.rowNodeTransactions);\n\n    switch (params.step) {\n      case ClientSideRowModelSteps.EVERYTHING:\n        this.doRowGrouping(params.groupState, params.rowNodeTransactions, params.rowNodeOrder, changedPath, !!params.afterColumnsChanged);\n\n      case ClientSideRowModelSteps.FILTER:\n        this.doFilter(changedPath);\n\n      case ClientSideRowModelSteps.PIVOT:\n        this.doPivot(changedPath);\n\n      case ClientSideRowModelSteps.AGGREGATE:\n        // depends on agg fields\n        this.doAggregate(changedPath);\n\n      case ClientSideRowModelSteps.SORT:\n        this.doSort(params.rowNodeTransactions, changedPath);\n\n      case ClientSideRowModelSteps.MAP:\n        this.doRowsToDisplay();\n    } // set all row tops to null, then set row tops on all visible rows. if we don't\n    // do this, then the algorithm below only sets row tops, old row tops from old rows\n    // will still lie around\n\n\n    var displayedNodesMapped = this.setRowTopAndRowIndex();\n    this.clearRowTopAndRowIndex(changedPath, displayedNodesMapped);\n    var event = {\n      type: Events.EVENT_MODEL_UPDATED,\n      api: this.gridApi,\n      columnApi: this.columnApi,\n      animate: params.animate,\n      keepRenderedRows: params.keepRenderedRows,\n      newData: params.newData,\n      newPage: false\n    };\n    this.eventService.dispatchEvent(event);\n\n    if (this.$scope) {\n      window.setTimeout(function () {\n        _this.$scope.$apply();\n      }, 0);\n    }\n  };\n\n  ClientSideRowModel.prototype.isEmpty = function () {\n    var rowsMissing = _.missing(this.rootNode.allLeafChildren) || this.rootNode.allLeafChildren.length === 0;\n    return _.missing(this.rootNode) || rowsMissing || !this.columnModel.isReady();\n  };\n\n  ClientSideRowModel.prototype.isRowsToRender = function () {\n    return _.exists(this.rowsToDisplay) && this.rowsToDisplay.length > 0;\n  };\n\n  ClientSideRowModel.prototype.getNodesInRangeForSelection = function (firstInRange, lastInRange) {\n    // if lastSelectedNode is missing, we start at the first row\n    var firstRowHit = !lastInRange;\n    var lastRowHit = false;\n    var lastRow;\n    var result = [];\n    var groupsSelectChildren = this.gridOptionsWrapper.isGroupSelectsChildren();\n    this.forEachNodeAfterFilterAndSort(function (rowNode) {\n      var lookingForLastRow = firstRowHit && !lastRowHit; // check if we need to flip the select switch\n\n      if (!firstRowHit) {\n        if (rowNode === lastInRange || rowNode === firstInRange) {\n          firstRowHit = true;\n        }\n      }\n\n      var skipThisGroupNode = rowNode.group && groupsSelectChildren;\n\n      if (!skipThisGroupNode) {\n        var inRange = firstRowHit && !lastRowHit;\n        var childOfLastRow = rowNode.isParentOfNode(lastRow);\n\n        if (inRange || childOfLastRow) {\n          result.push(rowNode);\n        }\n      }\n\n      if (lookingForLastRow) {\n        if (rowNode === lastInRange || rowNode === firstInRange) {\n          lastRowHit = true;\n\n          if (rowNode === lastInRange) {\n            lastRow = lastInRange;\n          } else {\n            lastRow = firstInRange;\n          }\n        }\n      }\n    });\n    return result;\n  };\n\n  ClientSideRowModel.prototype.setDatasource = function (datasource) {\n    console.error('AG Grid: should never call setDatasource on clientSideRowController');\n  };\n\n  ClientSideRowModel.prototype.getTopLevelNodes = function () {\n    return this.rootNode ? this.rootNode.childrenAfterGroup : null;\n  };\n\n  ClientSideRowModel.prototype.getRootNode = function () {\n    return this.rootNode;\n  };\n\n  ClientSideRowModel.prototype.getRow = function (index) {\n    return this.rowsToDisplay[index];\n  };\n\n  ClientSideRowModel.prototype.isRowPresent = function (rowNode) {\n    return this.rowsToDisplay.indexOf(rowNode) >= 0;\n  };\n\n  ClientSideRowModel.prototype.getRowIndexAtPixel = function (pixelToMatch) {\n    if (this.isEmpty()) {\n      return -1;\n    } // do binary search of tree\n    // http://oli.me.uk/2013/06/08/searching-javascript-arrays-with-a-binary-search/\n\n\n    var bottomPointer = 0;\n    var topPointer = this.rowsToDisplay.length - 1; // quick check, if the pixel is out of bounds, then return last row\n\n    if (pixelToMatch <= 0) {\n      // if pixel is less than or equal zero, it's always the first row\n      return 0;\n    }\n\n    var lastNode = _.last(this.rowsToDisplay);\n\n    if (lastNode.rowTop <= pixelToMatch) {\n      return this.rowsToDisplay.length - 1;\n    }\n\n    while (true) {\n      var midPointer = Math.floor((bottomPointer + topPointer) / 2);\n      var currentRowNode = this.rowsToDisplay[midPointer];\n\n      if (this.isRowInPixel(currentRowNode, pixelToMatch)) {\n        return midPointer;\n      }\n\n      if (currentRowNode.rowTop < pixelToMatch) {\n        bottomPointer = midPointer + 1;\n      } else if (currentRowNode.rowTop > pixelToMatch) {\n        topPointer = midPointer - 1;\n      }\n    }\n  };\n\n  ClientSideRowModel.prototype.isRowInPixel = function (rowNode, pixelToMatch) {\n    var topPixel = rowNode.rowTop;\n    var bottomPixel = rowNode.rowTop + rowNode.rowHeight;\n    var pixelInRow = topPixel <= pixelToMatch && bottomPixel > pixelToMatch;\n    return pixelInRow;\n  };\n\n  ClientSideRowModel.prototype.forEachLeafNode = function (callback) {\n    if (this.rootNode.allLeafChildren) {\n      this.rootNode.allLeafChildren.forEach(function (rowNode, index) {\n        return callback(rowNode, index);\n      });\n    }\n  };\n\n  ClientSideRowModel.prototype.forEachNode = function (callback) {\n    this.recursivelyWalkNodesAndCallback(this.rootNode.childrenAfterGroup, callback, RecursionType.Normal, 0);\n  };\n\n  ClientSideRowModel.prototype.forEachNodeAfterFilter = function (callback) {\n    this.recursivelyWalkNodesAndCallback(this.rootNode.childrenAfterFilter, callback, RecursionType.AfterFilter, 0);\n  };\n\n  ClientSideRowModel.prototype.forEachNodeAfterFilterAndSort = function (callback) {\n    this.recursivelyWalkNodesAndCallback(this.rootNode.childrenAfterSort, callback, RecursionType.AfterFilterAndSort, 0);\n  };\n\n  ClientSideRowModel.prototype.forEachPivotNode = function (callback) {\n    this.recursivelyWalkNodesAndCallback([this.rootNode], callback, RecursionType.PivotNodes, 0);\n  }; // iterates through each item in memory, and calls the callback function\n  // nodes - the rowNodes to traverse\n  // callback - the user provided callback\n  // recursion type - need this to know what child nodes to recurse, eg if looking at all nodes, or filtered notes etc\n  // index - works similar to the index in forEach in javascript's array function\n\n\n  ClientSideRowModel.prototype.recursivelyWalkNodesAndCallback = function (nodes, callback, recursionType, index) {\n    if (!nodes) {\n      return index;\n    }\n\n    for (var i = 0; i < nodes.length; i++) {\n      var node = nodes[i];\n      callback(node, index++); // go to the next level if it is a group\n\n      if (node.hasChildren()) {\n        // depending on the recursion type, we pick a difference set of children\n        var nodeChildren = null;\n\n        switch (recursionType) {\n          case RecursionType.Normal:\n            nodeChildren = node.childrenAfterGroup;\n            break;\n\n          case RecursionType.AfterFilter:\n            nodeChildren = node.childrenAfterFilter;\n            break;\n\n          case RecursionType.AfterFilterAndSort:\n            nodeChildren = node.childrenAfterSort;\n            break;\n\n          case RecursionType.PivotNodes:\n            // for pivot, we don't go below leafGroup levels\n            nodeChildren = !node.leafGroup ? node.childrenAfterSort : null;\n            break;\n        }\n\n        if (nodeChildren) {\n          index = this.recursivelyWalkNodesAndCallback(nodeChildren, callback, recursionType, index);\n        }\n      }\n    }\n\n    return index;\n  }; // it's possible to recompute the aggregate without doing the other parts\n  // + gridApi.recomputeAggregates()\n\n\n  ClientSideRowModel.prototype.doAggregate = function (changedPath) {\n    if (this.aggregationStage) {\n      this.aggregationStage.execute({\n        rowNode: this.rootNode,\n        changedPath: changedPath\n      });\n    }\n  }; // + gridApi.expandAll()\n  // + gridApi.collapseAll()\n\n\n  ClientSideRowModel.prototype.expandOrCollapseAll = function (expand) {\n    var usingTreeData = this.gridOptionsWrapper.isTreeData();\n\n    if (this.rootNode) {\n      recursiveExpandOrCollapse(this.rootNode.childrenAfterGroup);\n    }\n\n    function recursiveExpandOrCollapse(rowNodes) {\n      if (!rowNodes) {\n        return;\n      }\n\n      rowNodes.forEach(function (rowNode) {\n        var shouldExpandOrCollapse = usingTreeData ? _.exists(rowNode.childrenAfterGroup) : rowNode.group;\n\n        if (shouldExpandOrCollapse) {\n          rowNode.expanded = expand;\n          recursiveExpandOrCollapse(rowNode.childrenAfterGroup);\n        }\n      });\n    }\n\n    this.refreshModel({\n      step: ClientSideRowModelSteps.MAP\n    });\n    var eventSource = expand ? 'expandAll' : 'collapseAll';\n    var event = {\n      api: this.gridApi,\n      columnApi: this.columnApi,\n      type: Events.EVENT_EXPAND_COLLAPSE_ALL,\n      source: eventSource\n    };\n    this.eventService.dispatchEvent(event);\n  };\n\n  ClientSideRowModel.prototype.doSort = function (rowNodeTransactions, changedPath) {\n    this.sortStage.execute({\n      rowNode: this.rootNode,\n      rowNodeTransactions: rowNodeTransactions,\n      changedPath: changedPath\n    });\n  };\n\n  ClientSideRowModel.prototype.doRowGrouping = function (groupState, rowNodeTransactions, rowNodeOrder, changedPath, afterColumnsChanged) {\n    if (this.groupStage) {\n      if (rowNodeTransactions) {\n        this.groupStage.execute({\n          rowNode: this.rootNode,\n          rowNodeTransactions: rowNodeTransactions,\n          rowNodeOrder: rowNodeOrder,\n          changedPath: changedPath\n        });\n      } else {\n        this.groupStage.execute({\n          rowNode: this.rootNode,\n          changedPath: changedPath,\n          afterColumnsChanged: afterColumnsChanged\n        }); // set open/closed state on groups\n\n        this.restoreGroupState(groupState);\n      }\n\n      if (this.gridOptionsWrapper.isGroupSelectsChildren()) {\n        this.selectionService.updateGroupsFromChildrenSelections(changedPath);\n      }\n    } else {\n      this.rootNode.childrenAfterGroup = this.rootNode.allLeafChildren;\n\n      if (this.rootNode.sibling) {\n        this.rootNode.sibling.childrenAfterGroup = this.rootNode.childrenAfterGroup;\n      }\n\n      this.rootNode.updateHasChildren();\n    }\n  };\n\n  ClientSideRowModel.prototype.restoreGroupState = function (groupState) {\n    if (!groupState) {\n      return;\n    }\n\n    _.traverseNodesWithKey(this.rootNode.childrenAfterGroup, function (node, key) {\n      // if the group was open last time, then open it this time. however\n      // if was not open last time, then don't touch the group, so the 'groupDefaultExpanded'\n      // setting will take effect.\n      if (typeof groupState[key] === 'boolean') {\n        node.expanded = groupState[key];\n      }\n    });\n  };\n\n  ClientSideRowModel.prototype.doFilter = function (changedPath) {\n    this.filterStage.execute({\n      rowNode: this.rootNode,\n      changedPath: changedPath\n    });\n  };\n\n  ClientSideRowModel.prototype.doPivot = function (changedPath) {\n    if (this.pivotStage) {\n      this.pivotStage.execute({\n        rowNode: this.rootNode,\n        changedPath: changedPath\n      });\n    }\n  };\n\n  ClientSideRowModel.prototype.getGroupState = function () {\n    if (!this.rootNode.childrenAfterGroup || !this.gridOptionsWrapper.isRememberGroupStateWhenNewData()) {\n      return null;\n    }\n\n    var result = {};\n\n    _.traverseNodesWithKey(this.rootNode.childrenAfterGroup, function (node, key) {\n      return result[key] = node.expanded;\n    });\n\n    return result;\n  };\n\n  ClientSideRowModel.prototype.getCopyOfNodesMap = function () {\n    return this.nodeManager.getCopyOfNodesMap();\n  };\n\n  ClientSideRowModel.prototype.getRowNode = function (id) {\n    // although id is typed a string, this could be called by the user, and they could have passed a number\n    var idIsGroup = typeof id == 'string' && id.indexOf(RowNode.ID_PREFIX_ROW_GROUP) == 0;\n\n    if (idIsGroup) {\n      // only one users complained about getRowNode not working for groups, after years of\n      // this working for normal rows. so have done quick implementation. if users complain\n      // about performance, then GroupStage should store / manage created groups in a map,\n      // which is a chunk of work.\n      var res_1 = undefined;\n      this.forEachNode(function (node) {\n        if (node.id === id) {\n          res_1 = node;\n        }\n      });\n      return res_1;\n    } else {\n      return this.nodeManager.getRowNode(id);\n    }\n  }; // rows: the rows to put into the model\n\n\n  ClientSideRowModel.prototype.setRowData = function (rowData) {\n    // no need to invalidate cache, as the cache is stored on the rowNode,\n    // so new rowNodes means the cache is wiped anyway.\n    // remember group state, so we can expand groups that should be expanded\n    var groupState = this.getGroupState();\n    this.nodeManager.setRowData(rowData); // this event kicks off:\n    // - clears selection\n    // - updates filters\n    // - shows 'no rows' overlay if needed\n\n    var rowDataChangedEvent = {\n      type: Events.EVENT_ROW_DATA_CHANGED,\n      api: this.gridApi,\n      columnApi: this.columnApi\n    };\n    this.eventService.dispatchEvent(rowDataChangedEvent);\n    this.refreshModel({\n      step: ClientSideRowModelSteps.EVERYTHING,\n      groupState: groupState,\n      newData: true\n    });\n  };\n\n  ClientSideRowModel.prototype.batchUpdateRowData = function (rowDataTransaction, callback) {\n    var _this = this;\n\n    if (this.applyAsyncTransactionsTimeout == null) {\n      this.rowDataTransactionBatch = [];\n      var waitMillis = this.gridOptionsWrapper.getAsyncTransactionWaitMillis();\n      this.applyAsyncTransactionsTimeout = window.setTimeout(function () {\n        _this.executeBatchUpdateRowData();\n      }, waitMillis);\n    }\n\n    this.rowDataTransactionBatch.push({\n      rowDataTransaction: rowDataTransaction,\n      callback: callback\n    });\n  };\n\n  ClientSideRowModel.prototype.flushAsyncTransactions = function () {\n    if (this.applyAsyncTransactionsTimeout != null) {\n      clearTimeout(this.applyAsyncTransactionsTimeout);\n      this.executeBatchUpdateRowData();\n    }\n  };\n\n  ClientSideRowModel.prototype.executeBatchUpdateRowData = function () {\n    var _this = this;\n\n    this.valueCache.onDataChanged();\n    var callbackFuncsBound = [];\n    var rowNodeTrans = []; // The rowGroup stage uses rowNodeOrder if order was provided. if we didn't pass 'true' to\n    // commonUpdateRowData, using addIndex would have no effect when grouping.\n\n    var forceRowNodeOrder = false;\n\n    if (this.rowDataTransactionBatch) {\n      this.rowDataTransactionBatch.forEach(function (tranItem) {\n        var rowNodeTran = _this.nodeManager.updateRowData(tranItem.rowDataTransaction, undefined);\n\n        rowNodeTrans.push(rowNodeTran);\n\n        if (tranItem.callback) {\n          callbackFuncsBound.push(tranItem.callback.bind(null, rowNodeTran));\n        }\n\n        if (typeof tranItem.rowDataTransaction.addIndex === 'number') {\n          forceRowNodeOrder = true;\n        }\n      });\n    }\n\n    this.commonUpdateRowData(rowNodeTrans, undefined, forceRowNodeOrder); // do callbacks in next VM turn so it's async\n\n    if (callbackFuncsBound.length > 0) {\n      window.setTimeout(function () {\n        callbackFuncsBound.forEach(function (func) {\n          return func();\n        });\n      }, 0);\n    }\n\n    if (rowNodeTrans.length > 0) {\n      var event_1 = {\n        api: this.gridOptionsWrapper.getApi(),\n        columnApi: this.gridOptionsWrapper.getColumnApi(),\n        type: Events.EVENT_ASYNC_TRANSACTIONS_FLUSHED,\n        results: rowNodeTrans\n      };\n      this.eventService.dispatchEvent(event_1);\n    }\n\n    this.rowDataTransactionBatch = null;\n    this.applyAsyncTransactionsTimeout = undefined;\n  };\n\n  ClientSideRowModel.prototype.updateRowData = function (rowDataTran, rowNodeOrder) {\n    this.valueCache.onDataChanged();\n    var rowNodeTran = this.nodeManager.updateRowData(rowDataTran, rowNodeOrder); // if doing immutableData, addIndex is never present. however if doing standard transaction, and user\n    // provided addIndex, then this is used in updateRowData. However if doing Enterprise, then the rowGroup\n    // stage also uses the\n\n    var forceRowNodeOrder = typeof rowDataTran.addIndex === 'number';\n    this.commonUpdateRowData([rowNodeTran], rowNodeOrder, forceRowNodeOrder);\n    return rowNodeTran;\n  };\n\n  ClientSideRowModel.prototype.createRowNodeOrder = function () {\n    var suppressSortOrder = this.gridOptionsWrapper.isSuppressMaintainUnsortedOrder();\n\n    if (suppressSortOrder) {\n      return;\n    }\n\n    var orderMap = {};\n\n    if (this.rootNode && this.rootNode.allLeafChildren) {\n      for (var index = 0; index < this.rootNode.allLeafChildren.length; index++) {\n        var node = this.rootNode.allLeafChildren[index];\n        orderMap[node.id] = index;\n      }\n    }\n\n    return orderMap;\n  }; // common to updateRowData and batchUpdateRowData\n\n\n  ClientSideRowModel.prototype.commonUpdateRowData = function (rowNodeTrans, rowNodeOrder, forceRowNodeOrder) {\n    if (forceRowNodeOrder) {\n      rowNodeOrder = this.createRowNodeOrder();\n    }\n\n    this.refreshModel({\n      step: ClientSideRowModelSteps.EVERYTHING,\n      rowNodeTransactions: rowNodeTrans,\n      rowNodeOrder: rowNodeOrder,\n      keepRenderedRows: true,\n      animate: true,\n      keepEditingRows: true\n    });\n    var event = {\n      type: Events.EVENT_ROW_DATA_UPDATED,\n      api: this.gridApi,\n      columnApi: this.columnApi\n    };\n    this.eventService.dispatchEvent(event);\n  };\n\n  ClientSideRowModel.prototype.doRowsToDisplay = function () {\n    this.rowsToDisplay = this.flattenStage.execute({\n      rowNode: this.rootNode\n    });\n  };\n\n  ClientSideRowModel.prototype.onRowHeightChanged = function () {\n    this.refreshModel({\n      step: ClientSideRowModelSteps.MAP,\n      keepRenderedRows: true,\n      keepEditingRows: true\n    });\n  };\n\n  ClientSideRowModel.prototype.resetRowHeights = function () {\n    var atLeastOne = false;\n    this.forEachNode(function (rowNode) {\n      rowNode.setRowHeight(rowNode.rowHeight, true); // we keep the height each row is at, however we set estimated=true rather than clear the height.\n      // this means the grid will not reset the row heights back to defaults, rather it will re-calc\n      // the height for each row as the row is displayed. otherwise the scroll will jump when heights are reset.\n\n      var detailNode = rowNode.detailNode;\n\n      if (detailNode) {\n        detailNode.setRowHeight(detailNode.rowHeight, true);\n      }\n\n      atLeastOne = true;\n    });\n\n    if (atLeastOne) {\n      this.onRowHeightChanged();\n    }\n  };\n\n  __decorate([Autowired('columnModel')], ClientSideRowModel.prototype, \"columnModel\", void 0);\n\n  __decorate([Autowired('$scope')], ClientSideRowModel.prototype, \"$scope\", void 0);\n\n  __decorate([Autowired('selectionService')], ClientSideRowModel.prototype, \"selectionService\", void 0);\n\n  __decorate([Autowired('valueCache')], ClientSideRowModel.prototype, \"valueCache\", void 0);\n\n  __decorate([Autowired('columnApi')], ClientSideRowModel.prototype, \"columnApi\", void 0);\n\n  __decorate([Autowired('gridApi')], ClientSideRowModel.prototype, \"gridApi\", void 0);\n\n  __decorate([Autowired('animationFrameService')], ClientSideRowModel.prototype, \"animationFrameService\", void 0);\n\n  __decorate([Autowired('beans')], ClientSideRowModel.prototype, \"beans\", void 0);\n\n  __decorate([Autowired('filterStage')], ClientSideRowModel.prototype, \"filterStage\", void 0);\n\n  __decorate([Autowired('sortStage')], ClientSideRowModel.prototype, \"sortStage\", void 0);\n\n  __decorate([Autowired('flattenStage')], ClientSideRowModel.prototype, \"flattenStage\", void 0);\n\n  __decorate([Optional('groupStage')], ClientSideRowModel.prototype, \"groupStage\", void 0);\n\n  __decorate([Optional('aggregationStage')], ClientSideRowModel.prototype, \"aggregationStage\", void 0);\n\n  __decorate([Optional('pivotStage')], ClientSideRowModel.prototype, \"pivotStage\", void 0);\n\n  __decorate([PostConstruct], ClientSideRowModel.prototype, \"init\", null);\n\n  ClientSideRowModel = __decorate([Bean('rowModel')], ClientSideRowModel);\n  return ClientSideRowModel;\n}(BeanStub);\n\nexport { ClientSideRowModel };","map":{"version":3,"sources":["/Users/rongxuan/Desktop/reactmap/reactmap/node_modules/@ag-grid-community/client-side-row-model/dist/es6/clientSideRowModel/clientSideRowModel.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","_","Autowired","Bean","BeanStub","ChangedPath","Constants","Events","GridOptionsWrapper","Optional","PostConstruct","ClientSideRowModelSteps","RowNode","RowHighlightPosition","ClientSideNodeManager","RecursionType","ClientSideRowModel","_super","apply","init","refreshEverythingFunc","refreshModel","bind","step","EVERYTHING","refreshEverythingAfterColsChangedFunc","afterColumnsChanged","keepRenderedRows","animate","addManagedListener","eventService","EVENT_NEW_COLUMNS_LOADED","EVENT_COLUMN_ROW_GROUP_CHANGED","EVENT_COLUMN_VALUE_CHANGED","onValueChanged","EVENT_COLUMN_PIVOT_CHANGED","PIVOT","EVENT_FILTER_CHANGED","onFilterChanged","EVENT_SORT_CHANGED","onSortChanged","EVENT_COLUMN_PIVOT_MODE_CHANGED","refreshMapListener","MAP","gridOptionsWrapper","PROP_GROUP_REMOVE_SINGLE_CHILDREN","PROP_GROUP_REMOVE_LOWEST_SINGLE_CHILDREN","rootNode","beans","nodeManager","columnModel","gridApi","columnApi","selectionService","start","rowData","getRowData","setRowData","ensureRowHeightsValid","startPixel","endPixel","startLimitIndex","endLimitIndex","atLeastOneChange","res","rowAtStartPixel","getRowIndexAtPixel","rowAtEndPixel","firstRow","Math","max","lastRow","min","rowIndex","rowNode","getRow","rowHeightEstimated","rowHeight","getRowHeightForNode","setRowHeight","height","setRowTopAndRowIndex","defaultRowHeight","getDefaultRowHeight","nextRowTop","displayedRowsMapped","Set","allowEstimate","getDomLayout","DOM_LAYOUT_NORMAL","rowsToDisplay","id","add","estimated","setRowTop","setRowIndex","clearRowTopAndRowIndex","changedPath","changedPathActive","isActive","clearIfNotDisplayed","has","recurse","detailNode","sibling","hasChildren","childrenAfterGroup","isRootNode","level","skipChildren","expanded","forEach","ensureRowsAtPixel","rowNodes","pixel","increment","_this","indexAtPixelNow","rowNodeAtPixelNow","removeFromArray","allLeafChildren","idx","insertIntoArray","keepEditingRows","highlightRowAtPixel","lastHighlightedRow","setHighlighted","highlight","getHighlightPosition","index","Below","rowTop","Above","getLastHighlightedRowNode","isLastRowIndexKnown","getRowCount","getTopLevelRowCount","showingRootNode","childrenAfterFilter","getTopLevelRowDisplayedIndex","topLevelIndex","childrenAfterSort","isGroupHideOpenParents","getRowBounds","missing","onRowGroupOpened","isAnimateRows","event","afterDataChange","FILTER","SORT","getType","ROW_MODEL_TYPE_CLIENT_SIDE","isPivotActive","AGGREGATE","createChangePath","rowNodeTransactions","noTransactions","missingOrEmpty","isTreeData","setInactive","isSuppressModelUpdateAfterUpdateTransaction","params","transWithAddsOrDeletes","filter","tx","remove","transactionsContainUpdatesOnly","doRowGrouping","groupState","rowNodeOrder","doFilter","doPivot","doAggregate","doSort","doRowsToDisplay","displayedNodesMapped","type","EVENT_MODEL_UPDATED","api","newData","newPage","dispatchEvent","$scope","window","setTimeout","$apply","isEmpty","rowsMissing","isReady","isRowsToRender","exists","getNodesInRangeForSelection","firstInRange","lastInRange","firstRowHit","lastRowHit","result","groupsSelectChildren","isGroupSelectsChildren","forEachNodeAfterFilterAndSort","lookingForLastRow","skipThisGroupNode","group","inRange","childOfLastRow","isParentOfNode","push","setDatasource","datasource","console","error","getTopLevelNodes","getRootNode","isRowPresent","indexOf","pixelToMatch","bottomPointer","topPointer","lastNode","last","midPointer","floor","currentRowNode","isRowInPixel","topPixel","bottomPixel","pixelInRow","forEachLeafNode","callback","forEachNode","recursivelyWalkNodesAndCallback","Normal","forEachNodeAfterFilter","AfterFilter","AfterFilterAndSort","forEachPivotNode","PivotNodes","nodes","recursionType","node","nodeChildren","leafGroup","aggregationStage","execute","expandOrCollapseAll","expand","usingTreeData","recursiveExpandOrCollapse","shouldExpandOrCollapse","eventSource","EVENT_EXPAND_COLLAPSE_ALL","source","sortStage","groupStage","restoreGroupState","updateGroupsFromChildrenSelections","updateHasChildren","traverseNodesWithKey","filterStage","pivotStage","getGroupState","isRememberGroupStateWhenNewData","getCopyOfNodesMap","getRowNode","idIsGroup","ID_PREFIX_ROW_GROUP","res_1","undefined","rowDataChangedEvent","EVENT_ROW_DATA_CHANGED","batchUpdateRowData","rowDataTransaction","applyAsyncTransactionsTimeout","rowDataTransactionBatch","waitMillis","getAsyncTransactionWaitMillis","executeBatchUpdateRowData","flushAsyncTransactions","clearTimeout","valueCache","onDataChanged","callbackFuncsBound","rowNodeTrans","forceRowNodeOrder","tranItem","rowNodeTran","updateRowData","addIndex","commonUpdateRowData","func","event_1","getApi","getColumnApi","EVENT_ASYNC_TRANSACTIONS_FLUSHED","results","rowDataTran","createRowNodeOrder","suppressSortOrder","isSuppressMaintainUnsortedOrder","orderMap","EVENT_ROW_DATA_UPDATED","flattenStage","onRowHeightChanged","resetRowHeights","atLeastOne"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { _, Autowired, Bean, BeanStub, ChangedPath, Constants, Events, GridOptionsWrapper, Optional, PostConstruct, ClientSideRowModelSteps, RowNode, RowHighlightPosition } from \"@ag-grid-community/core\";\nimport { ClientSideNodeManager } from \"./clientSideNodeManager\";\nvar RecursionType;\n(function (RecursionType) {\n    RecursionType[RecursionType[\"Normal\"] = 0] = \"Normal\";\n    RecursionType[RecursionType[\"AfterFilter\"] = 1] = \"AfterFilter\";\n    RecursionType[RecursionType[\"AfterFilterAndSort\"] = 2] = \"AfterFilterAndSort\";\n    RecursionType[RecursionType[\"PivotNodes\"] = 3] = \"PivotNodes\";\n})(RecursionType || (RecursionType = {}));\nvar ClientSideRowModel = /** @class */ (function (_super) {\n    __extends(ClientSideRowModel, _super);\n    function ClientSideRowModel() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ClientSideRowModel.prototype.init = function () {\n        var refreshEverythingFunc = this.refreshModel.bind(this, { step: ClientSideRowModelSteps.EVERYTHING });\n        var refreshEverythingAfterColsChangedFunc = this.refreshModel.bind(this, {\n            step: ClientSideRowModelSteps.EVERYTHING,\n            afterColumnsChanged: true,\n            keepRenderedRows: true,\n            animate: true\n        });\n        this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, refreshEverythingAfterColsChangedFunc);\n        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, refreshEverythingFunc);\n        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_VALUE_CHANGED, this.onValueChanged.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_CHANGED, this.refreshModel.bind(this, { step: ClientSideRowModelSteps.PIVOT }));\n        this.addManagedListener(this.eventService, Events.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_SORT_CHANGED, this.onSortChanged.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, refreshEverythingFunc);\n        var refreshMapListener = this.refreshModel.bind(this, {\n            step: ClientSideRowModelSteps.MAP,\n            keepRenderedRows: true,\n            animate: true\n        });\n        this.addManagedListener(this.gridOptionsWrapper, GridOptionsWrapper.PROP_GROUP_REMOVE_SINGLE_CHILDREN, refreshMapListener);\n        this.addManagedListener(this.gridOptionsWrapper, GridOptionsWrapper.PROP_GROUP_REMOVE_LOWEST_SINGLE_CHILDREN, refreshMapListener);\n        this.rootNode = new RowNode(this.beans);\n        this.nodeManager = new ClientSideNodeManager(this.rootNode, this.gridOptionsWrapper, this.eventService, this.columnModel, this.gridApi, this.columnApi, this.selectionService, this.beans);\n    };\n    ClientSideRowModel.prototype.start = function () {\n        var rowData = this.gridOptionsWrapper.getRowData();\n        if (rowData) {\n            this.setRowData(rowData);\n        }\n    };\n    ClientSideRowModel.prototype.ensureRowHeightsValid = function (startPixel, endPixel, startLimitIndex, endLimitIndex) {\n        var atLeastOneChange;\n        var res = false;\n        // we do this multiple times as changing the row heights can also change the first and last rows,\n        // so the first pass can make lots of rows smaller, which means the second pass we end up changing\n        // more rows.\n        do {\n            atLeastOneChange = false;\n            var rowAtStartPixel = this.getRowIndexAtPixel(startPixel);\n            var rowAtEndPixel = this.getRowIndexAtPixel(endPixel);\n            // keep check to current page if doing pagination\n            var firstRow = Math.max(rowAtStartPixel, startLimitIndex);\n            var lastRow = Math.min(rowAtEndPixel, endLimitIndex);\n            for (var rowIndex = firstRow; rowIndex <= lastRow; rowIndex++) {\n                var rowNode = this.getRow(rowIndex);\n                if (rowNode.rowHeightEstimated) {\n                    var rowHeight = this.gridOptionsWrapper.getRowHeightForNode(rowNode);\n                    rowNode.setRowHeight(rowHeight.height);\n                    atLeastOneChange = true;\n                    res = true;\n                }\n            }\n            if (atLeastOneChange) {\n                this.setRowTopAndRowIndex();\n            }\n        } while (atLeastOneChange);\n        return res;\n    };\n    ClientSideRowModel.prototype.setRowTopAndRowIndex = function () {\n        var defaultRowHeight = this.gridOptionsWrapper.getDefaultRowHeight();\n        var nextRowTop = 0;\n        // mapping displayed rows is not needed for this method, however it's used in\n        // clearRowTopAndRowIndex(), and given we are looping through this.rowsToDisplay here,\n        // we create the map here for performance reasons, so we don't loop a second time\n        // in clearRowTopAndRowIndex()\n        var displayedRowsMapped = new Set();\n        // we don't estimate if doing fullHeight or autoHeight, as all rows get rendered all the time\n        // with these two layouts.\n        var allowEstimate = this.gridOptionsWrapper.getDomLayout() === Constants.DOM_LAYOUT_NORMAL;\n        for (var i = 0; i < this.rowsToDisplay.length; i++) {\n            var rowNode = this.rowsToDisplay[i];\n            if (rowNode.id != null) {\n                displayedRowsMapped.add(rowNode.id);\n            }\n            if (rowNode.rowHeight == null) {\n                var rowHeight = this.gridOptionsWrapper.getRowHeightForNode(rowNode, allowEstimate, defaultRowHeight);\n                rowNode.setRowHeight(rowHeight.height, rowHeight.estimated);\n            }\n            rowNode.setRowTop(nextRowTop);\n            rowNode.setRowIndex(i);\n            nextRowTop += rowNode.rowHeight;\n        }\n        return displayedRowsMapped;\n    };\n    ClientSideRowModel.prototype.clearRowTopAndRowIndex = function (changedPath, displayedRowsMapped) {\n        var changedPathActive = changedPath.isActive();\n        var clearIfNotDisplayed = function (rowNode) {\n            if (rowNode && rowNode.id != null && !displayedRowsMapped.has(rowNode.id)) {\n                rowNode.clearRowTopAndRowIndex();\n            }\n        };\n        var recurse = function (rowNode) {\n            clearIfNotDisplayed(rowNode);\n            clearIfNotDisplayed(rowNode.detailNode);\n            clearIfNotDisplayed(rowNode.sibling);\n            if (rowNode.hasChildren()) {\n                if (rowNode.childrenAfterGroup) {\n                    // if a changedPath is active, it means we are here because of a transaction update or\n                    // a change detection. neither of these impacts the open/closed state of groups. so if\n                    // a group is not open this time, it was not open last time. so we know all closed groups\n                    // already have their top positions cleared. so there is no need to traverse all the way\n                    // when changedPath is active and the rowNode is not expanded.\n                    var isRootNode = rowNode.level == -1; // we need to give special consideration for root node,\n                    // as expanded=undefined for root node\n                    var skipChildren = changedPathActive && !isRootNode && !rowNode.expanded;\n                    if (!skipChildren) {\n                        rowNode.childrenAfterGroup.forEach(recurse);\n                    }\n                }\n            }\n        };\n        recurse(this.rootNode);\n    };\n    // returns false if row was moved, otherwise true\n    ClientSideRowModel.prototype.ensureRowsAtPixel = function (rowNodes, pixel, increment) {\n        var _this = this;\n        if (increment === void 0) { increment = 0; }\n        var indexAtPixelNow = this.getRowIndexAtPixel(pixel);\n        var rowNodeAtPixelNow = this.getRow(indexAtPixelNow);\n        if (rowNodeAtPixelNow === rowNodes[0]) {\n            return false;\n        }\n        rowNodes.forEach(function (rowNode) {\n            _.removeFromArray(_this.rootNode.allLeafChildren, rowNode);\n        });\n        rowNodes.forEach(function (rowNode, idx) {\n            _.insertIntoArray(_this.rootNode.allLeafChildren, rowNode, Math.max(indexAtPixelNow + increment, 0) + idx);\n        });\n        this.refreshModel({\n            step: ClientSideRowModelSteps.EVERYTHING,\n            keepRenderedRows: true,\n            animate: true,\n            keepEditingRows: true\n        });\n        return true;\n    };\n    ClientSideRowModel.prototype.highlightRowAtPixel = function (rowNode, pixel) {\n        var indexAtPixelNow = pixel != null ? this.getRowIndexAtPixel(pixel) : null;\n        var rowNodeAtPixelNow = indexAtPixelNow != null ? this.getRow(indexAtPixelNow) : null;\n        if (!rowNodeAtPixelNow || !rowNode || rowNodeAtPixelNow === rowNode || pixel == null) {\n            if (this.lastHighlightedRow) {\n                this.lastHighlightedRow.setHighlighted(null);\n                this.lastHighlightedRow = null;\n            }\n            return;\n        }\n        var highlight = this.getHighlightPosition(pixel, rowNodeAtPixelNow);\n        if (this.lastHighlightedRow && this.lastHighlightedRow !== rowNodeAtPixelNow) {\n            this.lastHighlightedRow.setHighlighted(null);\n            this.lastHighlightedRow = null;\n        }\n        rowNodeAtPixelNow.setHighlighted(highlight);\n        this.lastHighlightedRow = rowNodeAtPixelNow;\n    };\n    ClientSideRowModel.prototype.getHighlightPosition = function (pixel, rowNode) {\n        if (!rowNode) {\n            var index = this.getRowIndexAtPixel(pixel);\n            rowNode = this.getRow(index || 0);\n            if (!rowNode) {\n                return RowHighlightPosition.Below;\n            }\n        }\n        var rowTop = rowNode.rowTop, rowHeight = rowNode.rowHeight;\n        return pixel - rowTop < rowHeight / 2 ? RowHighlightPosition.Above : RowHighlightPosition.Below;\n    };\n    ClientSideRowModel.prototype.getLastHighlightedRowNode = function () {\n        return this.lastHighlightedRow;\n    };\n    ClientSideRowModel.prototype.isLastRowIndexKnown = function () {\n        return true;\n    };\n    ClientSideRowModel.prototype.getRowCount = function () {\n        if (this.rowsToDisplay) {\n            return this.rowsToDisplay.length;\n        }\n        return 0;\n    };\n    ClientSideRowModel.prototype.getTopLevelRowCount = function () {\n        var showingRootNode = this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode;\n        if (showingRootNode) {\n            return 1;\n        }\n        return this.rootNode.childrenAfterFilter ? this.rootNode.childrenAfterFilter.length : 0;\n    };\n    ClientSideRowModel.prototype.getTopLevelRowDisplayedIndex = function (topLevelIndex) {\n        var showingRootNode = this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode;\n        if (showingRootNode) {\n            return topLevelIndex;\n        }\n        var rowNode = this.rootNode.childrenAfterSort[topLevelIndex];\n        if (this.gridOptionsWrapper.isGroupHideOpenParents()) {\n            // if hideOpenParents, and this row open, then this row is now displayed at this index, first child is\n            while (rowNode.expanded && rowNode.childrenAfterSort && rowNode.childrenAfterSort.length > 0) {\n                rowNode = rowNode.childrenAfterSort[0];\n            }\n        }\n        return rowNode.rowIndex;\n    };\n    ClientSideRowModel.prototype.getRowBounds = function (index) {\n        if (_.missing(this.rowsToDisplay)) {\n            return null;\n        }\n        var rowNode = this.rowsToDisplay[index];\n        if (rowNode) {\n            return {\n                rowTop: rowNode.rowTop,\n                rowHeight: rowNode.rowHeight\n            };\n        }\n        return null;\n    };\n    ClientSideRowModel.prototype.onRowGroupOpened = function () {\n        var animate = this.gridOptionsWrapper.isAnimateRows();\n        this.refreshModel({ step: ClientSideRowModelSteps.MAP, keepRenderedRows: true, animate: animate });\n    };\n    ClientSideRowModel.prototype.onFilterChanged = function (event) {\n        if (event.afterDataChange) {\n            return;\n        }\n        var animate = this.gridOptionsWrapper.isAnimateRows();\n        this.refreshModel({ step: ClientSideRowModelSteps.FILTER, keepRenderedRows: true, animate: animate });\n    };\n    ClientSideRowModel.prototype.onSortChanged = function () {\n        var animate = this.gridOptionsWrapper.isAnimateRows();\n        this.refreshModel({ step: ClientSideRowModelSteps.SORT, keepRenderedRows: true, animate: animate, keepEditingRows: true });\n    };\n    ClientSideRowModel.prototype.getType = function () {\n        return Constants.ROW_MODEL_TYPE_CLIENT_SIDE;\n    };\n    ClientSideRowModel.prototype.onValueChanged = function () {\n        if (this.columnModel.isPivotActive()) {\n            this.refreshModel({ step: ClientSideRowModelSteps.PIVOT });\n        }\n        else {\n            this.refreshModel({ step: ClientSideRowModelSteps.AGGREGATE });\n        }\n    };\n    ClientSideRowModel.prototype.createChangePath = function (rowNodeTransactions) {\n        // for updates, if the row is updated at all, then we re-calc all the values\n        // in that row. we could compare each value to each old value, however if we\n        // did this, we would be calling the valueService twice, once on the old value\n        // and once on the new value. so it's less valueGetter calls if we just assume\n        // each column is different. that way the changedPath is used so that only\n        // the impacted parent rows are recalculated, parents who's children have\n        // not changed are not impacted.\n        var noTransactions = _.missingOrEmpty(rowNodeTransactions);\n        var changedPath = new ChangedPath(false, this.rootNode);\n        if (noTransactions || this.gridOptionsWrapper.isTreeData()) {\n            changedPath.setInactive();\n        }\n        return changedPath;\n    };\n    ClientSideRowModel.prototype.isSuppressModelUpdateAfterUpdateTransaction = function (params) {\n        if (!this.gridOptionsWrapper.isSuppressModelUpdateAfterUpdateTransaction()) {\n            return false;\n        }\n        // return true if we are only doing update transactions\n        if (params.rowNodeTransactions == null) {\n            return false;\n        }\n        var transWithAddsOrDeletes = _.filter(params.rowNodeTransactions, function (tx) {\n            return (tx.add != null && tx.add.length > 0) || (tx.remove != null && tx.remove.length > 0);\n        });\n        var transactionsContainUpdatesOnly = transWithAddsOrDeletes == null || transWithAddsOrDeletes.length == 0;\n        return transactionsContainUpdatesOnly;\n    };\n    ClientSideRowModel.prototype.refreshModel = function (params) {\n        var _this = this;\n        if (this.isSuppressModelUpdateAfterUpdateTransaction(params)) {\n            return;\n        }\n        // this goes through the pipeline of stages. what's in my head is similar\n        // to the diagram on this page:\n        // http://commons.apache.org/sandbox/commons-pipeline/pipeline_basics.html\n        // however we want to keep the results of each stage, hence we manually call\n        // each step rather than have them chain each other.\n        // fallthrough in below switch is on purpose,\n        // eg if STEP_FILTER, then all steps below this\n        // step get done\n        // let start: number;\n        // console.log('======= start =======');\n        var changedPath = this.createChangePath(params.rowNodeTransactions);\n        switch (params.step) {\n            case ClientSideRowModelSteps.EVERYTHING:\n                this.doRowGrouping(params.groupState, params.rowNodeTransactions, params.rowNodeOrder, changedPath, !!params.afterColumnsChanged);\n            case ClientSideRowModelSteps.FILTER:\n                this.doFilter(changedPath);\n            case ClientSideRowModelSteps.PIVOT:\n                this.doPivot(changedPath);\n            case ClientSideRowModelSteps.AGGREGATE: // depends on agg fields\n                this.doAggregate(changedPath);\n            case ClientSideRowModelSteps.SORT:\n                this.doSort(params.rowNodeTransactions, changedPath);\n            case ClientSideRowModelSteps.MAP:\n                this.doRowsToDisplay();\n        }\n        // set all row tops to null, then set row tops on all visible rows. if we don't\n        // do this, then the algorithm below only sets row tops, old row tops from old rows\n        // will still lie around\n        var displayedNodesMapped = this.setRowTopAndRowIndex();\n        this.clearRowTopAndRowIndex(changedPath, displayedNodesMapped);\n        var event = {\n            type: Events.EVENT_MODEL_UPDATED,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            animate: params.animate,\n            keepRenderedRows: params.keepRenderedRows,\n            newData: params.newData,\n            newPage: false\n        };\n        this.eventService.dispatchEvent(event);\n        if (this.$scope) {\n            window.setTimeout(function () {\n                _this.$scope.$apply();\n            }, 0);\n        }\n    };\n    ClientSideRowModel.prototype.isEmpty = function () {\n        var rowsMissing = _.missing(this.rootNode.allLeafChildren) || this.rootNode.allLeafChildren.length === 0;\n        return _.missing(this.rootNode) || rowsMissing || !this.columnModel.isReady();\n    };\n    ClientSideRowModel.prototype.isRowsToRender = function () {\n        return _.exists(this.rowsToDisplay) && this.rowsToDisplay.length > 0;\n    };\n    ClientSideRowModel.prototype.getNodesInRangeForSelection = function (firstInRange, lastInRange) {\n        // if lastSelectedNode is missing, we start at the first row\n        var firstRowHit = !lastInRange;\n        var lastRowHit = false;\n        var lastRow;\n        var result = [];\n        var groupsSelectChildren = this.gridOptionsWrapper.isGroupSelectsChildren();\n        this.forEachNodeAfterFilterAndSort(function (rowNode) {\n            var lookingForLastRow = firstRowHit && !lastRowHit;\n            // check if we need to flip the select switch\n            if (!firstRowHit) {\n                if (rowNode === lastInRange || rowNode === firstInRange) {\n                    firstRowHit = true;\n                }\n            }\n            var skipThisGroupNode = rowNode.group && groupsSelectChildren;\n            if (!skipThisGroupNode) {\n                var inRange = firstRowHit && !lastRowHit;\n                var childOfLastRow = rowNode.isParentOfNode(lastRow);\n                if (inRange || childOfLastRow) {\n                    result.push(rowNode);\n                }\n            }\n            if (lookingForLastRow) {\n                if (rowNode === lastInRange || rowNode === firstInRange) {\n                    lastRowHit = true;\n                    if (rowNode === lastInRange) {\n                        lastRow = lastInRange;\n                    }\n                    else {\n                        lastRow = firstInRange;\n                    }\n                }\n            }\n        });\n        return result;\n    };\n    ClientSideRowModel.prototype.setDatasource = function (datasource) {\n        console.error('AG Grid: should never call setDatasource on clientSideRowController');\n    };\n    ClientSideRowModel.prototype.getTopLevelNodes = function () {\n        return this.rootNode ? this.rootNode.childrenAfterGroup : null;\n    };\n    ClientSideRowModel.prototype.getRootNode = function () {\n        return this.rootNode;\n    };\n    ClientSideRowModel.prototype.getRow = function (index) {\n        return this.rowsToDisplay[index];\n    };\n    ClientSideRowModel.prototype.isRowPresent = function (rowNode) {\n        return this.rowsToDisplay.indexOf(rowNode) >= 0;\n    };\n    ClientSideRowModel.prototype.getRowIndexAtPixel = function (pixelToMatch) {\n        if (this.isEmpty()) {\n            return -1;\n        }\n        // do binary search of tree\n        // http://oli.me.uk/2013/06/08/searching-javascript-arrays-with-a-binary-search/\n        var bottomPointer = 0;\n        var topPointer = this.rowsToDisplay.length - 1;\n        // quick check, if the pixel is out of bounds, then return last row\n        if (pixelToMatch <= 0) {\n            // if pixel is less than or equal zero, it's always the first row\n            return 0;\n        }\n        var lastNode = _.last(this.rowsToDisplay);\n        if (lastNode.rowTop <= pixelToMatch) {\n            return this.rowsToDisplay.length - 1;\n        }\n        while (true) {\n            var midPointer = Math.floor((bottomPointer + topPointer) / 2);\n            var currentRowNode = this.rowsToDisplay[midPointer];\n            if (this.isRowInPixel(currentRowNode, pixelToMatch)) {\n                return midPointer;\n            }\n            if (currentRowNode.rowTop < pixelToMatch) {\n                bottomPointer = midPointer + 1;\n            }\n            else if (currentRowNode.rowTop > pixelToMatch) {\n                topPointer = midPointer - 1;\n            }\n        }\n    };\n    ClientSideRowModel.prototype.isRowInPixel = function (rowNode, pixelToMatch) {\n        var topPixel = rowNode.rowTop;\n        var bottomPixel = rowNode.rowTop + rowNode.rowHeight;\n        var pixelInRow = topPixel <= pixelToMatch && bottomPixel > pixelToMatch;\n        return pixelInRow;\n    };\n    ClientSideRowModel.prototype.forEachLeafNode = function (callback) {\n        if (this.rootNode.allLeafChildren) {\n            this.rootNode.allLeafChildren.forEach(function (rowNode, index) { return callback(rowNode, index); });\n        }\n    };\n    ClientSideRowModel.prototype.forEachNode = function (callback) {\n        this.recursivelyWalkNodesAndCallback(this.rootNode.childrenAfterGroup, callback, RecursionType.Normal, 0);\n    };\n    ClientSideRowModel.prototype.forEachNodeAfterFilter = function (callback) {\n        this.recursivelyWalkNodesAndCallback(this.rootNode.childrenAfterFilter, callback, RecursionType.AfterFilter, 0);\n    };\n    ClientSideRowModel.prototype.forEachNodeAfterFilterAndSort = function (callback) {\n        this.recursivelyWalkNodesAndCallback(this.rootNode.childrenAfterSort, callback, RecursionType.AfterFilterAndSort, 0);\n    };\n    ClientSideRowModel.prototype.forEachPivotNode = function (callback) {\n        this.recursivelyWalkNodesAndCallback([this.rootNode], callback, RecursionType.PivotNodes, 0);\n    };\n    // iterates through each item in memory, and calls the callback function\n    // nodes - the rowNodes to traverse\n    // callback - the user provided callback\n    // recursion type - need this to know what child nodes to recurse, eg if looking at all nodes, or filtered notes etc\n    // index - works similar to the index in forEach in javascript's array function\n    ClientSideRowModel.prototype.recursivelyWalkNodesAndCallback = function (nodes, callback, recursionType, index) {\n        if (!nodes) {\n            return index;\n        }\n        for (var i = 0; i < nodes.length; i++) {\n            var node = nodes[i];\n            callback(node, index++);\n            // go to the next level if it is a group\n            if (node.hasChildren()) {\n                // depending on the recursion type, we pick a difference set of children\n                var nodeChildren = null;\n                switch (recursionType) {\n                    case RecursionType.Normal:\n                        nodeChildren = node.childrenAfterGroup;\n                        break;\n                    case RecursionType.AfterFilter:\n                        nodeChildren = node.childrenAfterFilter;\n                        break;\n                    case RecursionType.AfterFilterAndSort:\n                        nodeChildren = node.childrenAfterSort;\n                        break;\n                    case RecursionType.PivotNodes:\n                        // for pivot, we don't go below leafGroup levels\n                        nodeChildren = !node.leafGroup ? node.childrenAfterSort : null;\n                        break;\n                }\n                if (nodeChildren) {\n                    index = this.recursivelyWalkNodesAndCallback(nodeChildren, callback, recursionType, index);\n                }\n            }\n        }\n        return index;\n    };\n    // it's possible to recompute the aggregate without doing the other parts\n    // + gridApi.recomputeAggregates()\n    ClientSideRowModel.prototype.doAggregate = function (changedPath) {\n        if (this.aggregationStage) {\n            this.aggregationStage.execute({ rowNode: this.rootNode, changedPath: changedPath });\n        }\n    };\n    // + gridApi.expandAll()\n    // + gridApi.collapseAll()\n    ClientSideRowModel.prototype.expandOrCollapseAll = function (expand) {\n        var usingTreeData = this.gridOptionsWrapper.isTreeData();\n        if (this.rootNode) {\n            recursiveExpandOrCollapse(this.rootNode.childrenAfterGroup);\n        }\n        function recursiveExpandOrCollapse(rowNodes) {\n            if (!rowNodes) {\n                return;\n            }\n            rowNodes.forEach(function (rowNode) {\n                var shouldExpandOrCollapse = usingTreeData ? _.exists(rowNode.childrenAfterGroup) : rowNode.group;\n                if (shouldExpandOrCollapse) {\n                    rowNode.expanded = expand;\n                    recursiveExpandOrCollapse(rowNode.childrenAfterGroup);\n                }\n            });\n        }\n        this.refreshModel({ step: ClientSideRowModelSteps.MAP });\n        var eventSource = expand ? 'expandAll' : 'collapseAll';\n        var event = {\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            type: Events.EVENT_EXPAND_COLLAPSE_ALL,\n            source: eventSource\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    ClientSideRowModel.prototype.doSort = function (rowNodeTransactions, changedPath) {\n        this.sortStage.execute({\n            rowNode: this.rootNode,\n            rowNodeTransactions: rowNodeTransactions,\n            changedPath: changedPath\n        });\n    };\n    ClientSideRowModel.prototype.doRowGrouping = function (groupState, rowNodeTransactions, rowNodeOrder, changedPath, afterColumnsChanged) {\n        if (this.groupStage) {\n            if (rowNodeTransactions) {\n                this.groupStage.execute({\n                    rowNode: this.rootNode,\n                    rowNodeTransactions: rowNodeTransactions,\n                    rowNodeOrder: rowNodeOrder,\n                    changedPath: changedPath\n                });\n            }\n            else {\n                this.groupStage.execute({\n                    rowNode: this.rootNode,\n                    changedPath: changedPath,\n                    afterColumnsChanged: afterColumnsChanged\n                });\n                // set open/closed state on groups\n                this.restoreGroupState(groupState);\n            }\n            if (this.gridOptionsWrapper.isGroupSelectsChildren()) {\n                this.selectionService.updateGroupsFromChildrenSelections(changedPath);\n            }\n        }\n        else {\n            this.rootNode.childrenAfterGroup = this.rootNode.allLeafChildren;\n            if (this.rootNode.sibling) {\n                this.rootNode.sibling.childrenAfterGroup = this.rootNode.childrenAfterGroup;\n            }\n            this.rootNode.updateHasChildren();\n        }\n    };\n    ClientSideRowModel.prototype.restoreGroupState = function (groupState) {\n        if (!groupState) {\n            return;\n        }\n        _.traverseNodesWithKey(this.rootNode.childrenAfterGroup, function (node, key) {\n            // if the group was open last time, then open it this time. however\n            // if was not open last time, then don't touch the group, so the 'groupDefaultExpanded'\n            // setting will take effect.\n            if (typeof groupState[key] === 'boolean') {\n                node.expanded = groupState[key];\n            }\n        });\n    };\n    ClientSideRowModel.prototype.doFilter = function (changedPath) {\n        this.filterStage.execute({ rowNode: this.rootNode, changedPath: changedPath });\n    };\n    ClientSideRowModel.prototype.doPivot = function (changedPath) {\n        if (this.pivotStage) {\n            this.pivotStage.execute({ rowNode: this.rootNode, changedPath: changedPath });\n        }\n    };\n    ClientSideRowModel.prototype.getGroupState = function () {\n        if (!this.rootNode.childrenAfterGroup || !this.gridOptionsWrapper.isRememberGroupStateWhenNewData()) {\n            return null;\n        }\n        var result = {};\n        _.traverseNodesWithKey(this.rootNode.childrenAfterGroup, function (node, key) { return result[key] = node.expanded; });\n        return result;\n    };\n    ClientSideRowModel.prototype.getCopyOfNodesMap = function () {\n        return this.nodeManager.getCopyOfNodesMap();\n    };\n    ClientSideRowModel.prototype.getRowNode = function (id) {\n        // although id is typed a string, this could be called by the user, and they could have passed a number\n        var idIsGroup = typeof id == 'string' && id.indexOf(RowNode.ID_PREFIX_ROW_GROUP) == 0;\n        if (idIsGroup) {\n            // only one users complained about getRowNode not working for groups, after years of\n            // this working for normal rows. so have done quick implementation. if users complain\n            // about performance, then GroupStage should store / manage created groups in a map,\n            // which is a chunk of work.\n            var res_1 = undefined;\n            this.forEachNode(function (node) {\n                if (node.id === id) {\n                    res_1 = node;\n                }\n            });\n            return res_1;\n        }\n        else {\n            return this.nodeManager.getRowNode(id);\n        }\n    };\n    // rows: the rows to put into the model\n    ClientSideRowModel.prototype.setRowData = function (rowData) {\n        // no need to invalidate cache, as the cache is stored on the rowNode,\n        // so new rowNodes means the cache is wiped anyway.\n        // remember group state, so we can expand groups that should be expanded\n        var groupState = this.getGroupState();\n        this.nodeManager.setRowData(rowData);\n        // this event kicks off:\n        // - clears selection\n        // - updates filters\n        // - shows 'no rows' overlay if needed\n        var rowDataChangedEvent = {\n            type: Events.EVENT_ROW_DATA_CHANGED,\n            api: this.gridApi,\n            columnApi: this.columnApi\n        };\n        this.eventService.dispatchEvent(rowDataChangedEvent);\n        this.refreshModel({\n            step: ClientSideRowModelSteps.EVERYTHING,\n            groupState: groupState,\n            newData: true\n        });\n    };\n    ClientSideRowModel.prototype.batchUpdateRowData = function (rowDataTransaction, callback) {\n        var _this = this;\n        if (this.applyAsyncTransactionsTimeout == null) {\n            this.rowDataTransactionBatch = [];\n            var waitMillis = this.gridOptionsWrapper.getAsyncTransactionWaitMillis();\n            this.applyAsyncTransactionsTimeout = window.setTimeout(function () {\n                _this.executeBatchUpdateRowData();\n            }, waitMillis);\n        }\n        this.rowDataTransactionBatch.push({ rowDataTransaction: rowDataTransaction, callback: callback });\n    };\n    ClientSideRowModel.prototype.flushAsyncTransactions = function () {\n        if (this.applyAsyncTransactionsTimeout != null) {\n            clearTimeout(this.applyAsyncTransactionsTimeout);\n            this.executeBatchUpdateRowData();\n        }\n    };\n    ClientSideRowModel.prototype.executeBatchUpdateRowData = function () {\n        var _this = this;\n        this.valueCache.onDataChanged();\n        var callbackFuncsBound = [];\n        var rowNodeTrans = [];\n        // The rowGroup stage uses rowNodeOrder if order was provided. if we didn't pass 'true' to\n        // commonUpdateRowData, using addIndex would have no effect when grouping.\n        var forceRowNodeOrder = false;\n        if (this.rowDataTransactionBatch) {\n            this.rowDataTransactionBatch.forEach(function (tranItem) {\n                var rowNodeTran = _this.nodeManager.updateRowData(tranItem.rowDataTransaction, undefined);\n                rowNodeTrans.push(rowNodeTran);\n                if (tranItem.callback) {\n                    callbackFuncsBound.push(tranItem.callback.bind(null, rowNodeTran));\n                }\n                if (typeof tranItem.rowDataTransaction.addIndex === 'number') {\n                    forceRowNodeOrder = true;\n                }\n            });\n        }\n        this.commonUpdateRowData(rowNodeTrans, undefined, forceRowNodeOrder);\n        // do callbacks in next VM turn so it's async\n        if (callbackFuncsBound.length > 0) {\n            window.setTimeout(function () {\n                callbackFuncsBound.forEach(function (func) { return func(); });\n            }, 0);\n        }\n        if (rowNodeTrans.length > 0) {\n            var event_1 = {\n                api: this.gridOptionsWrapper.getApi(),\n                columnApi: this.gridOptionsWrapper.getColumnApi(),\n                type: Events.EVENT_ASYNC_TRANSACTIONS_FLUSHED,\n                results: rowNodeTrans\n            };\n            this.eventService.dispatchEvent(event_1);\n        }\n        this.rowDataTransactionBatch = null;\n        this.applyAsyncTransactionsTimeout = undefined;\n    };\n    ClientSideRowModel.prototype.updateRowData = function (rowDataTran, rowNodeOrder) {\n        this.valueCache.onDataChanged();\n        var rowNodeTran = this.nodeManager.updateRowData(rowDataTran, rowNodeOrder);\n        // if doing immutableData, addIndex is never present. however if doing standard transaction, and user\n        // provided addIndex, then this is used in updateRowData. However if doing Enterprise, then the rowGroup\n        // stage also uses the\n        var forceRowNodeOrder = typeof rowDataTran.addIndex === 'number';\n        this.commonUpdateRowData([rowNodeTran], rowNodeOrder, forceRowNodeOrder);\n        return rowNodeTran;\n    };\n    ClientSideRowModel.prototype.createRowNodeOrder = function () {\n        var suppressSortOrder = this.gridOptionsWrapper.isSuppressMaintainUnsortedOrder();\n        if (suppressSortOrder) {\n            return;\n        }\n        var orderMap = {};\n        if (this.rootNode && this.rootNode.allLeafChildren) {\n            for (var index = 0; index < this.rootNode.allLeafChildren.length; index++) {\n                var node = this.rootNode.allLeafChildren[index];\n                orderMap[node.id] = index;\n            }\n        }\n        return orderMap;\n    };\n    // common to updateRowData and batchUpdateRowData\n    ClientSideRowModel.prototype.commonUpdateRowData = function (rowNodeTrans, rowNodeOrder, forceRowNodeOrder) {\n        if (forceRowNodeOrder) {\n            rowNodeOrder = this.createRowNodeOrder();\n        }\n        this.refreshModel({\n            step: ClientSideRowModelSteps.EVERYTHING,\n            rowNodeTransactions: rowNodeTrans,\n            rowNodeOrder: rowNodeOrder,\n            keepRenderedRows: true,\n            animate: true,\n            keepEditingRows: true\n        });\n        var event = {\n            type: Events.EVENT_ROW_DATA_UPDATED,\n            api: this.gridApi,\n            columnApi: this.columnApi\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    ClientSideRowModel.prototype.doRowsToDisplay = function () {\n        this.rowsToDisplay = this.flattenStage.execute({ rowNode: this.rootNode });\n    };\n    ClientSideRowModel.prototype.onRowHeightChanged = function () {\n        this.refreshModel({ step: ClientSideRowModelSteps.MAP, keepRenderedRows: true, keepEditingRows: true });\n    };\n    ClientSideRowModel.prototype.resetRowHeights = function () {\n        var atLeastOne = false;\n        this.forEachNode(function (rowNode) {\n            rowNode.setRowHeight(rowNode.rowHeight, true);\n            // we keep the height each row is at, however we set estimated=true rather than clear the height.\n            // this means the grid will not reset the row heights back to defaults, rather it will re-calc\n            // the height for each row as the row is displayed. otherwise the scroll will jump when heights are reset.\n            var detailNode = rowNode.detailNode;\n            if (detailNode) {\n                detailNode.setRowHeight(detailNode.rowHeight, true);\n            }\n            atLeastOne = true;\n        });\n        if (atLeastOne) {\n            this.onRowHeightChanged();\n        }\n    };\n    __decorate([\n        Autowired('columnModel')\n    ], ClientSideRowModel.prototype, \"columnModel\", void 0);\n    __decorate([\n        Autowired('$scope')\n    ], ClientSideRowModel.prototype, \"$scope\", void 0);\n    __decorate([\n        Autowired('selectionService')\n    ], ClientSideRowModel.prototype, \"selectionService\", void 0);\n    __decorate([\n        Autowired('valueCache')\n    ], ClientSideRowModel.prototype, \"valueCache\", void 0);\n    __decorate([\n        Autowired('columnApi')\n    ], ClientSideRowModel.prototype, \"columnApi\", void 0);\n    __decorate([\n        Autowired('gridApi')\n    ], ClientSideRowModel.prototype, \"gridApi\", void 0);\n    __decorate([\n        Autowired('animationFrameService')\n    ], ClientSideRowModel.prototype, \"animationFrameService\", void 0);\n    __decorate([\n        Autowired('beans')\n    ], ClientSideRowModel.prototype, \"beans\", void 0);\n    __decorate([\n        Autowired('filterStage')\n    ], ClientSideRowModel.prototype, \"filterStage\", void 0);\n    __decorate([\n        Autowired('sortStage')\n    ], ClientSideRowModel.prototype, \"sortStage\", void 0);\n    __decorate([\n        Autowired('flattenStage')\n    ], ClientSideRowModel.prototype, \"flattenStage\", void 0);\n    __decorate([\n        Optional('groupStage')\n    ], ClientSideRowModel.prototype, \"groupStage\", void 0);\n    __decorate([\n        Optional('aggregationStage')\n    ], ClientSideRowModel.prototype, \"aggregationStage\", void 0);\n    __decorate([\n        Optional('pivotStage')\n    ], ClientSideRowModel.prototype, \"pivotStage\", void 0);\n    __decorate([\n        PostConstruct\n    ], ClientSideRowModel.prototype, \"init\", null);\n    ClientSideRowModel = __decorate([\n        Bean('rowModel')\n    ], ClientSideRowModel);\n    return ClientSideRowModel;\n}(BeanStub));\nexport { ClientSideRowModel };\n"]},"metadata":{},"sourceType":"module"}