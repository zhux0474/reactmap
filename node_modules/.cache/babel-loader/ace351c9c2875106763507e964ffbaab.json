{"ast":null,"code":"/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v26.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n};\n\nimport { GridOptionsWrapper } from \"../gridOptionsWrapper\";\nimport { RowCtrl } from \"./row/rowCtrl\";\nimport { Column } from \"../entities/column\";\nimport { Events } from \"../events\";\nimport { Constants } from \"../constants/constants\";\nimport { Autowired, Bean, Optional, PostConstruct } from \"../context/context\";\nimport { BeanStub } from \"../context/beanStub\";\nimport { exists, missing } from \"../utils/generic\";\nimport { getAllValuesInObject, iterateObject } from \"../utils/object\";\nimport { createArrayOfNumbers } from \"../utils/number\";\nimport { executeInAWhile } from \"../utils/function\";\nimport { CellCtrl } from \"./cell/cellCtrl\";\nimport { removeFromArray } from \"../utils/array\";\n\nvar RowRenderer =\n/** @class */\nfunction (_super) {\n  __extends(RowRenderer, _super);\n\n  function RowRenderer() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.destroyFuncsForColumnListeners = []; // map of row ids to row objects. keeps track of which elements\n    // are rendered for which rows in the dom.\n\n    _this.rowCtrlsByRowIndex = {};\n    _this.zombieRowCtrls = {};\n    _this.allRowCtrls = [];\n    _this.topRowCtrls = [];\n    _this.bottomRowCtrls = []; // we only allow one refresh at a time, otherwise the internal memory structure here\n    // will get messed up. this can happen if the user has a cellRenderer, and inside the\n    // renderer they call an API method that results in another pass of the refresh,\n    // then it will be trying to draw rows in the middle of a refresh.\n\n    _this.refreshInProgress = false;\n    return _this;\n  }\n\n  RowRenderer.prototype.postConstruct = function () {\n    var _this = this;\n\n    this.ctrlsService.whenReady(function () {\n      _this.gridBodyCtrl = _this.ctrlsService.getGridBodyCtrl();\n\n      _this.initialise();\n    });\n  };\n\n  RowRenderer.prototype.initialise = function () {\n    this.addManagedListener(this.eventService, Events.EVENT_PAGINATION_CHANGED, this.onPageLoaded.bind(this));\n    this.addManagedListener(this.eventService, Events.EVENT_PINNED_ROW_DATA_CHANGED, this.onPinnedRowDataChanged.bind(this));\n    this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this));\n    this.addManagedListener(this.eventService, Events.EVENT_BODY_SCROLL, this.redrawAfterScroll.bind(this));\n    this.addManagedListener(this.eventService, Events.EVENT_BODY_HEIGHT_CHANGED, this.redrawAfterScroll.bind(this));\n    this.addManagedListener(this.gridOptionsWrapper, GridOptionsWrapper.PROP_DOM_LAYOUT, this.onDomLayoutChanged.bind(this));\n    this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, this.onNewColumnsLoaded.bind(this));\n    this.registerCellEventListeners();\n    this.initialiseCache();\n    this.printLayout = this.gridOptionsWrapper.getDomLayout() === Constants.DOM_LAYOUT_PRINT;\n    this.embedFullWidthRows = this.printLayout || this.gridOptionsWrapper.isEmbedFullWidthRows();\n    this.redrawAfterModelUpdate();\n  };\n\n  RowRenderer.prototype.initialiseCache = function () {\n    if (this.gridOptionsWrapper.isKeepDetailRows()) {\n      var countProp = this.gridOptionsWrapper.getKeepDetailRowsCount();\n      var count = countProp != null ? countProp : 3;\n      this.cachedRowCtrls = new RowCtrlCache(count);\n    }\n  };\n\n  RowRenderer.prototype.getRowCtrls = function () {\n    return this.allRowCtrls;\n  };\n\n  RowRenderer.prototype.updateAllRowCtrls = function () {\n    var liveList = getAllValuesInObject(this.rowCtrlsByRowIndex);\n\n    if (this.beans.gridOptionsWrapper.isEnsureDomOrder()) {\n      liveList.sort(function (a, b) {\n        return a.getRowNode().rowIndex - b.getRowNode.rowIndex;\n      });\n    }\n\n    var zombieList = getAllValuesInObject(this.zombieRowCtrls);\n    var cachedList = this.cachedRowCtrls ? this.cachedRowCtrls.getEntries() : [];\n    this.allRowCtrls = __spreadArrays(liveList, zombieList, cachedList);\n  }; // in a clean design, each cell would register for each of these events. however when scrolling, all the cells\n  // registering and de-registering for events is a performance bottleneck. so we register here once and inform\n  // all active cells.\n\n\n  RowRenderer.prototype.registerCellEventListeners = function () {\n    var _this = this;\n\n    this.addManagedListener(this.eventService, Events.EVENT_CELL_FOCUSED, function (event) {\n      _this.getAllCellCtrls().forEach(function (cellCtrl) {\n        return cellCtrl.onCellFocused(event);\n      });\n\n      _this.getAllRowCtrls().forEach(function (rowCtrl) {\n        if (rowCtrl.isFullWidth()) {\n          rowCtrl.onFullWidthRowFocused(event);\n        }\n      });\n    });\n    this.addManagedListener(this.eventService, Events.EVENT_FLASH_CELLS, function (event) {\n      _this.getAllCellCtrls().forEach(function (cellCtrl) {\n        return cellCtrl.onFlashCells(event);\n      });\n    });\n    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_HOVER_CHANGED, function () {\n      _this.getAllCellCtrls().forEach(function (cellCtrl) {\n        return cellCtrl.onColumnHover();\n      });\n    }); // only for printLayout - because we are rendering all the cells in the same row, regardless of pinned state,\n    // then changing the width of the containers will impact left position. eg the center cols all have their\n    // left position adjusted by the width of the left pinned column, so if the pinned left column width changes,\n    // all the center cols need to be shifted to accommodate this. when in normal layout, the pinned cols are\n    // in different containers so doesn't impact.\n\n    this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, function () {\n      if (_this.printLayout) {\n        _this.getAllCellCtrls().forEach(function (cellCtrl) {\n          return cellCtrl.onLeftChanged();\n        });\n      }\n    });\n    var rangeSelectionEnabled = this.gridOptionsWrapper.isEnableRangeSelection();\n\n    if (rangeSelectionEnabled) {\n      this.addManagedListener(this.eventService, Events.EVENT_RANGE_SELECTION_CHANGED, function () {\n        _this.getAllCellCtrls().forEach(function (cellCtrl) {\n          return cellCtrl.onRangeSelectionChanged();\n        });\n      });\n      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_MOVED, function () {\n        _this.getAllCellCtrls().forEach(function (cellCtrl) {\n          return cellCtrl.updateRangeBordersIfRangeCount();\n        });\n      });\n      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PINNED, function () {\n        _this.getAllCellCtrls().forEach(function (cellCtrl) {\n          return cellCtrl.updateRangeBordersIfRangeCount();\n        });\n      });\n      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_VISIBLE, function () {\n        _this.getAllCellCtrls().forEach(function (cellCtrl) {\n          return cellCtrl.updateRangeBordersIfRangeCount();\n        });\n      });\n    } // add listeners to the grid columns\n\n\n    this.refreshListenersToColumnsForCellComps(); // if the grid columns change, then refresh the listeners again\n\n    this.addManagedListener(this.eventService, Events.EVENT_GRID_COLUMNS_CHANGED, this.refreshListenersToColumnsForCellComps.bind(this));\n    this.addDestroyFunc(this.removeGridColumnListeners.bind(this));\n  }; // executes all functions in destroyFuncsForColumnListeners and then clears the list\n\n\n  RowRenderer.prototype.removeGridColumnListeners = function () {\n    this.destroyFuncsForColumnListeners.forEach(function (func) {\n      return func();\n    });\n    this.destroyFuncsForColumnListeners.length = 0;\n  }; // this function adds listeners onto all the grid columns, which are the column that we could have cellComps for.\n  // when the grid columns change, we add listeners again. in an ideal design, each CellComp would just register to\n  // the column it belongs to on creation, however this was a bottleneck with the number of cells, so do it here\n  // once instead.\n\n\n  RowRenderer.prototype.refreshListenersToColumnsForCellComps = function () {\n    var _this = this;\n\n    this.removeGridColumnListeners();\n    var cols = this.columnModel.getAllGridColumns();\n\n    if (!cols) {\n      return;\n    }\n\n    cols.forEach(function (col) {\n      var forEachCellWithThisCol = function (callback) {\n        _this.getAllCellCtrls().forEach(function (cellCtrl) {\n          if (cellCtrl.getColumn() === col) {\n            callback(cellCtrl);\n          }\n        });\n      };\n\n      var leftChangedListener = function () {\n        forEachCellWithThisCol(function (cellCtrl) {\n          return cellCtrl.onLeftChanged();\n        });\n      };\n\n      var widthChangedListener = function () {\n        forEachCellWithThisCol(function (cellCtrl) {\n          return cellCtrl.onWidthChanged();\n        });\n      };\n\n      var firstRightPinnedChangedListener = function () {\n        forEachCellWithThisCol(function (cellCtrl) {\n          return cellCtrl.onFirstRightPinnedChanged();\n        });\n      };\n\n      var lastLeftPinnedChangedListener = function () {\n        forEachCellWithThisCol(function (cellCtrl) {\n          return cellCtrl.onLastLeftPinnedChanged();\n        });\n      };\n\n      col.addEventListener(Column.EVENT_LEFT_CHANGED, leftChangedListener);\n      col.addEventListener(Column.EVENT_WIDTH_CHANGED, widthChangedListener);\n      col.addEventListener(Column.EVENT_FIRST_RIGHT_PINNED_CHANGED, firstRightPinnedChangedListener);\n      col.addEventListener(Column.EVENT_LAST_LEFT_PINNED_CHANGED, lastLeftPinnedChangedListener);\n\n      _this.destroyFuncsForColumnListeners.push(function () {\n        col.removeEventListener(Column.EVENT_LEFT_CHANGED, leftChangedListener);\n        col.removeEventListener(Column.EVENT_WIDTH_CHANGED, widthChangedListener);\n        col.removeEventListener(Column.EVENT_FIRST_RIGHT_PINNED_CHANGED, firstRightPinnedChangedListener);\n        col.removeEventListener(Column.EVENT_LAST_LEFT_PINNED_CHANGED, lastLeftPinnedChangedListener);\n      });\n    });\n  };\n\n  RowRenderer.prototype.onDomLayoutChanged = function () {\n    var printLayout = this.gridOptionsWrapper.getDomLayout() === Constants.DOM_LAYOUT_PRINT;\n    var embedFullWidthRows = printLayout || this.gridOptionsWrapper.isEmbedFullWidthRows(); // if moving towards or away from print layout, means we need to destroy all rows, as rows are not laid\n    // out using absolute positioning when doing print layout\n\n    var destroyRows = embedFullWidthRows !== this.embedFullWidthRows || this.printLayout !== printLayout;\n    this.printLayout = printLayout;\n    this.embedFullWidthRows = embedFullWidthRows;\n\n    if (destroyRows) {\n      this.redrawAfterModelUpdate();\n    }\n  }; // for row models that have datasources, when we update the datasource, we need to force the rowRenderer\n  // to redraw all rows. otherwise the old rows from the old datasource will stay displayed.\n\n\n  RowRenderer.prototype.datasourceChanged = function () {\n    this.firstRenderedRow = 0;\n    this.lastRenderedRow = -1;\n    var rowIndexesToRemove = Object.keys(this.rowCtrlsByRowIndex);\n    this.removeRowCtrls(rowIndexesToRemove);\n  };\n\n  RowRenderer.prototype.onPageLoaded = function (event) {\n    var params = {\n      recycleRows: event.keepRenderedRows,\n      animate: event.animate,\n      newData: event.newData,\n      newPage: event.newPage,\n      // because this is a model updated event (not pinned rows), we\n      // can skip updating the pinned rows. this is needed so that if user\n      // is doing transaction updates, the pinned rows are not getting constantly\n      // trashed - or editing cells in pinned rows are not refreshed and put into read mode\n      onlyBody: true\n    };\n    this.redrawAfterModelUpdate(params);\n  };\n\n  RowRenderer.prototype.getAllCellsForColumn = function (column) {\n    var res = [];\n    this.getAllRowCtrls().forEach(function (rowCtrl) {\n      var eCell = rowCtrl.getCellElement(column);\n\n      if (eCell) {\n        res.push(eCell);\n      }\n    });\n    return res;\n  };\n\n  RowRenderer.prototype.refreshFloatingRowComps = function () {\n    this.refreshFloatingRows(this.topRowCtrls, this.pinnedRowModel.getPinnedTopRowData());\n    this.refreshFloatingRows(this.bottomRowCtrls, this.pinnedRowModel.getPinnedBottomRowData());\n  };\n\n  RowRenderer.prototype.getTopRowCtrls = function () {\n    return this.topRowCtrls;\n  };\n\n  RowRenderer.prototype.getBottomRowCtrls = function () {\n    return this.bottomRowCtrls;\n  };\n\n  RowRenderer.prototype.refreshFloatingRows = function (rowComps, rowNodes) {\n    var _this = this;\n\n    rowComps.forEach(function (row) {\n      row.destroyFirstPass();\n      row.destroySecondPass();\n    });\n    rowComps.length = 0;\n\n    if (!rowNodes) {\n      return;\n    }\n\n    rowNodes.forEach(function (rowNode) {\n      var rowCon = new RowCtrl(_this.$scope, rowNode, _this.beans, false, false, _this.printLayout);\n      rowComps.push(rowCon);\n    });\n  };\n\n  RowRenderer.prototype.onPinnedRowDataChanged = function () {\n    // recycling rows in order to ensure cell editing is not cancelled\n    var params = {\n      recycleRows: true\n    };\n    this.redrawAfterModelUpdate(params);\n  }; // if the row nodes are not rendered, no index is returned\n\n\n  RowRenderer.prototype.getRenderedIndexesForRowNodes = function (rowNodes) {\n    var result = [];\n\n    if (missing(rowNodes)) {\n      return result;\n    }\n\n    iterateObject(this.rowCtrlsByRowIndex, function (index, renderedRow) {\n      var rowNode = renderedRow.getRowNode();\n\n      if (rowNodes.indexOf(rowNode) >= 0) {\n        result.push(index);\n      }\n    });\n    return result;\n  };\n\n  RowRenderer.prototype.redrawRows = function (rowNodes) {\n    // if no row nodes provided, then refresh everything\n    var partialRefresh = rowNodes != null && rowNodes.length > 0;\n\n    if (partialRefresh) {\n      var indexesToRemove = this.getRenderedIndexesForRowNodes(rowNodes); // remove the rows\n\n      this.removeRowCtrls(indexesToRemove);\n    } // add draw them again\n\n\n    this.redrawAfterModelUpdate({\n      recycleRows: partialRefresh\n    });\n  };\n\n  RowRenderer.prototype.getCellToRestoreFocusToAfterRefresh = function (params) {\n    var focusedCell = params.suppressKeepFocus ? null : this.focusService.getFocusCellToUseAfterRefresh();\n\n    if (focusedCell == null) {\n      return null;\n    } // if the dom is not actually focused on a cell, then we don't try to refocus. the problem this\n    // solves is with editing - if the user is editing, eg focus is on a text field, and not on the\n    // cell itself, then the cell can be registered as having focus, however it's the text field that\n    // has the focus and not the cell div. therefore, when the refresh is finished, the grid will focus\n    // the cell, and not the textfield. that means if the user is in a text field, and the grid refreshes,\n    // the focus is lost from the text field. we do not want this.\n\n\n    var activeElement = document.activeElement;\n    var cellDomData = this.gridOptionsWrapper.getDomData(activeElement, CellCtrl.DOM_DATA_KEY_CELL_CTRL);\n    var rowDomData = this.gridOptionsWrapper.getDomData(activeElement, RowCtrl.DOM_DATA_KEY_ROW_CTRL);\n    var gridElementFocused = cellDomData || rowDomData;\n    return gridElementFocused ? focusedCell : null;\n  }; // gets called from:\n  // +) initialisation (in registerGridComp) params = null\n  // +) onDomLayoutChanged, params = null\n  // +) onPageLoaded, recycleRows, animate, newData, newPage from event, onlyBody=true\n  // +) onPinnedRowDataChanged, recycleRows = true\n  // +) redrawRows (from Grid API), recycleRows = true/false\n\n\n  RowRenderer.prototype.redrawAfterModelUpdate = function (params) {\n    if (params === void 0) {\n      params = {};\n    }\n\n    this.getLockOnRefresh();\n    var focusedCell = this.getCellToRestoreFocusToAfterRefresh(params);\n    this.updateContainerHeights();\n    this.scrollToTopIfNewData(params); // never recycle rows when print layout, we draw each row again from scratch. this is because print layout\n    // uses normal dom layout to put cells into dom - it doesn't allow reordering rows.\n\n    var recycleRows = !this.printLayout && !!params.recycleRows;\n    var animate = params.animate && this.gridOptionsWrapper.isAnimateRows(); // after modelUpdate, row indexes can change, so we clear out the rowsByIndex map,\n    // however we can reuse the rows, so we keep them but index by rowNode.id\n\n    var rowsToRecycle = recycleRows ? this.recycleRows() : null;\n\n    if (!recycleRows) {\n      this.removeAllRowComps();\n    }\n\n    var isFocusedCellGettingRecycled = function () {\n      if (focusedCell == null || rowsToRecycle == null) {\n        return false;\n      }\n\n      var res = false;\n      iterateObject(rowsToRecycle, function (key, rowComp) {\n        var rowNode = rowComp.getRowNode();\n        var rowIndexEqual = rowNode.rowIndex == focusedCell.rowIndex;\n        var pinnedEqual = rowNode.rowPinned == focusedCell.rowPinned;\n\n        if (rowIndexEqual && pinnedEqual) {\n          res = true;\n        }\n      });\n      return res;\n    };\n\n    var focusedCellRecycled = isFocusedCellGettingRecycled();\n    this.redraw(rowsToRecycle, animate);\n\n    if (!params.onlyBody) {\n      this.refreshFloatingRowComps();\n    }\n\n    this.dispatchDisplayedRowsChanged(); // if we focus a cell that's already focused, then we get an unnecessary 'cellFocused' event fired.\n    // this was happening when user clicked 'expand' on a rowGroup, then cellFocused was getting fired twice.\n\n    if (!focusedCellRecycled) {\n      this.restoreFocusedCell(focusedCell);\n    }\n\n    this.releaseLockOnRefresh();\n  };\n\n  RowRenderer.prototype.scrollToTopIfNewData = function (params) {\n    var scrollToTop = params.newData || params.newPage;\n    var suppressScrollToTop = this.gridOptionsWrapper.isSuppressScrollOnNewData();\n\n    if (scrollToTop && !suppressScrollToTop) {\n      this.gridBodyCtrl.getScrollFeature().scrollToTop();\n    }\n  };\n\n  RowRenderer.prototype.updateContainerHeights = function () {\n    // when doing print layout, we don't explicitly set height on the containers\n    if (this.printLayout) {\n      this.rowContainerHeightService.setModelHeight(null);\n      return;\n    }\n\n    var containerHeight = this.paginationProxy.getCurrentPageHeight(); // we need at least 1 pixel for the horizontal scroll to work. so if there are now rows,\n    // we still want the scroll to be present, otherwise there would be no way to scroll the header\n    // which might be needed us user wants to access columns\n    // on the RHS - and if that was where the filter was that cause no rows to be presented, there\n    // is no way to remove the filter.\n\n    if (containerHeight === 0) {\n      containerHeight = 1;\n    }\n\n    this.rowContainerHeightService.setModelHeight(containerHeight);\n  };\n\n  RowRenderer.prototype.getLockOnRefresh = function () {\n    if (this.refreshInProgress) {\n      throw new Error(\"AG Grid: cannot get grid to draw rows when it is in the middle of drawing rows. \" + \"Your code probably called a grid API method while the grid was in the render stage. To overcome \" + \"this, put the API call into a timeout, e.g. instead of api.refreshView(), \" + \"call setTimeout(function() { api.refreshView(); }, 0). To see what part of your code \" + \"that caused the refresh check this stacktrace.\");\n    }\n\n    this.refreshInProgress = true;\n  };\n\n  RowRenderer.prototype.releaseLockOnRefresh = function () {\n    this.refreshInProgress = false;\n  }; // sets the focus to the provided cell, if the cell is provided. this way, the user can call refresh without\n  // worry about the focus been lost. this is important when the user is using keyboard navigation to do edits\n  // and the cellEditor is calling 'refresh' to get other cells to update (as other cells might depend on the\n  // edited cell).\n\n\n  RowRenderer.prototype.restoreFocusedCell = function (cellPosition) {\n    if (cellPosition) {\n      this.focusService.setFocusedCell(cellPosition.rowIndex, cellPosition.column, cellPosition.rowPinned, true);\n    }\n  };\n\n  RowRenderer.prototype.stopEditing = function (cancel) {\n    if (cancel === void 0) {\n      cancel = false;\n    }\n\n    this.getAllRowCtrls().forEach(function (rowCtrl) {\n      rowCtrl.stopEditing(cancel);\n    });\n  };\n\n  RowRenderer.prototype.onNewColumnsLoaded = function () {\n    // we don't want each cellComp to register for events, as would increase rendering time.\n    // so for newColumnsLoaded, we register once here (in rowRenderer) and then inform\n    // each cell if / when event was fired.\n    this.getAllCellCtrls().forEach(function (cellCtrl) {\n      return cellCtrl.onNewColumnsLoaded();\n    });\n  };\n\n  RowRenderer.prototype.getAllCellCtrls = function () {\n    var res = [];\n    this.getAllRowCtrls().forEach(function (rowCtrl) {\n      return res = res.concat(rowCtrl.getAllCellCtrls());\n    });\n    return res;\n  };\n\n  RowRenderer.prototype.getAllRowCtrls = function () {\n    var _this = this;\n\n    var res = __spreadArrays(this.topRowCtrls, this.bottomRowCtrls);\n\n    Object.keys(this.rowCtrlsByRowIndex).forEach(function (key) {\n      return res.push(_this.rowCtrlsByRowIndex[key]);\n    });\n    return res;\n  };\n\n  RowRenderer.prototype.addRenderedRowListener = function (eventName, rowIndex, callback) {\n    var rowComp = this.rowCtrlsByRowIndex[rowIndex];\n\n    if (rowComp) {\n      rowComp.addEventListener(eventName, callback);\n    }\n  };\n\n  RowRenderer.prototype.flashCells = function (params) {\n    if (params === void 0) {\n      params = {};\n    }\n\n    var flashDelay = params.flashDelay,\n        fadeDelay = params.fadeDelay;\n    this.getCellCtrls(params.rowNodes, params.columns).forEach(function (cellCtrl) {\n      return cellCtrl.flashCell({\n        flashDelay: flashDelay,\n        fadeDelay: fadeDelay\n      });\n    });\n  };\n\n  RowRenderer.prototype.refreshCells = function (params) {\n    if (params === void 0) {\n      params = {};\n    }\n\n    var refreshCellParams = {\n      forceRefresh: params.force,\n      newData: false,\n      suppressFlash: params.suppressFlash\n    };\n    this.getCellCtrls(params.rowNodes, params.columns).forEach(function (cellCtrl) {\n      if (cellCtrl.refreshShouldDestroy()) {\n        var rowCtrl = cellCtrl.getRowCtrl();\n\n        if (rowCtrl) {\n          rowCtrl.refreshCell(cellCtrl);\n        }\n      } else {\n        cellCtrl.refreshCell(refreshCellParams);\n      }\n    });\n  };\n\n  RowRenderer.prototype.getCellRendererInstances = function (params) {\n    var res = this.getCellCtrls(params.rowNodes, params.columns).map(function (cellCtrl) {\n      return cellCtrl.getCellRenderer();\n    }).filter(function (renderer) {\n      return renderer != null;\n    });\n    return res;\n  };\n\n  RowRenderer.prototype.getCellEditorInstances = function (params) {\n    var res = [];\n    this.getCellCtrls(params.rowNodes, params.columns).forEach(function (cellCtrl) {\n      var cellEditor = cellCtrl.getCellEditor();\n\n      if (cellEditor) {\n        res.push(cellEditor);\n      }\n    });\n    return res;\n  };\n\n  RowRenderer.prototype.getEditingCells = function () {\n    var res = [];\n    this.getAllCellCtrls().forEach(function (cellCtrl) {\n      if (cellCtrl.isEditing()) {\n        var cellPosition = cellCtrl.getCellPosition();\n        res.push(cellPosition);\n      }\n    });\n    return res;\n  }; // returns CellCtrl's that match the provided rowNodes and columns. eg if one row node\n  // and two columns provided, that identifies 4 cells, so 4 CellCtrl's returned.\n\n\n  RowRenderer.prototype.getCellCtrls = function (rowNodes, columns) {\n    var _this = this;\n\n    var rowIdsMap;\n    var res = [];\n\n    if (exists(rowNodes)) {\n      rowIdsMap = {\n        top: {},\n        bottom: {},\n        normal: {}\n      };\n      rowNodes.forEach(function (rowNode) {\n        var id = rowNode.id;\n\n        if (rowNode.rowPinned === Constants.PINNED_TOP) {\n          rowIdsMap.top[id] = true;\n        } else if (rowNode.rowPinned === Constants.PINNED_BOTTOM) {\n          rowIdsMap.bottom[id] = true;\n        } else {\n          rowIdsMap.normal[id] = true;\n        }\n      });\n    }\n\n    var colIdsMap;\n\n    if (exists(columns)) {\n      colIdsMap = {};\n      columns.forEach(function (colKey) {\n        var column = _this.columnModel.getGridColumn(colKey);\n\n        if (exists(column)) {\n          colIdsMap[column.getId()] = true;\n        }\n      });\n    }\n\n    var processRow = function (rowComp) {\n      var rowNode = rowComp.getRowNode();\n      var id = rowNode.id;\n      var floating = rowNode.rowPinned; // skip this row if it is missing from the provided list\n\n      if (exists(rowIdsMap)) {\n        if (floating === Constants.PINNED_BOTTOM) {\n          if (!rowIdsMap.bottom[id]) {\n            return;\n          }\n        } else if (floating === Constants.PINNED_TOP) {\n          if (!rowIdsMap.top[id]) {\n            return;\n          }\n        } else {\n          if (!rowIdsMap.normal[id]) {\n            return;\n          }\n        }\n      }\n\n      rowComp.getAllCellCtrls().forEach(function (cellCtrl) {\n        var colId = cellCtrl.getColumn().getId();\n        var excludeColFromRefresh = colIdsMap && !colIdsMap[colId];\n\n        if (excludeColFromRefresh) {\n          return;\n        }\n\n        res.push(cellCtrl);\n      });\n    };\n\n    iterateObject(this.rowCtrlsByRowIndex, function (index, rowComp) {\n      processRow(rowComp);\n    });\n\n    if (this.topRowCtrls) {\n      this.topRowCtrls.forEach(processRow);\n    }\n\n    if (this.bottomRowCtrls) {\n      this.bottomRowCtrls.forEach(processRow);\n    }\n\n    return res;\n  };\n\n  RowRenderer.prototype.destroy = function () {\n    this.removeAllRowComps();\n\n    _super.prototype.destroy.call(this);\n  };\n\n  RowRenderer.prototype.removeAllRowComps = function () {\n    var rowIndexesToRemove = Object.keys(this.rowCtrlsByRowIndex);\n    this.removeRowCtrls(rowIndexesToRemove);\n  };\n\n  RowRenderer.prototype.recycleRows = function () {\n    // remove all stub nodes, they can't be reused, as no rowNode id\n    var stubNodeIndexes = [];\n    iterateObject(this.rowCtrlsByRowIndex, function (index, rowComp) {\n      var stubNode = rowComp.getRowNode().id == null;\n\n      if (stubNode) {\n        stubNodeIndexes.push(index);\n      }\n    });\n    this.removeRowCtrls(stubNodeIndexes); // then clear out rowCompsByIndex, but before that take a copy, but index by id, not rowIndex\n\n    var nodesByIdMap = {};\n    iterateObject(this.rowCtrlsByRowIndex, function (index, rowComp) {\n      var rowNode = rowComp.getRowNode();\n      nodesByIdMap[rowNode.id] = rowComp;\n    });\n    this.rowCtrlsByRowIndex = {};\n    return nodesByIdMap;\n  }; // takes array of row indexes\n\n\n  RowRenderer.prototype.removeRowCtrls = function (rowsToRemove) {\n    var _this = this; // if no fromIndex then set to -1, which will refresh everything\n    // let realFromIndex = -1;\n\n\n    rowsToRemove.forEach(function (indexToRemove) {\n      var rowCtrl = _this.rowCtrlsByRowIndex[indexToRemove];\n\n      if (rowCtrl) {\n        rowCtrl.destroyFirstPass();\n        rowCtrl.destroySecondPass();\n      }\n\n      delete _this.rowCtrlsByRowIndex[indexToRemove];\n    });\n  }; // gets called when rows don't change, but viewport does, so after:\n  // 1) height of grid body changes, ie number of displayed rows has changed\n  // 2) grid scrolled to new position\n  // 3) ensure index visible (which is a scroll)\n\n\n  RowRenderer.prototype.redrawAfterScroll = function () {\n    this.getLockOnRefresh();\n    this.redraw(null, false, true);\n    this.releaseLockOnRefresh();\n    this.dispatchDisplayedRowsChanged();\n  };\n\n  RowRenderer.prototype.removeRowCompsNotToDraw = function (indexesToDraw) {\n    // for speedy lookup, dump into map\n    var indexesToDrawMap = {};\n    indexesToDraw.forEach(function (index) {\n      return indexesToDrawMap[index] = true;\n    });\n    var existingIndexes = Object.keys(this.rowCtrlsByRowIndex);\n    var indexesNotToDraw = existingIndexes.filter(function (index) {\n      return !indexesToDrawMap[index];\n    });\n    this.removeRowCtrls(indexesNotToDraw);\n  };\n\n  RowRenderer.prototype.calculateIndexesToDraw = function (rowsToRecycle) {\n    var _this = this; // all in all indexes in the viewport\n\n\n    var indexesToDraw = createArrayOfNumbers(this.firstRenderedRow, this.lastRenderedRow);\n\n    var checkRowToDraw = function (indexStr, rowComp) {\n      var index = rowComp.getRowNode().rowIndex;\n\n      if (index == null) {\n        return;\n      }\n\n      if (index < _this.firstRenderedRow || index > _this.lastRenderedRow) {\n        if (_this.doNotUnVirtualiseRow(rowComp)) {\n          indexesToDraw.push(index);\n        }\n      }\n    }; // if we are redrawing due to scrolling change, then old rows are in this.rowCompsByIndex\n\n\n    iterateObject(this.rowCtrlsByRowIndex, checkRowToDraw); // if we are redrawing due to model update, then old rows are in rowsToRecycle\n\n    iterateObject(rowsToRecycle, checkRowToDraw);\n    indexesToDraw.sort(function (a, b) {\n      return a - b;\n    });\n    return indexesToDraw;\n  };\n\n  RowRenderer.prototype.redraw = function (rowsToRecycle, animate, afterScroll) {\n    var _this = this;\n\n    if (animate === void 0) {\n      animate = false;\n    }\n\n    if (afterScroll === void 0) {\n      afterScroll = false;\n    }\n\n    this.rowContainerHeightService.updateOffset();\n    this.workOutFirstAndLastRowsToRender(); // the row can already exist and be in the following:\n    // rowsToRecycle -> if model change, then the index may be different, however row may\n    //                         exist here from previous time (mapped by id).\n    // this.rowCompsByIndex -> if just a scroll, then this will contain what is currently in the viewport\n    // this is all the indexes we want, including those that already exist, so this method\n    // will end up going through each index and drawing only if the row doesn't already exist\n\n    var indexesToDraw = this.calculateIndexesToDraw(rowsToRecycle);\n    this.removeRowCompsNotToDraw(indexesToDraw); // never animate when doing print layout - as we want to get things ready to print as quickly as possible,\n    // otherwise we risk the printer printing a row that's half faded (half way through fading in)\n\n    if (this.printLayout) {\n      animate = false;\n    } // add in new rows\n\n\n    var rowCtrls = [];\n    indexesToDraw.forEach(function (rowIndex) {\n      var rowCtrl = _this.createOrUpdateRowCtrl(rowIndex, rowsToRecycle, animate, afterScroll);\n\n      if (exists(rowCtrl)) {\n        rowCtrls.push(rowCtrl);\n      }\n    });\n\n    if (rowsToRecycle) {\n      var useAnimationFrame = afterScroll && !this.gridOptionsWrapper.isSuppressAnimationFrame() && !this.printLayout;\n\n      if (useAnimationFrame) {\n        this.beans.animationFrameService.addDestroyTask(function () {\n          _this.destroyRowCtrls(rowsToRecycle, animate);\n\n          _this.updateAllRowCtrls();\n\n          _this.dispatchDisplayedRowsChanged();\n        });\n      } else {\n        this.destroyRowCtrls(rowsToRecycle, animate);\n      }\n    }\n\n    this.updateAllRowCtrls();\n    this.checkAngularCompile();\n    this.gridBodyCtrl.updateRowCount();\n  };\n\n  RowRenderer.prototype.dispatchDisplayedRowsChanged = function () {\n    var event = {\n      type: Events.EVENT_DISPLAYED_ROWS_CHANGED\n    };\n    this.eventService.dispatchEvent(event);\n  };\n\n  RowRenderer.prototype.onDisplayedColumnsChanged = function () {\n    var pinningLeft = this.columnModel.isPinningLeft();\n    var pinningRight = this.columnModel.isPinningRight();\n    var atLeastOneChanged = this.pinningLeft !== pinningLeft || pinningRight !== this.pinningRight;\n\n    if (atLeastOneChanged) {\n      this.pinningLeft = pinningLeft;\n      this.pinningRight = pinningRight;\n\n      if (this.embedFullWidthRows) {\n        this.redrawFullWidthEmbeddedRows();\n      }\n    }\n  }; // when embedding, what gets showed in each section depends on what is pinned. eg if embedding group expand / collapse,\n  // then it should go into the pinned left area if pinning left, or the center area if not pinning.\n\n\n  RowRenderer.prototype.redrawFullWidthEmbeddedRows = function () {\n    // if either of the pinned panels has shown / hidden, then need to redraw the fullWidth bits when\n    // embedded, as what appears in each section depends on whether we are pinned or not\n    var rowsToRemove = [];\n    iterateObject(this.rowCtrlsByRowIndex, function (id, rowComp) {\n      if (rowComp.isFullWidth()) {\n        var rowIndex = rowComp.getRowNode().rowIndex;\n        rowsToRemove.push(rowIndex.toString());\n      }\n    });\n    this.refreshFloatingRowComps();\n    this.removeRowCtrls(rowsToRemove);\n    this.redrawAfterScroll();\n  };\n\n  RowRenderer.prototype.refreshFullWidthRows = function (rowNodesToRefresh) {\n    var rowsToRemove = [];\n    var selectivelyRefreshing = !!rowNodesToRefresh;\n    var idsToRefresh = selectivelyRefreshing ? {} : undefined;\n\n    if (selectivelyRefreshing && idsToRefresh) {\n      rowNodesToRefresh.forEach(function (r) {\n        return idsToRefresh[r.id] = true;\n      });\n    }\n\n    iterateObject(this.rowCtrlsByRowIndex, function (id, rowCtrl) {\n      if (!rowCtrl.isFullWidth()) {\n        return;\n      }\n\n      var rowNode = rowCtrl.getRowNode();\n\n      if (selectivelyRefreshing && idsToRefresh) {\n        // we refresh if a) this node is present or b) this parents nodes is present. checking parent\n        // node is important for master/detail, as we want detail to refresh on changes to parent node.\n        // it's also possible, if user is provider their own fullWidth, that details panels contain\n        // some info on the parent, eg if in tree data and child row shows some data from parent row also.\n        var parentId = rowNode.level > 0 && rowNode.parent ? rowNode.parent.id : undefined;\n        var skipThisNode = !idsToRefresh[rowNode.id] && !idsToRefresh[parentId];\n\n        if (skipThisNode) {\n          return;\n        }\n      }\n\n      var fullWidthRowsRefreshed = rowCtrl.refreshFullWidth();\n\n      if (!fullWidthRowsRefreshed) {\n        var rowIndex = rowCtrl.getRowNode().rowIndex;\n        rowsToRemove.push(rowIndex.toString());\n      }\n    });\n    this.removeRowCtrls(rowsToRemove);\n    this.redrawAfterScroll();\n  };\n\n  RowRenderer.prototype.createOrUpdateRowCtrl = function (rowIndex, rowsToRecycle, animate, afterScroll) {\n    var rowNode;\n    var rowCon = this.rowCtrlsByRowIndex[rowIndex]; // if no row comp, see if we can get it from the previous rowComps\n\n    if (!rowCon) {\n      rowNode = this.paginationProxy.getRow(rowIndex);\n\n      if (exists(rowNode) && exists(rowsToRecycle) && rowsToRecycle[rowNode.id] && rowNode.alreadyRendered) {\n        rowCon = rowsToRecycle[rowNode.id];\n        rowsToRecycle[rowNode.id] = null;\n      }\n    }\n\n    var creatingNewRowCon = !rowCon;\n\n    if (creatingNewRowCon) {\n      // create a new one\n      if (!rowNode) {\n        rowNode = this.paginationProxy.getRow(rowIndex);\n      }\n\n      if (exists(rowNode)) {\n        rowCon = this.createRowCon(rowNode, animate, afterScroll);\n      } else {\n        // this should never happen - if somehow we are trying to create\n        // a row for a rowNode that does not exist.\n        return;\n      }\n    }\n\n    if (rowNode) {\n      // set node as 'alreadyRendered' to ensure we only recycle rowComps that have been rendered, this ensures\n      // we don't reuse rowComps that have been removed and then re-added in the same batch transaction.\n      rowNode.alreadyRendered = true;\n    }\n\n    this.rowCtrlsByRowIndex[rowIndex] = rowCon;\n    return rowCon;\n  };\n\n  RowRenderer.prototype.destroyRowCtrls = function (rowCtrlsMap, animate) {\n    var _this = this;\n\n    var executeInAWhileFuncs = [];\n    iterateObject(rowCtrlsMap, function (nodeId, rowCtrl) {\n      // if row was used, then it's null\n      if (!rowCtrl) {\n        return;\n      }\n\n      if (_this.cachedRowCtrls && rowCtrl.isCacheable()) {\n        _this.cachedRowCtrls.addRow(rowCtrl);\n\n        return;\n      }\n\n      rowCtrl.destroyFirstPass();\n\n      if (animate) {\n        _this.zombieRowCtrls[rowCtrl.getInstanceId()] = rowCtrl;\n        executeInAWhileFuncs.push(function () {\n          rowCtrl.destroySecondPass();\n          delete _this.zombieRowCtrls[rowCtrl.getInstanceId()];\n        });\n      } else {\n        rowCtrl.destroySecondPass();\n      }\n    });\n\n    if (animate) {\n      // this ensures we fire displayedRowsChanged AFTER all the 'executeInAWhileFuncs' get\n      // executed, as we added it to the end of the list.\n      executeInAWhileFuncs.push(function () {\n        _this.updateAllRowCtrls();\n\n        _this.dispatchDisplayedRowsChanged();\n      });\n      executeInAWhile(executeInAWhileFuncs);\n    }\n  };\n\n  RowRenderer.prototype.checkAngularCompile = function () {\n    var _this = this; // if we are doing angular compiling, then do digest the scope here\n\n\n    if (this.gridOptionsWrapper.isAngularCompileRows()) {\n      // we do it in a timeout, in case we are already in an apply\n      window.setTimeout(function () {\n        _this.$scope.$apply();\n      }, 0);\n    }\n  };\n\n  RowRenderer.prototype.workOutFirstAndLastRowsToRender = function () {\n    var _this = this;\n\n    var newFirst;\n    var newLast;\n\n    if (!this.paginationProxy.isRowsToRender()) {\n      newFirst = 0;\n      newLast = -1; // setting to -1 means nothing in range\n    } else if (this.printLayout) {\n      newFirst = this.paginationProxy.getPageFirstRow();\n      newLast = this.paginationProxy.getPageLastRow();\n    } else {\n      var bufferPixels = this.gridOptionsWrapper.getRowBufferInPixels();\n      var gridBodyCon = this.ctrlsService.getGridBodyCtrl();\n      var rowHeightsChanged = false;\n      var firstPixel = void 0;\n      var lastPixel = void 0;\n\n      do {\n        var paginationOffset = this.paginationProxy.getPixelOffset();\n\n        var _a = this.paginationProxy.getCurrentPagePixelRange(),\n            pageFirstPixel = _a.pageFirstPixel,\n            pageLastPixel = _a.pageLastPixel;\n\n        var divStretchOffset = this.rowContainerHeightService.getDivStretchOffset();\n        var bodyVRange = gridBodyCon.getScrollFeature().getVScrollPosition();\n        var bodyTopPixel = bodyVRange.top;\n        var bodyBottomPixel = bodyVRange.bottom;\n        firstPixel = Math.max(bodyTopPixel + paginationOffset - bufferPixels, pageFirstPixel) + divStretchOffset;\n        lastPixel = Math.min(bodyBottomPixel + paginationOffset + bufferPixels, pageLastPixel) + divStretchOffset; // if the rows we are about to display get their heights changed, then that upsets the calcs from above.\n\n        rowHeightsChanged = this.ensureAllRowsInRangeHaveHeightsCalculated(firstPixel, lastPixel);\n      } while (rowHeightsChanged);\n\n      var firstRowIndex = this.paginationProxy.getRowIndexAtPixel(firstPixel);\n      var lastRowIndex = this.paginationProxy.getRowIndexAtPixel(lastPixel);\n      var pageFirstRow = this.paginationProxy.getPageFirstRow();\n      var pageLastRow = this.paginationProxy.getPageLastRow(); // adjust, in case buffer extended actual size\n\n      if (firstRowIndex < pageFirstRow) {\n        firstRowIndex = pageFirstRow;\n      }\n\n      if (lastRowIndex > pageLastRow) {\n        lastRowIndex = pageLastRow;\n      }\n\n      newFirst = firstRowIndex;\n      newLast = lastRowIndex;\n    } // sometimes user doesn't set CSS right and ends up with grid with no height and grid ends up\n    // trying to render all the rows, eg 10,000+ rows. this will kill the browser. so instead of\n    // killing the browser, we limit the number of rows. just in case some use case we didn't think\n    // of, we also have a property to not do this operation.\n\n\n    var rowLayoutNormal = this.gridOptionsWrapper.getDomLayout() === Constants.DOM_LAYOUT_NORMAL;\n    var suppressRowCountRestriction = this.gridOptionsWrapper.isSuppressMaxRenderedRowRestriction();\n    var rowBufferMaxSize = Math.max(this.gridOptionsWrapper.getRowBuffer(), 500);\n\n    if (rowLayoutNormal && !suppressRowCountRestriction) {\n      if (newLast - newFirst > rowBufferMaxSize) {\n        newLast = newFirst + rowBufferMaxSize;\n      }\n    }\n\n    var firstDiffers = newFirst !== this.firstRenderedRow;\n    var lastDiffers = newLast !== this.lastRenderedRow;\n\n    if (firstDiffers || lastDiffers) {\n      this.firstRenderedRow = newFirst;\n      this.lastRenderedRow = newLast;\n      var event_1 = {\n        type: Events.EVENT_VIEWPORT_CHANGED,\n        firstRow: newFirst,\n        lastRow: newLast,\n        api: this.gridApi,\n        columnApi: this.columnApi\n      };\n      this.eventService.dispatchEvent(event_1);\n    } // only dispatch firstDataRendered if we have actually rendered some data\n\n\n    if (this.paginationProxy.isRowsToRender()) {\n      var event_2 = {\n        type: Events.EVENT_FIRST_DATA_RENDERED,\n        firstRow: newFirst,\n        lastRow: newLast,\n        api: this.gridApi,\n        columnApi: this.columnApi\n      }; // added a small delay here because in some scenarios this can be fired\n      // before the grid is actually rendered, causing component creation\n      // on EVENT_FIRST_DATA_RENDERED to fail.\n\n      window.setTimeout(function () {\n        return _this.eventService.dispatchEventOnce(event_2);\n      }, 50);\n    }\n  };\n\n  RowRenderer.prototype.ensureAllRowsInRangeHaveHeightsCalculated = function (topPixel, bottomPixel) {\n    // ensureRowHeightsVisible only works with CSRM, as it's the only row model that allows lazy row height calcs.\n    // all the other row models just hard code so the method just returns back false\n    var res = this.paginationProxy.ensureRowHeightsValid(topPixel, bottomPixel, -1, -1);\n\n    if (res) {\n      this.updateContainerHeights();\n    }\n\n    return res;\n  };\n\n  RowRenderer.prototype.getFirstVirtualRenderedRow = function () {\n    return this.firstRenderedRow;\n  };\n\n  RowRenderer.prototype.getLastVirtualRenderedRow = function () {\n    return this.lastRenderedRow;\n  }; // check that none of the rows to remove are editing or focused as:\n  // a) if editing, we want to keep them, otherwise the user will loose the context of the edit,\n  //    eg user starts editing, enters some text, then scrolls down and then up, next time row rendered\n  //    the edit is reset - so we want to keep it rendered.\n  // b) if focused, we want ot keep keyboard focus, so if user ctrl+c, it goes to clipboard,\n  //    otherwise the user can range select and drag (with focus cell going out of the viewport)\n  //    and then ctrl+c, nothing will happen if cell is removed from dom.\n  // c) if detail record of master detail, as users complained that the context of detail rows\n  //    was getting lost when detail row out of view. eg user expands to show detail row,\n  //    then manipulates the detail panel (eg sorts the detail grid), then context is lost\n  //    after detail panel is scrolled out of / into view.\n\n\n  RowRenderer.prototype.doNotUnVirtualiseRow = function (rowComp) {\n    var REMOVE_ROW = false;\n    var KEEP_ROW = true;\n    var rowNode = rowComp.getRowNode();\n    var rowHasFocus = this.focusService.isRowNodeFocused(rowNode);\n    var rowIsEditing = rowComp.isEditing();\n    var rowIsDetail = rowNode.detail;\n    var mightWantToKeepRow = rowHasFocus || rowIsEditing || rowIsDetail; // if we deffo don't want to keep it,\n\n    if (!mightWantToKeepRow) {\n      return REMOVE_ROW;\n    } // editing row, only remove if it is no longer rendered, eg filtered out or new data set.\n    // the reason we want to keep is if user is scrolling up and down, we don't want to loose\n    // the context of the editing in process.\n\n\n    var rowNodePresent = this.paginationProxy.isRowPresent(rowNode);\n    return rowNodePresent ? KEEP_ROW : REMOVE_ROW;\n  };\n\n  RowRenderer.prototype.createRowCon = function (rowNode, animate, afterScroll) {\n    var rowCtrlFromCache = this.cachedRowCtrls ? this.cachedRowCtrls.getRow(rowNode) : null;\n\n    if (rowCtrlFromCache) {\n      return rowCtrlFromCache;\n    } // we don't use animations frames for printing, so the user can put the grid into print mode\n    // and immediately print - otherwise the user would have to wait for the rows to draw in the background\n    // (via the animation frames) which is awkward to do from code.\n    // we only do the animation frames after scrolling, as this is where we want the smooth user experience.\n    // having animation frames for other times makes the grid look 'jumpy'.\n\n\n    var suppressAnimationFrame = this.gridOptionsWrapper.isSuppressAnimationFrame();\n    var useAnimationFrameForCreate = afterScroll && !suppressAnimationFrame && !this.printLayout;\n    var res = new RowCtrl(this.$scope, rowNode, this.beans, animate, useAnimationFrameForCreate, this.printLayout);\n    return res;\n  };\n\n  RowRenderer.prototype.getRenderedNodes = function () {\n    var renderedRows = this.rowCtrlsByRowIndex;\n    return Object.keys(renderedRows).map(function (key) {\n      return renderedRows[key].getRowNode();\n    });\n  };\n\n  RowRenderer.prototype.getRowByPosition = function (rowPosition) {\n    var rowComponent;\n\n    switch (rowPosition.rowPinned) {\n      case Constants.PINNED_TOP:\n        rowComponent = this.topRowCtrls[rowPosition.rowIndex];\n        break;\n\n      case Constants.PINNED_BOTTOM:\n        rowComponent = this.bottomRowCtrls[rowPosition.rowIndex];\n        break;\n\n      default:\n        rowComponent = this.rowCtrlsByRowIndex[rowPosition.rowIndex];\n        break;\n    }\n\n    return rowComponent;\n  };\n\n  RowRenderer.prototype.getRowNode = function (gridRow) {\n    switch (gridRow.rowPinned) {\n      case Constants.PINNED_TOP:\n        return this.pinnedRowModel.getPinnedTopRowData()[gridRow.rowIndex];\n\n      case Constants.PINNED_BOTTOM:\n        return this.pinnedRowModel.getPinnedBottomRowData()[gridRow.rowIndex];\n\n      default:\n        return this.rowModel.getRow(gridRow.rowIndex);\n    }\n  }; // returns true if any row between startIndex and endIndex is rendered. used by\n  // SSRM or IRM, as they don't want to purge visible blocks from cache.\n\n\n  RowRenderer.prototype.isRangeInRenderedViewport = function (startIndex, endIndex) {\n    // parent closed means the parent node is not expanded, thus these blocks are not visible\n    var parentClosed = startIndex == null || endIndex == null;\n\n    if (parentClosed) {\n      return false;\n    }\n\n    var blockAfterViewport = startIndex > this.lastRenderedRow;\n    var blockBeforeViewport = endIndex < this.firstRenderedRow;\n    var blockInsideViewport = !blockBeforeViewport && !blockAfterViewport;\n    return blockInsideViewport;\n  };\n\n  __decorate([Autowired(\"paginationProxy\")], RowRenderer.prototype, \"paginationProxy\", void 0);\n\n  __decorate([Autowired(\"columnModel\")], RowRenderer.prototype, \"columnModel\", void 0);\n\n  __decorate([Autowired(\"$scope\")], RowRenderer.prototype, \"$scope\", void 0);\n\n  __decorate([Autowired(\"pinnedRowModel\")], RowRenderer.prototype, \"pinnedRowModel\", void 0);\n\n  __decorate([Autowired(\"rowModel\")], RowRenderer.prototype, \"rowModel\", void 0);\n\n  __decorate([Autowired(\"focusService\")], RowRenderer.prototype, \"focusService\", void 0);\n\n  __decorate([Autowired(\"columnApi\")], RowRenderer.prototype, \"columnApi\", void 0);\n\n  __decorate([Autowired(\"gridApi\")], RowRenderer.prototype, \"gridApi\", void 0);\n\n  __decorate([Autowired(\"beans\")], RowRenderer.prototype, \"beans\", void 0);\n\n  __decorate([Autowired(\"rowContainerHeightService\")], RowRenderer.prototype, \"rowContainerHeightService\", void 0);\n\n  __decorate([Optional(\"ctrlsService\")], RowRenderer.prototype, \"ctrlsService\", void 0);\n\n  __decorate([PostConstruct], RowRenderer.prototype, \"postConstruct\", null);\n\n  RowRenderer = __decorate([Bean(\"rowRenderer\")], RowRenderer);\n  return RowRenderer;\n}(BeanStub);\n\nexport { RowRenderer };\n\nvar RowCtrlCache =\n/** @class */\nfunction () {\n  function RowCtrlCache(maxCount) {\n    // map for fast access\n    this.entriesMap = {}; // list for keeping order\n\n    this.entriesList = [];\n    this.maxCount = maxCount;\n  }\n\n  RowCtrlCache.prototype.toString = function () {\n    return this.entriesList.map(function (item) {\n      return item.getRowNode().data.name;\n    }).join(', ');\n  };\n\n  RowCtrlCache.prototype.addRow = function (rowCtrl) {\n    this.entriesMap[rowCtrl.getRowNode().id] = rowCtrl;\n    this.entriesList.push(rowCtrl);\n    rowCtrl.setCached(true);\n\n    if (this.entriesList.length > this.maxCount) {\n      var rowCtrlToDestroy = this.entriesList[0];\n      rowCtrlToDestroy.destroyFirstPass();\n      rowCtrlToDestroy.destroySecondPass();\n      this.removeFromCache(rowCtrlToDestroy);\n    }\n  };\n\n  RowCtrlCache.prototype.getRow = function (rowNode) {\n    if (rowNode == null || rowNode.id == null) {\n      return null;\n    }\n\n    var res = this.entriesMap[rowNode.id];\n\n    if (!res) {\n      return null;\n    }\n\n    this.removeFromCache(res);\n    res.setCached(false); // this can happen if user reloads data, and a new RowNode is reusing\n    // the same ID as the old one\n\n    var rowNodeMismatch = res.getRowNode() != rowNode;\n    return rowNodeMismatch ? null : res;\n  };\n\n  RowCtrlCache.prototype.removeFromCache = function (rowCtrl) {\n    var rowNodeId = rowCtrl.getRowNode().id;\n    delete this.entriesMap[rowNodeId];\n    removeFromArray(this.entriesList, rowCtrl);\n  };\n\n  RowCtrlCache.prototype.getEntries = function () {\n    return this.entriesList;\n  };\n\n  return RowCtrlCache;\n}();","map":{"version":3,"sources":["/Users/rongxuan/Desktop/reactmap/reactmap/node_modules/@ag-grid-community/core/dist/es6/rendering/rowRenderer.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","__spreadArrays","s","il","k","a","j","jl","GridOptionsWrapper","RowCtrl","Column","Events","Constants","Autowired","Bean","Optional","PostConstruct","BeanStub","exists","missing","getAllValuesInObject","iterateObject","createArrayOfNumbers","executeInAWhile","CellCtrl","removeFromArray","RowRenderer","_super","_this","apply","destroyFuncsForColumnListeners","rowCtrlsByRowIndex","zombieRowCtrls","allRowCtrls","topRowCtrls","bottomRowCtrls","refreshInProgress","postConstruct","ctrlsService","whenReady","gridBodyCtrl","getGridBodyCtrl","initialise","addManagedListener","eventService","EVENT_PAGINATION_CHANGED","onPageLoaded","bind","EVENT_PINNED_ROW_DATA_CHANGED","onPinnedRowDataChanged","EVENT_DISPLAYED_COLUMNS_CHANGED","onDisplayedColumnsChanged","EVENT_BODY_SCROLL","redrawAfterScroll","EVENT_BODY_HEIGHT_CHANGED","gridOptionsWrapper","PROP_DOM_LAYOUT","onDomLayoutChanged","EVENT_NEW_COLUMNS_LOADED","onNewColumnsLoaded","registerCellEventListeners","initialiseCache","printLayout","getDomLayout","DOM_LAYOUT_PRINT","embedFullWidthRows","isEmbedFullWidthRows","redrawAfterModelUpdate","isKeepDetailRows","countProp","getKeepDetailRowsCount","count","cachedRowCtrls","RowCtrlCache","getRowCtrls","updateAllRowCtrls","liveList","beans","isEnsureDomOrder","sort","getRowNode","rowIndex","zombieList","cachedList","getEntries","EVENT_CELL_FOCUSED","event","getAllCellCtrls","forEach","cellCtrl","onCellFocused","getAllRowCtrls","rowCtrl","isFullWidth","onFullWidthRowFocused","EVENT_FLASH_CELLS","onFlashCells","EVENT_COLUMN_HOVER_CHANGED","onColumnHover","EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED","onLeftChanged","rangeSelectionEnabled","isEnableRangeSelection","EVENT_RANGE_SELECTION_CHANGED","onRangeSelectionChanged","EVENT_COLUMN_MOVED","updateRangeBordersIfRangeCount","EVENT_COLUMN_PINNED","EVENT_COLUMN_VISIBLE","refreshListenersToColumnsForCellComps","EVENT_GRID_COLUMNS_CHANGED","addDestroyFunc","removeGridColumnListeners","func","cols","columnModel","getAllGridColumns","col","forEachCellWithThisCol","callback","getColumn","leftChangedListener","widthChangedListener","onWidthChanged","firstRightPinnedChangedListener","onFirstRightPinnedChanged","lastLeftPinnedChangedListener","onLastLeftPinnedChanged","addEventListener","EVENT_LEFT_CHANGED","EVENT_WIDTH_CHANGED","EVENT_FIRST_RIGHT_PINNED_CHANGED","EVENT_LAST_LEFT_PINNED_CHANGED","push","removeEventListener","destroyRows","datasourceChanged","firstRenderedRow","lastRenderedRow","rowIndexesToRemove","keys","removeRowCtrls","params","recycleRows","keepRenderedRows","animate","newData","newPage","onlyBody","getAllCellsForColumn","column","res","eCell","getCellElement","refreshFloatingRowComps","refreshFloatingRows","pinnedRowModel","getPinnedTopRowData","getPinnedBottomRowData","getTopRowCtrls","getBottomRowCtrls","rowComps","rowNodes","row","destroyFirstPass","destroySecondPass","rowNode","rowCon","$scope","getRenderedIndexesForRowNodes","result","index","renderedRow","indexOf","redrawRows","partialRefresh","indexesToRemove","getCellToRestoreFocusToAfterRefresh","focusedCell","suppressKeepFocus","focusService","getFocusCellToUseAfterRefresh","activeElement","document","cellDomData","getDomData","DOM_DATA_KEY_CELL_CTRL","rowDomData","DOM_DATA_KEY_ROW_CTRL","gridElementFocused","getLockOnRefresh","updateContainerHeights","scrollToTopIfNewData","isAnimateRows","rowsToRecycle","removeAllRowComps","isFocusedCellGettingRecycled","rowComp","rowIndexEqual","pinnedEqual","rowPinned","focusedCellRecycled","redraw","dispatchDisplayedRowsChanged","restoreFocusedCell","releaseLockOnRefresh","scrollToTop","suppressScrollToTop","isSuppressScrollOnNewData","getScrollFeature","rowContainerHeightService","setModelHeight","containerHeight","paginationProxy","getCurrentPageHeight","Error","cellPosition","setFocusedCell","stopEditing","cancel","concat","addRenderedRowListener","eventName","flashCells","flashDelay","fadeDelay","getCellCtrls","columns","flashCell","refreshCells","refreshCellParams","forceRefresh","force","suppressFlash","refreshShouldDestroy","getRowCtrl","refreshCell","getCellRendererInstances","map","getCellRenderer","filter","renderer","getCellEditorInstances","cellEditor","getCellEditor","getEditingCells","isEditing","getCellPosition","rowIdsMap","top","bottom","normal","id","PINNED_TOP","PINNED_BOTTOM","colIdsMap","colKey","getGridColumn","getId","processRow","floating","colId","excludeColFromRefresh","destroy","call","stubNodeIndexes","stubNode","nodesByIdMap","rowsToRemove","indexToRemove","removeRowCompsNotToDraw","indexesToDraw","indexesToDrawMap","existingIndexes","indexesNotToDraw","calculateIndexesToDraw","checkRowToDraw","indexStr","doNotUnVirtualiseRow","afterScroll","updateOffset","workOutFirstAndLastRowsToRender","rowCtrls","createOrUpdateRowCtrl","useAnimationFrame","isSuppressAnimationFrame","animationFrameService","addDestroyTask","destroyRowCtrls","checkAngularCompile","updateRowCount","type","EVENT_DISPLAYED_ROWS_CHANGED","dispatchEvent","pinningLeft","isPinningLeft","pinningRight","isPinningRight","atLeastOneChanged","redrawFullWidthEmbeddedRows","toString","refreshFullWidthRows","rowNodesToRefresh","selectivelyRefreshing","idsToRefresh","undefined","parentId","level","parent","skipThisNode","fullWidthRowsRefreshed","refreshFullWidth","getRow","alreadyRendered","creatingNewRowCon","createRowCon","rowCtrlsMap","executeInAWhileFuncs","nodeId","isCacheable","addRow","getInstanceId","isAngularCompileRows","window","setTimeout","$apply","newFirst","newLast","isRowsToRender","getPageFirstRow","getPageLastRow","bufferPixels","getRowBufferInPixels","gridBodyCon","rowHeightsChanged","firstPixel","lastPixel","paginationOffset","getPixelOffset","_a","getCurrentPagePixelRange","pageFirstPixel","pageLastPixel","divStretchOffset","getDivStretchOffset","bodyVRange","getVScrollPosition","bodyTopPixel","bodyBottomPixel","Math","max","min","ensureAllRowsInRangeHaveHeightsCalculated","firstRowIndex","getRowIndexAtPixel","lastRowIndex","pageFirstRow","pageLastRow","rowLayoutNormal","DOM_LAYOUT_NORMAL","suppressRowCountRestriction","isSuppressMaxRenderedRowRestriction","rowBufferMaxSize","getRowBuffer","firstDiffers","lastDiffers","event_1","EVENT_VIEWPORT_CHANGED","firstRow","lastRow","api","gridApi","columnApi","event_2","EVENT_FIRST_DATA_RENDERED","dispatchEventOnce","topPixel","bottomPixel","ensureRowHeightsValid","getFirstVirtualRenderedRow","getLastVirtualRenderedRow","REMOVE_ROW","KEEP_ROW","rowHasFocus","isRowNodeFocused","rowIsEditing","rowIsDetail","detail","mightWantToKeepRow","rowNodePresent","isRowPresent","rowCtrlFromCache","suppressAnimationFrame","useAnimationFrameForCreate","getRenderedNodes","renderedRows","getRowByPosition","rowPosition","rowComponent","gridRow","rowModel","isRangeInRenderedViewport","startIndex","endIndex","parentClosed","blockAfterViewport","blockBeforeViewport","blockInsideViewport","maxCount","entriesMap","entriesList","item","data","name","join","setCached","rowCtrlToDestroy","removeFromCache","rowNodeMismatch","rowNodeId"],"mappings":"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","sourcesContent":["/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v26.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { GridOptionsWrapper } from \"../gridOptionsWrapper\";\nimport { RowCtrl } from \"./row/rowCtrl\";\nimport { Column } from \"../entities/column\";\nimport { Events } from \"../events\";\nimport { Constants } from \"../constants/constants\";\nimport { Autowired, Bean, Optional, PostConstruct } from \"../context/context\";\nimport { BeanStub } from \"../context/beanStub\";\nimport { exists, missing } from \"../utils/generic\";\nimport { getAllValuesInObject, iterateObject } from \"../utils/object\";\nimport { createArrayOfNumbers } from \"../utils/number\";\nimport { executeInAWhile } from \"../utils/function\";\nimport { CellCtrl } from \"./cell/cellCtrl\";\nimport { removeFromArray } from \"../utils/array\";\nvar RowRenderer = /** @class */ (function (_super) {\n    __extends(RowRenderer, _super);\n    function RowRenderer() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.destroyFuncsForColumnListeners = [];\n        // map of row ids to row objects. keeps track of which elements\n        // are rendered for which rows in the dom.\n        _this.rowCtrlsByRowIndex = {};\n        _this.zombieRowCtrls = {};\n        _this.allRowCtrls = [];\n        _this.topRowCtrls = [];\n        _this.bottomRowCtrls = [];\n        // we only allow one refresh at a time, otherwise the internal memory structure here\n        // will get messed up. this can happen if the user has a cellRenderer, and inside the\n        // renderer they call an API method that results in another pass of the refresh,\n        // then it will be trying to draw rows in the middle of a refresh.\n        _this.refreshInProgress = false;\n        return _this;\n    }\n    RowRenderer.prototype.postConstruct = function () {\n        var _this = this;\n        this.ctrlsService.whenReady(function () {\n            _this.gridBodyCtrl = _this.ctrlsService.getGridBodyCtrl();\n            _this.initialise();\n        });\n    };\n    RowRenderer.prototype.initialise = function () {\n        this.addManagedListener(this.eventService, Events.EVENT_PAGINATION_CHANGED, this.onPageLoaded.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_PINNED_ROW_DATA_CHANGED, this.onPinnedRowDataChanged.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_BODY_SCROLL, this.redrawAfterScroll.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_BODY_HEIGHT_CHANGED, this.redrawAfterScroll.bind(this));\n        this.addManagedListener(this.gridOptionsWrapper, GridOptionsWrapper.PROP_DOM_LAYOUT, this.onDomLayoutChanged.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, this.onNewColumnsLoaded.bind(this));\n        this.registerCellEventListeners();\n        this.initialiseCache();\n        this.printLayout = this.gridOptionsWrapper.getDomLayout() === Constants.DOM_LAYOUT_PRINT;\n        this.embedFullWidthRows = this.printLayout || this.gridOptionsWrapper.isEmbedFullWidthRows();\n        this.redrawAfterModelUpdate();\n    };\n    RowRenderer.prototype.initialiseCache = function () {\n        if (this.gridOptionsWrapper.isKeepDetailRows()) {\n            var countProp = this.gridOptionsWrapper.getKeepDetailRowsCount();\n            var count = countProp != null ? countProp : 3;\n            this.cachedRowCtrls = new RowCtrlCache(count);\n        }\n    };\n    RowRenderer.prototype.getRowCtrls = function () {\n        return this.allRowCtrls;\n    };\n    RowRenderer.prototype.updateAllRowCtrls = function () {\n        var liveList = getAllValuesInObject(this.rowCtrlsByRowIndex);\n        if (this.beans.gridOptionsWrapper.isEnsureDomOrder()) {\n            liveList.sort(function (a, b) { return a.getRowNode().rowIndex - b.getRowNode.rowIndex; });\n        }\n        var zombieList = getAllValuesInObject(this.zombieRowCtrls);\n        var cachedList = this.cachedRowCtrls ? this.cachedRowCtrls.getEntries() : [];\n        this.allRowCtrls = __spreadArrays(liveList, zombieList, cachedList);\n    };\n    // in a clean design, each cell would register for each of these events. however when scrolling, all the cells\n    // registering and de-registering for events is a performance bottleneck. so we register here once and inform\n    // all active cells.\n    RowRenderer.prototype.registerCellEventListeners = function () {\n        var _this = this;\n        this.addManagedListener(this.eventService, Events.EVENT_CELL_FOCUSED, function (event) {\n            _this.getAllCellCtrls().forEach(function (cellCtrl) { return cellCtrl.onCellFocused(event); });\n            _this.getAllRowCtrls().forEach(function (rowCtrl) {\n                if (rowCtrl.isFullWidth()) {\n                    rowCtrl.onFullWidthRowFocused(event);\n                }\n            });\n        });\n        this.addManagedListener(this.eventService, Events.EVENT_FLASH_CELLS, function (event) {\n            _this.getAllCellCtrls().forEach(function (cellCtrl) { return cellCtrl.onFlashCells(event); });\n        });\n        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_HOVER_CHANGED, function () {\n            _this.getAllCellCtrls().forEach(function (cellCtrl) { return cellCtrl.onColumnHover(); });\n        });\n        // only for printLayout - because we are rendering all the cells in the same row, regardless of pinned state,\n        // then changing the width of the containers will impact left position. eg the center cols all have their\n        // left position adjusted by the width of the left pinned column, so if the pinned left column width changes,\n        // all the center cols need to be shifted to accommodate this. when in normal layout, the pinned cols are\n        // in different containers so doesn't impact.\n        this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, function () {\n            if (_this.printLayout) {\n                _this.getAllCellCtrls().forEach(function (cellCtrl) { return cellCtrl.onLeftChanged(); });\n            }\n        });\n        var rangeSelectionEnabled = this.gridOptionsWrapper.isEnableRangeSelection();\n        if (rangeSelectionEnabled) {\n            this.addManagedListener(this.eventService, Events.EVENT_RANGE_SELECTION_CHANGED, function () {\n                _this.getAllCellCtrls().forEach(function (cellCtrl) { return cellCtrl.onRangeSelectionChanged(); });\n            });\n            this.addManagedListener(this.eventService, Events.EVENT_COLUMN_MOVED, function () {\n                _this.getAllCellCtrls().forEach(function (cellCtrl) { return cellCtrl.updateRangeBordersIfRangeCount(); });\n            });\n            this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PINNED, function () {\n                _this.getAllCellCtrls().forEach(function (cellCtrl) { return cellCtrl.updateRangeBordersIfRangeCount(); });\n            });\n            this.addManagedListener(this.eventService, Events.EVENT_COLUMN_VISIBLE, function () {\n                _this.getAllCellCtrls().forEach(function (cellCtrl) { return cellCtrl.updateRangeBordersIfRangeCount(); });\n            });\n        }\n        // add listeners to the grid columns\n        this.refreshListenersToColumnsForCellComps();\n        // if the grid columns change, then refresh the listeners again\n        this.addManagedListener(this.eventService, Events.EVENT_GRID_COLUMNS_CHANGED, this.refreshListenersToColumnsForCellComps.bind(this));\n        this.addDestroyFunc(this.removeGridColumnListeners.bind(this));\n    };\n    // executes all functions in destroyFuncsForColumnListeners and then clears the list\n    RowRenderer.prototype.removeGridColumnListeners = function () {\n        this.destroyFuncsForColumnListeners.forEach(function (func) { return func(); });\n        this.destroyFuncsForColumnListeners.length = 0;\n    };\n    // this function adds listeners onto all the grid columns, which are the column that we could have cellComps for.\n    // when the grid columns change, we add listeners again. in an ideal design, each CellComp would just register to\n    // the column it belongs to on creation, however this was a bottleneck with the number of cells, so do it here\n    // once instead.\n    RowRenderer.prototype.refreshListenersToColumnsForCellComps = function () {\n        var _this = this;\n        this.removeGridColumnListeners();\n        var cols = this.columnModel.getAllGridColumns();\n        if (!cols) {\n            return;\n        }\n        cols.forEach(function (col) {\n            var forEachCellWithThisCol = function (callback) {\n                _this.getAllCellCtrls().forEach(function (cellCtrl) {\n                    if (cellCtrl.getColumn() === col) {\n                        callback(cellCtrl);\n                    }\n                });\n            };\n            var leftChangedListener = function () {\n                forEachCellWithThisCol(function (cellCtrl) { return cellCtrl.onLeftChanged(); });\n            };\n            var widthChangedListener = function () {\n                forEachCellWithThisCol(function (cellCtrl) { return cellCtrl.onWidthChanged(); });\n            };\n            var firstRightPinnedChangedListener = function () {\n                forEachCellWithThisCol(function (cellCtrl) { return cellCtrl.onFirstRightPinnedChanged(); });\n            };\n            var lastLeftPinnedChangedListener = function () {\n                forEachCellWithThisCol(function (cellCtrl) { return cellCtrl.onLastLeftPinnedChanged(); });\n            };\n            col.addEventListener(Column.EVENT_LEFT_CHANGED, leftChangedListener);\n            col.addEventListener(Column.EVENT_WIDTH_CHANGED, widthChangedListener);\n            col.addEventListener(Column.EVENT_FIRST_RIGHT_PINNED_CHANGED, firstRightPinnedChangedListener);\n            col.addEventListener(Column.EVENT_LAST_LEFT_PINNED_CHANGED, lastLeftPinnedChangedListener);\n            _this.destroyFuncsForColumnListeners.push(function () {\n                col.removeEventListener(Column.EVENT_LEFT_CHANGED, leftChangedListener);\n                col.removeEventListener(Column.EVENT_WIDTH_CHANGED, widthChangedListener);\n                col.removeEventListener(Column.EVENT_FIRST_RIGHT_PINNED_CHANGED, firstRightPinnedChangedListener);\n                col.removeEventListener(Column.EVENT_LAST_LEFT_PINNED_CHANGED, lastLeftPinnedChangedListener);\n            });\n        });\n    };\n    RowRenderer.prototype.onDomLayoutChanged = function () {\n        var printLayout = this.gridOptionsWrapper.getDomLayout() === Constants.DOM_LAYOUT_PRINT;\n        var embedFullWidthRows = printLayout || this.gridOptionsWrapper.isEmbedFullWidthRows();\n        // if moving towards or away from print layout, means we need to destroy all rows, as rows are not laid\n        // out using absolute positioning when doing print layout\n        var destroyRows = embedFullWidthRows !== this.embedFullWidthRows || this.printLayout !== printLayout;\n        this.printLayout = printLayout;\n        this.embedFullWidthRows = embedFullWidthRows;\n        if (destroyRows) {\n            this.redrawAfterModelUpdate();\n        }\n    };\n    // for row models that have datasources, when we update the datasource, we need to force the rowRenderer\n    // to redraw all rows. otherwise the old rows from the old datasource will stay displayed.\n    RowRenderer.prototype.datasourceChanged = function () {\n        this.firstRenderedRow = 0;\n        this.lastRenderedRow = -1;\n        var rowIndexesToRemove = Object.keys(this.rowCtrlsByRowIndex);\n        this.removeRowCtrls(rowIndexesToRemove);\n    };\n    RowRenderer.prototype.onPageLoaded = function (event) {\n        var params = {\n            recycleRows: event.keepRenderedRows,\n            animate: event.animate,\n            newData: event.newData,\n            newPage: event.newPage,\n            // because this is a model updated event (not pinned rows), we\n            // can skip updating the pinned rows. this is needed so that if user\n            // is doing transaction updates, the pinned rows are not getting constantly\n            // trashed - or editing cells in pinned rows are not refreshed and put into read mode\n            onlyBody: true\n        };\n        this.redrawAfterModelUpdate(params);\n    };\n    RowRenderer.prototype.getAllCellsForColumn = function (column) {\n        var res = [];\n        this.getAllRowCtrls().forEach(function (rowCtrl) {\n            var eCell = rowCtrl.getCellElement(column);\n            if (eCell) {\n                res.push(eCell);\n            }\n        });\n        return res;\n    };\n    RowRenderer.prototype.refreshFloatingRowComps = function () {\n        this.refreshFloatingRows(this.topRowCtrls, this.pinnedRowModel.getPinnedTopRowData());\n        this.refreshFloatingRows(this.bottomRowCtrls, this.pinnedRowModel.getPinnedBottomRowData());\n    };\n    RowRenderer.prototype.getTopRowCtrls = function () {\n        return this.topRowCtrls;\n    };\n    RowRenderer.prototype.getBottomRowCtrls = function () {\n        return this.bottomRowCtrls;\n    };\n    RowRenderer.prototype.refreshFloatingRows = function (rowComps, rowNodes) {\n        var _this = this;\n        rowComps.forEach(function (row) {\n            row.destroyFirstPass();\n            row.destroySecondPass();\n        });\n        rowComps.length = 0;\n        if (!rowNodes) {\n            return;\n        }\n        rowNodes.forEach(function (rowNode) {\n            var rowCon = new RowCtrl(_this.$scope, rowNode, _this.beans, false, false, _this.printLayout);\n            rowComps.push(rowCon);\n        });\n    };\n    RowRenderer.prototype.onPinnedRowDataChanged = function () {\n        // recycling rows in order to ensure cell editing is not cancelled\n        var params = {\n            recycleRows: true\n        };\n        this.redrawAfterModelUpdate(params);\n    };\n    // if the row nodes are not rendered, no index is returned\n    RowRenderer.prototype.getRenderedIndexesForRowNodes = function (rowNodes) {\n        var result = [];\n        if (missing(rowNodes)) {\n            return result;\n        }\n        iterateObject(this.rowCtrlsByRowIndex, function (index, renderedRow) {\n            var rowNode = renderedRow.getRowNode();\n            if (rowNodes.indexOf(rowNode) >= 0) {\n                result.push(index);\n            }\n        });\n        return result;\n    };\n    RowRenderer.prototype.redrawRows = function (rowNodes) {\n        // if no row nodes provided, then refresh everything\n        var partialRefresh = rowNodes != null && rowNodes.length > 0;\n        if (partialRefresh) {\n            var indexesToRemove = this.getRenderedIndexesForRowNodes(rowNodes);\n            // remove the rows\n            this.removeRowCtrls(indexesToRemove);\n        }\n        // add draw them again\n        this.redrawAfterModelUpdate({\n            recycleRows: partialRefresh\n        });\n    };\n    RowRenderer.prototype.getCellToRestoreFocusToAfterRefresh = function (params) {\n        var focusedCell = params.suppressKeepFocus ? null : this.focusService.getFocusCellToUseAfterRefresh();\n        if (focusedCell == null) {\n            return null;\n        }\n        // if the dom is not actually focused on a cell, then we don't try to refocus. the problem this\n        // solves is with editing - if the user is editing, eg focus is on a text field, and not on the\n        // cell itself, then the cell can be registered as having focus, however it's the text field that\n        // has the focus and not the cell div. therefore, when the refresh is finished, the grid will focus\n        // the cell, and not the textfield. that means if the user is in a text field, and the grid refreshes,\n        // the focus is lost from the text field. we do not want this.\n        var activeElement = document.activeElement;\n        var cellDomData = this.gridOptionsWrapper.getDomData(activeElement, CellCtrl.DOM_DATA_KEY_CELL_CTRL);\n        var rowDomData = this.gridOptionsWrapper.getDomData(activeElement, RowCtrl.DOM_DATA_KEY_ROW_CTRL);\n        var gridElementFocused = cellDomData || rowDomData;\n        return gridElementFocused ? focusedCell : null;\n    };\n    // gets called from:\n    // +) initialisation (in registerGridComp) params = null\n    // +) onDomLayoutChanged, params = null\n    // +) onPageLoaded, recycleRows, animate, newData, newPage from event, onlyBody=true\n    // +) onPinnedRowDataChanged, recycleRows = true\n    // +) redrawRows (from Grid API), recycleRows = true/false\n    RowRenderer.prototype.redrawAfterModelUpdate = function (params) {\n        if (params === void 0) { params = {}; }\n        this.getLockOnRefresh();\n        var focusedCell = this.getCellToRestoreFocusToAfterRefresh(params);\n        this.updateContainerHeights();\n        this.scrollToTopIfNewData(params);\n        // never recycle rows when print layout, we draw each row again from scratch. this is because print layout\n        // uses normal dom layout to put cells into dom - it doesn't allow reordering rows.\n        var recycleRows = !this.printLayout && !!params.recycleRows;\n        var animate = params.animate && this.gridOptionsWrapper.isAnimateRows();\n        // after modelUpdate, row indexes can change, so we clear out the rowsByIndex map,\n        // however we can reuse the rows, so we keep them but index by rowNode.id\n        var rowsToRecycle = recycleRows ? this.recycleRows() : null;\n        if (!recycleRows) {\n            this.removeAllRowComps();\n        }\n        var isFocusedCellGettingRecycled = function () {\n            if (focusedCell == null || rowsToRecycle == null) {\n                return false;\n            }\n            var res = false;\n            iterateObject(rowsToRecycle, function (key, rowComp) {\n                var rowNode = rowComp.getRowNode();\n                var rowIndexEqual = rowNode.rowIndex == focusedCell.rowIndex;\n                var pinnedEqual = rowNode.rowPinned == focusedCell.rowPinned;\n                if (rowIndexEqual && pinnedEqual) {\n                    res = true;\n                }\n            });\n            return res;\n        };\n        var focusedCellRecycled = isFocusedCellGettingRecycled();\n        this.redraw(rowsToRecycle, animate);\n        if (!params.onlyBody) {\n            this.refreshFloatingRowComps();\n        }\n        this.dispatchDisplayedRowsChanged();\n        // if we focus a cell that's already focused, then we get an unnecessary 'cellFocused' event fired.\n        // this was happening when user clicked 'expand' on a rowGroup, then cellFocused was getting fired twice.\n        if (!focusedCellRecycled) {\n            this.restoreFocusedCell(focusedCell);\n        }\n        this.releaseLockOnRefresh();\n    };\n    RowRenderer.prototype.scrollToTopIfNewData = function (params) {\n        var scrollToTop = params.newData || params.newPage;\n        var suppressScrollToTop = this.gridOptionsWrapper.isSuppressScrollOnNewData();\n        if (scrollToTop && !suppressScrollToTop) {\n            this.gridBodyCtrl.getScrollFeature().scrollToTop();\n        }\n    };\n    RowRenderer.prototype.updateContainerHeights = function () {\n        // when doing print layout, we don't explicitly set height on the containers\n        if (this.printLayout) {\n            this.rowContainerHeightService.setModelHeight(null);\n            return;\n        }\n        var containerHeight = this.paginationProxy.getCurrentPageHeight();\n        // we need at least 1 pixel for the horizontal scroll to work. so if there are now rows,\n        // we still want the scroll to be present, otherwise there would be no way to scroll the header\n        // which might be needed us user wants to access columns\n        // on the RHS - and if that was where the filter was that cause no rows to be presented, there\n        // is no way to remove the filter.\n        if (containerHeight === 0) {\n            containerHeight = 1;\n        }\n        this.rowContainerHeightService.setModelHeight(containerHeight);\n    };\n    RowRenderer.prototype.getLockOnRefresh = function () {\n        if (this.refreshInProgress) {\n            throw new Error(\"AG Grid: cannot get grid to draw rows when it is in the middle of drawing rows. \" +\n                \"Your code probably called a grid API method while the grid was in the render stage. To overcome \" +\n                \"this, put the API call into a timeout, e.g. instead of api.refreshView(), \" +\n                \"call setTimeout(function() { api.refreshView(); }, 0). To see what part of your code \" +\n                \"that caused the refresh check this stacktrace.\");\n        }\n        this.refreshInProgress = true;\n    };\n    RowRenderer.prototype.releaseLockOnRefresh = function () {\n        this.refreshInProgress = false;\n    };\n    // sets the focus to the provided cell, if the cell is provided. this way, the user can call refresh without\n    // worry about the focus been lost. this is important when the user is using keyboard navigation to do edits\n    // and the cellEditor is calling 'refresh' to get other cells to update (as other cells might depend on the\n    // edited cell).\n    RowRenderer.prototype.restoreFocusedCell = function (cellPosition) {\n        if (cellPosition) {\n            this.focusService.setFocusedCell(cellPosition.rowIndex, cellPosition.column, cellPosition.rowPinned, true);\n        }\n    };\n    RowRenderer.prototype.stopEditing = function (cancel) {\n        if (cancel === void 0) { cancel = false; }\n        this.getAllRowCtrls().forEach(function (rowCtrl) {\n            rowCtrl.stopEditing(cancel);\n        });\n    };\n    RowRenderer.prototype.onNewColumnsLoaded = function () {\n        // we don't want each cellComp to register for events, as would increase rendering time.\n        // so for newColumnsLoaded, we register once here (in rowRenderer) and then inform\n        // each cell if / when event was fired.\n        this.getAllCellCtrls().forEach(function (cellCtrl) { return cellCtrl.onNewColumnsLoaded(); });\n    };\n    RowRenderer.prototype.getAllCellCtrls = function () {\n        var res = [];\n        this.getAllRowCtrls().forEach(function (rowCtrl) { return res = res.concat(rowCtrl.getAllCellCtrls()); });\n        return res;\n    };\n    RowRenderer.prototype.getAllRowCtrls = function () {\n        var _this = this;\n        var res = __spreadArrays(this.topRowCtrls, this.bottomRowCtrls);\n        Object.keys(this.rowCtrlsByRowIndex).forEach(function (key) { return res.push(_this.rowCtrlsByRowIndex[key]); });\n        return res;\n    };\n    RowRenderer.prototype.addRenderedRowListener = function (eventName, rowIndex, callback) {\n        var rowComp = this.rowCtrlsByRowIndex[rowIndex];\n        if (rowComp) {\n            rowComp.addEventListener(eventName, callback);\n        }\n    };\n    RowRenderer.prototype.flashCells = function (params) {\n        if (params === void 0) { params = {}; }\n        var flashDelay = params.flashDelay, fadeDelay = params.fadeDelay;\n        this.getCellCtrls(params.rowNodes, params.columns)\n            .forEach(function (cellCtrl) { return cellCtrl.flashCell({ flashDelay: flashDelay, fadeDelay: fadeDelay }); });\n    };\n    RowRenderer.prototype.refreshCells = function (params) {\n        if (params === void 0) { params = {}; }\n        var refreshCellParams = {\n            forceRefresh: params.force,\n            newData: false,\n            suppressFlash: params.suppressFlash\n        };\n        this.getCellCtrls(params.rowNodes, params.columns)\n            .forEach(function (cellCtrl) {\n            if (cellCtrl.refreshShouldDestroy()) {\n                var rowCtrl = cellCtrl.getRowCtrl();\n                if (rowCtrl) {\n                    rowCtrl.refreshCell(cellCtrl);\n                }\n            }\n            else {\n                cellCtrl.refreshCell(refreshCellParams);\n            }\n        });\n    };\n    RowRenderer.prototype.getCellRendererInstances = function (params) {\n        var res = this.getCellCtrls(params.rowNodes, params.columns)\n            .map(function (cellCtrl) { return cellCtrl.getCellRenderer(); })\n            .filter(function (renderer) { return renderer != null; });\n        return res;\n    };\n    RowRenderer.prototype.getCellEditorInstances = function (params) {\n        var res = [];\n        this.getCellCtrls(params.rowNodes, params.columns).forEach(function (cellCtrl) {\n            var cellEditor = cellCtrl.getCellEditor();\n            if (cellEditor) {\n                res.push(cellEditor);\n            }\n        });\n        return res;\n    };\n    RowRenderer.prototype.getEditingCells = function () {\n        var res = [];\n        this.getAllCellCtrls().forEach(function (cellCtrl) {\n            if (cellCtrl.isEditing()) {\n                var cellPosition = cellCtrl.getCellPosition();\n                res.push(cellPosition);\n            }\n        });\n        return res;\n    };\n    // returns CellCtrl's that match the provided rowNodes and columns. eg if one row node\n    // and two columns provided, that identifies 4 cells, so 4 CellCtrl's returned.\n    RowRenderer.prototype.getCellCtrls = function (rowNodes, columns) {\n        var _this = this;\n        var rowIdsMap;\n        var res = [];\n        if (exists(rowNodes)) {\n            rowIdsMap = {\n                top: {},\n                bottom: {},\n                normal: {}\n            };\n            rowNodes.forEach(function (rowNode) {\n                var id = rowNode.id;\n                if (rowNode.rowPinned === Constants.PINNED_TOP) {\n                    rowIdsMap.top[id] = true;\n                }\n                else if (rowNode.rowPinned === Constants.PINNED_BOTTOM) {\n                    rowIdsMap.bottom[id] = true;\n                }\n                else {\n                    rowIdsMap.normal[id] = true;\n                }\n            });\n        }\n        var colIdsMap;\n        if (exists(columns)) {\n            colIdsMap = {};\n            columns.forEach(function (colKey) {\n                var column = _this.columnModel.getGridColumn(colKey);\n                if (exists(column)) {\n                    colIdsMap[column.getId()] = true;\n                }\n            });\n        }\n        var processRow = function (rowComp) {\n            var rowNode = rowComp.getRowNode();\n            var id = rowNode.id;\n            var floating = rowNode.rowPinned;\n            // skip this row if it is missing from the provided list\n            if (exists(rowIdsMap)) {\n                if (floating === Constants.PINNED_BOTTOM) {\n                    if (!rowIdsMap.bottom[id]) {\n                        return;\n                    }\n                }\n                else if (floating === Constants.PINNED_TOP) {\n                    if (!rowIdsMap.top[id]) {\n                        return;\n                    }\n                }\n                else {\n                    if (!rowIdsMap.normal[id]) {\n                        return;\n                    }\n                }\n            }\n            rowComp.getAllCellCtrls().forEach(function (cellCtrl) {\n                var colId = cellCtrl.getColumn().getId();\n                var excludeColFromRefresh = colIdsMap && !colIdsMap[colId];\n                if (excludeColFromRefresh) {\n                    return;\n                }\n                res.push(cellCtrl);\n            });\n        };\n        iterateObject(this.rowCtrlsByRowIndex, function (index, rowComp) {\n            processRow(rowComp);\n        });\n        if (this.topRowCtrls) {\n            this.topRowCtrls.forEach(processRow);\n        }\n        if (this.bottomRowCtrls) {\n            this.bottomRowCtrls.forEach(processRow);\n        }\n        return res;\n    };\n    RowRenderer.prototype.destroy = function () {\n        this.removeAllRowComps();\n        _super.prototype.destroy.call(this);\n    };\n    RowRenderer.prototype.removeAllRowComps = function () {\n        var rowIndexesToRemove = Object.keys(this.rowCtrlsByRowIndex);\n        this.removeRowCtrls(rowIndexesToRemove);\n    };\n    RowRenderer.prototype.recycleRows = function () {\n        // remove all stub nodes, they can't be reused, as no rowNode id\n        var stubNodeIndexes = [];\n        iterateObject(this.rowCtrlsByRowIndex, function (index, rowComp) {\n            var stubNode = rowComp.getRowNode().id == null;\n            if (stubNode) {\n                stubNodeIndexes.push(index);\n            }\n        });\n        this.removeRowCtrls(stubNodeIndexes);\n        // then clear out rowCompsByIndex, but before that take a copy, but index by id, not rowIndex\n        var nodesByIdMap = {};\n        iterateObject(this.rowCtrlsByRowIndex, function (index, rowComp) {\n            var rowNode = rowComp.getRowNode();\n            nodesByIdMap[rowNode.id] = rowComp;\n        });\n        this.rowCtrlsByRowIndex = {};\n        return nodesByIdMap;\n    };\n    // takes array of row indexes\n    RowRenderer.prototype.removeRowCtrls = function (rowsToRemove) {\n        var _this = this;\n        // if no fromIndex then set to -1, which will refresh everything\n        // let realFromIndex = -1;\n        rowsToRemove.forEach(function (indexToRemove) {\n            var rowCtrl = _this.rowCtrlsByRowIndex[indexToRemove];\n            if (rowCtrl) {\n                rowCtrl.destroyFirstPass();\n                rowCtrl.destroySecondPass();\n            }\n            delete _this.rowCtrlsByRowIndex[indexToRemove];\n        });\n    };\n    // gets called when rows don't change, but viewport does, so after:\n    // 1) height of grid body changes, ie number of displayed rows has changed\n    // 2) grid scrolled to new position\n    // 3) ensure index visible (which is a scroll)\n    RowRenderer.prototype.redrawAfterScroll = function () {\n        this.getLockOnRefresh();\n        this.redraw(null, false, true);\n        this.releaseLockOnRefresh();\n        this.dispatchDisplayedRowsChanged();\n    };\n    RowRenderer.prototype.removeRowCompsNotToDraw = function (indexesToDraw) {\n        // for speedy lookup, dump into map\n        var indexesToDrawMap = {};\n        indexesToDraw.forEach(function (index) { return (indexesToDrawMap[index] = true); });\n        var existingIndexes = Object.keys(this.rowCtrlsByRowIndex);\n        var indexesNotToDraw = existingIndexes.filter(function (index) { return !indexesToDrawMap[index]; });\n        this.removeRowCtrls(indexesNotToDraw);\n    };\n    RowRenderer.prototype.calculateIndexesToDraw = function (rowsToRecycle) {\n        var _this = this;\n        // all in all indexes in the viewport\n        var indexesToDraw = createArrayOfNumbers(this.firstRenderedRow, this.lastRenderedRow);\n        var checkRowToDraw = function (indexStr, rowComp) {\n            var index = rowComp.getRowNode().rowIndex;\n            if (index == null) {\n                return;\n            }\n            if (index < _this.firstRenderedRow || index > _this.lastRenderedRow) {\n                if (_this.doNotUnVirtualiseRow(rowComp)) {\n                    indexesToDraw.push(index);\n                }\n            }\n        };\n        // if we are redrawing due to scrolling change, then old rows are in this.rowCompsByIndex\n        iterateObject(this.rowCtrlsByRowIndex, checkRowToDraw);\n        // if we are redrawing due to model update, then old rows are in rowsToRecycle\n        iterateObject(rowsToRecycle, checkRowToDraw);\n        indexesToDraw.sort(function (a, b) { return a - b; });\n        return indexesToDraw;\n    };\n    RowRenderer.prototype.redraw = function (rowsToRecycle, animate, afterScroll) {\n        var _this = this;\n        if (animate === void 0) { animate = false; }\n        if (afterScroll === void 0) { afterScroll = false; }\n        this.rowContainerHeightService.updateOffset();\n        this.workOutFirstAndLastRowsToRender();\n        // the row can already exist and be in the following:\n        // rowsToRecycle -> if model change, then the index may be different, however row may\n        //                         exist here from previous time (mapped by id).\n        // this.rowCompsByIndex -> if just a scroll, then this will contain what is currently in the viewport\n        // this is all the indexes we want, including those that already exist, so this method\n        // will end up going through each index and drawing only if the row doesn't already exist\n        var indexesToDraw = this.calculateIndexesToDraw(rowsToRecycle);\n        this.removeRowCompsNotToDraw(indexesToDraw);\n        // never animate when doing print layout - as we want to get things ready to print as quickly as possible,\n        // otherwise we risk the printer printing a row that's half faded (half way through fading in)\n        if (this.printLayout) {\n            animate = false;\n        }\n        // add in new rows\n        var rowCtrls = [];\n        indexesToDraw.forEach(function (rowIndex) {\n            var rowCtrl = _this.createOrUpdateRowCtrl(rowIndex, rowsToRecycle, animate, afterScroll);\n            if (exists(rowCtrl)) {\n                rowCtrls.push(rowCtrl);\n            }\n        });\n        if (rowsToRecycle) {\n            var useAnimationFrame = afterScroll && !this.gridOptionsWrapper.isSuppressAnimationFrame() && !this.printLayout;\n            if (useAnimationFrame) {\n                this.beans.animationFrameService.addDestroyTask(function () {\n                    _this.destroyRowCtrls(rowsToRecycle, animate);\n                    _this.updateAllRowCtrls();\n                    _this.dispatchDisplayedRowsChanged();\n                });\n            }\n            else {\n                this.destroyRowCtrls(rowsToRecycle, animate);\n            }\n        }\n        this.updateAllRowCtrls();\n        this.checkAngularCompile();\n        this.gridBodyCtrl.updateRowCount();\n    };\n    RowRenderer.prototype.dispatchDisplayedRowsChanged = function () {\n        var event = { type: Events.EVENT_DISPLAYED_ROWS_CHANGED };\n        this.eventService.dispatchEvent(event);\n    };\n    RowRenderer.prototype.onDisplayedColumnsChanged = function () {\n        var pinningLeft = this.columnModel.isPinningLeft();\n        var pinningRight = this.columnModel.isPinningRight();\n        var atLeastOneChanged = this.pinningLeft !== pinningLeft || pinningRight !== this.pinningRight;\n        if (atLeastOneChanged) {\n            this.pinningLeft = pinningLeft;\n            this.pinningRight = pinningRight;\n            if (this.embedFullWidthRows) {\n                this.redrawFullWidthEmbeddedRows();\n            }\n        }\n    };\n    // when embedding, what gets showed in each section depends on what is pinned. eg if embedding group expand / collapse,\n    // then it should go into the pinned left area if pinning left, or the center area if not pinning.\n    RowRenderer.prototype.redrawFullWidthEmbeddedRows = function () {\n        // if either of the pinned panels has shown / hidden, then need to redraw the fullWidth bits when\n        // embedded, as what appears in each section depends on whether we are pinned or not\n        var rowsToRemove = [];\n        iterateObject(this.rowCtrlsByRowIndex, function (id, rowComp) {\n            if (rowComp.isFullWidth()) {\n                var rowIndex = rowComp.getRowNode().rowIndex;\n                rowsToRemove.push(rowIndex.toString());\n            }\n        });\n        this.refreshFloatingRowComps();\n        this.removeRowCtrls(rowsToRemove);\n        this.redrawAfterScroll();\n    };\n    RowRenderer.prototype.refreshFullWidthRows = function (rowNodesToRefresh) {\n        var rowsToRemove = [];\n        var selectivelyRefreshing = !!rowNodesToRefresh;\n        var idsToRefresh = selectivelyRefreshing ? {} : undefined;\n        if (selectivelyRefreshing && idsToRefresh) {\n            rowNodesToRefresh.forEach(function (r) { return idsToRefresh[r.id] = true; });\n        }\n        iterateObject(this.rowCtrlsByRowIndex, function (id, rowCtrl) {\n            if (!rowCtrl.isFullWidth()) {\n                return;\n            }\n            var rowNode = rowCtrl.getRowNode();\n            if (selectivelyRefreshing && idsToRefresh) {\n                // we refresh if a) this node is present or b) this parents nodes is present. checking parent\n                // node is important for master/detail, as we want detail to refresh on changes to parent node.\n                // it's also possible, if user is provider their own fullWidth, that details panels contain\n                // some info on the parent, eg if in tree data and child row shows some data from parent row also.\n                var parentId = (rowNode.level > 0 && rowNode.parent) ? rowNode.parent.id : undefined;\n                var skipThisNode = !idsToRefresh[rowNode.id] && !idsToRefresh[parentId];\n                if (skipThisNode) {\n                    return;\n                }\n            }\n            var fullWidthRowsRefreshed = rowCtrl.refreshFullWidth();\n            if (!fullWidthRowsRefreshed) {\n                var rowIndex = rowCtrl.getRowNode().rowIndex;\n                rowsToRemove.push(rowIndex.toString());\n            }\n        });\n        this.removeRowCtrls(rowsToRemove);\n        this.redrawAfterScroll();\n    };\n    RowRenderer.prototype.createOrUpdateRowCtrl = function (rowIndex, rowsToRecycle, animate, afterScroll) {\n        var rowNode;\n        var rowCon = this.rowCtrlsByRowIndex[rowIndex];\n        // if no row comp, see if we can get it from the previous rowComps\n        if (!rowCon) {\n            rowNode = this.paginationProxy.getRow(rowIndex);\n            if (exists(rowNode) && exists(rowsToRecycle) && rowsToRecycle[rowNode.id] && rowNode.alreadyRendered) {\n                rowCon = rowsToRecycle[rowNode.id];\n                rowsToRecycle[rowNode.id] = null;\n            }\n        }\n        var creatingNewRowCon = !rowCon;\n        if (creatingNewRowCon) {\n            // create a new one\n            if (!rowNode) {\n                rowNode = this.paginationProxy.getRow(rowIndex);\n            }\n            if (exists(rowNode)) {\n                rowCon = this.createRowCon(rowNode, animate, afterScroll);\n            }\n            else {\n                // this should never happen - if somehow we are trying to create\n                // a row for a rowNode that does not exist.\n                return;\n            }\n        }\n        if (rowNode) {\n            // set node as 'alreadyRendered' to ensure we only recycle rowComps that have been rendered, this ensures\n            // we don't reuse rowComps that have been removed and then re-added in the same batch transaction.\n            rowNode.alreadyRendered = true;\n        }\n        this.rowCtrlsByRowIndex[rowIndex] = rowCon;\n        return rowCon;\n    };\n    RowRenderer.prototype.destroyRowCtrls = function (rowCtrlsMap, animate) {\n        var _this = this;\n        var executeInAWhileFuncs = [];\n        iterateObject(rowCtrlsMap, function (nodeId, rowCtrl) {\n            // if row was used, then it's null\n            if (!rowCtrl) {\n                return;\n            }\n            if (_this.cachedRowCtrls && rowCtrl.isCacheable()) {\n                _this.cachedRowCtrls.addRow(rowCtrl);\n                return;\n            }\n            rowCtrl.destroyFirstPass();\n            if (animate) {\n                _this.zombieRowCtrls[rowCtrl.getInstanceId()] = rowCtrl;\n                executeInAWhileFuncs.push(function () {\n                    rowCtrl.destroySecondPass();\n                    delete _this.zombieRowCtrls[rowCtrl.getInstanceId()];\n                });\n            }\n            else {\n                rowCtrl.destroySecondPass();\n            }\n        });\n        if (animate) {\n            // this ensures we fire displayedRowsChanged AFTER all the 'executeInAWhileFuncs' get\n            // executed, as we added it to the end of the list.\n            executeInAWhileFuncs.push(function () {\n                _this.updateAllRowCtrls();\n                _this.dispatchDisplayedRowsChanged();\n            });\n            executeInAWhile(executeInAWhileFuncs);\n        }\n    };\n    RowRenderer.prototype.checkAngularCompile = function () {\n        var _this = this;\n        // if we are doing angular compiling, then do digest the scope here\n        if (this.gridOptionsWrapper.isAngularCompileRows()) {\n            // we do it in a timeout, in case we are already in an apply\n            window.setTimeout(function () {\n                _this.$scope.$apply();\n            }, 0);\n        }\n    };\n    RowRenderer.prototype.workOutFirstAndLastRowsToRender = function () {\n        var _this = this;\n        var newFirst;\n        var newLast;\n        if (!this.paginationProxy.isRowsToRender()) {\n            newFirst = 0;\n            newLast = -1; // setting to -1 means nothing in range\n        }\n        else if (this.printLayout) {\n            newFirst = this.paginationProxy.getPageFirstRow();\n            newLast = this.paginationProxy.getPageLastRow();\n        }\n        else {\n            var bufferPixels = this.gridOptionsWrapper.getRowBufferInPixels();\n            var gridBodyCon = this.ctrlsService.getGridBodyCtrl();\n            var rowHeightsChanged = false;\n            var firstPixel = void 0;\n            var lastPixel = void 0;\n            do {\n                var paginationOffset = this.paginationProxy.getPixelOffset();\n                var _a = this.paginationProxy.getCurrentPagePixelRange(), pageFirstPixel = _a.pageFirstPixel, pageLastPixel = _a.pageLastPixel;\n                var divStretchOffset = this.rowContainerHeightService.getDivStretchOffset();\n                var bodyVRange = gridBodyCon.getScrollFeature().getVScrollPosition();\n                var bodyTopPixel = bodyVRange.top;\n                var bodyBottomPixel = bodyVRange.bottom;\n                firstPixel = Math.max(bodyTopPixel + paginationOffset - bufferPixels, pageFirstPixel) + divStretchOffset;\n                lastPixel = Math.min(bodyBottomPixel + paginationOffset + bufferPixels, pageLastPixel) + divStretchOffset;\n                // if the rows we are about to display get their heights changed, then that upsets the calcs from above.\n                rowHeightsChanged = this.ensureAllRowsInRangeHaveHeightsCalculated(firstPixel, lastPixel);\n            } while (rowHeightsChanged);\n            var firstRowIndex = this.paginationProxy.getRowIndexAtPixel(firstPixel);\n            var lastRowIndex = this.paginationProxy.getRowIndexAtPixel(lastPixel);\n            var pageFirstRow = this.paginationProxy.getPageFirstRow();\n            var pageLastRow = this.paginationProxy.getPageLastRow();\n            // adjust, in case buffer extended actual size\n            if (firstRowIndex < pageFirstRow) {\n                firstRowIndex = pageFirstRow;\n            }\n            if (lastRowIndex > pageLastRow) {\n                lastRowIndex = pageLastRow;\n            }\n            newFirst = firstRowIndex;\n            newLast = lastRowIndex;\n        }\n        // sometimes user doesn't set CSS right and ends up with grid with no height and grid ends up\n        // trying to render all the rows, eg 10,000+ rows. this will kill the browser. so instead of\n        // killing the browser, we limit the number of rows. just in case some use case we didn't think\n        // of, we also have a property to not do this operation.\n        var rowLayoutNormal = this.gridOptionsWrapper.getDomLayout() === Constants.DOM_LAYOUT_NORMAL;\n        var suppressRowCountRestriction = this.gridOptionsWrapper.isSuppressMaxRenderedRowRestriction();\n        var rowBufferMaxSize = Math.max(this.gridOptionsWrapper.getRowBuffer(), 500);\n        if (rowLayoutNormal && !suppressRowCountRestriction) {\n            if (newLast - newFirst > rowBufferMaxSize) {\n                newLast = newFirst + rowBufferMaxSize;\n            }\n        }\n        var firstDiffers = newFirst !== this.firstRenderedRow;\n        var lastDiffers = newLast !== this.lastRenderedRow;\n        if (firstDiffers || lastDiffers) {\n            this.firstRenderedRow = newFirst;\n            this.lastRenderedRow = newLast;\n            var event_1 = {\n                type: Events.EVENT_VIEWPORT_CHANGED,\n                firstRow: newFirst,\n                lastRow: newLast,\n                api: this.gridApi,\n                columnApi: this.columnApi\n            };\n            this.eventService.dispatchEvent(event_1);\n        }\n        // only dispatch firstDataRendered if we have actually rendered some data\n        if (this.paginationProxy.isRowsToRender()) {\n            var event_2 = {\n                type: Events.EVENT_FIRST_DATA_RENDERED,\n                firstRow: newFirst,\n                lastRow: newLast,\n                api: this.gridApi,\n                columnApi: this.columnApi\n            };\n            // added a small delay here because in some scenarios this can be fired\n            // before the grid is actually rendered, causing component creation\n            // on EVENT_FIRST_DATA_RENDERED to fail.\n            window.setTimeout(function () { return _this.eventService.dispatchEventOnce(event_2); }, 50);\n        }\n    };\n    RowRenderer.prototype.ensureAllRowsInRangeHaveHeightsCalculated = function (topPixel, bottomPixel) {\n        // ensureRowHeightsVisible only works with CSRM, as it's the only row model that allows lazy row height calcs.\n        // all the other row models just hard code so the method just returns back false\n        var res = this.paginationProxy.ensureRowHeightsValid(topPixel, bottomPixel, -1, -1);\n        if (res) {\n            this.updateContainerHeights();\n        }\n        return res;\n    };\n    RowRenderer.prototype.getFirstVirtualRenderedRow = function () {\n        return this.firstRenderedRow;\n    };\n    RowRenderer.prototype.getLastVirtualRenderedRow = function () {\n        return this.lastRenderedRow;\n    };\n    // check that none of the rows to remove are editing or focused as:\n    // a) if editing, we want to keep them, otherwise the user will loose the context of the edit,\n    //    eg user starts editing, enters some text, then scrolls down and then up, next time row rendered\n    //    the edit is reset - so we want to keep it rendered.\n    // b) if focused, we want ot keep keyboard focus, so if user ctrl+c, it goes to clipboard,\n    //    otherwise the user can range select and drag (with focus cell going out of the viewport)\n    //    and then ctrl+c, nothing will happen if cell is removed from dom.\n    // c) if detail record of master detail, as users complained that the context of detail rows\n    //    was getting lost when detail row out of view. eg user expands to show detail row,\n    //    then manipulates the detail panel (eg sorts the detail grid), then context is lost\n    //    after detail panel is scrolled out of / into view.\n    RowRenderer.prototype.doNotUnVirtualiseRow = function (rowComp) {\n        var REMOVE_ROW = false;\n        var KEEP_ROW = true;\n        var rowNode = rowComp.getRowNode();\n        var rowHasFocus = this.focusService.isRowNodeFocused(rowNode);\n        var rowIsEditing = rowComp.isEditing();\n        var rowIsDetail = rowNode.detail;\n        var mightWantToKeepRow = rowHasFocus || rowIsEditing || rowIsDetail;\n        // if we deffo don't want to keep it,\n        if (!mightWantToKeepRow) {\n            return REMOVE_ROW;\n        }\n        // editing row, only remove if it is no longer rendered, eg filtered out or new data set.\n        // the reason we want to keep is if user is scrolling up and down, we don't want to loose\n        // the context of the editing in process.\n        var rowNodePresent = this.paginationProxy.isRowPresent(rowNode);\n        return rowNodePresent ? KEEP_ROW : REMOVE_ROW;\n    };\n    RowRenderer.prototype.createRowCon = function (rowNode, animate, afterScroll) {\n        var rowCtrlFromCache = this.cachedRowCtrls ? this.cachedRowCtrls.getRow(rowNode) : null;\n        if (rowCtrlFromCache) {\n            return rowCtrlFromCache;\n        }\n        // we don't use animations frames for printing, so the user can put the grid into print mode\n        // and immediately print - otherwise the user would have to wait for the rows to draw in the background\n        // (via the animation frames) which is awkward to do from code.\n        // we only do the animation frames after scrolling, as this is where we want the smooth user experience.\n        // having animation frames for other times makes the grid look 'jumpy'.\n        var suppressAnimationFrame = this.gridOptionsWrapper.isSuppressAnimationFrame();\n        var useAnimationFrameForCreate = afterScroll && !suppressAnimationFrame && !this.printLayout;\n        var res = new RowCtrl(this.$scope, rowNode, this.beans, animate, useAnimationFrameForCreate, this.printLayout);\n        return res;\n    };\n    RowRenderer.prototype.getRenderedNodes = function () {\n        var renderedRows = this.rowCtrlsByRowIndex;\n        return Object.keys(renderedRows).map(function (key) { return renderedRows[key].getRowNode(); });\n    };\n    RowRenderer.prototype.getRowByPosition = function (rowPosition) {\n        var rowComponent;\n        switch (rowPosition.rowPinned) {\n            case Constants.PINNED_TOP:\n                rowComponent = this.topRowCtrls[rowPosition.rowIndex];\n                break;\n            case Constants.PINNED_BOTTOM:\n                rowComponent = this.bottomRowCtrls[rowPosition.rowIndex];\n                break;\n            default:\n                rowComponent = this.rowCtrlsByRowIndex[rowPosition.rowIndex];\n                break;\n        }\n        return rowComponent;\n    };\n    RowRenderer.prototype.getRowNode = function (gridRow) {\n        switch (gridRow.rowPinned) {\n            case Constants.PINNED_TOP:\n                return this.pinnedRowModel.getPinnedTopRowData()[gridRow.rowIndex];\n            case Constants.PINNED_BOTTOM:\n                return this.pinnedRowModel.getPinnedBottomRowData()[gridRow.rowIndex];\n            default:\n                return this.rowModel.getRow(gridRow.rowIndex);\n        }\n    };\n    // returns true if any row between startIndex and endIndex is rendered. used by\n    // SSRM or IRM, as they don't want to purge visible blocks from cache.\n    RowRenderer.prototype.isRangeInRenderedViewport = function (startIndex, endIndex) {\n        // parent closed means the parent node is not expanded, thus these blocks are not visible\n        var parentClosed = startIndex == null || endIndex == null;\n        if (parentClosed) {\n            return false;\n        }\n        var blockAfterViewport = startIndex > this.lastRenderedRow;\n        var blockBeforeViewport = endIndex < this.firstRenderedRow;\n        var blockInsideViewport = !blockBeforeViewport && !blockAfterViewport;\n        return blockInsideViewport;\n    };\n    __decorate([\n        Autowired(\"paginationProxy\")\n    ], RowRenderer.prototype, \"paginationProxy\", void 0);\n    __decorate([\n        Autowired(\"columnModel\")\n    ], RowRenderer.prototype, \"columnModel\", void 0);\n    __decorate([\n        Autowired(\"$scope\")\n    ], RowRenderer.prototype, \"$scope\", void 0);\n    __decorate([\n        Autowired(\"pinnedRowModel\")\n    ], RowRenderer.prototype, \"pinnedRowModel\", void 0);\n    __decorate([\n        Autowired(\"rowModel\")\n    ], RowRenderer.prototype, \"rowModel\", void 0);\n    __decorate([\n        Autowired(\"focusService\")\n    ], RowRenderer.prototype, \"focusService\", void 0);\n    __decorate([\n        Autowired(\"columnApi\")\n    ], RowRenderer.prototype, \"columnApi\", void 0);\n    __decorate([\n        Autowired(\"gridApi\")\n    ], RowRenderer.prototype, \"gridApi\", void 0);\n    __decorate([\n        Autowired(\"beans\")\n    ], RowRenderer.prototype, \"beans\", void 0);\n    __decorate([\n        Autowired(\"rowContainerHeightService\")\n    ], RowRenderer.prototype, \"rowContainerHeightService\", void 0);\n    __decorate([\n        Optional(\"ctrlsService\")\n    ], RowRenderer.prototype, \"ctrlsService\", void 0);\n    __decorate([\n        PostConstruct\n    ], RowRenderer.prototype, \"postConstruct\", null);\n    RowRenderer = __decorate([\n        Bean(\"rowRenderer\")\n    ], RowRenderer);\n    return RowRenderer;\n}(BeanStub));\nexport { RowRenderer };\nvar RowCtrlCache = /** @class */ (function () {\n    function RowCtrlCache(maxCount) {\n        // map for fast access\n        this.entriesMap = {};\n        // list for keeping order\n        this.entriesList = [];\n        this.maxCount = maxCount;\n    }\n    RowCtrlCache.prototype.toString = function () {\n        return this.entriesList.map(function (item) { return item.getRowNode().data.name; }).join(', ');\n    };\n    RowCtrlCache.prototype.addRow = function (rowCtrl) {\n        this.entriesMap[rowCtrl.getRowNode().id] = rowCtrl;\n        this.entriesList.push(rowCtrl);\n        rowCtrl.setCached(true);\n        if (this.entriesList.length > this.maxCount) {\n            var rowCtrlToDestroy = this.entriesList[0];\n            rowCtrlToDestroy.destroyFirstPass();\n            rowCtrlToDestroy.destroySecondPass();\n            this.removeFromCache(rowCtrlToDestroy);\n        }\n    };\n    RowCtrlCache.prototype.getRow = function (rowNode) {\n        if (rowNode == null || rowNode.id == null) {\n            return null;\n        }\n        var res = this.entriesMap[rowNode.id];\n        if (!res) {\n            return null;\n        }\n        this.removeFromCache(res);\n        res.setCached(false);\n        // this can happen if user reloads data, and a new RowNode is reusing\n        // the same ID as the old one\n        var rowNodeMismatch = res.getRowNode() != rowNode;\n        return rowNodeMismatch ? null : res;\n    };\n    RowCtrlCache.prototype.removeFromCache = function (rowCtrl) {\n        var rowNodeId = rowCtrl.getRowNode().id;\n        delete this.entriesMap[rowNodeId];\n        removeFromArray(this.entriesList, rowCtrl);\n    };\n    RowCtrlCache.prototype.getEntries = function () {\n        return this.entriesList;\n    };\n    return RowCtrlCache;\n}());\n"]},"metadata":{},"sourceType":"module"}