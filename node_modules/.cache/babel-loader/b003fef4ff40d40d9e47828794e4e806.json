{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.MapUtil = void 0;\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _Map = _interopRequireDefault(require(\"ol/Map\"));\n\nvar _TileWMS = _interopRequireDefault(require(\"ol/source/TileWMS\"));\n\nvar _ImageWMS = _interopRequireDefault(require(\"ol/source/ImageWMS\"));\n\nvar _Group = _interopRequireDefault(require(\"ol/layer/Group\"));\n\nvar _Base = _interopRequireDefault(require(\"ol/layer/Base\"));\n\nvar _GeometryCollection = _interopRequireDefault(require(\"ol/geom/GeometryCollection\"));\n\nvar _Units = require(\"ol/proj/Units\");\n\nvar _UrlUtil = _interopRequireDefault(require(\"@terrestris/base-util/dist/UrlUtil/UrlUtil\"));\n\nvar _Logger = _interopRequireDefault(require(\"@terrestris/base-util/dist/Logger\"));\n\nvar _FeatureUtil = _interopRequireDefault(require(\"../FeatureUtil/FeatureUtil\"));\n\nvar _findIndex = _interopRequireDefault(require(\"lodash/findIndex\"));\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n/**\n * Helper class for the OpenLayers map.\n *\n * @class\n */\n\n\nvar MapUtil = /*#__PURE__*/function () {\n  function MapUtil() {\n    (0, _classCallCheck2[\"default\"])(this, MapUtil);\n  }\n\n  (0, _createClass2[\"default\"])(MapUtil, null, [{\n    key: \"getInteractionsByName\",\n    value:\n    /**\n     * Returns all interactions by the given name of a map.\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {string} name The name of the interaction to look for.\n     * @return {ol.interaction[]} The list of result interactions.\n     */\n    function getInteractionsByName(map, name) {\n      var interactionCandidates = [];\n\n      if (!(map instanceof _Map[\"default\"])) {\n        _Logger[\"default\"].debug('Input parameter map must be from type `ol.Map`.');\n\n        return interactionCandidates;\n      }\n\n      var interactions = map.getInteractions();\n      interactions.forEach(function (interaction) {\n        if (interaction.get('name') === name) {\n          interactionCandidates.push(interaction);\n        }\n      });\n      return interactionCandidates;\n    }\n    /**\n     * Returns all interactions of the given class of the passed map.\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {ol.interaction} clazz The class of the interaction to look for.\n     * @return {ol.interaction[]} The list of result interactions.\n     */\n\n  }, {\n    key: \"getInteractionsByClass\",\n    value: function getInteractionsByClass(map, clazz) {\n      var interactionCandidates = [];\n\n      if (!(map instanceof _Map[\"default\"])) {\n        _Logger[\"default\"].debug('Input parameter map must be from type `ol.Map`.');\n\n        return interactionCandidates;\n      }\n\n      var interactions = map.getInteractions();\n      interactions.forEach(function (interaction) {\n        if (interaction instanceof clazz) {\n          interactionCandidates.push(interaction);\n        }\n      });\n      return interactionCandidates;\n    }\n    /**\n     * Calculates the appropriate map resolution for a given scale in the given\n     * units.\n     *\n     * See: https://gis.stackexchange.com/questions/158435/\n     * how-to-get-current-scale-in-openlayers-3\n     *\n     * @method\n     * @param {number} scale The input scale to calculate the appropriate\n     *                       resolution for.\n     * @param {string} units The units to use for calculation (m or degrees).\n     * @return {number} The calculated resolution.\n     */\n\n  }, {\n    key: \"getResolutionForScale\",\n    value: function getResolutionForScale(scale, units) {\n      var dpi = 25.4 / 0.28;\n      var mpu = _Units.METERS_PER_UNIT[units];\n      var inchesPerMeter = 39.37;\n      return parseFloat(scale) / (mpu * inchesPerMeter * dpi);\n    }\n    /**\n     * Returns the appropriate scale for the given resolution and units.\n     *\n     * @method\n     * @param {number} resolution The resolutions to calculate the scale for.\n     * @param {string} units The units the resolution is based on, typically\n     *                       either 'm' or 'degrees'.\n     * @return {number} The appropriate scale.\n     */\n\n  }, {\n    key: \"getScaleForResolution\",\n    value: function getScaleForResolution(resolution, units) {\n      var dpi = 25.4 / 0.28;\n      var mpu = _Units.METERS_PER_UNIT[units];\n      var inchesPerMeter = 39.37;\n      return parseFloat(resolution) * mpu * inchesPerMeter * dpi;\n    }\n    /**\n     * Returns all layers of a collection. Even the hidden ones.\n     *\n     * @param {ol.Map|ol.layer.Group} collection The collection to get the layers\n     *                                           from. This can be an ol.layer.Group\n     *                                           or an ol.Map.\n     * @param {Function} [filter] A filter function that receives the layer.\n     *                            If it returns true it will be included in the\n     *                            returned layers.\n     * @return {Array} An array of all Layers.\n     */\n\n  }, {\n    key: \"getAllLayers\",\n    value: function getAllLayers(collection) {\n      var filter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n        return true;\n      };\n\n      if (!(collection instanceof _Map[\"default\"]) && !(collection instanceof _Group[\"default\"])) {\n        _Logger[\"default\"].error('Input parameter collection must be from type `ol.Map`' + 'or `ol.layer.Group`.');\n\n        return [];\n      }\n\n      var layers = collection.getLayers().getArray();\n      var allLayers = [];\n      layers.forEach(function (layer) {\n        if (layer instanceof _Group[\"default\"]) {\n          MapUtil.getAllLayers(layer).forEach(function (layeri) {\n            if (filter(layeri)) {\n              allLayers.push(layeri);\n            }\n          });\n        }\n\n        if (filter(layer)) {\n          allLayers.push(layer);\n        }\n      });\n      return allLayers;\n    }\n    /**\n     * Get a layer by its key (ol_uid).\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {string} ol_uid The ol_uid of a layer.\n     * @return {ol.layer.Layer} The layer.\n     */\n\n  }, {\n    key: \"getLayerByName\",\n    value:\n    /**\n     * Returns the layer from the provided map by the given name.\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {string} name The name to get the layer by.\n     * @return {ol.Layer} The result layer or undefined if the layer could not\n     *                    be found.\n     */\n    function getLayerByName(map, name) {\n      var layers = MapUtil.getAllLayers(map);\n      return layers.filter(function (layer) {\n        return layer.get('name') === name;\n      })[0];\n    }\n    /**\n     * Returns the layer from the provided map by the given name\n     * (parameter LAYERS).\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {string} name The name to get the layer by.\n     * @return {ol.Layer} The result layer or undefined if the layer could not\n     *                    be found.\n     */\n\n  }, {\n    key: \"getLayerByNameParam\",\n    value: function getLayerByNameParam(map, name) {\n      var layers = MapUtil.getAllLayers(map);\n      var layerCandidate;\n\n      var _iterator = _createForOfIteratorHelper(layers),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var layer = _step.value;\n\n          if (layer.getSource && layer.getSource().getParams && layer.getSource().getParams()['LAYERS'] === name) {\n            layerCandidate = layer;\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return layerCandidate;\n    }\n    /**\n     * Returns the layer from the provided map by the given feature.\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {ol.Feature} feature The feature to get the layer by.\n     * @param {Array} namespaces list of supported GeoServer namespaces.\n     * @return {ol.Layer} The result layer or undefined if the layer could not\n     *                    be found.\n     */\n\n  }, {\n    key: \"getLayerByFeature\",\n    value: function getLayerByFeature(map, feature, namespaces) {\n      var featureTypeName = _FeatureUtil[\"default\"].getFeatureTypeName(feature);\n\n      var layerCandidate;\n\n      var _iterator2 = _createForOfIteratorHelper(namespaces),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var namespace = _step2.value;\n          var qualifiedFeatureTypeName = \"\".concat(namespace, \":\").concat(featureTypeName);\n          var layer = MapUtil.getLayerByNameParam(map, qualifiedFeatureTypeName);\n\n          if (layer) {\n            layerCandidate = layer;\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return layerCandidate;\n    }\n    /**\n     * Returns all layers of the specified layer group recursively.\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {ol.Layer.Group} layerGroup The group to flatten.\n     * @return {Array} The (flattened) layers from the group\n     */\n\n  }, {\n    key: \"getLayersByGroup\",\n    value: function getLayersByGroup(map, layerGroup) {\n      var layerCandidates = [];\n      layerGroup.getLayers().forEach(function (layer) {\n        if (layer instanceof _Group[\"default\"]) {\n          layerCandidates.push.apply(layerCandidates, (0, _toConsumableArray2[\"default\"])(MapUtil.getLayersByGroup(map, layer)));\n        } else {\n          layerCandidates.push(layer);\n        }\n      });\n      return layerCandidates;\n    }\n    /**\n     * Returns the list of layers matching the given pair of properties.\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {string} key The property key.\n     * @param {Object} value The property value.\n     *\n     * @return {ol.layer.Base[]} The array of matching layers.\n     */\n\n  }, {\n    key: \"getLayersByProperty\",\n    value: function getLayersByProperty(map, key, value) {\n      if (!map || !key) {\n        return;\n      }\n\n      var mapLayers = MapUtil.getAllLayers(map);\n      return mapLayers.filter(function (l) {\n        return l.get(key) === value;\n      });\n    }\n    /**\n     * Get information about the LayerPosition in the tree.\n     *\n     * @param {ol.layer.Layer} layer The layer to get the information.\n     * @param {ol.layer.Group|ol.Map} [groupLayerOrMap] The groupLayer or map\n     *                                                  containing the layer.\n     * @return {Object} An object with these keys:\n     *    {ol.layer.Group} groupLayer The groupLayer containing the layer.\n     *    {Integer} position The position of the layer in the collection.\n     */\n\n  }, {\n    key: \"getLayerPositionInfo\",\n    value: function getLayerPositionInfo(layer, groupLayerOrMap) {\n      var groupLayer = groupLayerOrMap instanceof _Group[\"default\"] ? groupLayerOrMap : groupLayerOrMap.getLayerGroup();\n      var layers = groupLayer.getLayers().getArray();\n      var info = {};\n\n      if (layers.indexOf(layer) < 0) {\n        layers.forEach(function (childLayer) {\n          if (childLayer instanceof _Group[\"default\"] && !info.groupLayer) {\n            info = MapUtil.getLayerPositionInfo(layer, childLayer);\n          }\n        });\n      } else {\n        info.position = layers.indexOf(layer);\n        info.groupLayer = groupLayer;\n      }\n\n      return info;\n    }\n    /**\n     * Get the getlegendGraphic url of a layer. Designed for geoserver.\n     * Currently supported Sources:\n     *  - ol.source.TileWms (with url configured)\n     *  - ol.source.ImageWms (with url configured)\n     *\n     * @param {ol.layer.Layer} layer The layer that you want to have a legendUrlfor.\n     * @return {string|undefined} The getLegendGraphicUrl.\n     */\n\n  }, {\n    key: \"getLegendGraphicUrl\",\n    value: function getLegendGraphicUrl(layer, extraParams) {\n      if (!layer) {\n        _Logger[\"default\"].error('No layer passed to MapUtil.getLegendGraphicUrl.');\n\n        return;\n      }\n\n      var source = layer.getSource();\n\n      if (!(layer instanceof _Base[\"default\"]) || !source) {\n        _Logger[\"default\"].error('Invalid layer passed to MapUtil.getLegendGraphicUrl.');\n\n        return;\n      }\n\n      var isTiledWMS = source instanceof _TileWMS[\"default\"];\n      var isImageWMS = source instanceof _ImageWMS[\"default\"];\n\n      if (isTiledWMS || isImageWMS) {\n        var _source = layer.getSource();\n\n        var url = isTiledWMS ? _source.getUrls() ? _source.getUrls()[0] : '' : _source.getUrl();\n        var params = {\n          LAYER: _source.getParams().LAYERS,\n          VERSION: '1.3.0',\n          SERVICE: 'WMS',\n          REQUEST: 'getLegendGraphic',\n          FORMAT: 'image/png'\n        };\n\n        var queryString = _UrlUtil[\"default\"].objectToRequestString(Object.assign(params, extraParams));\n\n        return /\\?/.test(url) ? \"\".concat(url, \"&\").concat(queryString) : \"\".concat(url, \"?\").concat(queryString);\n      } else {\n        _Logger[\"default\"].warn(\"Source of \\\"\".concat(layer.get('name'), \"\\\" is currently not supported \") + \"by MapUtil.getLegendGraphicUrl.\");\n\n        return;\n      }\n    }\n    /**\n     * Checks whether the resolution of the passed map's view lies inside of the\n     * min- and max-resolution of the passed layer, e.g. whether the layer should\n     * be displayed at the current map view resolution.\n     *\n     * @param {ol.layer.Layer} layer The layer to check.\n     * @param {ol.Map} map The map to get the view resolution for comparison\n     *     from.\n     * @return {boolean} Whether the resolution of the passed map's view lies\n     *     inside of the min- and max-resolution of the passed layer, e.g. whether\n     *     the layer should be displayed at the current map view resolution. Will\n     *     be `false` when no `layer` or no `map` is passed or if the view of the\n     *     map is falsy or does not have a resolution (yet).\n     */\n\n  }, {\n    key: \"layerInResolutionRange\",\n    value: function layerInResolutionRange(layer, map) {\n      var mapView = map && map.getView();\n      var currentRes = mapView && mapView.getResolution();\n\n      if (!layer || !mapView || !currentRes) {\n        // It is questionable what we should return in this case, I opted for\n        // false, since we cannot sanely determine a correct answer.\n        return false;\n      }\n\n      var layerMinRes = layer.getMinResolution(); // default: 0 if unset\n\n      var layerMaxRes = layer.getMaxResolution(); // default: Infinity if unset\n      // minimum resolution is inclusive, maximum resolution exclusive\n\n      var within = currentRes >= layerMinRes && currentRes < layerMaxRes;\n      return within;\n    }\n    /**\n     * Rounds a scalenumber in dependency to its size.\n     *\n     * @param  {number} scale The exact scale\n     * @return {number} The roundedScale\n     */\n\n  }, {\n    key: \"roundScale\",\n    value: function roundScale(scale) {\n      var roundScale;\n\n      if (scale < 100) {\n        roundScale = Math.round(scale, 10);\n      }\n\n      if (scale >= 100 && scale < 10000) {\n        roundScale = Math.round(scale / 10) * 10;\n      }\n\n      if (scale >= 10000 && scale < 1000000) {\n        roundScale = Math.round(scale / 100) * 100;\n      }\n\n      if (scale >= 1000000) {\n        roundScale = Math.round(scale / 1000) * 1000;\n      }\n\n      return roundScale;\n    }\n    /**\n     * Returns the appropriate zoom level for the given scale and units.\n      * @method\n     * @param {number} scale Map scale to get the zoom for.\n     * @param {Array} resolutions Resolutions array.\n     * @param {string} units The units the resolutions are based on, typically\n     *                       either 'm' or 'degrees'. Default is 'm'.\n     *\n     * @return {number} Determined zoom level for the given scale.\n     */\n\n  }, {\n    key: \"getZoomForScale\",\n    value: function getZoomForScale(scale, resolutions) {\n      var units = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'm';\n\n      if (Number.isNaN(Number(scale))) {\n        return 0;\n      }\n\n      if (scale < 0) {\n        return 0;\n      }\n\n      var calculatedResolution = MapUtil.getResolutionForScale(scale, units);\n      var closestVal = resolutions.reduce(function (prev, curr) {\n        var res = Math.abs(curr - calculatedResolution) < Math.abs(prev - calculatedResolution) ? curr : prev;\n        return res;\n      });\n      var zoom = (0, _findIndex[\"default\"])(resolutions, function (o) {\n        return Math.abs(o - closestVal) <= 1e-10;\n      });\n      return zoom;\n    }\n    /**\n     * Fits the map's view to the extent of the passed features.\n     *\n     * @param {ol.Map} map The map to get the view from.\n     * @param {ol.Feature[]} features The features to zoom to.\n     */\n\n  }, {\n    key: \"zoomToFeatures\",\n    value: function zoomToFeatures(map, features) {\n      if (!(map instanceof _Map[\"default\"])) {\n        return;\n      }\n\n      var featGeometries = [];\n      features.forEach(function (feature) {\n        if (feature.getGeometry() !== null) {\n          featGeometries.push(feature.getGeometry());\n        }\n      });\n\n      if (featGeometries.length > 0) {\n        var geomCollection = new _GeometryCollection[\"default\"](featGeometries);\n        map.getView().fit(geomCollection.getExtent());\n      }\n    }\n    /**\n     * Checks if the given layer is visible for the given resolution.\n     *\n     * @param {ol.layer.Base} layer The layer.\n     * @param {number} resolution The resolution of the map\n     */\n\n  }, {\n    key: \"isInScaleRange\",\n    value: function isInScaleRange(layer, resolution) {\n      return resolution >= layer.get('minResolution') && resolution < layer.get('maxResolution');\n    }\n  }]);\n  return MapUtil;\n}();\n\nexports.MapUtil = MapUtil;\n(0, _defineProperty2[\"default\"])(MapUtil, \"getLayerByOlUid\", function (map, ol_uid) {\n  var layers = MapUtil.getAllLayers(map);\n  var layer = layers.find(function (l) {\n    return ol_uid === l.ol_uid.toString();\n  });\n  return layer;\n});\nvar _default = MapUtil;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["/Users/rongxuan/Desktop/reactmap/reactmap/node_modules/@terrestris/ol-util/dist/MapUtil/MapUtil.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","MapUtil","_toConsumableArray2","_classCallCheck2","_createClass2","_defineProperty2","_Map","_TileWMS","_ImageWMS","_Group","_Base","_GeometryCollection","_Units","_UrlUtil","_Logger","_FeatureUtil","_findIndex","_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","length","i","F","s","n","done","e","_e","f","TypeError","normalCompletion","didErr","err","call","step","next","_e2","minLen","_arrayLikeToArray","prototype","toString","slice","constructor","name","from","test","arr","len","arr2","key","getInteractionsByName","map","interactionCandidates","debug","interactions","getInteractions","forEach","interaction","get","push","getInteractionsByClass","clazz","getResolutionForScale","scale","units","dpi","mpu","METERS_PER_UNIT","inchesPerMeter","parseFloat","getScaleForResolution","resolution","getAllLayers","collection","filter","arguments","undefined","error","layers","getLayers","getArray","allLayers","layer","layeri","getLayerByName","getLayerByNameParam","layerCandidate","_iterator","_step","getSource","getParams","getLayerByFeature","feature","namespaces","featureTypeName","getFeatureTypeName","_iterator2","_step2","namespace","qualifiedFeatureTypeName","concat","getLayersByGroup","layerGroup","layerCandidates","apply","getLayersByProperty","mapLayers","l","getLayerPositionInfo","groupLayerOrMap","groupLayer","getLayerGroup","info","indexOf","childLayer","position","getLegendGraphicUrl","extraParams","source","isTiledWMS","isImageWMS","_source","url","getUrls","getUrl","params","LAYER","LAYERS","VERSION","SERVICE","REQUEST","FORMAT","queryString","objectToRequestString","assign","warn","layerInResolutionRange","mapView","getView","currentRes","getResolution","layerMinRes","getMinResolution","layerMaxRes","getMaxResolution","within","roundScale","Math","round","getZoomForScale","resolutions","Number","isNaN","calculatedResolution","closestVal","reduce","prev","curr","res","abs","zoom","zoomToFeatures","features","featGeometries","getGeometry","geomCollection","fit","getExtent","isInScaleRange","ol_uid","find","_default"],"mappings":"AAAA;;AAEA,IAAIA,sBAAsB,GAAGC,OAAO,CAAC,8CAAD,CAApC;;AAEAC,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAAC,SAAD,CAAP,GAAqBA,OAAO,CAACE,OAAR,GAAkB,KAAK,CAA5C;;AAEA,IAAIC,mBAAmB,GAAGP,sBAAsB,CAACC,OAAO,CAAC,0CAAD,CAAR,CAAhD;;AAEA,IAAIO,gBAAgB,GAAGR,sBAAsB,CAACC,OAAO,CAAC,uCAAD,CAAR,CAA7C;;AAEA,IAAIQ,aAAa,GAAGT,sBAAsB,CAACC,OAAO,CAAC,oCAAD,CAAR,CAA1C;;AAEA,IAAIS,gBAAgB,GAAGV,sBAAsB,CAACC,OAAO,CAAC,uCAAD,CAAR,CAA7C;;AAEA,IAAIU,IAAI,GAAGX,sBAAsB,CAACC,OAAO,CAAC,QAAD,CAAR,CAAjC;;AAEA,IAAIW,QAAQ,GAAGZ,sBAAsB,CAACC,OAAO,CAAC,mBAAD,CAAR,CAArC;;AAEA,IAAIY,SAAS,GAAGb,sBAAsB,CAACC,OAAO,CAAC,oBAAD,CAAR,CAAtC;;AAEA,IAAIa,MAAM,GAAGd,sBAAsB,CAACC,OAAO,CAAC,gBAAD,CAAR,CAAnC;;AAEA,IAAIc,KAAK,GAAGf,sBAAsB,CAACC,OAAO,CAAC,eAAD,CAAR,CAAlC;;AAEA,IAAIe,mBAAmB,GAAGhB,sBAAsB,CAACC,OAAO,CAAC,4BAAD,CAAR,CAAhD;;AAEA,IAAIgB,MAAM,GAAGhB,OAAO,CAAC,eAAD,CAApB;;AAEA,IAAIiB,QAAQ,GAAGlB,sBAAsB,CAACC,OAAO,CAAC,4CAAD,CAAR,CAArC;;AAEA,IAAIkB,OAAO,GAAGnB,sBAAsB,CAACC,OAAO,CAAC,mCAAD,CAAR,CAApC;;AAEA,IAAImB,YAAY,GAAGpB,sBAAsB,CAACC,OAAO,CAAC,4BAAD,CAAR,CAAzC;;AAEA,IAAIoB,UAAU,GAAGrB,sBAAsB,CAACC,OAAO,CAAC,kBAAD,CAAR,CAAvC;;AAEA,SAASqB,0BAAT,CAAoCC,CAApC,EAAuCC,cAAvC,EAAuD;AAAE,MAAIC,EAAE,GAAG,OAAOC,MAAP,KAAkB,WAAlB,IAAiCH,CAAC,CAACG,MAAM,CAACC,QAAR,CAAlC,IAAuDJ,CAAC,CAAC,YAAD,CAAjE;;AAAiF,MAAI,CAACE,EAAL,EAAS;AAAE,QAAIG,KAAK,CAACC,OAAN,CAAcN,CAAd,MAAqBE,EAAE,GAAGK,2BAA2B,CAACP,CAAD,CAArD,KAA6DC,cAAc,IAAID,CAAlB,IAAuB,OAAOA,CAAC,CAACQ,MAAT,KAAoB,QAA5G,EAAsH;AAAE,UAAIN,EAAJ,EAAQF,CAAC,GAAGE,EAAJ;AAAQ,UAAIO,CAAC,GAAG,CAAR;;AAAW,UAAIC,CAAC,GAAG,SAASA,CAAT,GAAa,CAAE,CAAvB;;AAAyB,aAAO;AAAEC,QAAAA,CAAC,EAAED,CAAL;AAAQE,QAAAA,CAAC,EAAE,SAASA,CAAT,GAAa;AAAE,cAAIH,CAAC,IAAIT,CAAC,CAACQ,MAAX,EAAmB,OAAO;AAAEK,YAAAA,IAAI,EAAE;AAAR,WAAP;AAAuB,iBAAO;AAAEA,YAAAA,IAAI,EAAE,KAAR;AAAe/B,YAAAA,KAAK,EAAEkB,CAAC,CAACS,CAAC,EAAF;AAAvB,WAAP;AAAwC,SAA5G;AAA8GK,QAAAA,CAAC,EAAE,SAASA,CAAT,CAAWC,EAAX,EAAe;AAAE,gBAAMA,EAAN;AAAW,SAA7I;AAA+IC,QAAAA,CAAC,EAAEN;AAAlJ,OAAP;AAA+J;;AAAC,UAAM,IAAIO,SAAJ,CAAc,uIAAd,CAAN;AAA+J;;AAAC,MAAIC,gBAAgB,GAAG,IAAvB;AAAA,MAA6BC,MAAM,GAAG,KAAtC;AAAA,MAA6CC,GAA7C;AAAkD,SAAO;AAAET,IAAAA,CAAC,EAAE,SAASA,CAAT,GAAa;AAAET,MAAAA,EAAE,GAAGA,EAAE,CAACmB,IAAH,CAAQrB,CAAR,CAAL;AAAkB,KAAtC;AAAwCY,IAAAA,CAAC,EAAE,SAASA,CAAT,GAAa;AAAE,UAAIU,IAAI,GAAGpB,EAAE,CAACqB,IAAH,EAAX;AAAsBL,MAAAA,gBAAgB,GAAGI,IAAI,CAACT,IAAxB;AAA8B,aAAOS,IAAP;AAAc,KAA5H;AAA8HR,IAAAA,CAAC,EAAE,SAASA,CAAT,CAAWU,GAAX,EAAgB;AAAEL,MAAAA,MAAM,GAAG,IAAT;AAAeC,MAAAA,GAAG,GAAGI,GAAN;AAAY,KAA9K;AAAgLR,IAAAA,CAAC,EAAE,SAASA,CAAT,GAAa;AAAE,UAAI;AAAE,YAAI,CAACE,gBAAD,IAAqBhB,EAAE,CAAC,QAAD,CAAF,IAAgB,IAAzC,EAA+CA,EAAE,CAAC,QAAD,CAAF;AAAiB,OAAtE,SAA+E;AAAE,YAAIiB,MAAJ,EAAY,MAAMC,GAAN;AAAY;AAAE;AAA7S,GAAP;AAAyT;;AAE5+B,SAASb,2BAAT,CAAqCP,CAArC,EAAwCyB,MAAxC,EAAgD;AAAE,MAAI,CAACzB,CAAL,EAAQ;AAAQ,MAAI,OAAOA,CAAP,KAAa,QAAjB,EAA2B,OAAO0B,iBAAiB,CAAC1B,CAAD,EAAIyB,MAAJ,CAAxB;AAAqC,MAAIb,CAAC,GAAGjC,MAAM,CAACgD,SAAP,CAAiBC,QAAjB,CAA0BP,IAA1B,CAA+BrB,CAA/B,EAAkC6B,KAAlC,CAAwC,CAAxC,EAA2C,CAAC,CAA5C,CAAR;AAAwD,MAAIjB,CAAC,KAAK,QAAN,IAAkBZ,CAAC,CAAC8B,WAAxB,EAAqClB,CAAC,GAAGZ,CAAC,CAAC8B,WAAF,CAAcC,IAAlB;AAAwB,MAAInB,CAAC,KAAK,KAAN,IAAeA,CAAC,KAAK,KAAzB,EAAgC,OAAOP,KAAK,CAAC2B,IAAN,CAAWhC,CAAX,CAAP;AAAsB,MAAIY,CAAC,KAAK,WAAN,IAAqB,2CAA2CqB,IAA3C,CAAgDrB,CAAhD,CAAzB,EAA6E,OAAOc,iBAAiB,CAAC1B,CAAD,EAAIyB,MAAJ,CAAxB;AAAsC;;AAEha,SAASC,iBAAT,CAA2BQ,GAA3B,EAAgCC,GAAhC,EAAqC;AAAE,MAAIA,GAAG,IAAI,IAAP,IAAeA,GAAG,GAAGD,GAAG,CAAC1B,MAA7B,EAAqC2B,GAAG,GAAGD,GAAG,CAAC1B,MAAV;;AAAkB,OAAK,IAAIC,CAAC,GAAG,CAAR,EAAW2B,IAAI,GAAG,IAAI/B,KAAJ,CAAU8B,GAAV,CAAvB,EAAuC1B,CAAC,GAAG0B,GAA3C,EAAgD1B,CAAC,EAAjD,EAAqD;AAAE2B,IAAAA,IAAI,CAAC3B,CAAD,CAAJ,GAAUyB,GAAG,CAACzB,CAAD,CAAb;AAAmB;;AAAC,SAAO2B,IAAP;AAAc;AAEvL;AACA;AACA;AACA;AACA;;;AACA,IAAIrD,OAAO,GAAG,aAAa,YAAY;AACrC,WAASA,OAAT,GAAmB;AACjB,KAAC,GAAGE,gBAAgB,CAAC,SAAD,CAApB,EAAiC,IAAjC,EAAuCF,OAAvC;AACD;;AAED,GAAC,GAAGG,aAAa,CAAC,SAAD,CAAjB,EAA8BH,OAA9B,EAAuC,IAAvC,EAA6C,CAAC;AAC5CsD,IAAAA,GAAG,EAAE,uBADuC;AAE5CvD,IAAAA,KAAK;AACL;AACJ;AACA;AACA;AACA;AACA;AACA;AACI,aAASwD,qBAAT,CAA+BC,GAA/B,EAAoCR,IAApC,EAA0C;AACxC,UAAIS,qBAAqB,GAAG,EAA5B;;AAEA,UAAI,EAAED,GAAG,YAAYnD,IAAI,CAAC,SAAD,CAArB,CAAJ,EAAuC;AACrCQ,QAAAA,OAAO,CAAC,SAAD,CAAP,CAAmB6C,KAAnB,CAAyB,iDAAzB;;AAEA,eAAOD,qBAAP;AACD;;AAED,UAAIE,YAAY,GAAGH,GAAG,CAACI,eAAJ,EAAnB;AACAD,MAAAA,YAAY,CAACE,OAAb,CAAqB,UAAUC,WAAV,EAAuB;AAC1C,YAAIA,WAAW,CAACC,GAAZ,CAAgB,MAAhB,MAA4Bf,IAAhC,EAAsC;AACpCS,UAAAA,qBAAqB,CAACO,IAAtB,CAA2BF,WAA3B;AACD;AACF,OAJD;AAKA,aAAOL,qBAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;AAjCgD,GAAD,EAmC1C;AACDH,IAAAA,GAAG,EAAE,wBADJ;AAEDvD,IAAAA,KAAK,EAAE,SAASkE,sBAAT,CAAgCT,GAAhC,EAAqCU,KAArC,EAA4C;AACjD,UAAIT,qBAAqB,GAAG,EAA5B;;AAEA,UAAI,EAAED,GAAG,YAAYnD,IAAI,CAAC,SAAD,CAArB,CAAJ,EAAuC;AACrCQ,QAAAA,OAAO,CAAC,SAAD,CAAP,CAAmB6C,KAAnB,CAAyB,iDAAzB;;AAEA,eAAOD,qBAAP;AACD;;AAED,UAAIE,YAAY,GAAGH,GAAG,CAACI,eAAJ,EAAnB;AACAD,MAAAA,YAAY,CAACE,OAAb,CAAqB,UAAUC,WAAV,EAAuB;AAC1C,YAAIA,WAAW,YAAYI,KAA3B,EAAkC;AAChCT,UAAAA,qBAAqB,CAACO,IAAtB,CAA2BF,WAA3B;AACD;AACF,OAJD;AAKA,aAAOL,qBAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA/BK,GAnC0C,EAoE1C;AACDH,IAAAA,GAAG,EAAE,uBADJ;AAEDvD,IAAAA,KAAK,EAAE,SAASoE,qBAAT,CAA+BC,KAA/B,EAAsCC,KAAtC,EAA6C;AAClD,UAAIC,GAAG,GAAG,OAAO,IAAjB;AACA,UAAIC,GAAG,GAAG5D,MAAM,CAAC6D,eAAP,CAAuBH,KAAvB,CAAV;AACA,UAAII,cAAc,GAAG,KAArB;AACA,aAAOC,UAAU,CAACN,KAAD,CAAV,IAAqBG,GAAG,GAAGE,cAAN,GAAuBH,GAA5C,CAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAhBK,GApE0C,EAsF1C;AACDhB,IAAAA,GAAG,EAAE,uBADJ;AAEDvD,IAAAA,KAAK,EAAE,SAAS4E,qBAAT,CAA+BC,UAA/B,EAA2CP,KAA3C,EAAkD;AACvD,UAAIC,GAAG,GAAG,OAAO,IAAjB;AACA,UAAIC,GAAG,GAAG5D,MAAM,CAAC6D,eAAP,CAAuBH,KAAvB,CAAV;AACA,UAAII,cAAc,GAAG,KAArB;AACA,aAAOC,UAAU,CAACE,UAAD,CAAV,GAAyBL,GAAzB,GAA+BE,cAA/B,GAAgDH,GAAvD;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAlBK,GAtF0C,EA0G1C;AACDhB,IAAAA,GAAG,EAAE,cADJ;AAEDvD,IAAAA,KAAK,EAAE,SAAS8E,YAAT,CAAsBC,UAAtB,EAAkC;AACvC,UAAIC,MAAM,GAAGC,SAAS,CAACvD,MAAV,GAAmB,CAAnB,IAAwBuD,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,YAAY;AAC3F,eAAO,IAAP;AACD,OAFD;;AAIA,UAAI,EAAEF,UAAU,YAAYzE,IAAI,CAAC,SAAD,CAA5B,KAA4C,EAAEyE,UAAU,YAAYtE,MAAM,CAAC,SAAD,CAA9B,CAAhD,EAA4F;AAC1FK,QAAAA,OAAO,CAAC,SAAD,CAAP,CAAmBqE,KAAnB,CAAyB,0DAA0D,sBAAnF;;AAEA,eAAO,EAAP;AACD;;AAED,UAAIC,MAAM,GAAGL,UAAU,CAACM,SAAX,GAAuBC,QAAvB,EAAb;AACA,UAAIC,SAAS,GAAG,EAAhB;AACAH,MAAAA,MAAM,CAACtB,OAAP,CAAe,UAAU0B,KAAV,EAAiB;AAC9B,YAAIA,KAAK,YAAY/E,MAAM,CAAC,SAAD,CAA3B,EAAwC;AACtCR,UAAAA,OAAO,CAAC6E,YAAR,CAAqBU,KAArB,EAA4B1B,OAA5B,CAAoC,UAAU2B,MAAV,EAAkB;AACpD,gBAAIT,MAAM,CAACS,MAAD,CAAV,EAAoB;AAClBF,cAAAA,SAAS,CAACtB,IAAV,CAAewB,MAAf;AACD;AACF,WAJD;AAKD;;AAED,YAAIT,MAAM,CAACQ,KAAD,CAAV,EAAmB;AACjBD,UAAAA,SAAS,CAACtB,IAAV,CAAeuB,KAAf;AACD;AACF,OAZD;AAaA,aAAOD,SAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;AApCK,GA1G0C,EAgJ1C;AACDhC,IAAAA,GAAG,EAAE,gBADJ;AAEDvD,IAAAA,KAAK;AACL;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACI,aAAS0F,cAAT,CAAwBjC,GAAxB,EAA6BR,IAA7B,EAAmC;AACjC,UAAImC,MAAM,GAAGnF,OAAO,CAAC6E,YAAR,CAAqBrB,GAArB,CAAb;AACA,aAAO2B,MAAM,CAACJ,MAAP,CAAc,UAAUQ,KAAV,EAAiB;AACpC,eAAOA,KAAK,CAACxB,GAAN,CAAU,MAAV,MAAsBf,IAA7B;AACD,OAFM,EAEJ,CAFI,CAAP;AAGD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAzBK,GAhJ0C,EA2K1C;AACDM,IAAAA,GAAG,EAAE,qBADJ;AAEDvD,IAAAA,KAAK,EAAE,SAAS2F,mBAAT,CAA6BlC,GAA7B,EAAkCR,IAAlC,EAAwC;AAC7C,UAAImC,MAAM,GAAGnF,OAAO,CAAC6E,YAAR,CAAqBrB,GAArB,CAAb;AACA,UAAImC,cAAJ;;AAEA,UAAIC,SAAS,GAAG5E,0BAA0B,CAACmE,MAAD,CAA1C;AAAA,UACIU,KADJ;;AAGA,UAAI;AACF,aAAKD,SAAS,CAAChE,CAAV,EAAL,EAAoB,CAAC,CAACiE,KAAK,GAAGD,SAAS,CAAC/D,CAAV,EAAT,EAAwBC,IAA7C,GAAoD;AAClD,cAAIyD,KAAK,GAAGM,KAAK,CAAC9F,KAAlB;;AAEA,cAAIwF,KAAK,CAACO,SAAN,IAAmBP,KAAK,CAACO,SAAN,GAAkBC,SAArC,IAAkDR,KAAK,CAACO,SAAN,GAAkBC,SAAlB,GAA8B,QAA9B,MAA4C/C,IAAlG,EAAwG;AACtG2C,YAAAA,cAAc,GAAGJ,KAAjB;AACA;AACD;AACF;AACF,OATD,CASE,OAAOlD,GAAP,EAAY;AACZuD,QAAAA,SAAS,CAAC7D,CAAV,CAAYM,GAAZ;AACD,OAXD,SAWU;AACRuD,QAAAA,SAAS,CAAC3D,CAAV;AACD;;AAED,aAAO0D,cAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAlCK,GA3K0C,EA+M1C;AACDrC,IAAAA,GAAG,EAAE,mBADJ;AAEDvD,IAAAA,KAAK,EAAE,SAASiG,iBAAT,CAA2BxC,GAA3B,EAAgCyC,OAAhC,EAAyCC,UAAzC,EAAqD;AAC1D,UAAIC,eAAe,GAAGrF,YAAY,CAAC,SAAD,CAAZ,CAAwBsF,kBAAxB,CAA2CH,OAA3C,CAAtB;;AAEA,UAAIN,cAAJ;;AAEA,UAAIU,UAAU,GAAGrF,0BAA0B,CAACkF,UAAD,CAA3C;AAAA,UACII,MADJ;;AAGA,UAAI;AACF,aAAKD,UAAU,CAACzE,CAAX,EAAL,EAAqB,CAAC,CAAC0E,MAAM,GAAGD,UAAU,CAACxE,CAAX,EAAV,EAA0BC,IAAhD,GAAuD;AACrD,cAAIyE,SAAS,GAAGD,MAAM,CAACvG,KAAvB;AACA,cAAIyG,wBAAwB,GAAG,GAAGC,MAAH,CAAUF,SAAV,EAAqB,GAArB,EAA0BE,MAA1B,CAAiCN,eAAjC,CAA/B;AACA,cAAIZ,KAAK,GAAGvF,OAAO,CAAC0F,mBAAR,CAA4BlC,GAA5B,EAAiCgD,wBAAjC,CAAZ;;AAEA,cAAIjB,KAAJ,EAAW;AACTI,YAAAA,cAAc,GAAGJ,KAAjB;AACA;AACD;AACF;AACF,OAXD,CAWE,OAAOlD,GAAP,EAAY;AACZgE,QAAAA,UAAU,CAACtE,CAAX,CAAaM,GAAb;AACD,OAbD,SAaU;AACRgE,QAAAA,UAAU,CAACpE,CAAX;AACD;;AAED,aAAO0D,cAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;AAnCK,GA/M0C,EAoP1C;AACDrC,IAAAA,GAAG,EAAE,kBADJ;AAEDvD,IAAAA,KAAK,EAAE,SAAS2G,gBAAT,CAA0BlD,GAA1B,EAA+BmD,UAA/B,EAA2C;AAChD,UAAIC,eAAe,GAAG,EAAtB;AACAD,MAAAA,UAAU,CAACvB,SAAX,GAAuBvB,OAAvB,CAA+B,UAAU0B,KAAV,EAAiB;AAC9C,YAAIA,KAAK,YAAY/E,MAAM,CAAC,SAAD,CAA3B,EAAwC;AACtCoG,UAAAA,eAAe,CAAC5C,IAAhB,CAAqB6C,KAArB,CAA2BD,eAA3B,EAA4C,CAAC,GAAG3G,mBAAmB,CAAC,SAAD,CAAvB,EAAoCD,OAAO,CAAC0G,gBAAR,CAAyBlD,GAAzB,EAA8B+B,KAA9B,CAApC,CAA5C;AACD,SAFD,MAEO;AACLqB,UAAAA,eAAe,CAAC5C,IAAhB,CAAqBuB,KAArB;AACD;AACF,OAND;AAOA,aAAOqB,eAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AArBK,GApP0C,EA2Q1C;AACDtD,IAAAA,GAAG,EAAE,qBADJ;AAEDvD,IAAAA,KAAK,EAAE,SAAS+G,mBAAT,CAA6BtD,GAA7B,EAAkCF,GAAlC,EAAuCvD,KAAvC,EAA8C;AACnD,UAAI,CAACyD,GAAD,IAAQ,CAACF,GAAb,EAAkB;AAChB;AACD;;AAED,UAAIyD,SAAS,GAAG/G,OAAO,CAAC6E,YAAR,CAAqBrB,GAArB,CAAhB;AACA,aAAOuD,SAAS,CAAChC,MAAV,CAAiB,UAAUiC,CAAV,EAAa;AACnC,eAAOA,CAAC,CAACjD,GAAF,CAAMT,GAAN,MAAevD,KAAtB;AACD,OAFM,CAAP;AAGD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AArBK,GA3Q0C,EAkS1C;AACDuD,IAAAA,GAAG,EAAE,sBADJ;AAEDvD,IAAAA,KAAK,EAAE,SAASkH,oBAAT,CAA8B1B,KAA9B,EAAqC2B,eAArC,EAAsD;AAC3D,UAAIC,UAAU,GAAGD,eAAe,YAAY1G,MAAM,CAAC,SAAD,CAAjC,GAA+C0G,eAA/C,GAAiEA,eAAe,CAACE,aAAhB,EAAlF;AACA,UAAIjC,MAAM,GAAGgC,UAAU,CAAC/B,SAAX,GAAuBC,QAAvB,EAAb;AACA,UAAIgC,IAAI,GAAG,EAAX;;AAEA,UAAIlC,MAAM,CAACmC,OAAP,CAAe/B,KAAf,IAAwB,CAA5B,EAA+B;AAC7BJ,QAAAA,MAAM,CAACtB,OAAP,CAAe,UAAU0D,UAAV,EAAsB;AACnC,cAAIA,UAAU,YAAY/G,MAAM,CAAC,SAAD,CAA5B,IAA2C,CAAC6G,IAAI,CAACF,UAArD,EAAiE;AAC/DE,YAAAA,IAAI,GAAGrH,OAAO,CAACiH,oBAAR,CAA6B1B,KAA7B,EAAoCgC,UAApC,CAAP;AACD;AACF,SAJD;AAKD,OAND,MAMO;AACLF,QAAAA,IAAI,CAACG,QAAL,GAAgBrC,MAAM,CAACmC,OAAP,CAAe/B,KAAf,CAAhB;AACA8B,QAAAA,IAAI,CAACF,UAAL,GAAkBA,UAAlB;AACD;;AAED,aAAOE,IAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA5BK,GAlS0C,EAgU1C;AACD/D,IAAAA,GAAG,EAAE,qBADJ;AAEDvD,IAAAA,KAAK,EAAE,SAAS0H,mBAAT,CAA6BlC,KAA7B,EAAoCmC,WAApC,EAAiD;AACtD,UAAI,CAACnC,KAAL,EAAY;AACV1E,QAAAA,OAAO,CAAC,SAAD,CAAP,CAAmBqE,KAAnB,CAAyB,iDAAzB;;AAEA;AACD;;AAED,UAAIyC,MAAM,GAAGpC,KAAK,CAACO,SAAN,EAAb;;AAEA,UAAI,EAAEP,KAAK,YAAY9E,KAAK,CAAC,SAAD,CAAxB,KAAwC,CAACkH,MAA7C,EAAqD;AACnD9G,QAAAA,OAAO,CAAC,SAAD,CAAP,CAAmBqE,KAAnB,CAAyB,sDAAzB;;AAEA;AACD;;AAED,UAAI0C,UAAU,GAAGD,MAAM,YAAYrH,QAAQ,CAAC,SAAD,CAA3C;AACA,UAAIuH,UAAU,GAAGF,MAAM,YAAYpH,SAAS,CAAC,SAAD,CAA5C;;AAEA,UAAIqH,UAAU,IAAIC,UAAlB,EAA8B;AAC5B,YAAIC,OAAO,GAAGvC,KAAK,CAACO,SAAN,EAAd;;AAEA,YAAIiC,GAAG,GAAGH,UAAU,GAAGE,OAAO,CAACE,OAAR,KAAoBF,OAAO,CAACE,OAAR,GAAkB,CAAlB,CAApB,GAA2C,EAA9C,GAAmDF,OAAO,CAACG,MAAR,EAAvE;AACA,YAAIC,MAAM,GAAG;AACXC,UAAAA,KAAK,EAAEL,OAAO,CAAC/B,SAAR,GAAoBqC,MADhB;AAEXC,UAAAA,OAAO,EAAE,OAFE;AAGXC,UAAAA,OAAO,EAAE,KAHE;AAIXC,UAAAA,OAAO,EAAE,kBAJE;AAKXC,UAAAA,MAAM,EAAE;AALG,SAAb;;AAQA,YAAIC,WAAW,GAAG7H,QAAQ,CAAC,SAAD,CAAR,CAAoB8H,qBAApB,CAA0C9I,MAAM,CAAC+I,MAAP,CAAcT,MAAd,EAAsBR,WAAtB,CAA1C,CAAlB;;AAEA,eAAO,KAAKxE,IAAL,CAAU6E,GAAV,IAAiB,GAAGtB,MAAH,CAAUsB,GAAV,EAAe,GAAf,EAAoBtB,MAApB,CAA2BgC,WAA3B,CAAjB,GAA2D,GAAGhC,MAAH,CAAUsB,GAAV,EAAe,GAAf,EAAoBtB,MAApB,CAA2BgC,WAA3B,CAAlE;AACD,OAfD,MAeO;AACL5H,QAAAA,OAAO,CAAC,SAAD,CAAP,CAAmB+H,IAAnB,CAAwB,eAAenC,MAAf,CAAsBlB,KAAK,CAACxB,GAAN,CAAU,MAAV,CAAtB,EAAyC,gCAAzC,IAA6E,iCAArG;;AAEA;AACD;AACF;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAtDK,GAhU0C,EAwX1C;AACDT,IAAAA,GAAG,EAAE,wBADJ;AAEDvD,IAAAA,KAAK,EAAE,SAAS8I,sBAAT,CAAgCtD,KAAhC,EAAuC/B,GAAvC,EAA4C;AACjD,UAAIsF,OAAO,GAAGtF,GAAG,IAAIA,GAAG,CAACuF,OAAJ,EAArB;AACA,UAAIC,UAAU,GAAGF,OAAO,IAAIA,OAAO,CAACG,aAAR,EAA5B;;AAEA,UAAI,CAAC1D,KAAD,IAAU,CAACuD,OAAX,IAAsB,CAACE,UAA3B,EAAuC;AACrC;AACA;AACA,eAAO,KAAP;AACD;;AAED,UAAIE,WAAW,GAAG3D,KAAK,CAAC4D,gBAAN,EAAlB,CAViD,CAUL;;AAE5C,UAAIC,WAAW,GAAG7D,KAAK,CAAC8D,gBAAN,EAAlB,CAZiD,CAYL;AAC5C;;AAEA,UAAIC,MAAM,GAAGN,UAAU,IAAIE,WAAd,IAA6BF,UAAU,GAAGI,WAAvD;AACA,aAAOE,MAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;;AAzBK,GAxX0C,EAmZ1C;AACDhG,IAAAA,GAAG,EAAE,YADJ;AAEDvD,IAAAA,KAAK,EAAE,SAASwJ,UAAT,CAAoBnF,KAApB,EAA2B;AAChC,UAAImF,UAAJ;;AAEA,UAAInF,KAAK,GAAG,GAAZ,EAAiB;AACfmF,QAAAA,UAAU,GAAGC,IAAI,CAACC,KAAL,CAAWrF,KAAX,EAAkB,EAAlB,CAAb;AACD;;AAED,UAAIA,KAAK,IAAI,GAAT,IAAgBA,KAAK,GAAG,KAA5B,EAAmC;AACjCmF,QAAAA,UAAU,GAAGC,IAAI,CAACC,KAAL,CAAWrF,KAAK,GAAG,EAAnB,IAAyB,EAAtC;AACD;;AAED,UAAIA,KAAK,IAAI,KAAT,IAAkBA,KAAK,GAAG,OAA9B,EAAuC;AACrCmF,QAAAA,UAAU,GAAGC,IAAI,CAACC,KAAL,CAAWrF,KAAK,GAAG,GAAnB,IAA0B,GAAvC;AACD;;AAED,UAAIA,KAAK,IAAI,OAAb,EAAsB;AACpBmF,QAAAA,UAAU,GAAGC,IAAI,CAACC,KAAL,CAAWrF,KAAK,GAAG,IAAnB,IAA2B,IAAxC;AACD;;AAED,aAAOmF,UAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAhCK,GAnZ0C,EAqb1C;AACDjG,IAAAA,GAAG,EAAE,iBADJ;AAEDvD,IAAAA,KAAK,EAAE,SAAS2J,eAAT,CAAyBtF,KAAzB,EAAgCuF,WAAhC,EAA6C;AAClD,UAAItF,KAAK,GAAGW,SAAS,CAACvD,MAAV,GAAmB,CAAnB,IAAwBuD,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,GAAhF;;AAEA,UAAI4E,MAAM,CAACC,KAAP,CAAaD,MAAM,CAACxF,KAAD,CAAnB,CAAJ,EAAiC;AAC/B,eAAO,CAAP;AACD;;AAED,UAAIA,KAAK,GAAG,CAAZ,EAAe;AACb,eAAO,CAAP;AACD;;AAED,UAAI0F,oBAAoB,GAAG9J,OAAO,CAACmE,qBAAR,CAA8BC,KAA9B,EAAqCC,KAArC,CAA3B;AACA,UAAI0F,UAAU,GAAGJ,WAAW,CAACK,MAAZ,CAAmB,UAAUC,IAAV,EAAgBC,IAAhB,EAAsB;AACxD,YAAIC,GAAG,GAAGX,IAAI,CAACY,GAAL,CAASF,IAAI,GAAGJ,oBAAhB,IAAwCN,IAAI,CAACY,GAAL,CAASH,IAAI,GAAGH,oBAAhB,CAAxC,GAAgFI,IAAhF,GAAuFD,IAAjG;AACA,eAAOE,GAAP;AACD,OAHgB,CAAjB;AAIA,UAAIE,IAAI,GAAG,CAAC,GAAGtJ,UAAU,CAAC,SAAD,CAAd,EAA2B4I,WAA3B,EAAwC,UAAU1I,CAAV,EAAa;AAC9D,eAAOuI,IAAI,CAACY,GAAL,CAASnJ,CAAC,GAAG8I,UAAb,KAA4B,KAAnC;AACD,OAFU,CAAX;AAGA,aAAOM,IAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;;AA5BK,GArb0C,EAmd1C;AACD/G,IAAAA,GAAG,EAAE,gBADJ;AAEDvD,IAAAA,KAAK,EAAE,SAASuK,cAAT,CAAwB9G,GAAxB,EAA6B+G,QAA7B,EAAuC;AAC5C,UAAI,EAAE/G,GAAG,YAAYnD,IAAI,CAAC,SAAD,CAArB,CAAJ,EAAuC;AACrC;AACD;;AAED,UAAImK,cAAc,GAAG,EAArB;AACAD,MAAAA,QAAQ,CAAC1G,OAAT,CAAiB,UAAUoC,OAAV,EAAmB;AAClC,YAAIA,OAAO,CAACwE,WAAR,OAA0B,IAA9B,EAAoC;AAClCD,UAAAA,cAAc,CAACxG,IAAf,CAAoBiC,OAAO,CAACwE,WAAR,EAApB;AACD;AACF,OAJD;;AAMA,UAAID,cAAc,CAAC/I,MAAf,GAAwB,CAA5B,EAA+B;AAC7B,YAAIiJ,cAAc,GAAG,IAAIhK,mBAAmB,CAAC,SAAD,CAAvB,CAAmC8J,cAAnC,CAArB;AACAhH,QAAAA,GAAG,CAACuF,OAAJ,GAAc4B,GAAd,CAAkBD,cAAc,CAACE,SAAf,EAAlB;AACD;AACF;AACD;AACJ;AACA;AACA;AACA;AACA;;AAxBK,GAnd0C,EA6e1C;AACDtH,IAAAA,GAAG,EAAE,gBADJ;AAEDvD,IAAAA,KAAK,EAAE,SAAS8K,cAAT,CAAwBtF,KAAxB,EAA+BX,UAA/B,EAA2C;AAChD,aAAOA,UAAU,IAAIW,KAAK,CAACxB,GAAN,CAAU,eAAV,CAAd,IAA4Ca,UAAU,GAAGW,KAAK,CAACxB,GAAN,CAAU,eAAV,CAAhE;AACD;AAJA,GA7e0C,CAA7C;AAmfA,SAAO/D,OAAP;AACD,CAzf0B,EAA3B;;AA2fAF,OAAO,CAACE,OAAR,GAAkBA,OAAlB;AACA,CAAC,GAAGI,gBAAgB,CAAC,SAAD,CAApB,EAAiCJ,OAAjC,EAA0C,iBAA1C,EAA6D,UAAUwD,GAAV,EAAesH,MAAf,EAAuB;AAClF,MAAI3F,MAAM,GAAGnF,OAAO,CAAC6E,YAAR,CAAqBrB,GAArB,CAAb;AACA,MAAI+B,KAAK,GAAGJ,MAAM,CAAC4F,IAAP,CAAY,UAAU/D,CAAV,EAAa;AACnC,WAAO8D,MAAM,KAAK9D,CAAC,CAAC8D,MAAF,CAASjI,QAAT,EAAlB;AACD,GAFW,CAAZ;AAGA,SAAO0C,KAAP;AACD,CAND;AAOA,IAAIyF,QAAQ,GAAGhL,OAAf;AACAF,OAAO,CAAC,SAAD,CAAP,GAAqBkL,QAArB","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.MapUtil = void 0;\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _Map = _interopRequireDefault(require(\"ol/Map\"));\n\nvar _TileWMS = _interopRequireDefault(require(\"ol/source/TileWMS\"));\n\nvar _ImageWMS = _interopRequireDefault(require(\"ol/source/ImageWMS\"));\n\nvar _Group = _interopRequireDefault(require(\"ol/layer/Group\"));\n\nvar _Base = _interopRequireDefault(require(\"ol/layer/Base\"));\n\nvar _GeometryCollection = _interopRequireDefault(require(\"ol/geom/GeometryCollection\"));\n\nvar _Units = require(\"ol/proj/Units\");\n\nvar _UrlUtil = _interopRequireDefault(require(\"@terrestris/base-util/dist/UrlUtil/UrlUtil\"));\n\nvar _Logger = _interopRequireDefault(require(\"@terrestris/base-util/dist/Logger\"));\n\nvar _FeatureUtil = _interopRequireDefault(require(\"../FeatureUtil/FeatureUtil\"));\n\nvar _findIndex = _interopRequireDefault(require(\"lodash/findIndex\"));\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * Helper class for the OpenLayers map.\n *\n * @class\n */\nvar MapUtil = /*#__PURE__*/function () {\n  function MapUtil() {\n    (0, _classCallCheck2[\"default\"])(this, MapUtil);\n  }\n\n  (0, _createClass2[\"default\"])(MapUtil, null, [{\n    key: \"getInteractionsByName\",\n    value:\n    /**\n     * Returns all interactions by the given name of a map.\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {string} name The name of the interaction to look for.\n     * @return {ol.interaction[]} The list of result interactions.\n     */\n    function getInteractionsByName(map, name) {\n      var interactionCandidates = [];\n\n      if (!(map instanceof _Map[\"default\"])) {\n        _Logger[\"default\"].debug('Input parameter map must be from type `ol.Map`.');\n\n        return interactionCandidates;\n      }\n\n      var interactions = map.getInteractions();\n      interactions.forEach(function (interaction) {\n        if (interaction.get('name') === name) {\n          interactionCandidates.push(interaction);\n        }\n      });\n      return interactionCandidates;\n    }\n    /**\n     * Returns all interactions of the given class of the passed map.\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {ol.interaction} clazz The class of the interaction to look for.\n     * @return {ol.interaction[]} The list of result interactions.\n     */\n\n  }, {\n    key: \"getInteractionsByClass\",\n    value: function getInteractionsByClass(map, clazz) {\n      var interactionCandidates = [];\n\n      if (!(map instanceof _Map[\"default\"])) {\n        _Logger[\"default\"].debug('Input parameter map must be from type `ol.Map`.');\n\n        return interactionCandidates;\n      }\n\n      var interactions = map.getInteractions();\n      interactions.forEach(function (interaction) {\n        if (interaction instanceof clazz) {\n          interactionCandidates.push(interaction);\n        }\n      });\n      return interactionCandidates;\n    }\n    /**\n     * Calculates the appropriate map resolution for a given scale in the given\n     * units.\n     *\n     * See: https://gis.stackexchange.com/questions/158435/\n     * how-to-get-current-scale-in-openlayers-3\n     *\n     * @method\n     * @param {number} scale The input scale to calculate the appropriate\n     *                       resolution for.\n     * @param {string} units The units to use for calculation (m or degrees).\n     * @return {number} The calculated resolution.\n     */\n\n  }, {\n    key: \"getResolutionForScale\",\n    value: function getResolutionForScale(scale, units) {\n      var dpi = 25.4 / 0.28;\n      var mpu = _Units.METERS_PER_UNIT[units];\n      var inchesPerMeter = 39.37;\n      return parseFloat(scale) / (mpu * inchesPerMeter * dpi);\n    }\n    /**\n     * Returns the appropriate scale for the given resolution and units.\n     *\n     * @method\n     * @param {number} resolution The resolutions to calculate the scale for.\n     * @param {string} units The units the resolution is based on, typically\n     *                       either 'm' or 'degrees'.\n     * @return {number} The appropriate scale.\n     */\n\n  }, {\n    key: \"getScaleForResolution\",\n    value: function getScaleForResolution(resolution, units) {\n      var dpi = 25.4 / 0.28;\n      var mpu = _Units.METERS_PER_UNIT[units];\n      var inchesPerMeter = 39.37;\n      return parseFloat(resolution) * mpu * inchesPerMeter * dpi;\n    }\n    /**\n     * Returns all layers of a collection. Even the hidden ones.\n     *\n     * @param {ol.Map|ol.layer.Group} collection The collection to get the layers\n     *                                           from. This can be an ol.layer.Group\n     *                                           or an ol.Map.\n     * @param {Function} [filter] A filter function that receives the layer.\n     *                            If it returns true it will be included in the\n     *                            returned layers.\n     * @return {Array} An array of all Layers.\n     */\n\n  }, {\n    key: \"getAllLayers\",\n    value: function getAllLayers(collection) {\n      var filter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n        return true;\n      };\n\n      if (!(collection instanceof _Map[\"default\"]) && !(collection instanceof _Group[\"default\"])) {\n        _Logger[\"default\"].error('Input parameter collection must be from type `ol.Map`' + 'or `ol.layer.Group`.');\n\n        return [];\n      }\n\n      var layers = collection.getLayers().getArray();\n      var allLayers = [];\n      layers.forEach(function (layer) {\n        if (layer instanceof _Group[\"default\"]) {\n          MapUtil.getAllLayers(layer).forEach(function (layeri) {\n            if (filter(layeri)) {\n              allLayers.push(layeri);\n            }\n          });\n        }\n\n        if (filter(layer)) {\n          allLayers.push(layer);\n        }\n      });\n      return allLayers;\n    }\n    /**\n     * Get a layer by its key (ol_uid).\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {string} ol_uid The ol_uid of a layer.\n     * @return {ol.layer.Layer} The layer.\n     */\n\n  }, {\n    key: \"getLayerByName\",\n    value:\n    /**\n     * Returns the layer from the provided map by the given name.\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {string} name The name to get the layer by.\n     * @return {ol.Layer} The result layer or undefined if the layer could not\n     *                    be found.\n     */\n    function getLayerByName(map, name) {\n      var layers = MapUtil.getAllLayers(map);\n      return layers.filter(function (layer) {\n        return layer.get('name') === name;\n      })[0];\n    }\n    /**\n     * Returns the layer from the provided map by the given name\n     * (parameter LAYERS).\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {string} name The name to get the layer by.\n     * @return {ol.Layer} The result layer or undefined if the layer could not\n     *                    be found.\n     */\n\n  }, {\n    key: \"getLayerByNameParam\",\n    value: function getLayerByNameParam(map, name) {\n      var layers = MapUtil.getAllLayers(map);\n      var layerCandidate;\n\n      var _iterator = _createForOfIteratorHelper(layers),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var layer = _step.value;\n\n          if (layer.getSource && layer.getSource().getParams && layer.getSource().getParams()['LAYERS'] === name) {\n            layerCandidate = layer;\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return layerCandidate;\n    }\n    /**\n     * Returns the layer from the provided map by the given feature.\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {ol.Feature} feature The feature to get the layer by.\n     * @param {Array} namespaces list of supported GeoServer namespaces.\n     * @return {ol.Layer} The result layer or undefined if the layer could not\n     *                    be found.\n     */\n\n  }, {\n    key: \"getLayerByFeature\",\n    value: function getLayerByFeature(map, feature, namespaces) {\n      var featureTypeName = _FeatureUtil[\"default\"].getFeatureTypeName(feature);\n\n      var layerCandidate;\n\n      var _iterator2 = _createForOfIteratorHelper(namespaces),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var namespace = _step2.value;\n          var qualifiedFeatureTypeName = \"\".concat(namespace, \":\").concat(featureTypeName);\n          var layer = MapUtil.getLayerByNameParam(map, qualifiedFeatureTypeName);\n\n          if (layer) {\n            layerCandidate = layer;\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return layerCandidate;\n    }\n    /**\n     * Returns all layers of the specified layer group recursively.\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {ol.Layer.Group} layerGroup The group to flatten.\n     * @return {Array} The (flattened) layers from the group\n     */\n\n  }, {\n    key: \"getLayersByGroup\",\n    value: function getLayersByGroup(map, layerGroup) {\n      var layerCandidates = [];\n      layerGroup.getLayers().forEach(function (layer) {\n        if (layer instanceof _Group[\"default\"]) {\n          layerCandidates.push.apply(layerCandidates, (0, _toConsumableArray2[\"default\"])(MapUtil.getLayersByGroup(map, layer)));\n        } else {\n          layerCandidates.push(layer);\n        }\n      });\n      return layerCandidates;\n    }\n    /**\n     * Returns the list of layers matching the given pair of properties.\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {string} key The property key.\n     * @param {Object} value The property value.\n     *\n     * @return {ol.layer.Base[]} The array of matching layers.\n     */\n\n  }, {\n    key: \"getLayersByProperty\",\n    value: function getLayersByProperty(map, key, value) {\n      if (!map || !key) {\n        return;\n      }\n\n      var mapLayers = MapUtil.getAllLayers(map);\n      return mapLayers.filter(function (l) {\n        return l.get(key) === value;\n      });\n    }\n    /**\n     * Get information about the LayerPosition in the tree.\n     *\n     * @param {ol.layer.Layer} layer The layer to get the information.\n     * @param {ol.layer.Group|ol.Map} [groupLayerOrMap] The groupLayer or map\n     *                                                  containing the layer.\n     * @return {Object} An object with these keys:\n     *    {ol.layer.Group} groupLayer The groupLayer containing the layer.\n     *    {Integer} position The position of the layer in the collection.\n     */\n\n  }, {\n    key: \"getLayerPositionInfo\",\n    value: function getLayerPositionInfo(layer, groupLayerOrMap) {\n      var groupLayer = groupLayerOrMap instanceof _Group[\"default\"] ? groupLayerOrMap : groupLayerOrMap.getLayerGroup();\n      var layers = groupLayer.getLayers().getArray();\n      var info = {};\n\n      if (layers.indexOf(layer) < 0) {\n        layers.forEach(function (childLayer) {\n          if (childLayer instanceof _Group[\"default\"] && !info.groupLayer) {\n            info = MapUtil.getLayerPositionInfo(layer, childLayer);\n          }\n        });\n      } else {\n        info.position = layers.indexOf(layer);\n        info.groupLayer = groupLayer;\n      }\n\n      return info;\n    }\n    /**\n     * Get the getlegendGraphic url of a layer. Designed for geoserver.\n     * Currently supported Sources:\n     *  - ol.source.TileWms (with url configured)\n     *  - ol.source.ImageWms (with url configured)\n     *\n     * @param {ol.layer.Layer} layer The layer that you want to have a legendUrlfor.\n     * @return {string|undefined} The getLegendGraphicUrl.\n     */\n\n  }, {\n    key: \"getLegendGraphicUrl\",\n    value: function getLegendGraphicUrl(layer, extraParams) {\n      if (!layer) {\n        _Logger[\"default\"].error('No layer passed to MapUtil.getLegendGraphicUrl.');\n\n        return;\n      }\n\n      var source = layer.getSource();\n\n      if (!(layer instanceof _Base[\"default\"]) || !source) {\n        _Logger[\"default\"].error('Invalid layer passed to MapUtil.getLegendGraphicUrl.');\n\n        return;\n      }\n\n      var isTiledWMS = source instanceof _TileWMS[\"default\"];\n      var isImageWMS = source instanceof _ImageWMS[\"default\"];\n\n      if (isTiledWMS || isImageWMS) {\n        var _source = layer.getSource();\n\n        var url = isTiledWMS ? _source.getUrls() ? _source.getUrls()[0] : '' : _source.getUrl();\n        var params = {\n          LAYER: _source.getParams().LAYERS,\n          VERSION: '1.3.0',\n          SERVICE: 'WMS',\n          REQUEST: 'getLegendGraphic',\n          FORMAT: 'image/png'\n        };\n\n        var queryString = _UrlUtil[\"default\"].objectToRequestString(Object.assign(params, extraParams));\n\n        return /\\?/.test(url) ? \"\".concat(url, \"&\").concat(queryString) : \"\".concat(url, \"?\").concat(queryString);\n      } else {\n        _Logger[\"default\"].warn(\"Source of \\\"\".concat(layer.get('name'), \"\\\" is currently not supported \") + \"by MapUtil.getLegendGraphicUrl.\");\n\n        return;\n      }\n    }\n    /**\n     * Checks whether the resolution of the passed map's view lies inside of the\n     * min- and max-resolution of the passed layer, e.g. whether the layer should\n     * be displayed at the current map view resolution.\n     *\n     * @param {ol.layer.Layer} layer The layer to check.\n     * @param {ol.Map} map The map to get the view resolution for comparison\n     *     from.\n     * @return {boolean} Whether the resolution of the passed map's view lies\n     *     inside of the min- and max-resolution of the passed layer, e.g. whether\n     *     the layer should be displayed at the current map view resolution. Will\n     *     be `false` when no `layer` or no `map` is passed or if the view of the\n     *     map is falsy or does not have a resolution (yet).\n     */\n\n  }, {\n    key: \"layerInResolutionRange\",\n    value: function layerInResolutionRange(layer, map) {\n      var mapView = map && map.getView();\n      var currentRes = mapView && mapView.getResolution();\n\n      if (!layer || !mapView || !currentRes) {\n        // It is questionable what we should return in this case, I opted for\n        // false, since we cannot sanely determine a correct answer.\n        return false;\n      }\n\n      var layerMinRes = layer.getMinResolution(); // default: 0 if unset\n\n      var layerMaxRes = layer.getMaxResolution(); // default: Infinity if unset\n      // minimum resolution is inclusive, maximum resolution exclusive\n\n      var within = currentRes >= layerMinRes && currentRes < layerMaxRes;\n      return within;\n    }\n    /**\n     * Rounds a scalenumber in dependency to its size.\n     *\n     * @param  {number} scale The exact scale\n     * @return {number} The roundedScale\n     */\n\n  }, {\n    key: \"roundScale\",\n    value: function roundScale(scale) {\n      var roundScale;\n\n      if (scale < 100) {\n        roundScale = Math.round(scale, 10);\n      }\n\n      if (scale >= 100 && scale < 10000) {\n        roundScale = Math.round(scale / 10) * 10;\n      }\n\n      if (scale >= 10000 && scale < 1000000) {\n        roundScale = Math.round(scale / 100) * 100;\n      }\n\n      if (scale >= 1000000) {\n        roundScale = Math.round(scale / 1000) * 1000;\n      }\n\n      return roundScale;\n    }\n    /**\n     * Returns the appropriate zoom level for the given scale and units.\n      * @method\n     * @param {number} scale Map scale to get the zoom for.\n     * @param {Array} resolutions Resolutions array.\n     * @param {string} units The units the resolutions are based on, typically\n     *                       either 'm' or 'degrees'. Default is 'm'.\n     *\n     * @return {number} Determined zoom level for the given scale.\n     */\n\n  }, {\n    key: \"getZoomForScale\",\n    value: function getZoomForScale(scale, resolutions) {\n      var units = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'm';\n\n      if (Number.isNaN(Number(scale))) {\n        return 0;\n      }\n\n      if (scale < 0) {\n        return 0;\n      }\n\n      var calculatedResolution = MapUtil.getResolutionForScale(scale, units);\n      var closestVal = resolutions.reduce(function (prev, curr) {\n        var res = Math.abs(curr - calculatedResolution) < Math.abs(prev - calculatedResolution) ? curr : prev;\n        return res;\n      });\n      var zoom = (0, _findIndex[\"default\"])(resolutions, function (o) {\n        return Math.abs(o - closestVal) <= 1e-10;\n      });\n      return zoom;\n    }\n    /**\n     * Fits the map's view to the extent of the passed features.\n     *\n     * @param {ol.Map} map The map to get the view from.\n     * @param {ol.Feature[]} features The features to zoom to.\n     */\n\n  }, {\n    key: \"zoomToFeatures\",\n    value: function zoomToFeatures(map, features) {\n      if (!(map instanceof _Map[\"default\"])) {\n        return;\n      }\n\n      var featGeometries = [];\n      features.forEach(function (feature) {\n        if (feature.getGeometry() !== null) {\n          featGeometries.push(feature.getGeometry());\n        }\n      });\n\n      if (featGeometries.length > 0) {\n        var geomCollection = new _GeometryCollection[\"default\"](featGeometries);\n        map.getView().fit(geomCollection.getExtent());\n      }\n    }\n    /**\n     * Checks if the given layer is visible for the given resolution.\n     *\n     * @param {ol.layer.Base} layer The layer.\n     * @param {number} resolution The resolution of the map\n     */\n\n  }, {\n    key: \"isInScaleRange\",\n    value: function isInScaleRange(layer, resolution) {\n      return resolution >= layer.get('minResolution') && resolution < layer.get('maxResolution');\n    }\n  }]);\n  return MapUtil;\n}();\n\nexports.MapUtil = MapUtil;\n(0, _defineProperty2[\"default\"])(MapUtil, \"getLayerByOlUid\", function (map, ol_uid) {\n  var layers = MapUtil.getAllLayers(map);\n  var layer = layers.find(function (l) {\n    return ol_uid === l.ol_uid.toString();\n  });\n  return layer;\n});\nvar _default = MapUtil;\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"script"}