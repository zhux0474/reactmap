{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/renderer/canvas/TileLayer\n */\n\n\nimport CanvasLayerRenderer from './Layer.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport { IMAGE_SMOOTHING_DISABLED, IMAGE_SMOOTHING_ENABLED } from './common.js';\nimport { apply as applyTransform, compose as composeTransform, makeInverse } from '../../transform.js';\nimport { assign } from '../../obj.js';\nimport { createEmpty, equals, getIntersection, getTopLeft } from '../../extent.js';\nimport { cssOpacity } from '../../css.js';\nimport { fromUserExtent } from '../../proj.js';\nimport { getUid } from '../../util.js';\nimport { numberSafeCompareFunction } from '../../array.js';\nimport { toString as toTransformString } from '../../transform.js';\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n */\n\nvar CanvasTileLayerRenderer =\n/** @class */\nfunction (_super) {\n  __extends(CanvasTileLayerRenderer, _super);\n  /**\n   * @param {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default} tileLayer Tile layer.\n   */\n\n\n  function CanvasTileLayerRenderer(tileLayer) {\n    var _this = _super.call(this, tileLayer) || this;\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n\n\n    _this.extentChanged = true;\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n\n    _this.renderedExtent_ = null;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    _this.renderedPixelRatio;\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n\n    _this.renderedProjection = null;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    _this.renderedRevision;\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n\n    _this.renderedTiles = [];\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    _this.newTiles_ = false;\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n\n    _this.tmpExtent = createEmpty();\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n\n    _this.tmpTileRange_ = new TileRange(0, 0, 0, 0);\n    return _this;\n  }\n  /**\n   * @protected\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n\n\n  CanvasTileLayerRenderer.prototype.isDrawableTile = function (tile) {\n    var tileLayer = this.getLayer();\n    var tileState = tile.getState();\n    var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return tileState == TileState.LOADED || tileState == TileState.EMPTY || tileState == TileState.ERROR && !useInterimTilesOnError;\n  };\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n\n\n  CanvasTileLayerRenderer.prototype.getTile = function (z, x, y, frameState) {\n    var pixelRatio = frameState.pixelRatio;\n    var projection = frameState.viewState.projection;\n    var tileLayer = this.getLayer();\n    var tileSource = tileLayer.getSource();\n    var tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n\n    if (tile.getState() == TileState.ERROR) {\n      if (!tileLayer.getUseInterimTilesOnError()) {\n        // When useInterimTilesOnError is false, we consider the error tile as loaded.\n        tile.setState(TileState.LOADED);\n      } else if (tileLayer.getPreload() > 0) {\n        // Preloaded tiles for lower resolutions might have finished loading.\n        this.newTiles_ = true;\n      }\n    }\n\n    if (!this.isDrawableTile(tile)) {\n      tile = tile.getInterimTile();\n    }\n\n    return tile;\n  };\n  /**\n   * @param {Object<number, Object<string, import(\"../../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @param {number} zoom Zoom level.\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\n   */\n\n\n  CanvasTileLayerRenderer.prototype.loadedTileCallback = function (tiles, zoom, tile) {\n    if (this.isDrawableTile(tile)) {\n      return _super.prototype.loadedTileCallback.call(this, tiles, zoom, tile);\n    }\n\n    return false;\n  };\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n\n\n  CanvasTileLayerRenderer.prototype.prepareFrame = function (frameState) {\n    return !!this.getLayer().getSource();\n  };\n  /**\n   * Render the layer.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n\n\n  CanvasTileLayerRenderer.prototype.renderFrame = function (frameState, target) {\n    var layerState = frameState.layerStatesArray[frameState.layerIndex];\n    var viewState = frameState.viewState;\n    var projection = viewState.projection;\n    var viewResolution = viewState.resolution;\n    var viewCenter = viewState.center;\n    var rotation = viewState.rotation;\n    var pixelRatio = frameState.pixelRatio;\n    var tileLayer = this.getLayer();\n    var tileSource = tileLayer.getSource();\n    var sourceRevision = tileSource.getRevision();\n    var tileGrid = tileSource.getTileGridForProjection(projection);\n    var z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    var tileResolution = tileGrid.getResolution(z);\n    var extent = frameState.extent;\n    var layerExtent = layerState.extent && fromUserExtent(layerState.extent, projection);\n\n    if (layerExtent) {\n      extent = getIntersection(extent, fromUserExtent(layerState.extent, projection));\n    }\n\n    var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio); // desired dimensions of the canvas in pixels\n\n    var width = Math.round(frameState.size[0] * tilePixelRatio);\n    var height = Math.round(frameState.size[1] * tilePixelRatio);\n\n    if (rotation) {\n      var size = Math.round(Math.sqrt(width * width + height * height));\n      width = size;\n      height = size;\n    }\n\n    var dx = tileResolution * width / 2 / tilePixelRatio;\n    var dy = tileResolution * height / 2 / tilePixelRatio;\n    var canvasExtent = [viewCenter[0] - dx, viewCenter[1] - dy, viewCenter[0] + dx, viewCenter[1] + dy];\n    var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n    /**\n     * @type {Object<number, Object<string, import(\"../../Tile.js\").default>>}\n     */\n\n    var tilesToDrawByZ = {};\n    tilesToDrawByZ[z] = {};\n    var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);\n    var tmpExtent = this.tmpExtent;\n    var tmpTileRange = this.tmpTileRange_;\n    this.newTiles_ = false;\n\n    for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        var tile = this.getTile(z, x, y, frameState);\n\n        if (this.isDrawableTile(tile)) {\n          var uid = getUid(this);\n\n          if (tile.getState() == TileState.LOADED) {\n            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n            var inTransition = tile.inTransition(uid);\n\n            if (!this.newTiles_ && (inTransition || this.renderedTiles.indexOf(tile) === -1)) {\n              this.newTiles_ = true;\n            }\n          }\n\n          if (tile.getAlpha(uid, frameState.time) === 1) {\n            // don't look for alt tiles if alpha is 1\n            continue;\n          }\n        }\n\n        var childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);\n        var covered = false;\n\n        if (childTileRange) {\n          covered = findLoadedTiles(z + 1, childTileRange);\n        }\n\n        if (!covered) {\n          tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, tmpTileRange, tmpExtent);\n        }\n      }\n    }\n\n    var canvasScale = tileResolution / viewResolution; // set forward and inverse pixel transforms\n\n    composeTransform(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / tilePixelRatio, 1 / tilePixelRatio, rotation, -width / 2, -height / 2);\n    var canvasTransform = toTransformString(this.pixelTransform);\n    this.useContainer(target, canvasTransform, layerState.opacity, this.getBackground(frameState));\n    var context = this.context;\n    var canvas = context.canvas;\n    makeInverse(this.inversePixelTransform, this.pixelTransform); // set scale transform for calculating tile positions on the canvas\n\n    composeTransform(this.tempTransform, width / 2, height / 2, canvasScale, canvasScale, 0, -width / 2, -height / 2);\n\n    if (canvas.width != width || canvas.height != height) {\n      canvas.width = width;\n      canvas.height = height;\n    } else if (!this.containerReused) {\n      context.clearRect(0, 0, width, height);\n    }\n\n    if (layerExtent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n\n    if (!tileSource.getInterpolate()) {\n      assign(context, IMAGE_SMOOTHING_DISABLED);\n    }\n\n    this.preRender(context, frameState);\n    this.renderedTiles.length = 0;\n    /** @type {Array<number>} */\n\n    var zs = Object.keys(tilesToDrawByZ).map(Number);\n    zs.sort(numberSafeCompareFunction);\n    var clips, clipZs, currentClip;\n\n    if (layerState.opacity === 1 && (!this.containerReused || tileSource.getOpaque(frameState.viewState.projection))) {\n      zs = zs.reverse();\n    } else {\n      clips = [];\n      clipZs = [];\n    }\n\n    for (var i = zs.length - 1; i >= 0; --i) {\n      var currentZ = zs[i];\n      var currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);\n      var currentResolution = tileGrid.getResolution(currentZ);\n      var currentScale = currentResolution / tileResolution;\n      var dx_1 = currentTilePixelSize[0] * currentScale * canvasScale;\n      var dy_1 = currentTilePixelSize[1] * currentScale * canvasScale;\n      var originTileCoord = tileGrid.getTileCoordForCoordAndZ(getTopLeft(canvasExtent), currentZ);\n      var originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      var origin_1 = applyTransform(this.tempTransform, [tilePixelRatio * (originTileExtent[0] - canvasExtent[0]) / tileResolution, tilePixelRatio * (canvasExtent[3] - originTileExtent[3]) / tileResolution]);\n      var tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);\n      var tilesToDraw = tilesToDrawByZ[currentZ];\n\n      for (var tileCoordKey in tilesToDraw) {\n        var tile =\n        /** @type {import(\"../../ImageTile.js\").default} */\n        tilesToDraw[tileCoordKey];\n        var tileCoord = tile.tileCoord; // Calculate integer positions and sizes so that tiles align\n\n        var xIndex = originTileCoord[1] - tileCoord[1];\n        var nextX = Math.round(origin_1[0] - (xIndex - 1) * dx_1);\n        var yIndex = originTileCoord[2] - tileCoord[2];\n        var nextY = Math.round(origin_1[1] - (yIndex - 1) * dy_1);\n        var x = Math.round(origin_1[0] - xIndex * dx_1);\n        var y = Math.round(origin_1[1] - yIndex * dy_1);\n        var w = nextX - x;\n        var h = nextY - y;\n        var transition = z === currentZ;\n        var inTransition = transition && tile.getAlpha(getUid(this), frameState.time) !== 1;\n\n        if (!inTransition) {\n          if (clips) {\n            // Clip mask for regions in this tile that already filled by a higher z tile\n            context.save();\n            currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n\n            for (var i_1 = 0, ii = clips.length; i_1 < ii; ++i_1) {\n              if (z !== currentZ && currentZ < clipZs[i_1]) {\n                var clip = clips[i_1];\n                context.beginPath(); // counter-clockwise (outer ring) for current tile\n\n                context.moveTo(currentClip[0], currentClip[1]);\n                context.lineTo(currentClip[2], currentClip[3]);\n                context.lineTo(currentClip[4], currentClip[5]);\n                context.lineTo(currentClip[6], currentClip[7]); // clockwise (inner ring) for higher z tile\n\n                context.moveTo(clip[6], clip[7]);\n                context.lineTo(clip[4], clip[5]);\n                context.lineTo(clip[2], clip[3]);\n                context.lineTo(clip[0], clip[1]);\n                context.clip();\n              }\n            }\n\n            clips.push(currentClip);\n            clipZs.push(currentZ);\n          } else {\n            context.clearRect(x, y, w, h);\n          }\n        }\n\n        this.drawTileImage(tile, frameState, x, y, w, h, tileGutter, transition);\n\n        if (clips && !inTransition) {\n          context.restore();\n          this.renderedTiles.unshift(tile);\n        } else {\n          this.renderedTiles.push(tile);\n        }\n\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n\n    this.renderedRevision = sourceRevision;\n    this.renderedResolution = tileResolution;\n    this.extentChanged = !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n    this.renderedProjection = projection;\n    this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());\n    this.scheduleExpireCache(frameState, tileSource);\n    this.postRender(context, frameState);\n\n    if (layerState.extent) {\n      context.restore();\n    }\n\n    assign(context, IMAGE_SMOOTHING_ENABLED);\n\n    if (canvasTransform !== canvas.style.transform) {\n      canvas.style.transform = canvasTransform;\n    }\n\n    var opacity = cssOpacity(layerState.opacity);\n    var container = this.container;\n\n    if (opacity !== container.style.opacity) {\n      container.style.opacity = opacity;\n    }\n\n    return this.container;\n  };\n  /**\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   */\n\n\n  CanvasTileLayerRenderer.prototype.drawTileImage = function (tile, frameState, x, y, w, h, gutter, transition) {\n    var image = this.getTileImage(tile);\n\n    if (!image) {\n      return;\n    }\n\n    var uid = getUid(this);\n    var alpha = transition ? tile.getAlpha(uid, frameState.time) : 1;\n    var alphaChanged = alpha !== this.context.globalAlpha;\n\n    if (alphaChanged) {\n      this.context.save();\n      this.context.globalAlpha = alpha;\n    }\n\n    this.context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);\n\n    if (alphaChanged) {\n      this.context.restore();\n    }\n\n    if (alpha !== 1) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  };\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n\n\n  CanvasTileLayerRenderer.prototype.getImage = function () {\n    var context = this.context;\n    return context ? context.canvas : null;\n  };\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n\n\n  CanvasTileLayerRenderer.prototype.getTileImage = function (tile) {\n    return tile.getImage();\n  };\n  /**\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @protected\n   */\n\n\n  CanvasTileLayerRenderer.prototype.scheduleExpireCache = function (frameState, tileSource) {\n    if (tileSource.canExpireCache()) {\n      /**\n       * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n       * @param {import(\"../../PluggableMap.js\").default} map Map.\n       * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n       */\n      var postRenderFunction = function (tileSource, map, frameState) {\n        var tileSourceKey = getUid(tileSource);\n\n        if (tileSourceKey in frameState.usedTiles) {\n          tileSource.expireCache(frameState.viewState.projection, frameState.usedTiles[tileSourceKey]);\n        }\n      }.bind(null, tileSource);\n\n      frameState.postRenderFunctions.push(\n      /** @type {import(\"../../PluggableMap.js\").PostRenderFunction} */\n      postRenderFunction);\n    }\n  };\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n\n\n  CanvasTileLayerRenderer.prototype.updateUsedTiles = function (usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    var tileSourceKey = getUid(tileSource);\n\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  };\n  /**\n   * Manage tile pyramid.\n   * This function performs a number of functions related to the tiles at the\n   * current zoom and lower zoom levels:\n   * - registers idle tiles in frameState.wantedTiles so that they are not\n   *   discarded by the tile queue\n   * - enqueues missing tiles\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @param {import(\"../../extent.js\").Extent} extent Extent.\n   * @param {number} currentZ Current Z.\n   * @param {number} preload Load low resolution tiles up to 'preload' levels.\n   * @param {function(import(\"../../Tile.js\").default):void} [opt_tileCallback] Tile callback.\n   * @protected\n   */\n\n\n  CanvasTileLayerRenderer.prototype.manageTilePyramid = function (frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, opt_tileCallback) {\n    var tileSourceKey = getUid(tileSource);\n\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n\n    var wantedTiles = frameState.wantedTiles[tileSourceKey];\n    var tileQueue = frameState.tileQueue;\n    var minZoom = tileGrid.getMinZoom();\n    var tileCount = 0;\n    var tile, tileRange, tileResolution, x, y, z;\n\n    for (z = minZoom; z <= currentZ; ++z) {\n      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\n      tileResolution = tileGrid.getResolution(z);\n\n      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (currentZ - z <= preload) {\n            ++tileCount;\n            tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n\n            if (tile.getState() == TileState.IDLE) {\n              wantedTiles[tile.getKey()] = true;\n\n              if (!tileQueue.isKeyQueued(tile.getKey())) {\n                tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tile.tileCoord), tileResolution]);\n              }\n            }\n\n            if (opt_tileCallback !== undefined) {\n              opt_tileCallback(tile);\n            }\n          } else {\n            tileSource.useTile(z, x, y, projection);\n          }\n        }\n      }\n    }\n\n    tileSource.updateCacheSize(tileCount, projection);\n  };\n\n  return CanvasTileLayerRenderer;\n}(CanvasLayerRenderer);\n/**\n * @function\n * @return {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default}\n */\n\n\nCanvasTileLayerRenderer.prototype.getLayer;\nexport default CanvasTileLayerRenderer;","map":{"version":3,"sources":["/Users/rongxuan/node_modules/ol/src/renderer/canvas/TileLayer.js"],"names":[],"mappings":"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","sourcesContent":["/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport {IMAGE_SMOOTHING_DISABLED, IMAGE_SMOOTHING_ENABLED} from './common.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n  makeInverse,\n} from '../../transform.js';\nimport {assign} from '../../obj.js';\nimport {\n  createEmpty,\n  equals,\n  getIntersection,\n  getTopLeft,\n} from '../../extent.js';\nimport {cssOpacity} from '../../css.js';\nimport {fromUserExtent} from '../../proj.js';\nimport {getUid} from '../../util.js';\nimport {numberSafeCompareFunction} from '../../array.js';\nimport {toString as toTransformString} from '../../transform.js';\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n */\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default} tileLayer Tile layer.\n   */\n  constructor(tileLayer) {\n    super(tileLayer);\n\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    this.extentChanged = true;\n\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedPixelRatio;\n\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n    this.renderedProjection = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedRevision;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.newTiles_ = false;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tmpExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tmpTileRange_ = new TileRange(0, 0, 0, 0);\n  }\n\n  /**\n   * @protected\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n  isDrawableTile(tile) {\n    const tileLayer = this.getLayer();\n    const tileState = tile.getState();\n    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return (\n      tileState == TileState.LOADED ||\n      tileState == TileState.EMPTY ||\n      (tileState == TileState.ERROR && !useInterimTilesOnError)\n    );\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n  getTile(z, x, y, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const projection = frameState.viewState.projection;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    let tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n    if (tile.getState() == TileState.ERROR) {\n      if (!tileLayer.getUseInterimTilesOnError()) {\n        // When useInterimTilesOnError is false, we consider the error tile as loaded.\n        tile.setState(TileState.LOADED);\n      } else if (tileLayer.getPreload() > 0) {\n        // Preloaded tiles for lower resolutions might have finished loading.\n        this.newTiles_ = true;\n      }\n    }\n    if (!this.isDrawableTile(tile)) {\n      tile = tile.getInterimTile();\n    }\n    return tile;\n  }\n\n  /**\n   * @param {Object<number, Object<string, import(\"../../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @param {number} zoom Zoom level.\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\n   */\n  loadedTileCallback(tiles, zoom, tile) {\n    if (this.isDrawableTile(tile)) {\n      return super.loadedTileCallback(tiles, zoom, tile);\n    }\n    return false;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    return !!this.getLayer().getSource();\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n    const rotation = viewState.rotation;\n    const pixelRatio = frameState.pixelRatio;\n\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const sourceRevision = tileSource.getRevision();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n\n    let extent = frameState.extent;\n    const layerExtent =\n      layerState.extent && fromUserExtent(layerState.extent, projection);\n    if (layerExtent) {\n      extent = getIntersection(\n        extent,\n        fromUserExtent(layerState.extent, projection)\n      );\n    }\n\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n\n    // desired dimensions of the canvas in pixels\n    let width = Math.round(frameState.size[0] * tilePixelRatio);\n    let height = Math.round(frameState.size[1] * tilePixelRatio);\n\n    if (rotation) {\n      const size = Math.round(Math.sqrt(width * width + height * height));\n      width = size;\n      height = size;\n    }\n\n    const dx = (tileResolution * width) / 2 / tilePixelRatio;\n    const dy = (tileResolution * height) / 2 / tilePixelRatio;\n    const canvasExtent = [\n      viewCenter[0] - dx,\n      viewCenter[1] - dy,\n      viewCenter[0] + dx,\n      viewCenter[1] + dy,\n    ];\n\n    const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n\n    /**\n     * @type {Object<number, Object<string, import(\"../../Tile.js\").default>>}\n     */\n    const tilesToDrawByZ = {};\n    tilesToDrawByZ[z] = {};\n\n    const findLoadedTiles = this.createLoadedTileFinder(\n      tileSource,\n      projection,\n      tilesToDrawByZ\n    );\n\n    const tmpExtent = this.tmpExtent;\n    const tmpTileRange = this.tmpTileRange_;\n    this.newTiles_ = false;\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        const tile = this.getTile(z, x, y, frameState);\n        if (this.isDrawableTile(tile)) {\n          const uid = getUid(this);\n          if (tile.getState() == TileState.LOADED) {\n            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n            const inTransition = tile.inTransition(uid);\n            if (\n              !this.newTiles_ &&\n              (inTransition || this.renderedTiles.indexOf(tile) === -1)\n            ) {\n              this.newTiles_ = true;\n            }\n          }\n          if (tile.getAlpha(uid, frameState.time) === 1) {\n            // don't look for alt tiles if alpha is 1\n            continue;\n          }\n        }\n\n        const childTileRange = tileGrid.getTileCoordChildTileRange(\n          tile.tileCoord,\n          tmpTileRange,\n          tmpExtent\n        );\n\n        let covered = false;\n        if (childTileRange) {\n          covered = findLoadedTiles(z + 1, childTileRange);\n        }\n        if (!covered) {\n          tileGrid.forEachTileCoordParentTileRange(\n            tile.tileCoord,\n            findLoadedTiles,\n            tmpTileRange,\n            tmpExtent\n          );\n        }\n      }\n    }\n\n    const canvasScale = tileResolution / viewResolution;\n\n    // set forward and inverse pixel transforms\n    composeTransform(\n      this.pixelTransform,\n      frameState.size[0] / 2,\n      frameState.size[1] / 2,\n      1 / tilePixelRatio,\n      1 / tilePixelRatio,\n      rotation,\n      -width / 2,\n      -height / 2\n    );\n\n    const canvasTransform = toTransformString(this.pixelTransform);\n\n    this.useContainer(\n      target,\n      canvasTransform,\n      layerState.opacity,\n      this.getBackground(frameState)\n    );\n    const context = this.context;\n    const canvas = context.canvas;\n\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\n\n    // set scale transform for calculating tile positions on the canvas\n    composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      canvasScale,\n      canvasScale,\n      0,\n      -width / 2,\n      -height / 2\n    );\n\n    if (canvas.width != width || canvas.height != height) {\n      canvas.width = width;\n      canvas.height = height;\n    } else if (!this.containerReused) {\n      context.clearRect(0, 0, width, height);\n    }\n\n    if (layerExtent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n\n    if (!tileSource.getInterpolate()) {\n      assign(context, IMAGE_SMOOTHING_DISABLED);\n    }\n\n    this.preRender(context, frameState);\n\n    this.renderedTiles.length = 0;\n    /** @type {Array<number>} */\n    let zs = Object.keys(tilesToDrawByZ).map(Number);\n    zs.sort(numberSafeCompareFunction);\n\n    let clips, clipZs, currentClip;\n    if (\n      layerState.opacity === 1 &&\n      (!this.containerReused ||\n        tileSource.getOpaque(frameState.viewState.projection))\n    ) {\n      zs = zs.reverse();\n    } else {\n      clips = [];\n      clipZs = [];\n    }\n    for (let i = zs.length - 1; i >= 0; --i) {\n      const currentZ = zs[i];\n      const currentTilePixelSize = tileSource.getTilePixelSize(\n        currentZ,\n        pixelRatio,\n        projection\n      );\n      const currentResolution = tileGrid.getResolution(currentZ);\n      const currentScale = currentResolution / tileResolution;\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(\n        getTopLeft(canvasExtent),\n        currentZ\n      );\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      const origin = applyTransform(this.tempTransform, [\n        (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /\n          tileResolution,\n        (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /\n          tileResolution,\n      ]);\n      const tileGutter =\n        tilePixelRatio * tileSource.getGutterForProjection(projection);\n      const tilesToDraw = tilesToDrawByZ[currentZ];\n      for (const tileCoordKey in tilesToDraw) {\n        const tile = /** @type {import(\"../../ImageTile.js\").default} */ (\n          tilesToDraw[tileCoordKey]\n        );\n        const tileCoord = tile.tileCoord;\n\n        // Calculate integer positions and sizes so that tiles align\n        const xIndex = originTileCoord[1] - tileCoord[1];\n        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);\n        const yIndex = originTileCoord[2] - tileCoord[2];\n        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);\n        const x = Math.round(origin[0] - xIndex * dx);\n        const y = Math.round(origin[1] - yIndex * dy);\n        const w = nextX - x;\n        const h = nextY - y;\n        const transition = z === currentZ;\n\n        const inTransition =\n          transition && tile.getAlpha(getUid(this), frameState.time) !== 1;\n        if (!inTransition) {\n          if (clips) {\n            // Clip mask for regions in this tile that already filled by a higher z tile\n            context.save();\n            currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n            for (let i = 0, ii = clips.length; i < ii; ++i) {\n              if (z !== currentZ && currentZ < clipZs[i]) {\n                const clip = clips[i];\n                context.beginPath();\n                // counter-clockwise (outer ring) for current tile\n                context.moveTo(currentClip[0], currentClip[1]);\n                context.lineTo(currentClip[2], currentClip[3]);\n                context.lineTo(currentClip[4], currentClip[5]);\n                context.lineTo(currentClip[6], currentClip[7]);\n                // clockwise (inner ring) for higher z tile\n                context.moveTo(clip[6], clip[7]);\n                context.lineTo(clip[4], clip[5]);\n                context.lineTo(clip[2], clip[3]);\n                context.lineTo(clip[0], clip[1]);\n                context.clip();\n              }\n            }\n            clips.push(currentClip);\n            clipZs.push(currentZ);\n          } else {\n            context.clearRect(x, y, w, h);\n          }\n        }\n        this.drawTileImage(\n          tile,\n          frameState,\n          x,\n          y,\n          w,\n          h,\n          tileGutter,\n          transition\n        );\n        if (clips && !inTransition) {\n          context.restore();\n          this.renderedTiles.unshift(tile);\n        } else {\n          this.renderedTiles.push(tile);\n        }\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n\n    this.renderedRevision = sourceRevision;\n    this.renderedResolution = tileResolution;\n    this.extentChanged =\n      !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n    this.renderedProjection = projection;\n\n    this.manageTilePyramid(\n      frameState,\n      tileSource,\n      tileGrid,\n      pixelRatio,\n      projection,\n      extent,\n      z,\n      tileLayer.getPreload()\n    );\n    this.scheduleExpireCache(frameState, tileSource);\n\n    this.postRender(context, frameState);\n\n    if (layerState.extent) {\n      context.restore();\n    }\n    assign(context, IMAGE_SMOOTHING_ENABLED);\n\n    if (canvasTransform !== canvas.style.transform) {\n      canvas.style.transform = canvasTransform;\n    }\n    const opacity = cssOpacity(layerState.opacity);\n    const container = this.container;\n    if (opacity !== container.style.opacity) {\n      container.style.opacity = opacity;\n    }\n\n    return this.container;\n  }\n\n  /**\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   */\n  drawTileImage(tile, frameState, x, y, w, h, gutter, transition) {\n    const image = this.getTileImage(tile);\n    if (!image) {\n      return;\n    }\n    const uid = getUid(this);\n    const alpha = transition ? tile.getAlpha(uid, frameState.time) : 1;\n    const alphaChanged = alpha !== this.context.globalAlpha;\n    if (alphaChanged) {\n      this.context.save();\n      this.context.globalAlpha = alpha;\n    }\n    this.context.drawImage(\n      image,\n      gutter,\n      gutter,\n      image.width - 2 * gutter,\n      image.height - 2 * gutter,\n      x,\n      y,\n      w,\n      h\n    );\n\n    if (alphaChanged) {\n      this.context.restore();\n    }\n    if (alpha !== 1) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  getTileImage(tile) {\n    return tile.getImage();\n  }\n\n  /**\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @protected\n   */\n  scheduleExpireCache(frameState, tileSource) {\n    if (tileSource.canExpireCache()) {\n      /**\n       * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n       * @param {import(\"../../PluggableMap.js\").default} map Map.\n       * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n       */\n      const postRenderFunction = function (tileSource, map, frameState) {\n        const tileSourceKey = getUid(tileSource);\n        if (tileSourceKey in frameState.usedTiles) {\n          tileSource.expireCache(\n            frameState.viewState.projection,\n            frameState.usedTiles[tileSourceKey]\n          );\n        }\n      }.bind(null, tileSource);\n\n      frameState.postRenderFunctions.push(\n        /** @type {import(\"../../PluggableMap.js\").PostRenderFunction} */ (\n          postRenderFunction\n        )\n      );\n    }\n  }\n\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n  updateUsedTiles(usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  }\n\n  /**\n   * Manage tile pyramid.\n   * This function performs a number of functions related to the tiles at the\n   * current zoom and lower zoom levels:\n   * - registers idle tiles in frameState.wantedTiles so that they are not\n   *   discarded by the tile queue\n   * - enqueues missing tiles\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @param {import(\"../../extent.js\").Extent} extent Extent.\n   * @param {number} currentZ Current Z.\n   * @param {number} preload Load low resolution tiles up to 'preload' levels.\n   * @param {function(import(\"../../Tile.js\").default):void} [opt_tileCallback] Tile callback.\n   * @protected\n   */\n  manageTilePyramid(\n    frameState,\n    tileSource,\n    tileGrid,\n    pixelRatio,\n    projection,\n    extent,\n    currentZ,\n    preload,\n    opt_tileCallback\n  ) {\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n    const tileQueue = frameState.tileQueue;\n    const minZoom = tileGrid.getMinZoom();\n    let tileCount = 0;\n    let tile, tileRange, tileResolution, x, y, z;\n    for (z = minZoom; z <= currentZ; ++z) {\n      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\n      tileResolution = tileGrid.getResolution(z);\n      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (currentZ - z <= preload) {\n            ++tileCount;\n            tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n            if (tile.getState() == TileState.IDLE) {\n              wantedTiles[tile.getKey()] = true;\n              if (!tileQueue.isKeyQueued(tile.getKey())) {\n                tileQueue.enqueue([\n                  tile,\n                  tileSourceKey,\n                  tileGrid.getTileCoordCenter(tile.tileCoord),\n                  tileResolution,\n                ]);\n              }\n            }\n            if (opt_tileCallback !== undefined) {\n              opt_tileCallback(tile);\n            }\n          } else {\n            tileSource.useTile(z, x, y, projection);\n          }\n        }\n      }\n    }\n    tileSource.updateCacheSize(tileCount, projection);\n  }\n}\n\n/**\n * @function\n * @return {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default}\n */\nCanvasTileLayerRenderer.prototype.getLayer;\n\nexport default CanvasTileLayerRenderer;\n"]},"metadata":{},"sourceType":"module"}