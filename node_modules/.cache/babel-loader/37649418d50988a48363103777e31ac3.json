{"ast":null,"code":"/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v26.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n// when doing transactions, or change detection, and grouping is present\n// in the data, there is no need for the ClientSideRowModel to update each\n// group after an update, ony parts that were impacted by the change.\n// this class keeps track of all groups that were impacted by a transaction.\n// the the different CSRM operations (filter, sort etc) use the forEach method\n// to visit each group that was changed.\nvar ChangedPath =\n/** @class */\nfunction () {\n  function ChangedPath(keepingColumns, rootNode) {\n    // whether changed path is active of not. it is active when a) doing\n    // a transaction update or b) doing change detection. if we are doing\n    // a CSRM refresh for other reasons (after sort or filter, or user calling\n    // setRowData() without delta mode) then we are not active. we are also\n    // marked as not active if secondary columns change in pivot (as this impacts\n    // aggregations)\n    this.active = true; // for each node in the change path, we also store which columns need\n    // to be re-aggregated.\n\n    this.nodeIdsToColumns = {}; // for quick lookup, all items in the change path are mapped by nodeId\n\n    this.mapToItems = {};\n    this.keepingColumns = keepingColumns;\n    this.pathRoot = {\n      rowNode: rootNode,\n      children: null\n    };\n    this.mapToItems[rootNode.id] = this.pathRoot;\n  } // can be set inactive by:\n  // a) ClientSideRowModel, if no transactions or\n  // b) PivotService, if secondary columns changed\n\n\n  ChangedPath.prototype.setInactive = function () {\n    this.active = false;\n  };\n\n  ChangedPath.prototype.isActive = function () {\n    return this.active;\n  };\n\n  ChangedPath.prototype.depthFirstSearchChangedPath = function (pathItem, callback) {\n    if (pathItem.children) {\n      for (var i = 0; i < pathItem.children.length; i++) {\n        this.depthFirstSearchChangedPath(pathItem.children[i], callback);\n      }\n    }\n\n    callback(pathItem.rowNode);\n  };\n\n  ChangedPath.prototype.depthFirstSearchEverything = function (rowNode, callback, traverseEverything) {\n    if (rowNode.childrenAfterGroup) {\n      for (var i = 0; i < rowNode.childrenAfterGroup.length; i++) {\n        var childNode = rowNode.childrenAfterGroup[i];\n\n        if (childNode.childrenAfterGroup) {\n          this.depthFirstSearchEverything(rowNode.childrenAfterGroup[i], callback, traverseEverything);\n        } else if (traverseEverything) {\n          callback(childNode);\n        }\n      }\n    }\n\n    callback(rowNode);\n  }; // traverseLeafNodes -> used when NOT doing changed path, ie traversing everything. the callback\n  // will be called for child nodes in addition to parent nodes.\n\n\n  ChangedPath.prototype.forEachChangedNodeDepthFirst = function (callback, traverseLeafNodes) {\n    if (traverseLeafNodes === void 0) {\n      traverseLeafNodes = false;\n    }\n\n    if (this.active) {\n      // if we are active, then use the change path to callback\n      // only for updated groups\n      this.depthFirstSearchChangedPath(this.pathRoot, callback);\n    } else {\n      // we are not active, so callback for everything, walk the entire path\n      this.depthFirstSearchEverything(this.pathRoot.rowNode, callback, traverseLeafNodes);\n    }\n  };\n\n  ChangedPath.prototype.executeFromRootNode = function (callback) {\n    callback(this.pathRoot.rowNode);\n  };\n\n  ChangedPath.prototype.createPathItems = function (rowNode) {\n    var pointer = rowNode;\n    var newEntryCount = 0;\n\n    while (!this.mapToItems[pointer.id]) {\n      var newEntry = {\n        rowNode: pointer,\n        children: null\n      };\n      this.mapToItems[pointer.id] = newEntry;\n      newEntryCount++;\n      pointer = pointer.parent;\n    }\n\n    return newEntryCount;\n  };\n\n  ChangedPath.prototype.populateColumnsMap = function (rowNode, columns) {\n    var _this = this;\n\n    if (!this.keepingColumns || !columns) {\n      return;\n    }\n\n    var pointer = rowNode;\n\n    while (pointer) {\n      // if columns, add the columns in all the way to parent, merging\n      // in any other columns that might be there already\n      if (!this.nodeIdsToColumns[pointer.id]) {\n        this.nodeIdsToColumns[pointer.id] = {};\n      }\n\n      columns.forEach(function (col) {\n        return _this.nodeIdsToColumns[pointer.id][col.getId()] = true;\n      });\n      pointer = pointer.parent;\n    }\n  };\n\n  ChangedPath.prototype.linkPathItems = function (rowNode, newEntryCount) {\n    var pointer = rowNode;\n\n    for (var i = 0; i < newEntryCount; i++) {\n      var thisItem = this.mapToItems[pointer.id];\n      var parentItem = this.mapToItems[pointer.parent.id];\n\n      if (!parentItem.children) {\n        parentItem.children = [];\n      }\n\n      parentItem.children.push(thisItem);\n      pointer = pointer.parent;\n    }\n  }; // called by\n  // 1) change detection (provides cols) and\n  // 2) groupStage if doing transaction update (doesn't provide cols)\n\n\n  ChangedPath.prototype.addParentNode = function (rowNode, columns) {\n    if (!rowNode || rowNode.isRowPinned()) {\n      return;\n    } // we cannot do  both steps below in the same loop as\n    // the second loop has a dependency on the first loop.\n    // ie the hierarchy cannot be stitched up yet because\n    // we don't have it built yet\n    // create the new PathItem objects.\n\n\n    var newEntryCount = this.createPathItems(rowNode); // link in the node items\n\n    this.linkPathItems(rowNode, newEntryCount); // update columns\n\n    this.populateColumnsMap(rowNode, columns);\n  };\n\n  ChangedPath.prototype.canSkip = function (rowNode) {\n    return this.active && !this.mapToItems[rowNode.id];\n  };\n\n  ChangedPath.prototype.getValueColumnsForNode = function (rowNode, valueColumns) {\n    if (!this.keepingColumns) {\n      return valueColumns;\n    }\n\n    var colsForThisNode = this.nodeIdsToColumns[rowNode.id];\n    var result = valueColumns.filter(function (col) {\n      return colsForThisNode[col.getId()];\n    });\n    return result;\n  };\n\n  ChangedPath.prototype.getNotValueColumnsForNode = function (rowNode, valueColumns) {\n    if (!this.keepingColumns) {\n      return null;\n    }\n\n    var colsForThisNode = this.nodeIdsToColumns[rowNode.id];\n    var result = valueColumns.filter(function (col) {\n      return !colsForThisNode[col.getId()];\n    });\n    return result;\n  };\n\n  return ChangedPath;\n}();\n\nexport { ChangedPath };","map":{"version":3,"sources":["/Users/rongxuan/Desktop/reactmap/reactmap/node_modules/@ag-grid-community/core/dist/es6/utils/changedPath.js"],"names":["ChangedPath","keepingColumns","rootNode","active","nodeIdsToColumns","mapToItems","pathRoot","rowNode","children","id","prototype","setInactive","isActive","depthFirstSearchChangedPath","pathItem","callback","i","length","depthFirstSearchEverything","traverseEverything","childrenAfterGroup","childNode","forEachChangedNodeDepthFirst","traverseLeafNodes","executeFromRootNode","createPathItems","pointer","newEntryCount","newEntry","parent","populateColumnsMap","columns","_this","forEach","col","getId","linkPathItems","thisItem","parentItem","push","addParentNode","isRowPinned","canSkip","getValueColumnsForNode","valueColumns","colsForThisNode","result","filter","getNotValueColumnsForNode"],"mappings":"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","sourcesContent":["/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v26.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n// when doing transactions, or change detection, and grouping is present\n// in the data, there is no need for the ClientSideRowModel to update each\n// group after an update, ony parts that were impacted by the change.\n// this class keeps track of all groups that were impacted by a transaction.\n// the the different CSRM operations (filter, sort etc) use the forEach method\n// to visit each group that was changed.\nvar ChangedPath = /** @class */ (function () {\n    function ChangedPath(keepingColumns, rootNode) {\n        // whether changed path is active of not. it is active when a) doing\n        // a transaction update or b) doing change detection. if we are doing\n        // a CSRM refresh for other reasons (after sort or filter, or user calling\n        // setRowData() without delta mode) then we are not active. we are also\n        // marked as not active if secondary columns change in pivot (as this impacts\n        // aggregations)\n        this.active = true;\n        // for each node in the change path, we also store which columns need\n        // to be re-aggregated.\n        this.nodeIdsToColumns = {};\n        // for quick lookup, all items in the change path are mapped by nodeId\n        this.mapToItems = {};\n        this.keepingColumns = keepingColumns;\n        this.pathRoot = {\n            rowNode: rootNode,\n            children: null\n        };\n        this.mapToItems[rootNode.id] = this.pathRoot;\n    }\n    // can be set inactive by:\n    // a) ClientSideRowModel, if no transactions or\n    // b) PivotService, if secondary columns changed\n    ChangedPath.prototype.setInactive = function () {\n        this.active = false;\n    };\n    ChangedPath.prototype.isActive = function () {\n        return this.active;\n    };\n    ChangedPath.prototype.depthFirstSearchChangedPath = function (pathItem, callback) {\n        if (pathItem.children) {\n            for (var i = 0; i < pathItem.children.length; i++) {\n                this.depthFirstSearchChangedPath(pathItem.children[i], callback);\n            }\n        }\n        callback(pathItem.rowNode);\n    };\n    ChangedPath.prototype.depthFirstSearchEverything = function (rowNode, callback, traverseEverything) {\n        if (rowNode.childrenAfterGroup) {\n            for (var i = 0; i < rowNode.childrenAfterGroup.length; i++) {\n                var childNode = rowNode.childrenAfterGroup[i];\n                if (childNode.childrenAfterGroup) {\n                    this.depthFirstSearchEverything(rowNode.childrenAfterGroup[i], callback, traverseEverything);\n                }\n                else if (traverseEverything) {\n                    callback(childNode);\n                }\n            }\n        }\n        callback(rowNode);\n    };\n    // traverseLeafNodes -> used when NOT doing changed path, ie traversing everything. the callback\n    // will be called for child nodes in addition to parent nodes.\n    ChangedPath.prototype.forEachChangedNodeDepthFirst = function (callback, traverseLeafNodes) {\n        if (traverseLeafNodes === void 0) { traverseLeafNodes = false; }\n        if (this.active) {\n            // if we are active, then use the change path to callback\n            // only for updated groups\n            this.depthFirstSearchChangedPath(this.pathRoot, callback);\n        }\n        else {\n            // we are not active, so callback for everything, walk the entire path\n            this.depthFirstSearchEverything(this.pathRoot.rowNode, callback, traverseLeafNodes);\n        }\n    };\n    ChangedPath.prototype.executeFromRootNode = function (callback) {\n        callback(this.pathRoot.rowNode);\n    };\n    ChangedPath.prototype.createPathItems = function (rowNode) {\n        var pointer = rowNode;\n        var newEntryCount = 0;\n        while (!this.mapToItems[pointer.id]) {\n            var newEntry = {\n                rowNode: pointer,\n                children: null\n            };\n            this.mapToItems[pointer.id] = newEntry;\n            newEntryCount++;\n            pointer = pointer.parent;\n        }\n        return newEntryCount;\n    };\n    ChangedPath.prototype.populateColumnsMap = function (rowNode, columns) {\n        var _this = this;\n        if (!this.keepingColumns || !columns) {\n            return;\n        }\n        var pointer = rowNode;\n        while (pointer) {\n            // if columns, add the columns in all the way to parent, merging\n            // in any other columns that might be there already\n            if (!this.nodeIdsToColumns[pointer.id]) {\n                this.nodeIdsToColumns[pointer.id] = {};\n            }\n            columns.forEach(function (col) { return _this.nodeIdsToColumns[pointer.id][col.getId()] = true; });\n            pointer = pointer.parent;\n        }\n    };\n    ChangedPath.prototype.linkPathItems = function (rowNode, newEntryCount) {\n        var pointer = rowNode;\n        for (var i = 0; i < newEntryCount; i++) {\n            var thisItem = this.mapToItems[pointer.id];\n            var parentItem = this.mapToItems[pointer.parent.id];\n            if (!parentItem.children) {\n                parentItem.children = [];\n            }\n            parentItem.children.push(thisItem);\n            pointer = pointer.parent;\n        }\n    };\n    // called by\n    // 1) change detection (provides cols) and\n    // 2) groupStage if doing transaction update (doesn't provide cols)\n    ChangedPath.prototype.addParentNode = function (rowNode, columns) {\n        if (!rowNode || rowNode.isRowPinned()) {\n            return;\n        }\n        // we cannot do  both steps below in the same loop as\n        // the second loop has a dependency on the first loop.\n        // ie the hierarchy cannot be stitched up yet because\n        // we don't have it built yet\n        // create the new PathItem objects.\n        var newEntryCount = this.createPathItems(rowNode);\n        // link in the node items\n        this.linkPathItems(rowNode, newEntryCount);\n        // update columns\n        this.populateColumnsMap(rowNode, columns);\n    };\n    ChangedPath.prototype.canSkip = function (rowNode) {\n        return this.active && !this.mapToItems[rowNode.id];\n    };\n    ChangedPath.prototype.getValueColumnsForNode = function (rowNode, valueColumns) {\n        if (!this.keepingColumns) {\n            return valueColumns;\n        }\n        var colsForThisNode = this.nodeIdsToColumns[rowNode.id];\n        var result = valueColumns.filter(function (col) { return colsForThisNode[col.getId()]; });\n        return result;\n    };\n    ChangedPath.prototype.getNotValueColumnsForNode = function (rowNode, valueColumns) {\n        if (!this.keepingColumns) {\n            return null;\n        }\n        var colsForThisNode = this.nodeIdsToColumns[rowNode.id];\n        var result = valueColumns.filter(function (col) { return !colsForThisNode[col.getId()]; });\n        return result;\n    };\n    return ChangedPath;\n}());\nexport { ChangedPath };\n"]},"metadata":{},"sourceType":"module"}