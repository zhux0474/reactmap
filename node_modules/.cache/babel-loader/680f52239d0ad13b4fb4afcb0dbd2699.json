{"ast":null,"code":"/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v26.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\n\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n};\n\nimport { ColumnGroup } from '../entities/columnGroup';\nimport { Column } from '../entities/column';\nimport { Events } from '../events';\nimport { BeanStub } from \"../context/beanStub\";\nimport { ProvidedColumnGroup } from '../entities/providedColumnGroup';\nimport { GroupInstanceIdCreator } from './groupInstanceIdCreator';\nimport { Autowired, Bean, Optional, PostConstruct, Qualifier } from '../context/context';\nimport { Constants } from '../constants/constants';\nimport { areEqual, last, removeFromArray, moveInArray, filter, includes, insertIntoArray, removeAllFromArray } from '../utils/array';\nimport { missingOrEmpty, exists, missing, find, attrToBoolean, attrToNumber } from '../utils/generic';\nimport { camelCaseToHumanText, startsWith } from '../utils/string';\nimport { convertToMap } from '../utils/map';\nimport { doOnce } from '../utils/function';\n\nvar ColumnModel =\n/** @class */\nfunction (_super) {\n  __extends(ColumnModel, _super);\n\n  function ColumnModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this; // header row count, based on user provided columns\n\n\n    _this.primaryHeaderRowCount = 0;\n    _this.secondaryHeaderRowCount = 0;\n    _this.secondaryColumnsPresent = false; // header row count, either above, or based on pivoting if we are pivoting\n\n    _this.gridHeaderRowCount = 0; // leave level columns of the displayed trees\n\n    _this.displayedColumnsLeft = [];\n    _this.displayedColumnsRight = [];\n    _this.displayedColumnsCenter = []; // all three lists above combined\n\n    _this.displayedColumns = []; // for fast lookup, to see if a column or group is still displayed\n\n    _this.displayedColumnsAndGroupsMap = {}; // all columns to be rendered\n\n    _this.viewportColumns = []; // all columns to be rendered in the centre\n\n    _this.viewportColumnsCenter = [];\n    _this.autoHeightActiveAtLeastOnce = false;\n    _this.rowGroupColumns = [];\n    _this.valueColumns = [];\n    _this.pivotColumns = [];\n    _this.ready = false;\n    _this.autoGroupsNeedBuilding = false;\n    _this.forceRecreateAutoGroups = false;\n    _this.pivotMode = false;\n    _this.bodyWidth = 0;\n    _this.leftWidth = 0;\n    _this.rightWidth = 0;\n    _this.bodyWidthDirty = true;\n    _this.colDefVersion = 0;\n    _this.flexColsCalculatedAtLestOnce = false;\n    return _this;\n  }\n\n  ColumnModel.prototype.init = function () {\n    this.suppressColumnVirtualisation = this.gridOptionsWrapper.isSuppressColumnVirtualisation();\n    var pivotMode = this.gridOptionsWrapper.isPivotMode();\n\n    if (this.isPivotSettingAllowed(pivotMode)) {\n      this.pivotMode = pivotMode;\n    }\n\n    this.usingTreeData = this.gridOptionsWrapper.isTreeData();\n    this.addManagedListener(this.gridOptionsWrapper, 'autoGroupColumnDef', this.onAutoGroupColumnDefChanged.bind(this));\n  };\n\n  ColumnModel.prototype.onAutoGroupColumnDefChanged = function () {\n    this.autoGroupsNeedBuilding = true;\n    this.forceRecreateAutoGroups = true;\n    this.updateGridColumns();\n    this.updateDisplayedColumns('gridOptionsChanged');\n  };\n\n  ColumnModel.prototype.getColDefVersion = function () {\n    return this.colDefVersion;\n  };\n\n  ColumnModel.prototype.setColumnDefs = function (columnDefs, source) {\n    var _this = this;\n\n    if (source === void 0) {\n      source = 'api';\n    }\n\n    var colsPreviouslyExisted = !!this.columnDefs;\n    this.colDefVersion++;\n    var raiseEventsFunc = this.compareColumnStatesAndRaiseEvents(source);\n    this.columnDefs = columnDefs; // always invalidate cache on changing columns, as the column id's for the new columns\n    // could overlap with the old id's, so the cache would return old values for new columns.\n\n    this.valueCache.expire(); // NOTE ==================\n    // we should be destroying the existing columns and groups if they exist, for example, the original column\n    // group adds a listener to the columns, it should be also removing the listeners\n\n    this.autoGroupsNeedBuilding = true;\n    var oldPrimaryColumns = this.primaryColumns;\n    var oldPrimaryTree = this.primaryColumnTree;\n    var balancedTreeResult = this.columnFactory.createColumnTree(columnDefs, true, oldPrimaryTree);\n    this.primaryColumnTree = balancedTreeResult.columnTree;\n    this.primaryHeaderRowCount = balancedTreeResult.treeDept + 1;\n    this.primaryColumns = this.getColumnsFromTree(this.primaryColumnTree);\n    this.primaryColumnsMap = {};\n    this.primaryColumns.forEach(function (col) {\n      return _this.primaryColumnsMap[col.getId()] = col;\n    });\n    this.extractRowGroupColumns(source, oldPrimaryColumns);\n    this.extractPivotColumns(source, oldPrimaryColumns);\n    this.extractValueColumns(source, oldPrimaryColumns);\n    this.ready = true;\n    this.updateGridColumns();\n\n    if (colsPreviouslyExisted && this.gridColsArePrimary && !this.gridOptionsWrapper.isMaintainColumnOrder()) {\n      this.orderGridColumnsLikePrimary();\n    }\n\n    this.updateDisplayedColumns(source);\n    this.checkViewportColumns(); // this event is not used by AG Grid, but left here for backwards compatibility,\n    // in case applications use it\n\n    this.dispatchEverythingChanged(source);\n    raiseEventsFunc();\n    this.dispatchNewColumnsLoaded();\n  };\n\n  ColumnModel.prototype.dispatchNewColumnsLoaded = function () {\n    var newColumnsLoadedEvent = {\n      type: Events.EVENT_NEW_COLUMNS_LOADED,\n      api: this.gridApi,\n      columnApi: this.columnApi\n    };\n    this.eventService.dispatchEvent(newColumnsLoadedEvent);\n  }; // this event is legacy, no grid code listens to it. instead the grid listens to New Columns Loaded\n\n\n  ColumnModel.prototype.dispatchEverythingChanged = function (source) {\n    if (source === void 0) {\n      source = 'api';\n    }\n\n    var eventEverythingChanged = {\n      type: Events.EVENT_COLUMN_EVERYTHING_CHANGED,\n      api: this.gridApi,\n      columnApi: this.columnApi,\n      source: source\n    };\n    this.eventService.dispatchEvent(eventEverythingChanged);\n  };\n\n  ColumnModel.prototype.orderGridColumnsLikePrimary = function () {\n    var _this = this;\n\n    var primaryColumns = this.primaryColumns;\n\n    if (!primaryColumns) {\n      return;\n    }\n\n    this.gridColumns.sort(function (colA, colB) {\n      var primaryIndexA = primaryColumns.indexOf(colA);\n      var primaryIndexB = primaryColumns.indexOf(colB); // if both cols are present in primary, then we just return the position,\n      // so position is maintained.\n\n      var indexAPresent = primaryIndexA >= 0;\n      var indexBPresent = primaryIndexB >= 0;\n\n      if (indexAPresent && indexBPresent) {\n        return primaryIndexA - primaryIndexB;\n      }\n\n      if (indexAPresent) {\n        // B is auto group column, so put B first\n        return 1;\n      }\n\n      if (indexBPresent) {\n        // A is auto group column, so put A first\n        return -1;\n      } // otherwise both A and B are auto-group columns. so we just keep the order\n      // as they were already in.\n\n\n      var gridIndexA = _this.gridColumns.indexOf(colA);\n\n      var gridIndexB = _this.gridColumns.indexOf(colB);\n\n      return gridIndexA - gridIndexB;\n    });\n  };\n\n  ColumnModel.prototype.getAllDisplayedAutoHeightCols = function () {\n    return this.displayedAutoHeightCols;\n  };\n\n  ColumnModel.prototype.setViewport = function () {\n    if (this.gridOptionsWrapper.isEnableRtl()) {\n      this.viewportLeft = this.bodyWidth - this.scrollPosition - this.scrollWidth;\n      this.viewportRight = this.bodyWidth - this.scrollPosition;\n    } else {\n      this.viewportLeft = this.scrollPosition;\n      this.viewportRight = this.scrollWidth + this.scrollPosition;\n    }\n  }; // used by clipboard service, to know what columns to paste into\n\n\n  ColumnModel.prototype.getDisplayedColumnsStartingAt = function (column) {\n    var currentColumn = column;\n    var columns = [];\n\n    while (currentColumn != null) {\n      columns.push(currentColumn);\n      currentColumn = this.getDisplayedColAfter(currentColumn);\n    }\n\n    return columns;\n  }; // checks what columns are currently displayed due to column virtualisation. fires an event\n  // if the list of columns has changed.\n  // + setColumnWidth(), setViewportPosition(), setColumnDefs(), sizeColumnsToFit()\n\n\n  ColumnModel.prototype.checkViewportColumns = function () {\n    // check displayCenterColumnTree exists first, as it won't exist when grid is initialising\n    if (this.displayedColumnsCenter == null) {\n      return;\n    }\n\n    var hashBefore = this.viewportColumns.map(function (column) {\n      return column.getId();\n    }).join('#');\n    this.extractViewport();\n    var hashAfter = this.viewportColumns.map(function (column) {\n      return column.getId();\n    }).join('#');\n\n    if (hashBefore !== hashAfter) {\n      var event_1 = {\n        type: Events.EVENT_VIRTUAL_COLUMNS_CHANGED,\n        api: this.gridApi,\n        columnApi: this.columnApi\n      };\n      this.eventService.dispatchEvent(event_1);\n    }\n  };\n\n  ColumnModel.prototype.setViewportPosition = function (scrollWidth, scrollPosition) {\n    if (scrollWidth !== this.scrollWidth || scrollPosition !== this.scrollPosition || this.bodyWidthDirty) {\n      this.scrollWidth = scrollWidth;\n      this.scrollPosition = scrollPosition; // we need to call setVirtualViewportLeftAndRight() at least once after the body width changes,\n      // as the viewport can stay the same, but in RTL, if body width changes, we need to work out the\n      // virtual columns again\n\n      this.bodyWidthDirty = true;\n      this.setViewport();\n\n      if (this.ready) {\n        this.checkViewportColumns();\n      }\n    }\n  };\n\n  ColumnModel.prototype.isPivotMode = function () {\n    return this.pivotMode;\n  };\n\n  ColumnModel.prototype.isPivotSettingAllowed = function (pivot) {\n    if (pivot && this.gridOptionsWrapper.isTreeData()) {\n      console.warn(\"AG Grid: Pivot mode not available in conjunction Tree Data i.e. 'gridOptions.treeData: true'\");\n      return false;\n    }\n\n    return true;\n  };\n\n  ColumnModel.prototype.setPivotMode = function (pivotMode, source) {\n    if (source === void 0) {\n      source = 'api';\n    }\n\n    if (pivotMode === this.pivotMode || !this.isPivotSettingAllowed(this.pivotMode)) {\n      return;\n    }\n\n    this.pivotMode = pivotMode; // we need to update grid columns to cover the scenario where user has groupSuppressAutoColumn=true, as\n    // this means we don't use auto group column UNLESS we are in pivot mode (it's mandatory in pivot mode),\n    // so need to updateGridColumn() to check it autoGroupCol needs to be added / removed\n\n    this.autoGroupsNeedBuilding = true;\n    this.updateGridColumns();\n    this.updateDisplayedColumns(source);\n    var event = {\n      type: Events.EVENT_COLUMN_PIVOT_MODE_CHANGED,\n      api: this.gridApi,\n      columnApi: this.columnApi\n    };\n    this.eventService.dispatchEvent(event);\n  };\n\n  ColumnModel.prototype.getSecondaryPivotColumn = function (pivotKeys, valueColKey) {\n    if (!this.secondaryColumnsPresent || !this.secondaryColumns) {\n      return null;\n    }\n\n    var valueColumnToFind = this.getPrimaryColumn(valueColKey);\n    var foundColumn = null;\n    this.secondaryColumns.forEach(function (column) {\n      var thisPivotKeys = column.getColDef().pivotKeys;\n      var pivotValueColumn = column.getColDef().pivotValueColumn;\n      var pivotKeyMatches = areEqual(thisPivotKeys, pivotKeys);\n      var pivotValueMatches = pivotValueColumn === valueColumnToFind;\n\n      if (pivotKeyMatches && pivotValueMatches) {\n        foundColumn = column;\n      }\n    });\n    return foundColumn;\n  };\n\n  ColumnModel.prototype.setBeans = function (loggerFactory) {\n    this.logger = loggerFactory.create('columnModel');\n  };\n\n  ColumnModel.prototype.setFirstRightAndLastLeftPinned = function (source) {\n    var lastLeft;\n    var firstRight;\n\n    if (this.gridOptionsWrapper.isEnableRtl()) {\n      lastLeft = this.displayedColumnsLeft ? this.displayedColumnsLeft[0] : null;\n      firstRight = this.displayedColumnsRight ? last(this.displayedColumnsRight) : null;\n    } else {\n      lastLeft = this.displayedColumnsLeft ? last(this.displayedColumnsLeft) : null;\n      firstRight = this.displayedColumnsRight ? this.displayedColumnsRight[0] : null;\n    }\n\n    this.gridColumns.forEach(function (column) {\n      column.setLastLeftPinned(column === lastLeft, source);\n      column.setFirstRightPinned(column === firstRight, source);\n    });\n  };\n\n  ColumnModel.prototype.autoSizeColumns = function (keys, skipHeader, source) {\n    // because of column virtualisation, we can only do this function on columns that are\n    // actually rendered, as non-rendered columns (outside the viewport and not rendered\n    // due to column virtualisation) are not present. this can result in all rendered columns\n    // getting narrowed, which in turn introduces more rendered columns on the RHS which\n    // did not get autosized in the original run, leaving the visible grid with columns on\n    // the LHS sized, but RHS no. so we keep looping through the visible columns until\n    // no more cols are available (rendered) to be resized\n    var _this = this;\n\n    if (source === void 0) {\n      source = \"api\";\n    } // we autosize after animation frames finish in case any cell renderers need to complete first. this can\n    // happen eg if client code is calling api.autoSizeAllColumns() straight after grid is initialised, but grid\n    // hasn't fully drawn out all the cells yet (due to cell renderers in animation frames).\n\n\n    this.animationFrameService.flushAllFrames(); // keep track of which cols we have resized in here\n\n    var columnsAutosized = []; // initialise with anything except 0 so that while loop executes at least once\n\n    var changesThisTimeAround = -1;\n\n    if (skipHeader == null) {\n      skipHeader = this.gridOptionsWrapper.isSkipHeaderOnAutoSize();\n    }\n\n    while (changesThisTimeAround !== 0) {\n      changesThisTimeAround = 0;\n      this.actionOnGridColumns(keys, function (column) {\n        // if already autosized, skip it\n        if (columnsAutosized.indexOf(column) >= 0) {\n          return false;\n        } // get how wide this col should be\n\n\n        var preferredWidth = _this.autoWidthCalculator.getPreferredWidthForColumn(column, skipHeader); // preferredWidth = -1 if this col is not on the screen\n\n\n        if (preferredWidth > 0) {\n          var newWidth = _this.normaliseColumnWidth(column, preferredWidth);\n\n          column.setActualWidth(newWidth, source);\n          columnsAutosized.push(column);\n          changesThisTimeAround++;\n        }\n\n        return true;\n      }, source);\n    }\n\n    this.fireColumnResizedEvent(columnsAutosized, true, 'autosizeColumns');\n  };\n\n  ColumnModel.prototype.fireColumnResizedEvent = function (columns, finished, source, flexColumns) {\n    if (flexColumns === void 0) {\n      flexColumns = null;\n    }\n\n    if (columns && columns.length) {\n      var event_2 = {\n        type: Events.EVENT_COLUMN_RESIZED,\n        columns: columns,\n        column: columns.length === 1 ? columns[0] : null,\n        flexColumns: flexColumns,\n        finished: finished,\n        api: this.gridApi,\n        columnApi: this.columnApi,\n        source: source\n      };\n      this.eventService.dispatchEvent(event_2);\n    }\n  };\n\n  ColumnModel.prototype.autoSizeColumn = function (key, skipHeader, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    if (key) {\n      this.autoSizeColumns([key], skipHeader, source);\n    }\n  };\n\n  ColumnModel.prototype.autoSizeAllColumns = function (skipHeader, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    var allDisplayedColumns = this.getAllDisplayedColumns();\n    this.autoSizeColumns(allDisplayedColumns, skipHeader, source);\n  };\n\n  ColumnModel.prototype.getColumnsFromTree = function (rootColumns) {\n    var result = [];\n\n    var recursiveFindColumns = function (childColumns) {\n      for (var i = 0; i < childColumns.length; i++) {\n        var child = childColumns[i];\n\n        if (child instanceof Column) {\n          result.push(child);\n        } else if (child instanceof ProvidedColumnGroup) {\n          recursiveFindColumns(child.getChildren());\n        }\n      }\n    };\n\n    recursiveFindColumns(rootColumns);\n    return result;\n  };\n\n  ColumnModel.prototype.getAllDisplayedTrees = function () {\n    if (this.displayedTreeLeft && this.displayedTreeRight && this.displayedTreeCentre) {\n      return this.displayedTreeLeft.concat(this.displayedTreeCentre).concat(this.displayedTreeRight);\n    }\n\n    return null;\n  }; // + columnSelectPanel\n\n\n  ColumnModel.prototype.getPrimaryColumnTree = function () {\n    return this.primaryColumnTree;\n  }; // + gridPanel -> for resizing the body and setting top margin\n\n\n  ColumnModel.prototype.getHeaderRowCount = function () {\n    return this.gridHeaderRowCount;\n  }; // + headerRenderer -> setting pinned body width\n\n\n  ColumnModel.prototype.getDisplayedTreeLeft = function () {\n    return this.displayedTreeLeft;\n  }; // + headerRenderer -> setting pinned body width\n\n\n  ColumnModel.prototype.getDisplayedTreeRight = function () {\n    return this.displayedTreeRight;\n  }; // + headerRenderer -> setting pinned body width\n\n\n  ColumnModel.prototype.getDisplayedTreeCentre = function () {\n    return this.displayedTreeCentre;\n  }; // gridPanel -> ensureColumnVisible\n\n\n  ColumnModel.prototype.isColumnDisplayed = function (column) {\n    return this.getAllDisplayedColumns().indexOf(column) >= 0;\n  }; // + csvCreator\n\n\n  ColumnModel.prototype.getAllDisplayedColumns = function () {\n    return this.displayedColumns;\n  };\n\n  ColumnModel.prototype.getViewportColumns = function () {\n    return this.viewportColumns;\n  };\n\n  ColumnModel.prototype.getDisplayedLeftColumnsForRow = function (rowNode) {\n    if (!this.colSpanActive) {\n      return this.displayedColumnsLeft;\n    }\n\n    return this.getDisplayedColumnsForRow(rowNode, this.displayedColumnsLeft);\n  };\n\n  ColumnModel.prototype.getDisplayedRightColumnsForRow = function (rowNode) {\n    if (!this.colSpanActive) {\n      return this.displayedColumnsRight;\n    }\n\n    return this.getDisplayedColumnsForRow(rowNode, this.displayedColumnsRight);\n  };\n\n  ColumnModel.prototype.getDisplayedColumnsForRow = function (rowNode, displayedColumns, filterCallback, emptySpaceBeforeColumn) {\n    var result = [];\n    var lastConsideredCol = null;\n\n    var _loop_1 = function (i) {\n      var col = displayedColumns[i];\n      var maxAllowedColSpan = displayedColumns.length - i;\n      var colSpan = Math.min(col.getColSpan(rowNode), maxAllowedColSpan);\n      var columnsToCheckFilter = [col];\n\n      if (colSpan > 1) {\n        var colsToRemove = colSpan - 1;\n\n        for (var j = 1; j <= colsToRemove; j++) {\n          columnsToCheckFilter.push(displayedColumns[i + j]);\n        }\n\n        i += colsToRemove;\n      } // see which cols we should take out for column virtualisation\n\n\n      var filterPasses;\n\n      if (filterCallback) {\n        // if user provided a callback, means some columns may not be in the viewport.\n        // the user will NOT provide a callback if we are talking about pinned areas,\n        // as pinned areas have no horizontal scroll and do not virtualise the columns.\n        // if lots of columns, that means column spanning, and we set filterPasses = true\n        // if one or more of the columns spanned pass the filter.\n        filterPasses = false;\n        columnsToCheckFilter.forEach(function (colForFilter) {\n          if (filterCallback(colForFilter)) {\n            filterPasses = true;\n          }\n        });\n      } else {\n        filterPasses = true;\n      }\n\n      if (filterPasses) {\n        if (result.length === 0 && lastConsideredCol) {\n          var gapBeforeColumn = emptySpaceBeforeColumn ? emptySpaceBeforeColumn(col) : false;\n\n          if (gapBeforeColumn) {\n            result.push(lastConsideredCol);\n          }\n        }\n\n        result.push(col);\n      }\n\n      lastConsideredCol = col;\n      out_i_1 = i;\n    };\n\n    var out_i_1;\n\n    for (var i = 0; i < displayedColumns.length; i++) {\n      _loop_1(i);\n\n      i = out_i_1;\n    }\n\n    return result;\n  }; // + rowRenderer\n  // if we are not column spanning, this just returns back the virtual centre columns,\n  // however if we are column spanning, then different rows can have different virtual\n  // columns, so we have to work out the list for each individual row.\n\n\n  ColumnModel.prototype.getViewportCenterColumnsForRow = function (rowNode) {\n    var _this = this;\n\n    if (!this.colSpanActive) {\n      return this.viewportColumnsCenter;\n    }\n\n    var emptySpaceBeforeColumn = function (col) {\n      var left = col.getLeft();\n      return exists(left) && left > _this.viewportLeft;\n    }; // if doing column virtualisation, then we filter based on the viewport.\n\n\n    var filterCallback = this.suppressColumnVirtualisation ? null : this.isColumnInViewport.bind(this);\n    return this.getDisplayedColumnsForRow(rowNode, this.displayedColumnsCenter, filterCallback, emptySpaceBeforeColumn);\n  };\n\n  ColumnModel.prototype.getAriaColumnIndex = function (col) {\n    return this.getAllGridColumns().indexOf(col) + 1;\n  };\n\n  ColumnModel.prototype.isColumnInViewport = function (col) {\n    // we never filter out autoHeight columns, as we need them in the DOM for calculating Auto Height\n    if (col.getColDef().autoHeight) {\n      return true;\n    }\n\n    var columnLeft = col.getLeft() || 0;\n    var columnRight = columnLeft + col.getActualWidth(); // adding 200 for buffer size, so some cols off viewport are rendered.\n    // this helps horizontal scrolling so user rarely sees white space (unless\n    // they scroll horizontally fast). however we are conservative, as the more\n    // buffer the slower the vertical redraw speed\n\n    var leftBounds = this.viewportLeft - 200;\n    var rightBounds = this.viewportRight + 200;\n    var columnToMuchLeft = columnLeft < leftBounds && columnRight < leftBounds;\n    var columnToMuchRight = columnLeft > rightBounds && columnRight > rightBounds;\n    return !columnToMuchLeft && !columnToMuchRight;\n  }; // used by:\n  // + angularGrid -> setting pinned body width\n  // note: this should be cached\n\n\n  ColumnModel.prototype.getDisplayedColumnsLeftWidth = function () {\n    return this.getWidthOfColsInList(this.displayedColumnsLeft);\n  }; // note: this should be cached\n\n\n  ColumnModel.prototype.getDisplayedColumnsRightWidth = function () {\n    return this.getWidthOfColsInList(this.displayedColumnsRight);\n  };\n\n  ColumnModel.prototype.updatePrimaryColumnList = function (keys, masterList, actionIsAdd, columnCallback, eventType, source) {\n    var _this = this;\n\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    if (!keys || missingOrEmpty(keys)) {\n      return;\n    }\n\n    var atLeastOne = false;\n    keys.forEach(function (key) {\n      var columnToAdd = _this.getPrimaryColumn(key);\n\n      if (!columnToAdd) {\n        return;\n      }\n\n      if (actionIsAdd) {\n        if (masterList.indexOf(columnToAdd) >= 0) {\n          return;\n        }\n\n        masterList.push(columnToAdd);\n      } else {\n        if (masterList.indexOf(columnToAdd) < 0) {\n          return;\n        }\n\n        removeFromArray(masterList, columnToAdd);\n      }\n\n      columnCallback(columnToAdd);\n      atLeastOne = true;\n    });\n\n    if (!atLeastOne) {\n      return;\n    }\n\n    if (this.autoGroupsNeedBuilding) {\n      this.updateGridColumns();\n    }\n\n    this.updateDisplayedColumns(source);\n    var event = {\n      type: eventType,\n      columns: masterList,\n      column: masterList.length === 1 ? masterList[0] : null,\n      api: this.gridApi,\n      columnApi: this.columnApi,\n      source: source\n    };\n    this.eventService.dispatchEvent(event);\n  };\n\n  ColumnModel.prototype.setRowGroupColumns = function (colKeys, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.autoGroupsNeedBuilding = true;\n    this.setPrimaryColumnList(colKeys, this.rowGroupColumns, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.setRowGroupActive.bind(this), source);\n  };\n\n  ColumnModel.prototype.setRowGroupActive = function (active, column, source) {\n    if (active === column.isRowGroupActive()) {\n      return;\n    }\n\n    column.setRowGroupActive(active, source);\n\n    if (!active && !this.gridOptionsWrapper.isSuppressMakeColumnVisibleAfterUnGroup()) {\n      column.setVisible(true, source);\n    }\n  };\n\n  ColumnModel.prototype.addRowGroupColumn = function (key, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    if (key) {\n      this.addRowGroupColumns([key], source);\n    }\n  };\n\n  ColumnModel.prototype.addRowGroupColumns = function (keys, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.autoGroupsNeedBuilding = true;\n    this.updatePrimaryColumnList(keys, this.rowGroupColumns, true, this.setRowGroupActive.bind(this, true), Events.EVENT_COLUMN_ROW_GROUP_CHANGED, source);\n  };\n\n  ColumnModel.prototype.removeRowGroupColumns = function (keys, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.autoGroupsNeedBuilding = true;\n    this.updatePrimaryColumnList(keys, this.rowGroupColumns, false, this.setRowGroupActive.bind(this, false), Events.EVENT_COLUMN_ROW_GROUP_CHANGED, source);\n  };\n\n  ColumnModel.prototype.removeRowGroupColumn = function (key, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    if (key) {\n      this.removeRowGroupColumns([key], source);\n    }\n  };\n\n  ColumnModel.prototype.addPivotColumns = function (keys, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.updatePrimaryColumnList(keys, this.pivotColumns, true, function (column) {\n      return column.setPivotActive(true, source);\n    }, Events.EVENT_COLUMN_PIVOT_CHANGED, source);\n  };\n\n  ColumnModel.prototype.setPivotColumns = function (colKeys, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.setPrimaryColumnList(colKeys, this.pivotColumns, Events.EVENT_COLUMN_PIVOT_CHANGED, function (added, column) {\n      column.setPivotActive(added, source);\n    }, source);\n  };\n\n  ColumnModel.prototype.addPivotColumn = function (key, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.addPivotColumns([key], source);\n  };\n\n  ColumnModel.prototype.removePivotColumns = function (keys, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.updatePrimaryColumnList(keys, this.pivotColumns, false, function (column) {\n      return column.setPivotActive(false, source);\n    }, Events.EVENT_COLUMN_PIVOT_CHANGED, source);\n  };\n\n  ColumnModel.prototype.removePivotColumn = function (key, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.removePivotColumns([key], source);\n  };\n\n  ColumnModel.prototype.setPrimaryColumnList = function (colKeys, masterList, eventName, columnCallback, source) {\n    var _this = this;\n\n    masterList.length = 0;\n\n    if (exists(colKeys)) {\n      colKeys.forEach(function (key) {\n        var column = _this.getPrimaryColumn(key);\n\n        if (column) {\n          masterList.push(column);\n        }\n      });\n    }\n\n    (this.primaryColumns || []).forEach(function (column) {\n      var added = masterList.indexOf(column) >= 0;\n      columnCallback(added, column);\n    });\n\n    if (this.autoGroupsNeedBuilding) {\n      this.updateGridColumns();\n    }\n\n    this.updateDisplayedColumns(source);\n    this.fireColumnEvent(eventName, masterList, source);\n  };\n\n  ColumnModel.prototype.setValueColumns = function (colKeys, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.setPrimaryColumnList(colKeys, this.valueColumns, Events.EVENT_COLUMN_VALUE_CHANGED, this.setValueActive.bind(this), source);\n  };\n\n  ColumnModel.prototype.setValueActive = function (active, column, source) {\n    if (active === column.isValueActive()) {\n      return;\n    }\n\n    column.setValueActive(active, source);\n\n    if (active && !column.getAggFunc()) {\n      var initialAggFunc = this.aggFuncService.getDefaultAggFunc(column);\n      column.setAggFunc(initialAggFunc);\n    }\n  };\n\n  ColumnModel.prototype.addValueColumns = function (keys, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.updatePrimaryColumnList(keys, this.valueColumns, true, this.setValueActive.bind(this, true), Events.EVENT_COLUMN_VALUE_CHANGED, source);\n  };\n\n  ColumnModel.prototype.addValueColumn = function (colKey, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    if (colKey) {\n      this.addValueColumns([colKey], source);\n    }\n  };\n\n  ColumnModel.prototype.removeValueColumn = function (colKey, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.removeValueColumns([colKey], source);\n  };\n\n  ColumnModel.prototype.removeValueColumns = function (keys, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.updatePrimaryColumnList(keys, this.valueColumns, false, this.setValueActive.bind(this, false), Events.EVENT_COLUMN_VALUE_CHANGED, source);\n  }; // returns the width we can set to this col, taking into consideration min and max widths\n\n\n  ColumnModel.prototype.normaliseColumnWidth = function (column, newWidth) {\n    var minWidth = column.getMinWidth();\n\n    if (exists(minWidth) && newWidth < minWidth) {\n      newWidth = minWidth;\n    }\n\n    var maxWidth = column.getMaxWidth();\n\n    if (exists(maxWidth) && column.isGreaterThanMax(newWidth)) {\n      newWidth = maxWidth;\n    }\n\n    return newWidth;\n  };\n\n  ColumnModel.prototype.getPrimaryOrGridColumn = function (key) {\n    var column = this.getPrimaryColumn(key);\n    return column || this.getGridColumn(key);\n  };\n\n  ColumnModel.prototype.setColumnWidths = function (columnWidths, shiftKey, // @takeFromAdjacent - if user has 'shift' pressed, then pixels are taken from adjacent column\n  finished, // @finished - ends up in the event, tells the user if more events are to come\n  source) {\n    var _this = this;\n\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    var sets = [];\n    columnWidths.forEach(function (columnWidth) {\n      var col = _this.getPrimaryOrGridColumn(columnWidth.key);\n\n      if (!col) {\n        return;\n      }\n\n      sets.push({\n        width: columnWidth.newWidth,\n        ratios: [1],\n        columns: [col]\n      }); // if user wants to do shift resize by default, then we invert the shift operation\n\n      var defaultIsShift = _this.gridOptionsWrapper.getColResizeDefault() === 'shift';\n\n      if (defaultIsShift) {\n        shiftKey = !shiftKey;\n      }\n\n      if (shiftKey) {\n        var otherCol = _this.getDisplayedColAfter(col);\n\n        if (!otherCol) {\n          return;\n        }\n\n        var widthDiff = col.getActualWidth() - columnWidth.newWidth;\n        var otherColWidth = otherCol.getActualWidth() + widthDiff;\n        sets.push({\n          width: otherColWidth,\n          ratios: [1],\n          columns: [otherCol]\n        });\n      }\n    });\n\n    if (sets.length === 0) {\n      return;\n    }\n\n    this.resizeColumnSets(sets, finished, source);\n  };\n\n  ColumnModel.prototype.checkMinAndMaxWidthsForSet = function (columnResizeSet) {\n    var columns = columnResizeSet.columns,\n        width = columnResizeSet.width; // every col has a min width, so sum them all up and see if we have enough room\n    // for all the min widths\n\n    var minWidthAccumulated = 0;\n    var maxWidthAccumulated = 0;\n    var maxWidthActive = true;\n    columns.forEach(function (col) {\n      var minWidth = col.getMinWidth();\n      minWidthAccumulated += minWidth || 0;\n      var maxWidth = col.getMaxWidth();\n\n      if (exists(maxWidth) && maxWidth > 0) {\n        maxWidthAccumulated += maxWidth;\n      } else {\n        // if at least one columns has no max width, it means the group of columns\n        // then has no max width, as at least one column can take as much width as possible\n        maxWidthActive = false;\n      }\n    });\n    var minWidthPasses = width >= minWidthAccumulated;\n    var maxWidthPasses = !maxWidthActive || width <= maxWidthAccumulated;\n    return minWidthPasses && maxWidthPasses;\n  }; // method takes sets of columns and resizes them. either all sets will be resized, or nothing\n  // be resized. this is used for example when user tries to resize a group and holds shift key,\n  // then both the current group (grows), and the adjacent group (shrinks), will get resized,\n  // so that's two sets for this method.\n\n\n  ColumnModel.prototype.resizeColumnSets = function (resizeSets, finished, source) {\n    var _this = this;\n\n    var passMinMaxCheck = !resizeSets || resizeSets.every(function (columnResizeSet) {\n      return _this.checkMinAndMaxWidthsForSet(columnResizeSet);\n    });\n\n    if (!passMinMaxCheck) {\n      // even though we are not going to resize beyond min/max size, we still need to raise event when finished\n      if (finished) {\n        var columns = resizeSets && resizeSets.length > 0 ? resizeSets[0].columns : null;\n        this.fireColumnResizedEvent(columns, finished, source);\n      }\n\n      return; // don't resize!\n    }\n\n    var changedCols = [];\n    var allResizedCols = [];\n    resizeSets.forEach(function (set) {\n      var width = set.width,\n          columns = set.columns,\n          ratios = set.ratios; // keep track of pixels used, and last column gets the remaining,\n      // to cater for rounding errors, and min width adjustments\n\n      var newWidths = {};\n      var finishedCols = {};\n      columns.forEach(function (col) {\n        return allResizedCols.push(col);\n      }); // the loop below goes through each col. if a col exceeds it's min/max width,\n      // it then gets set to its min/max width and the column is removed marked as 'finished'\n      // and the calculation is done again leaving this column out. take for example columns\n      // {A, width: 50, maxWidth: 100}\n      // {B, width: 50}\n      // {C, width: 50}\n      // and then the set is set to width 600 - on the first pass the grid tries to set each column\n      // to 200. it checks A and sees 200 > 100 and so sets the width to 100. col A is then marked\n      // as 'finished' and the calculation is done again with the remaining cols B and C, which end up\n      // splitting the remaining 500 pixels.\n\n      var finishedColsGrew = true;\n      var loopCount = 0;\n\n      var _loop_2 = function () {\n        loopCount++;\n\n        if (loopCount > 1000) {\n          // this should never happen, but in the future, someone might introduce a bug here,\n          // so we stop the browser from hanging and report bug properly\n          console.error('AG Grid: infinite loop in resizeColumnSets');\n          return \"break\";\n        }\n\n        finishedColsGrew = false;\n        var subsetCols = [];\n        var subsetRatioTotal = 0;\n        var pixelsToDistribute = width;\n        columns.forEach(function (col, index) {\n          var thisColFinished = finishedCols[col.getId()];\n\n          if (thisColFinished) {\n            pixelsToDistribute -= newWidths[col.getId()];\n          } else {\n            subsetCols.push(col);\n            var ratioThisCol = ratios[index];\n            subsetRatioTotal += ratioThisCol;\n          }\n        }); // because we are not using all of the ratios (cols can be missing),\n        // we scale the ratio. if all columns are included, then subsetRatioTotal=1,\n        // and so the ratioScale will be 1.\n\n        var ratioScale = 1 / subsetRatioTotal;\n        subsetCols.forEach(function (col, index) {\n          var lastCol = index === subsetCols.length - 1;\n          var colNewWidth;\n\n          if (lastCol) {\n            colNewWidth = pixelsToDistribute;\n          } else {\n            colNewWidth = Math.round(ratios[index] * width * ratioScale);\n            pixelsToDistribute -= colNewWidth;\n          }\n\n          var minWidth = col.getMinWidth();\n          var maxWidth = col.getMaxWidth();\n\n          if (exists(minWidth) && colNewWidth < minWidth) {\n            colNewWidth = minWidth;\n            finishedCols[col.getId()] = true;\n            finishedColsGrew = true;\n          } else if (exists(maxWidth) && maxWidth > 0 && colNewWidth > maxWidth) {\n            colNewWidth = maxWidth;\n            finishedCols[col.getId()] = true;\n            finishedColsGrew = true;\n          }\n\n          newWidths[col.getId()] = colNewWidth;\n        });\n      };\n\n      while (finishedColsGrew) {\n        var state_1 = _loop_2();\n\n        if (state_1 === \"break\") break;\n      }\n\n      columns.forEach(function (col) {\n        var newWidth = newWidths[col.getId()];\n\n        if (col.getActualWidth() !== newWidth) {\n          col.setActualWidth(newWidth, source);\n          changedCols.push(col);\n        }\n      });\n    }); // if no cols changed, then no need to update more or send event.\n\n    var atLeastOneColChanged = changedCols.length > 0;\n    var flexedCols = this.refreshFlexedColumns({\n      resizingCols: allResizedCols,\n      skipSetLeft: true\n    });\n\n    if (atLeastOneColChanged) {\n      this.setLeftValues(source);\n      this.updateBodyWidths();\n      this.checkViewportColumns();\n    } // check for change first, to avoid unnecessary firing of events\n    // however we always fire 'finished' events. this is important\n    // when groups are resized, as if the group is changing slowly,\n    // eg 1 pixel at a time, then each change will fire change events\n    // in all the columns in the group, but only one with get the pixel.\n\n\n    var colsForEvent = allResizedCols.concat(flexedCols);\n\n    if (atLeastOneColChanged || finished) {\n      this.fireColumnResizedEvent(colsForEvent, finished, source, flexedCols);\n    }\n  };\n\n  ColumnModel.prototype.setColumnAggFunc = function (key, aggFunc, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    if (!key) {\n      return;\n    }\n\n    var column = this.getPrimaryColumn(key);\n\n    if (!column) {\n      return;\n    }\n\n    column.setAggFunc(aggFunc);\n    this.fireColumnEvent(Events.EVENT_COLUMN_VALUE_CHANGED, [column], source);\n  };\n\n  ColumnModel.prototype.fireColumnEvent = function (type, columns, source) {\n    var event = {\n      type: type,\n      columns: columns,\n      column: columns && columns.length == 1 ? columns[0] : null,\n      api: this.gridApi,\n      columnApi: this.columnApi,\n      source: source\n    };\n    this.eventService.dispatchEvent(event);\n  };\n\n  ColumnModel.prototype.moveRowGroupColumn = function (fromIndex, toIndex, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    var column = this.rowGroupColumns[fromIndex];\n    this.rowGroupColumns.splice(fromIndex, 1);\n    this.rowGroupColumns.splice(toIndex, 0, column);\n    var event = {\n      type: Events.EVENT_COLUMN_ROW_GROUP_CHANGED,\n      columns: this.rowGroupColumns,\n      column: this.rowGroupColumns.length === 1 ? this.rowGroupColumns[0] : null,\n      api: this.gridApi,\n      columnApi: this.columnApi,\n      source: source\n    };\n    this.eventService.dispatchEvent(event);\n  };\n\n  ColumnModel.prototype.moveColumns = function (columnsToMoveKeys, toIndex, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.columnAnimationService.start();\n\n    if (toIndex > this.gridColumns.length - columnsToMoveKeys.length) {\n      console.warn('AG Grid: tried to insert columns in invalid location, toIndex = ' + toIndex);\n      console.warn('AG Grid: remember that you should not count the moving columns when calculating the new index');\n      return;\n    } // we want to pull all the columns out first and put them into an ordered list\n\n\n    var columnsToMove = this.getGridColumns(columnsToMoveKeys);\n    var failedRules = !this.doesMovePassRules(columnsToMove, toIndex);\n\n    if (failedRules) {\n      return;\n    }\n\n    moveInArray(this.gridColumns, columnsToMove, toIndex);\n    this.updateDisplayedColumns(source);\n    var event = {\n      type: Events.EVENT_COLUMN_MOVED,\n      columns: columnsToMove,\n      column: columnsToMove.length === 1 ? columnsToMove[0] : null,\n      toIndex: toIndex,\n      api: this.gridApi,\n      columnApi: this.columnApi,\n      source: source\n    };\n    this.eventService.dispatchEvent(event);\n    this.columnAnimationService.finish();\n  };\n\n  ColumnModel.prototype.doesMovePassRules = function (columnsToMove, toIndex) {\n    // make a copy of what the grid columns would look like after the move\n    var proposedColumnOrder = this.gridColumns.slice();\n    moveInArray(proposedColumnOrder, columnsToMove, toIndex); // then check that the new proposed order of the columns passes all rules\n\n    if (!this.doesMovePassMarryChildren(proposedColumnOrder)) {\n      return false;\n    }\n\n    if (!this.doesMovePassLockedPositions(proposedColumnOrder)) {\n      return false;\n    }\n\n    return true;\n  }; // returns the provided cols sorted in same order as they appear in grid columns. eg if grid columns\n  // contains [a,b,c,d,e] and col passed is [e,a] then the passed cols are sorted into [a,e]\n\n\n  ColumnModel.prototype.sortColumnsLikeGridColumns = function (cols) {\n    var _this = this;\n\n    if (!cols || cols.length <= 1) {\n      return;\n    }\n\n    var notAllColsInGridColumns = cols.filter(function (c) {\n      return _this.gridColumns.indexOf(c) < 0;\n    }).length > 0;\n\n    if (notAllColsInGridColumns) {\n      return;\n    }\n\n    cols.sort(function (a, b) {\n      var indexA = _this.gridColumns.indexOf(a);\n\n      var indexB = _this.gridColumns.indexOf(b);\n\n      return indexA - indexB;\n    });\n  };\n\n  ColumnModel.prototype.doesMovePassLockedPositions = function (proposedColumnOrder) {\n    var foundNonLocked = false;\n    var rulePassed = true; // go though the cols, see if any non-locked appear before any locked\n\n    proposedColumnOrder.forEach(function (col) {\n      if (col.getColDef().lockPosition) {\n        if (foundNonLocked) {\n          rulePassed = false;\n        }\n      } else {\n        foundNonLocked = true;\n      }\n    });\n    return rulePassed;\n  };\n\n  ColumnModel.prototype.doesMovePassMarryChildren = function (allColumnsCopy) {\n    var rulePassed = true;\n    this.columnUtils.depthFirstOriginalTreeSearch(null, this.gridBalancedTree, function (child) {\n      if (!(child instanceof ProvidedColumnGroup)) {\n        return;\n      }\n\n      var columnGroup = child;\n      var colGroupDef = columnGroup.getColGroupDef();\n      var marryChildren = colGroupDef && colGroupDef.marryChildren;\n\n      if (!marryChildren) {\n        return;\n      }\n\n      var newIndexes = [];\n      columnGroup.getLeafColumns().forEach(function (col) {\n        var newColIndex = allColumnsCopy.indexOf(col);\n        newIndexes.push(newColIndex);\n      });\n      var maxIndex = Math.max.apply(Math, newIndexes);\n      var minIndex = Math.min.apply(Math, newIndexes); // spread is how far the first column in this group is away from the last column\n\n      var spread = maxIndex - minIndex;\n      var maxSpread = columnGroup.getLeafColumns().length - 1; // if the columns\n\n      if (spread > maxSpread) {\n        rulePassed = false;\n      } // console.log(`maxIndex = ${maxIndex}, minIndex = ${minIndex}, spread = ${spread}, maxSpread = ${maxSpread}, fail = ${spread > (count-1)}`)\n      // console.log(allColumnsCopy.map( col => col.getColDef().field).join(','));\n\n    });\n    return rulePassed;\n  };\n\n  ColumnModel.prototype.moveColumn = function (key, toIndex, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.moveColumns([key], toIndex, source);\n  };\n\n  ColumnModel.prototype.moveColumnByIndex = function (fromIndex, toIndex, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    var column = this.gridColumns[fromIndex];\n    this.moveColumn(column, toIndex, source);\n  };\n\n  ColumnModel.prototype.getColumnDefs = function () {\n    var _this = this;\n\n    if (!this.primaryColumns) {\n      return;\n    }\n\n    var cols = this.primaryColumns.slice();\n\n    if (this.gridColsArePrimary) {\n      cols.sort(function (a, b) {\n        return _this.gridColumns.indexOf(a) - _this.gridColumns.indexOf(b);\n      });\n    } else if (this.lastPrimaryOrder) {\n      cols.sort(function (a, b) {\n        return _this.lastPrimaryOrder.indexOf(a) - _this.lastPrimaryOrder.indexOf(b);\n      });\n    }\n\n    return this.columnDefFactory.buildColumnDefs(cols, this.rowGroupColumns, this.pivotColumns);\n  }; // used by:\n  // + angularGrid -> for setting body width\n  // + rowController -> setting main row widths (when inserting and resizing)\n  // need to cache this\n\n\n  ColumnModel.prototype.getBodyContainerWidth = function () {\n    return this.bodyWidth;\n  };\n\n  ColumnModel.prototype.getContainerWidth = function (pinned) {\n    switch (pinned) {\n      case Constants.PINNED_LEFT:\n        return this.leftWidth;\n\n      case Constants.PINNED_RIGHT:\n        return this.rightWidth;\n\n      default:\n        return this.bodyWidth;\n    }\n  }; // after setColumnWidth or updateGroupsAndDisplayedColumns\n\n\n  ColumnModel.prototype.updateBodyWidths = function () {\n    var newBodyWidth = this.getWidthOfColsInList(this.displayedColumnsCenter);\n    var newLeftWidth = this.getWidthOfColsInList(this.displayedColumnsLeft);\n    var newRightWidth = this.getWidthOfColsInList(this.displayedColumnsRight); // this is used by virtual col calculation, for RTL only, as a change to body width can impact displayed\n    // columns, due to RTL inverting the y coordinates\n\n    this.bodyWidthDirty = this.bodyWidth !== newBodyWidth;\n    var atLeastOneChanged = this.bodyWidth !== newBodyWidth || this.leftWidth !== newLeftWidth || this.rightWidth !== newRightWidth;\n\n    if (atLeastOneChanged) {\n      this.bodyWidth = newBodyWidth;\n      this.leftWidth = newLeftWidth;\n      this.rightWidth = newRightWidth; // when this fires, it is picked up by the gridPanel, which ends up in\n      // gridPanel calling setWidthAndScrollPosition(), which in turn calls setViewportPosition()\n\n      var event_3 = {\n        type: Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED,\n        api: this.gridApi,\n        columnApi: this.columnApi\n      };\n      this.eventService.dispatchEvent(event_3);\n    }\n  }; // + rowController\n\n\n  ColumnModel.prototype.getValueColumns = function () {\n    return this.valueColumns ? this.valueColumns : [];\n  }; // + rowController\n\n\n  ColumnModel.prototype.getPivotColumns = function () {\n    return this.pivotColumns ? this.pivotColumns : [];\n  }; // + clientSideRowModel\n\n\n  ColumnModel.prototype.isPivotActive = function () {\n    return this.pivotColumns && this.pivotColumns.length > 0 && this.pivotMode;\n  }; // + toolPanel\n\n\n  ColumnModel.prototype.getRowGroupColumns = function () {\n    return this.rowGroupColumns ? this.rowGroupColumns : [];\n  }; // + rowController -> while inserting rows\n\n\n  ColumnModel.prototype.getDisplayedCenterColumns = function () {\n    return this.displayedColumnsCenter;\n  }; // + rowController -> while inserting rows\n\n\n  ColumnModel.prototype.getDisplayedLeftColumns = function () {\n    return this.displayedColumnsLeft;\n  };\n\n  ColumnModel.prototype.getDisplayedRightColumns = function () {\n    return this.displayedColumnsRight;\n  };\n\n  ColumnModel.prototype.getDisplayedColumns = function (type) {\n    switch (type) {\n      case Constants.PINNED_LEFT:\n        return this.getDisplayedLeftColumns();\n\n      case Constants.PINNED_RIGHT:\n        return this.getDisplayedRightColumns();\n\n      default:\n        return this.getDisplayedCenterColumns();\n    }\n  }; // used by:\n  // + clientSideRowController -> sorting, building quick filter text\n  // + headerRenderer -> sorting (clearing icon)\n\n\n  ColumnModel.prototype.getAllPrimaryColumns = function () {\n    return this.primaryColumns ? this.primaryColumns.slice() : null;\n  };\n\n  ColumnModel.prototype.getSecondaryColumns = function () {\n    return this.secondaryColumns ? this.secondaryColumns.slice() : null;\n  };\n\n  ColumnModel.prototype.getAllColumnsForQuickFilter = function () {\n    return this.columnsForQuickFilter;\n  }; // + moveColumnController\n\n\n  ColumnModel.prototype.getAllGridColumns = function () {\n    return this.gridColumns;\n  };\n\n  ColumnModel.prototype.isEmpty = function () {\n    return missingOrEmpty(this.gridColumns);\n  };\n\n  ColumnModel.prototype.isRowGroupEmpty = function () {\n    return missingOrEmpty(this.rowGroupColumns);\n  };\n\n  ColumnModel.prototype.setColumnVisible = function (key, visible, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.setColumnsVisible([key], visible, source);\n  };\n\n  ColumnModel.prototype.setColumnsVisible = function (keys, visible, source) {\n    var _this = this;\n\n    if (visible === void 0) {\n      visible = false;\n    }\n\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.columnAnimationService.start();\n    this.actionOnGridColumns(keys, function (column) {\n      if (column.isVisible() !== visible) {\n        column.setVisible(visible, source);\n        return true;\n      }\n\n      return false;\n    }, source, function () {\n      var event = {\n        type: Events.EVENT_COLUMN_VISIBLE,\n        visible: visible,\n        column: null,\n        columns: null,\n        api: _this.gridApi,\n        columnApi: _this.columnApi,\n        source: source\n      };\n      return event;\n    });\n    this.columnAnimationService.finish();\n  };\n\n  ColumnModel.prototype.setColumnPinned = function (key, pinned, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    if (key) {\n      this.setColumnsPinned([key], pinned, source);\n    }\n  };\n\n  ColumnModel.prototype.setColumnsPinned = function (keys, pinned, source) {\n    var _this = this;\n\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    if (this.gridOptionsWrapper.getDomLayout() === 'print') {\n      console.warn(\"Changing the column pinning status is not allowed with domLayout='print'\");\n      return;\n    }\n\n    this.columnAnimationService.start();\n    var actualPinned;\n\n    if (pinned === true || pinned === Constants.PINNED_LEFT) {\n      actualPinned = Constants.PINNED_LEFT;\n    } else if (pinned === Constants.PINNED_RIGHT) {\n      actualPinned = Constants.PINNED_RIGHT;\n    } else {\n      actualPinned = null;\n    }\n\n    this.actionOnGridColumns(keys, function (col) {\n      if (col.getPinned() !== actualPinned) {\n        col.setPinned(actualPinned);\n        return true;\n      }\n\n      return false;\n    }, source, function () {\n      var event = {\n        type: Events.EVENT_COLUMN_PINNED,\n        pinned: actualPinned,\n        column: null,\n        columns: null,\n        api: _this.gridApi,\n        columnApi: _this.columnApi,\n        source: source\n      };\n      return event;\n    });\n    this.columnAnimationService.finish();\n  }; // does an action on a set of columns. provides common functionality for looking up the\n  // columns based on key, getting a list of effected columns, and then updated the event\n  // with either one column (if it was just one col) or a list of columns\n  // used by: autoResize, setVisible, setPinned\n\n\n  ColumnModel.prototype.actionOnGridColumns = function ( // the column keys this action will be on\n  keys, // the action to do - if this returns false, the column was skipped\n  // and won't be included in the event\n  action, // should return back a column event of the right type\n  source, createEvent) {\n    var _this = this;\n\n    if (missingOrEmpty(keys)) {\n      return;\n    }\n\n    var updatedColumns = [];\n    keys.forEach(function (key) {\n      var column = _this.getGridColumn(key);\n\n      if (!column) {\n        return;\n      } // need to check for false with type (ie !== instead of !=)\n      // as not returning anything (undefined) would also be false\n\n\n      var resultOfAction = action(column);\n\n      if (resultOfAction !== false) {\n        updatedColumns.push(column);\n      }\n    });\n\n    if (!updatedColumns.length) {\n      return;\n    }\n\n    this.updateDisplayedColumns(source);\n\n    if (exists(createEvent) && createEvent) {\n      var event_4 = createEvent();\n      event_4.columns = updatedColumns;\n      event_4.column = updatedColumns.length === 1 ? updatedColumns[0] : null;\n      this.eventService.dispatchEvent(event_4);\n    }\n  };\n\n  ColumnModel.prototype.getDisplayedColBefore = function (col) {\n    var allDisplayedColumns = this.getAllDisplayedColumns();\n    var oldIndex = allDisplayedColumns.indexOf(col);\n\n    if (oldIndex > 0) {\n      return allDisplayedColumns[oldIndex - 1];\n    }\n\n    return null;\n  }; // used by:\n  // + rowRenderer -> for navigation\n\n\n  ColumnModel.prototype.getDisplayedColAfter = function (col) {\n    var allDisplayedColumns = this.getAllDisplayedColumns();\n    var oldIndex = allDisplayedColumns.indexOf(col);\n\n    if (oldIndex < allDisplayedColumns.length - 1) {\n      return allDisplayedColumns[oldIndex + 1];\n    }\n\n    return null;\n  };\n\n  ColumnModel.prototype.getDisplayedGroupAfter = function (columnGroup) {\n    return this.getDisplayedGroupAtDirection(columnGroup, 'After');\n  };\n\n  ColumnModel.prototype.getDisplayedGroupBefore = function (columnGroup) {\n    return this.getDisplayedGroupAtDirection(columnGroup, 'Before');\n  };\n\n  ColumnModel.prototype.getDisplayedGroupAtDirection = function (columnGroup, direction) {\n    // pick the last displayed column in this group\n    var requiredLevel = columnGroup.getOriginalColumnGroup().getLevel() + columnGroup.getPaddingLevel();\n    var colGroupLeafColumns = columnGroup.getDisplayedLeafColumns();\n    var col = direction === 'After' ? last(colGroupLeafColumns) : colGroupLeafColumns[0];\n    var getDisplayColMethod = \"getDisplayedCol\" + direction;\n\n    while (true) {\n      // keep moving to the next col, until we get to another group\n      var column = this[getDisplayColMethod](col);\n\n      if (!column) {\n        return null;\n      }\n\n      var groupPointer = this.getColumnGroupAtLevel(column, requiredLevel);\n\n      if (groupPointer !== columnGroup) {\n        return groupPointer;\n      }\n    }\n  };\n\n  ColumnModel.prototype.getColumnGroupAtLevel = function (column, level) {\n    // get group at same level as the one we are looking for\n    var groupPointer = column.getParent();\n    var originalGroupLevel;\n    var groupPointerLevel;\n\n    while (true) {\n      var groupPointerOriginalColumnGroup = groupPointer.getOriginalColumnGroup();\n      originalGroupLevel = groupPointerOriginalColumnGroup.getLevel();\n      groupPointerLevel = groupPointer.getPaddingLevel();\n\n      if (originalGroupLevel + groupPointerLevel <= level) {\n        break;\n      }\n\n      groupPointer = groupPointer.getParent();\n    }\n\n    return groupPointer;\n  };\n\n  ColumnModel.prototype.isPinningLeft = function () {\n    return this.displayedColumnsLeft.length > 0;\n  };\n\n  ColumnModel.prototype.isPinningRight = function () {\n    return this.displayedColumnsRight.length > 0;\n  };\n\n  ColumnModel.prototype.getPrimaryAndSecondaryAndAutoColumns = function () {\n    var result = this.primaryColumns ? this.primaryColumns.slice(0) : [];\n\n    if (this.groupAutoColumns && exists(this.groupAutoColumns)) {\n      this.groupAutoColumns.forEach(function (col) {\n        return result.push(col);\n      });\n    }\n\n    if (this.secondaryColumnsPresent && this.secondaryColumns) {\n      this.secondaryColumns.forEach(function (column) {\n        return result.push(column);\n      });\n    }\n\n    return result;\n  };\n\n  ColumnModel.prototype.createStateItemFromColumn = function (column) {\n    var rowGroupIndex = column.isRowGroupActive() ? this.rowGroupColumns.indexOf(column) : null;\n    var pivotIndex = column.isPivotActive() ? this.pivotColumns.indexOf(column) : null;\n    var aggFunc = column.isValueActive() ? column.getAggFunc() : null;\n    var sort = column.getSort() != null ? column.getSort() : null;\n    var sortIndex = column.getSortIndex() != null ? column.getSortIndex() : null;\n    var flex = column.getFlex() != null && column.getFlex() > 0 ? column.getFlex() : null;\n    var res = {\n      colId: column.getColId(),\n      width: column.getActualWidth(),\n      hide: !column.isVisible(),\n      pinned: column.getPinned(),\n      sort: sort,\n      sortIndex: sortIndex,\n      aggFunc: aggFunc,\n      rowGroup: column.isRowGroupActive(),\n      rowGroupIndex: rowGroupIndex,\n      pivot: column.isPivotActive(),\n      pivotIndex: pivotIndex,\n      flex: flex\n    };\n    return res;\n  };\n\n  ColumnModel.prototype.getColumnState = function () {\n    if (missing(this.primaryColumns) || !this.isAlive()) {\n      return [];\n    }\n\n    var colsForState = this.getPrimaryAndSecondaryAndAutoColumns();\n    var res = colsForState.map(this.createStateItemFromColumn.bind(this));\n\n    if (!this.pivotMode) {\n      this.orderColumnStateList(res);\n    }\n\n    return res;\n  };\n\n  ColumnModel.prototype.getPrimaryAndAutoGroupCols = function () {\n    if (!this.groupAutoColumns) {\n      return this.primaryColumns;\n    }\n\n    return __spreadArrays(this.primaryColumns || [], this.groupAutoColumns);\n  };\n\n  ColumnModel.prototype.orderColumnStateList = function (columnStateList) {\n    // for fast looking, store the index of each column\n    var gridColumnIdMap = convertToMap(this.gridColumns.map(function (col, index) {\n      return [col.getColId(), index];\n    }));\n    columnStateList.sort(function (itemA, itemB) {\n      var posA = gridColumnIdMap.has(itemA.colId) ? gridColumnIdMap.get(itemA.colId) : -1;\n      var posB = gridColumnIdMap.has(itemB.colId) ? gridColumnIdMap.get(itemB.colId) : -1;\n      return posA - posB;\n    });\n  };\n\n  ColumnModel.prototype.resetColumnState = function (source) {\n    // NOTE = there is one bug here that no customer has noticed - if a column has colDef.lockPosition,\n    // this is ignored  below when ordering the cols. to work, we should always put lockPosition cols first.\n    // As a work around, developers should just put lockPosition columns first in their colDef list.\n    if (source === void 0) {\n      source = \"api\";\n    } // we can't use 'allColumns' as the order might of messed up, so get the primary ordered list\n\n\n    var primaryColumns = this.getColumnsFromTree(this.primaryColumnTree);\n    var columnStates = []; // we start at 1000, so if user has mix of rowGroup and group specified, it will work with both.\n    // eg IF user has ColA.rowGroupIndex=0, ColB.rowGroupIndex=1, ColC.rowGroup=true,\n    // THEN result will be ColA.rowGroupIndex=0, ColB.rowGroupIndex=1, ColC.rowGroup=1000\n\n    var letRowGroupIndex = 1000;\n    var letPivotIndex = 1000;\n    var colsToProcess = [];\n\n    if (this.groupAutoColumns) {\n      colsToProcess = colsToProcess.concat(this.groupAutoColumns);\n    }\n\n    if (primaryColumns) {\n      colsToProcess = colsToProcess.concat(primaryColumns);\n    }\n\n    colsToProcess.forEach(function (column) {\n      var getValueOrNull = function (a, b) {\n        return a != null ? a : b != null ? b : null;\n      };\n\n      var colDef = column.getColDef();\n      var sort = getValueOrNull(colDef.sort, colDef.initialSort);\n      var sortIndex = getValueOrNull(colDef.sortIndex, colDef.initialSortIndex);\n      var hide = getValueOrNull(colDef.hide, colDef.initialHide);\n      var pinned = getValueOrNull(colDef.pinned, colDef.initialPinned);\n      var width = getValueOrNull(colDef.width, colDef.initialWidth);\n      var flex = getValueOrNull(colDef.flex, colDef.initialFlex);\n      var rowGroupIndex = getValueOrNull(colDef.rowGroupIndex, colDef.initialRowGroupIndex);\n      var rowGroup = getValueOrNull(colDef.rowGroup, colDef.initialRowGroup);\n\n      if (rowGroupIndex == null && (rowGroup == null || rowGroup == false)) {\n        rowGroupIndex = null;\n        rowGroup = null;\n      }\n\n      var pivotIndex = getValueOrNull(colDef.pivotIndex, colDef.initialPivotIndex);\n      var pivot = getValueOrNull(colDef.pivot, colDef.initialPivot);\n\n      if (pivotIndex == null && (pivot == null || pivot == false)) {\n        pivotIndex = null;\n        pivot = null;\n      }\n\n      var aggFunc = getValueOrNull(colDef.aggFunc, colDef.initialAggFunc);\n      var stateItem = {\n        colId: column.getColId(),\n        sort: sort,\n        sortIndex: sortIndex,\n        hide: hide,\n        pinned: pinned,\n        width: width,\n        flex: flex,\n        rowGroup: rowGroup,\n        rowGroupIndex: rowGroupIndex,\n        pivot: pivot,\n        pivotIndex: pivotIndex,\n        aggFunc: aggFunc\n      };\n\n      if (missing(rowGroupIndex) && rowGroup) {\n        stateItem.rowGroupIndex = letRowGroupIndex++;\n      }\n\n      if (missing(pivotIndex) && pivot) {\n        stateItem.pivotIndex = letPivotIndex++;\n      }\n\n      columnStates.push(stateItem);\n    });\n    this.applyColumnState({\n      state: columnStates,\n      applyOrder: true\n    }, source);\n  };\n\n  ColumnModel.prototype.applyColumnState = function (params, source) {\n    var _this = this;\n\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    if (missingOrEmpty(this.primaryColumns)) {\n      return false;\n    }\n\n    if (params && params.state && !params.state.forEach) {\n      console.warn('AG Grid: applyColumnState() - the state attribute should be an array, however an array was not found. Please provide an array of items (one for each col you want to change) for state.');\n      return false;\n    }\n\n    this.columnAnimationService.start();\n    var raiseEventsFunc = this.compareColumnStatesAndRaiseEvents(source);\n    this.autoGroupsNeedBuilding = true; // at the end below, this list will have all columns we got no state for\n\n    var columnsWithNoState = this.primaryColumns.slice();\n    var success = true;\n    var rowGroupIndexes = {};\n    var pivotIndexes = {};\n    var autoGroupColumnStates = [];\n    var previousRowGroupCols = this.rowGroupColumns.slice();\n    var previousPivotCols = this.pivotColumns.slice();\n\n    if (params.state) {\n      params.state.forEach(function (state) {\n        var groupAutoColumnId = Constants.GROUP_AUTO_COLUMN_ID;\n        var colId = state.colId || ''; // auto group columns are re-created so deferring syncing with ColumnState\n\n        var isAutoGroupColumn = startsWith(colId, groupAutoColumnId);\n\n        if (isAutoGroupColumn) {\n          autoGroupColumnStates.push(state);\n          return;\n        }\n\n        var column = _this.getPrimaryColumn(colId);\n\n        if (!column) {\n          // we don't log the failure, as it's possible the user is applying that has extra\n          // cols in it. for example they could of save while row-grouping (so state includes\n          // auto-group column) and then applied state when not grouping (so the auto-group\n          // column would be in the state but no used).\n          success = false;\n        } else {\n          _this.syncColumnWithStateItem(column, state, params.defaultState, rowGroupIndexes, pivotIndexes, false, source);\n\n          removeFromArray(columnsWithNoState, column);\n        }\n      });\n    } // anything left over, we got no data for, so add in the column as non-value, non-rowGroup and hidden\n\n\n    var applyDefaultsFunc = function (col) {\n      return _this.syncColumnWithStateItem(col, null, params.defaultState, rowGroupIndexes, pivotIndexes, false, source);\n    };\n\n    columnsWithNoState.forEach(applyDefaultsFunc); // sort the lists according to the indexes that were provided\n\n    var comparator = function (indexes, oldList, colA, colB) {\n      var indexA = indexes[colA.getId()];\n      var indexB = indexes[colB.getId()];\n      var aHasIndex = indexA != null;\n      var bHasIndex = indexB != null;\n\n      if (aHasIndex && bHasIndex) {\n        // both a and b are new cols with index, so sort on index\n        return indexA - indexB;\n      }\n\n      if (aHasIndex) {\n        // a has an index, so it should be before a\n        return -1;\n      }\n\n      if (bHasIndex) {\n        // b has an index, so it should be before a\n        return 1;\n      }\n\n      var oldIndexA = oldList.indexOf(colA);\n      var oldIndexB = oldList.indexOf(colB);\n      var aHasOldIndex = oldIndexA >= 0;\n      var bHasOldIndex = oldIndexB >= 0;\n\n      if (aHasOldIndex && bHasOldIndex) {\n        // both a and b are old cols, so sort based on last order\n        return oldIndexA - oldIndexB;\n      }\n\n      if (aHasOldIndex) {\n        // a is old, b is new, so b is first\n        return -1;\n      } // this bit does matter, means both are new cols\n      // but without index or that b is old and a is new\n\n\n      return 1;\n    };\n\n    this.rowGroupColumns.sort(comparator.bind(this, rowGroupIndexes, previousRowGroupCols));\n    this.pivotColumns.sort(comparator.bind(this, pivotIndexes, previousPivotCols));\n    this.updateGridColumns(); // sync newly created auto group columns with ColumnState\n\n    var autoGroupColsCopy = this.groupAutoColumns ? this.groupAutoColumns.slice() : [];\n    autoGroupColumnStates.forEach(function (stateItem) {\n      var autoCol = _this.getAutoColumn(stateItem.colId);\n\n      removeFromArray(autoGroupColsCopy, autoCol);\n\n      _this.syncColumnWithStateItem(autoCol, stateItem, params.defaultState, null, null, true, source);\n    }); // autogroup cols with nothing else, apply the default\n\n    autoGroupColsCopy.forEach(applyDefaultsFunc);\n    this.applyOrderAfterApplyState(params);\n    this.updateDisplayedColumns(source);\n    this.dispatchEverythingChanged(source);\n    raiseEventsFunc();\n    this.columnAnimationService.finish();\n    return success;\n  };\n\n  ColumnModel.prototype.applyOrderAfterApplyState = function (params) {\n    if (!this.gridColsArePrimary || !params.applyOrder || !params.state) {\n      return;\n    }\n\n    var newOrder = [];\n    var processedColIds = {};\n    var gridColumnsMap = {};\n    this.gridColumns.forEach(function (col) {\n      return gridColumnsMap[col.getId()] = col;\n    });\n    params.state.forEach(function (item) {\n      if (!item.colId || processedColIds[item.colId]) {\n        return;\n      }\n\n      var col = gridColumnsMap[item.colId];\n\n      if (col) {\n        newOrder.push(col);\n        processedColIds[item.colId] = true;\n      }\n    }); // add in all other columns\n\n    this.gridColumns.forEach(function (col) {\n      if (!processedColIds[col.getColId()]) {\n        newOrder.push(col);\n      }\n    }); // this is already done in updateGridColumns, however we changed the order above (to match the order of the state\n    // columns) so we need to do it again. we could of put logic into the order above to take into account fixed\n    // columns, however if we did then we would have logic for updating fixed columns twice. reusing the logic here\n    // is less sexy for the code here, but it keeps consistency.\n\n    newOrder = this.putFixedColumnsFirst(newOrder);\n\n    if (!this.doesMovePassMarryChildren(newOrder)) {\n      console.warn('AG Grid: Applying column order broke a group where columns should be married together. Applying new order has been discarded.');\n      return;\n    }\n\n    this.gridColumns = newOrder;\n  };\n\n  ColumnModel.prototype.compareColumnStatesAndRaiseEvents = function (source) {\n    var _this = this; // if no columns to begin with, then it means we are setting columns for the first time, so\n    // there should be no events fired to show differences in columns.\n\n\n    var colsPreviouslyExisted = !!this.columnDefs;\n\n    if (!colsPreviouslyExisted) {\n      return function () {};\n    }\n\n    var startState = {\n      rowGroupColumns: this.rowGroupColumns.slice(),\n      pivotColumns: this.pivotColumns.slice(),\n      valueColumns: this.valueColumns.slice()\n    };\n    var columnStateBefore = this.getColumnState();\n    var columnStateBeforeMap = {};\n    columnStateBefore.forEach(function (col) {\n      columnStateBeforeMap[col.colId] = col;\n    });\n    return function () {\n      if (_this.gridOptionsWrapper.isSuppressColumnStateEvents()) {\n        return;\n      }\n\n      var colsForState = _this.getPrimaryAndAutoGroupCols(); // raises generic ColumnEvents where all columns are returned rather than what has changed\n\n\n      var raiseWhenListsDifferent = function (eventType, colsBefore, colsAfter, idMapper) {\n        var beforeList = colsBefore.map(idMapper);\n        var afterList = colsAfter.map(idMapper);\n        var unchanged = areEqual(beforeList, afterList);\n\n        if (unchanged) {\n          return;\n        } // returning all columns rather than what has changed!\n\n\n        var event = {\n          type: eventType,\n          columns: colsAfter,\n          column: colsAfter.length === 1 ? colsAfter[0] : null,\n          api: _this.gridApi,\n          columnApi: _this.columnApi,\n          source: source\n        };\n\n        _this.eventService.dispatchEvent(event);\n      }; // determines which columns have changed according to supplied predicate\n\n\n      var getChangedColumns = function (changedPredicate) {\n        var changedColumns = [];\n        (colsForState || []).forEach(function (column) {\n          var colStateBefore = columnStateBeforeMap[column.getColId()];\n\n          if (colStateBefore && changedPredicate(colStateBefore, column)) {\n            changedColumns.push(column);\n          }\n        });\n        return changedColumns;\n      };\n\n      var columnIdMapper = function (c) {\n        return c.getColId();\n      };\n\n      raiseWhenListsDifferent(Events.EVENT_COLUMN_ROW_GROUP_CHANGED, startState.rowGroupColumns, _this.rowGroupColumns, columnIdMapper);\n      raiseWhenListsDifferent(Events.EVENT_COLUMN_PIVOT_CHANGED, startState.pivotColumns, _this.pivotColumns, columnIdMapper);\n\n      var valueChangePredicate = function (cs, c) {\n        var oldActive = cs.aggFunc != null;\n        var activeChanged = oldActive != c.isValueActive(); // we only check aggFunc if the agg is active\n\n        var aggFuncChanged = oldActive && cs.aggFunc != c.getAggFunc();\n        return activeChanged || aggFuncChanged;\n      };\n\n      var changedValues = getChangedColumns(valueChangePredicate);\n\n      if (changedValues.length > 0) {\n        // we pass all value columns, now the ones that changed. this is the same\n        // as pivot and rowGroup cols, but different to all other properties below.\n        // this is more for backwards compatibility, as it's always been this way.\n        // really it should be the other way, as the order of the cols makes no difference\n        // for valueColumns (apart from displaying them in the tool panel).\n        _this.fireColumnEvent(Events.EVENT_COLUMN_VALUE_CHANGED, _this.valueColumns, source);\n      }\n\n      var resizeChangePredicate = function (cs, c) {\n        return cs.width != c.getActualWidth();\n      };\n\n      _this.fireColumnResizedEvent(getChangedColumns(resizeChangePredicate), true, source);\n\n      var pinnedChangePredicate = function (cs, c) {\n        return cs.pinned != c.getPinned();\n      };\n\n      _this.raiseColumnPinnedEvent(getChangedColumns(pinnedChangePredicate), source);\n\n      var visibilityChangePredicate = function (cs, c) {\n        return cs.hide == c.isVisible();\n      };\n\n      _this.raiseColumnVisibleEvent(getChangedColumns(visibilityChangePredicate), source);\n\n      var sortChangePredicate = function (cs, c) {\n        return cs.sort != c.getSort() || cs.sortIndex != c.getSortIndex();\n      };\n\n      if (getChangedColumns(sortChangePredicate).length > 0) {\n        _this.sortController.dispatchSortChangedEvents();\n      } // special handling for moved column events\n\n\n      _this.raiseColumnMovedEvent(columnStateBefore, source);\n    };\n  };\n\n  ColumnModel.prototype.raiseColumnPinnedEvent = function (changedColumns, source) {\n    if (!changedColumns.length) {\n      return;\n    } // if just one column, we use this, otherwise we don't include the col\n\n\n    var column = changedColumns.length === 1 ? changedColumns[0] : null; // only include visible if it's common in all columns\n\n    var pinned = this.getCommonValue(changedColumns, function (col) {\n      return col.getPinned();\n    });\n    var event = {\n      type: Events.EVENT_COLUMN_PINNED,\n      // mistake in typing, 'undefined' should be allowed, as 'null' means 'not pinned'\n      pinned: pinned != null ? pinned : null,\n      columns: changedColumns,\n      column: column,\n      api: this.gridApi,\n      columnApi: this.columnApi,\n      source: source\n    };\n    this.eventService.dispatchEvent(event);\n  };\n\n  ColumnModel.prototype.getCommonValue = function (cols, valueGetter) {\n    if (!cols || cols.length == 0) {\n      return undefined;\n    } // compare each value to the first value. if nothing differs, then value is common so return it.\n\n\n    var firstValue = valueGetter(cols[0]);\n\n    for (var i = 1; i < cols.length; i++) {\n      if (firstValue !== valueGetter(cols[i])) {\n        // values differ, no common value\n        return undefined;\n      }\n    }\n\n    return firstValue;\n  };\n\n  ColumnModel.prototype.raiseColumnVisibleEvent = function (changedColumns, source) {\n    if (!changedColumns.length) {\n      return;\n    } // if just one column, we use this, otherwise we don't include the col\n\n\n    var column = changedColumns.length === 1 ? changedColumns[0] : null; // only include visible if it's common in all columns\n\n    var visible = this.getCommonValue(changedColumns, function (col) {\n      return col.isVisible();\n    });\n    var event = {\n      type: Events.EVENT_COLUMN_VISIBLE,\n      visible: visible,\n      columns: changedColumns,\n      column: column,\n      api: this.gridApi,\n      columnApi: this.columnApi,\n      source: source\n    };\n    this.eventService.dispatchEvent(event);\n  };\n\n  ColumnModel.prototype.raiseColumnMovedEvent = function (colStateBefore, source) {\n    // we are only interested in columns that were both present and visible before and after\n    var _this = this;\n\n    var colStateAfter = this.getColumnState();\n    var colStateAfterMapped = {};\n    colStateAfter.forEach(function (s) {\n      return colStateAfterMapped[s.colId] = s;\n    }); // get id's of cols in both before and after lists\n\n    var colsIntersectIds = {};\n    colStateBefore.forEach(function (s) {\n      if (colStateAfterMapped[s.colId]) {\n        colsIntersectIds[s.colId] = true;\n      }\n    }); // filter state lists, so we only have cols that were present before and after\n\n    var beforeFiltered = filter(colStateBefore, function (c) {\n      return colsIntersectIds[c.colId];\n    });\n    var afterFiltered = filter(colStateAfter, function (c) {\n      return colsIntersectIds[c.colId];\n    }); // see if any cols are in a different location\n\n    var movedColumns = [];\n    afterFiltered.forEach(function (csAfter, index) {\n      var csBefore = beforeFiltered && beforeFiltered[index];\n\n      if (csBefore && csBefore.colId !== csAfter.colId) {\n        var gridCol = _this.getGridColumn(csBefore.colId);\n\n        if (gridCol) {\n          movedColumns.push(gridCol);\n        }\n      }\n    });\n\n    if (!movedColumns.length) {\n      return;\n    }\n\n    var event = {\n      type: Events.EVENT_COLUMN_MOVED,\n      columns: movedColumns,\n      column: null,\n      api: this.gridApi,\n      columnApi: this.columnApi,\n      source: source\n    };\n    this.eventService.dispatchEvent(event);\n  };\n\n  ColumnModel.prototype.syncColumnWithStateItem = function (column, stateItem, defaultState, rowGroupIndexes, pivotIndexes, autoCol, source) {\n    if (!column) {\n      return;\n    }\n\n    var getValue = function (key1, key2) {\n      var stateAny = stateItem;\n      var defaultAny = defaultState;\n      var obj = {\n        value1: undefined,\n        value2: undefined\n      };\n      var calculated = false;\n\n      if (stateAny) {\n        if (stateAny[key1] !== undefined) {\n          obj.value1 = stateAny[key1];\n          calculated = true;\n        }\n\n        if (exists(key2) && stateAny[key2] !== undefined) {\n          obj.value2 = stateAny[key2];\n          calculated = true;\n        }\n      }\n\n      if (!calculated && defaultAny) {\n        if (defaultAny[key1] !== undefined) {\n          obj.value1 = defaultAny[key1];\n        }\n\n        if (exists(key2) && defaultAny[key2] !== undefined) {\n          obj.value2 = defaultAny[key2];\n        }\n      }\n\n      return obj;\n    }; // following ensures we are left with boolean true or false, eg converts (null, undefined, 0) all to true\n\n\n    var hide = getValue('hide').value1;\n\n    if (hide !== undefined) {\n      column.setVisible(!hide, source);\n    } // sets pinned to 'left' or 'right'\n\n\n    var pinned = getValue('pinned').value1;\n\n    if (pinned !== undefined) {\n      column.setPinned(pinned);\n    } // if width provided and valid, use it, otherwise stick with the old width\n\n\n    var minColWidth = this.columnUtils.calculateColMinWidth(column.getColDef()); // flex\n\n    var flex = getValue('flex').value1;\n\n    if (flex !== undefined) {\n      column.setFlex(flex);\n    } // width - we only set width if column is not flexing\n\n\n    var noFlexThisCol = column.getFlex() <= 0;\n\n    if (noFlexThisCol) {\n      // both null and undefined means we skip, as it's not possible to 'clear' width (a column must have a width)\n      var width = getValue('width').value1;\n\n      if (width != null) {\n        if (minColWidth != null && width >= minColWidth) {\n          column.setActualWidth(width, source);\n        }\n      }\n    }\n\n    var sort = getValue('sort').value1;\n\n    if (sort !== undefined) {\n      if (sort === Constants.SORT_DESC || sort === Constants.SORT_ASC) {\n        column.setSort(sort);\n      } else {\n        column.setSort(undefined);\n      }\n    }\n\n    var sortIndex = getValue('sortIndex').value1;\n\n    if (sortIndex !== undefined) {\n      column.setSortIndex(sortIndex);\n    } // we do not do aggFunc, rowGroup or pivot for auto cols, as you can't do these with auto col\n\n\n    if (autoCol) {\n      return;\n    }\n\n    var aggFunc = getValue('aggFunc').value1;\n\n    if (aggFunc !== undefined) {\n      if (typeof aggFunc === 'string') {\n        column.setAggFunc(aggFunc);\n\n        if (!column.isValueActive()) {\n          column.setValueActive(true, source);\n          this.valueColumns.push(column);\n        }\n      } else {\n        if (exists(aggFunc)) {\n          console.warn('AG Grid: stateItem.aggFunc must be a string. if using your own aggregation ' + 'functions, register the functions first before using them in get/set state. This is because it is ' + 'intended for the column state to be stored and retrieved as simple JSON.');\n        } // Note: we do not call column.setAggFunc(null), so that next time we aggregate\n        // by this column (eg drag teh column to the agg section int he toolpanel) it will\n        // default to the last aggregation function.\n\n\n        if (column.isValueActive()) {\n          column.setValueActive(false, source);\n          removeFromArray(this.valueColumns, column);\n        }\n      }\n    }\n\n    var _a = getValue('rowGroup', 'rowGroupIndex'),\n        rowGroup = _a.value1,\n        rowGroupIndex = _a.value2;\n\n    if (rowGroup !== undefined || rowGroupIndex !== undefined) {\n      if (typeof rowGroupIndex === 'number' || rowGroup) {\n        if (!column.isRowGroupActive()) {\n          column.setRowGroupActive(true, source);\n          this.rowGroupColumns.push(column);\n        }\n\n        if (rowGroupIndexes && typeof rowGroupIndex === 'number') {\n          rowGroupIndexes[column.getId()] = rowGroupIndex;\n        }\n      } else {\n        if (column.isRowGroupActive()) {\n          column.setRowGroupActive(false, source);\n          removeFromArray(this.rowGroupColumns, column);\n        }\n      }\n    }\n\n    var _b = getValue('pivot', 'pivotIndex'),\n        pivot = _b.value1,\n        pivotIndex = _b.value2;\n\n    if (pivot !== undefined || pivotIndex !== undefined) {\n      if (typeof pivotIndex === 'number' || pivot) {\n        if (!column.isPivotActive()) {\n          column.setPivotActive(true, source);\n          this.pivotColumns.push(column);\n        }\n\n        if (pivotIndexes && typeof pivotIndex === 'number') {\n          pivotIndexes[column.getId()] = pivotIndex;\n        }\n      } else {\n        if (column.isPivotActive()) {\n          column.setPivotActive(false, source);\n          removeFromArray(this.pivotColumns, column);\n        }\n      }\n    }\n  };\n\n  ColumnModel.prototype.getGridColumns = function (keys) {\n    return this.getColumns(keys, this.getGridColumn.bind(this));\n  };\n\n  ColumnModel.prototype.getColumns = function (keys, columnLookupCallback) {\n    var foundColumns = [];\n\n    if (keys) {\n      keys.forEach(function (key) {\n        var column = columnLookupCallback(key);\n\n        if (column) {\n          foundColumns.push(column);\n        }\n      });\n    }\n\n    return foundColumns;\n  }; // used by growGroupPanel\n\n\n  ColumnModel.prototype.getColumnWithValidation = function (key) {\n    if (key == null) {\n      return null;\n    }\n\n    var column = this.getGridColumn(key);\n\n    if (!column) {\n      console.warn('AG Grid: could not find column ' + key);\n    }\n\n    return column;\n  };\n\n  ColumnModel.prototype.getPrimaryColumn = function (key) {\n    if (!this.primaryColumns) {\n      return null;\n    }\n\n    return this.getColumn(key, this.primaryColumns, this.primaryColumnsMap);\n  };\n\n  ColumnModel.prototype.getGridColumn = function (key) {\n    return this.getColumn(key, this.gridColumns, this.gridColumnsMap);\n  };\n\n  ColumnModel.prototype.getColumn = function (key, columnList, columnMap) {\n    if (!key) {\n      return null;\n    } // most of the time this method gets called the key is a string, so we put this shortcut in\n    // for performance reasons, to see if we can match for ID (it doesn't do auto columns, that's done below)\n\n\n    if (typeof key == 'string' && columnMap[key]) {\n      return columnMap[key];\n    }\n\n    for (var i = 0; i < columnList.length; i++) {\n      if (this.columnsMatch(columnList[i], key)) {\n        return columnList[i];\n      }\n    }\n\n    return this.getAutoColumn(key);\n  };\n\n  ColumnModel.prototype.getAutoColumn = function (key) {\n    var _this = this;\n\n    if (!this.groupAutoColumns || !exists(this.groupAutoColumns) || missing(this.groupAutoColumns)) {\n      return null;\n    }\n\n    return find(this.groupAutoColumns, function (groupCol) {\n      return _this.columnsMatch(groupCol, key);\n    });\n  };\n\n  ColumnModel.prototype.columnsMatch = function (column, key) {\n    var columnMatches = column === key;\n    var colDefMatches = column.getColDef() === key;\n    var idMatches = column.getColId() == key;\n    return columnMatches || colDefMatches || idMatches;\n  };\n\n  ColumnModel.prototype.getDisplayNameForColumn = function (column, location, includeAggFunc) {\n    if (includeAggFunc === void 0) {\n      includeAggFunc = false;\n    }\n\n    if (!column) {\n      return null;\n    }\n\n    var headerName = this.getHeaderName(column.getColDef(), column, null, null, location);\n\n    if (includeAggFunc) {\n      return this.wrapHeaderNameWithAggFunc(column, headerName);\n    }\n\n    return headerName;\n  };\n\n  ColumnModel.prototype.getDisplayNameForOriginalColumnGroup = function (columnGroup, originalColumnGroup, location) {\n    var colGroupDef = originalColumnGroup ? originalColumnGroup.getColGroupDef() : null;\n\n    if (colGroupDef) {\n      return this.getHeaderName(colGroupDef, null, columnGroup, originalColumnGroup, location);\n    }\n\n    return null;\n  };\n\n  ColumnModel.prototype.getDisplayNameForColumnGroup = function (columnGroup, location) {\n    return this.getDisplayNameForOriginalColumnGroup(columnGroup, columnGroup.getOriginalColumnGroup(), location);\n  }; // location is where the column is going to appear, ie who is calling us\n\n\n  ColumnModel.prototype.getHeaderName = function (colDef, column, columnGroup, originalColumnGroup, location) {\n    var headerValueGetter = colDef.headerValueGetter;\n\n    if (headerValueGetter) {\n      var params = {\n        colDef: colDef,\n        column: column,\n        columnGroup: columnGroup,\n        originalColumnGroup: originalColumnGroup,\n        location: location,\n        api: this.gridOptionsWrapper.getApi(),\n        context: this.gridOptionsWrapper.getContext()\n      };\n\n      if (typeof headerValueGetter === 'function') {\n        // valueGetter is a function, so just call it\n        return headerValueGetter(params);\n      } else if (typeof headerValueGetter === 'string') {\n        // valueGetter is an expression, so execute the expression\n        return this.expressionService.evaluate(headerValueGetter, params);\n      }\n\n      console.warn('ag-grid: headerValueGetter must be a function or a string');\n      return '';\n    } else if (colDef.headerName != null) {\n      return colDef.headerName;\n    } else if (colDef.field) {\n      return camelCaseToHumanText(colDef.field);\n    }\n\n    return '';\n  };\n\n  ColumnModel.prototype.wrapHeaderNameWithAggFunc = function (column, headerName) {\n    if (this.gridOptionsWrapper.isSuppressAggFuncInHeader()) {\n      return headerName;\n    } // only columns with aggregation active can have aggregations\n\n\n    var pivotValueColumn = column.getColDef().pivotValueColumn;\n    var pivotActiveOnThisColumn = exists(pivotValueColumn);\n    var aggFunc = null;\n    var aggFuncFound; // otherwise we have a measure that is active, and we are doing aggregation on it\n\n    if (pivotActiveOnThisColumn) {\n      aggFunc = pivotValueColumn ? pivotValueColumn.getAggFunc() : null;\n      aggFuncFound = true;\n    } else {\n      var measureActive = column.isValueActive();\n      var aggregationPresent = this.pivotMode || !this.isRowGroupEmpty();\n\n      if (measureActive && aggregationPresent) {\n        aggFunc = column.getAggFunc();\n        aggFuncFound = true;\n      } else {\n        aggFuncFound = false;\n      }\n    }\n\n    if (aggFuncFound) {\n      var aggFuncString = typeof aggFunc === 'string' ? aggFunc : 'func';\n      var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();\n      var aggFuncStringTranslated = localeTextFunc(aggFuncString, aggFuncString);\n      return aggFuncStringTranslated + \"(\" + headerName + \")\";\n    }\n\n    return headerName;\n  }; // returns the group with matching colId and instanceId. If instanceId is missing,\n  // matches only on the colId.\n\n\n  ColumnModel.prototype.getColumnGroup = function (colId, instanceId) {\n    if (!colId) {\n      return null;\n    }\n\n    if (colId instanceof ColumnGroup) {\n      return colId;\n    }\n\n    var allColumnGroups = this.getAllDisplayedTrees();\n    var checkInstanceId = typeof instanceId === 'number';\n    var result = null;\n    this.columnUtils.depthFirstAllColumnTreeSearch(allColumnGroups, function (child) {\n      if (child instanceof ColumnGroup) {\n        var columnGroup = child;\n        var matched = void 0;\n\n        if (checkInstanceId) {\n          matched = colId === columnGroup.getGroupId() && instanceId === columnGroup.getInstanceId();\n        } else {\n          matched = colId === columnGroup.getGroupId();\n        }\n\n        if (matched) {\n          result = columnGroup;\n        }\n      }\n    });\n    return result;\n  };\n\n  ColumnModel.prototype.isReady = function () {\n    return this.ready;\n  };\n\n  ColumnModel.prototype.extractValueColumns = function (source, oldPrimaryColumns) {\n    this.valueColumns = this.extractColumns(oldPrimaryColumns, this.valueColumns, function (col, flag) {\n      return col.setValueActive(flag, source);\n    }, // aggFunc doesn't have index variant, cos order of value cols doesn't matter, so always return null\n    function () {\n      return undefined;\n    }, function () {\n      return undefined;\n    }, // aggFunc is a string, so return it's existence\n    function (colDef) {\n      var aggFunc = colDef.aggFunc; // null or empty string means clear\n\n      if (aggFunc === null || aggFunc === '') {\n        return null;\n      }\n\n      if (aggFunc === undefined) {\n        return;\n      }\n\n      return !!aggFunc;\n    }, function (colDef) {\n      // return false if any of the following: null, undefined, empty string\n      return colDef.initialAggFunc != null && colDef.initialAggFunc != '';\n    }); // all new columns added will have aggFunc missing, so set it to what is in the colDef\n\n    this.valueColumns.forEach(function (col) {\n      var colDef = col.getColDef(); // if aggFunc provided, we always override, as reactive property\n\n      if (colDef.aggFunc != null && colDef.aggFunc != '') {\n        col.setAggFunc(colDef.aggFunc);\n      } else {\n        // otherwise we use initialAggFunc only if no agg func set - which happens when new column only\n        if (!col.getAggFunc()) {\n          col.setAggFunc(colDef.initialAggFunc);\n        }\n      }\n    });\n  };\n\n  ColumnModel.prototype.extractRowGroupColumns = function (source, oldPrimaryColumns) {\n    this.rowGroupColumns = this.extractColumns(oldPrimaryColumns, this.rowGroupColumns, function (col, flag) {\n      return col.setRowGroupActive(flag, source);\n    }, function (colDef) {\n      return colDef.rowGroupIndex;\n    }, function (colDef) {\n      return colDef.initialRowGroupIndex;\n    }, function (colDef) {\n      return colDef.rowGroup;\n    }, function (colDef) {\n      return colDef.initialRowGroup;\n    });\n  };\n\n  ColumnModel.prototype.extractColumns = function (oldPrimaryColumns, previousCols, setFlagFunc, getIndexFunc, getInitialIndexFunc, getValueFunc, getInitialValueFunc) {\n    if (oldPrimaryColumns === void 0) {\n      oldPrimaryColumns = [];\n    }\n\n    if (previousCols === void 0) {\n      previousCols = [];\n    }\n\n    var colsWithIndex = [];\n    var colsWithValue = []; // go though all cols.\n    // if value, change\n    // if default only, change only if new\n\n    (this.primaryColumns || []).forEach(function (col) {\n      var colIsNew = oldPrimaryColumns.indexOf(col) < 0;\n      var colDef = col.getColDef();\n      var value = attrToBoolean(getValueFunc(colDef));\n      var initialValue = attrToBoolean(getInitialValueFunc(colDef));\n      var index = attrToNumber(getIndexFunc(colDef));\n      var initialIndex = attrToNumber(getInitialIndexFunc(colDef));\n      var include;\n      var valuePresent = value !== undefined;\n      var indexPresent = index !== undefined;\n      var initialValuePresent = initialValue !== undefined;\n      var initialIndexPresent = initialIndex !== undefined;\n\n      if (valuePresent) {\n        include = value; // boolean value is guaranteed as attrToBoolean() is used above\n      } else if (indexPresent) {\n        if (index === null) {\n          // if col is new we don't want to use the default / initial if index is set to null. Similarly,\n          // we don't want to include the property for existing columns, i.e. we want to 'clear' it.\n          include = false;\n        } else {\n          // note that 'null >= 0' evaluates to true which means 'rowGroupIndex = null' would enable row\n          // grouping if the null check didn't exist above.\n          include = index >= 0;\n        }\n      } else {\n        if (colIsNew) {\n          // as no value or index is 'present' we use the default / initial when col is new\n          if (initialValuePresent) {\n            include = initialValue;\n          } else if (initialIndexPresent) {\n            include = initialIndex != null && initialIndex >= 0;\n          } else {\n            include = false;\n          }\n        } else {\n          // otherwise include it if included last time, e.g. if we are extracting row group cols and this col\n          // is an existing row group col (i.e. it exists in 'previousCols') then we should include it.\n          include = previousCols.indexOf(col) >= 0;\n        }\n      }\n\n      if (include) {\n        var useIndex = colIsNew ? index != null || initialIndex != null : index != null;\n        useIndex ? colsWithIndex.push(col) : colsWithValue.push(col);\n      }\n    });\n\n    var getIndexForCol = function (col) {\n      var index = getIndexFunc(col.getColDef());\n      var defaultIndex = getInitialIndexFunc(col.getColDef());\n      return index != null ? index : defaultIndex;\n    }; // sort cols with index, and add these first\n\n\n    colsWithIndex.sort(function (colA, colB) {\n      var indexA = getIndexForCol(colA);\n      var indexB = getIndexForCol(colB);\n\n      if (indexA === indexB) {\n        return 0;\n      }\n\n      if (indexA < indexB) {\n        return -1;\n      }\n\n      return 1;\n    });\n    var res = [].concat(colsWithIndex); // second add columns that were there before and in the same order as they were before,\n    // so we are preserving order of current grouping of columns that simply have rowGroup=true\n\n    previousCols.forEach(function (col) {\n      if (colsWithValue.indexOf(col) >= 0) {\n        res.push(col);\n      }\n    }); // lastly put in all remaining cols\n\n    colsWithValue.forEach(function (col) {\n      if (res.indexOf(col) < 0) {\n        res.push(col);\n      }\n    }); // set flag=false for removed cols\n\n    previousCols.forEach(function (col) {\n      if (res.indexOf(col) < 0) {\n        setFlagFunc(col, false);\n      }\n    }); // set flag=true for newly added cols\n\n    res.forEach(function (col) {\n      if (previousCols.indexOf(col) < 0) {\n        setFlagFunc(col, true);\n      }\n    });\n    return res;\n  };\n\n  ColumnModel.prototype.extractPivotColumns = function (source, oldPrimaryColumns) {\n    this.pivotColumns = this.extractColumns(oldPrimaryColumns, this.pivotColumns, function (col, flag) {\n      return col.setPivotActive(flag, source);\n    }, function (colDef) {\n      return colDef.pivotIndex;\n    }, function (colDef) {\n      return colDef.initialPivotIndex;\n    }, function (colDef) {\n      return colDef.pivot;\n    }, function (colDef) {\n      return colDef.initialPivot;\n    });\n  };\n\n  ColumnModel.prototype.resetColumnGroupState = function (source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    var stateItems = [];\n    this.columnUtils.depthFirstOriginalTreeSearch(null, this.primaryColumnTree, function (child) {\n      if (child instanceof ProvidedColumnGroup) {\n        var colGroupDef = child.getColGroupDef();\n        var groupState = {\n          groupId: child.getGroupId(),\n          open: !colGroupDef ? undefined : colGroupDef.openByDefault\n        };\n        stateItems.push(groupState);\n      }\n    });\n    this.setColumnGroupState(stateItems, source);\n  };\n\n  ColumnModel.prototype.getColumnGroupState = function () {\n    var columnGroupState = [];\n    this.columnUtils.depthFirstOriginalTreeSearch(null, this.gridBalancedTree, function (node) {\n      if (node instanceof ProvidedColumnGroup) {\n        var originalColumnGroup = node;\n        columnGroupState.push({\n          groupId: originalColumnGroup.getGroupId(),\n          open: originalColumnGroup.isExpanded()\n        });\n      }\n    });\n    return columnGroupState;\n  };\n\n  ColumnModel.prototype.setColumnGroupState = function (stateItems, source) {\n    var _this = this;\n\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.columnAnimationService.start();\n    var impactedGroups = [];\n    stateItems.forEach(function (stateItem) {\n      var groupKey = stateItem.groupId;\n      var newValue = stateItem.open;\n\n      var originalColumnGroup = _this.getOriginalColumnGroup(groupKey);\n\n      if (!originalColumnGroup) {\n        return;\n      }\n\n      if (originalColumnGroup.isExpanded() === newValue) {\n        return;\n      }\n\n      _this.logger.log('columnGroupOpened(' + originalColumnGroup.getGroupId() + ',' + newValue + ')');\n\n      originalColumnGroup.setExpanded(newValue);\n      impactedGroups.push(originalColumnGroup);\n    });\n    this.updateGroupsAndDisplayedColumns(source);\n    this.setFirstRightAndLastLeftPinned(source);\n    impactedGroups.forEach(function (originalColumnGroup) {\n      var event = {\n        type: Events.EVENT_COLUMN_GROUP_OPENED,\n        columnGroup: originalColumnGroup,\n        api: _this.gridApi,\n        columnApi: _this.columnApi\n      };\n\n      _this.eventService.dispatchEvent(event);\n    });\n    this.columnAnimationService.finish();\n  }; // called by headerRenderer - when a header is opened or closed\n\n\n  ColumnModel.prototype.setColumnGroupOpened = function (key, newValue, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    var keyAsString;\n\n    if (key instanceof ProvidedColumnGroup) {\n      keyAsString = key.getId();\n    } else {\n      keyAsString = key || '';\n    }\n\n    this.setColumnGroupState([{\n      groupId: keyAsString,\n      open: newValue\n    }], source);\n  };\n\n  ColumnModel.prototype.getOriginalColumnGroup = function (key) {\n    if (key instanceof ProvidedColumnGroup) {\n      return key;\n    }\n\n    if (typeof key !== 'string') {\n      console.error('AG Grid: group key must be a string');\n    } // otherwise, search for the column group by id\n\n\n    var res = null;\n    this.columnUtils.depthFirstOriginalTreeSearch(null, this.gridBalancedTree, function (node) {\n      if (node instanceof ProvidedColumnGroup) {\n        var originalColumnGroup = node;\n\n        if (originalColumnGroup.getId() === key) {\n          res = originalColumnGroup;\n        }\n      }\n    });\n    return res;\n  };\n\n  ColumnModel.prototype.calculateColumnsForDisplay = function () {\n    var _this = this;\n\n    var columnsForDisplay;\n\n    if (this.pivotMode && !this.secondaryColumnsPresent) {\n      // pivot mode is on, but we are not pivoting, so we only\n      // show columns we are aggregating on\n      columnsForDisplay = this.gridColumns.filter(function (column) {\n        var isAutoGroupCol = _this.groupAutoColumns && includes(_this.groupAutoColumns, column);\n        var isValueCol = _this.valueColumns && includes(_this.valueColumns, column);\n        return isAutoGroupCol || isValueCol;\n      });\n    } else {\n      // otherwise continue as normal. this can be working on the primary\n      // or secondary columns, whatever the gridColumns are set to\n      columnsForDisplay = this.gridColumns.filter(function (column) {\n        // keep col if a) it's auto-group or b) it's visible\n        var isAutoGroupCol = _this.groupAutoColumns && includes(_this.groupAutoColumns, column);\n        return isAutoGroupCol || column.isVisible();\n      });\n    }\n\n    return columnsForDisplay;\n  };\n\n  ColumnModel.prototype.checkColSpanActiveInCols = function (columns) {\n    var result = false;\n    columns.forEach(function (col) {\n      if (exists(col.getColDef().colSpan)) {\n        result = true;\n      }\n    });\n    return result;\n  };\n\n  ColumnModel.prototype.calculateColumnsForGroupDisplay = function () {\n    var _this = this;\n\n    this.groupDisplayColumns = [];\n\n    var checkFunc = function (col) {\n      var colDef = col.getColDef();\n\n      if (colDef && exists(colDef.showRowGroup)) {\n        _this.groupDisplayColumns.push(col);\n      }\n    };\n\n    this.gridColumns.forEach(checkFunc);\n\n    if (this.groupAutoColumns) {\n      this.groupAutoColumns.forEach(checkFunc);\n    }\n  };\n\n  ColumnModel.prototype.getGroupDisplayColumns = function () {\n    return this.groupDisplayColumns;\n  };\n\n  ColumnModel.prototype.updateDisplayedColumns = function (source) {\n    var columnsForDisplay = this.calculateColumnsForDisplay();\n    this.buildDisplayedTrees(columnsForDisplay);\n    this.calculateColumnsForGroupDisplay(); // also called when group opened/closed\n\n    this.updateGroupsAndDisplayedColumns(source); // also called when group opened/closed\n\n    this.setFirstRightAndLastLeftPinned(source);\n  };\n\n  ColumnModel.prototype.isSecondaryColumnsPresent = function () {\n    return this.secondaryColumnsPresent;\n  };\n\n  ColumnModel.prototype.setSecondaryColumns = function (colDefs, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    var newColsPresent = colDefs && colDefs.length > 0; // if not cols passed, and we had to cols anyway, then do nothing\n\n    if (!newColsPresent && !this.secondaryColumnsPresent) {\n      return;\n    }\n\n    if (newColsPresent) {\n      this.processSecondaryColumnDefinitions(colDefs);\n      var balancedTreeResult = this.columnFactory.createColumnTree(colDefs, false);\n      this.secondaryBalancedTree = balancedTreeResult.columnTree;\n      this.secondaryHeaderRowCount = balancedTreeResult.treeDept + 1;\n      this.secondaryColumns = this.getColumnsFromTree(this.secondaryBalancedTree);\n      this.secondaryColumnsPresent = true;\n    } else {\n      this.secondaryBalancedTree = null;\n      this.secondaryHeaderRowCount = -1;\n      this.secondaryColumns = null;\n      this.secondaryColumnsPresent = false;\n    }\n\n    this.updateGridColumns();\n    this.updateDisplayedColumns(source);\n  };\n\n  ColumnModel.prototype.processSecondaryColumnDefinitions = function (colDefs) {\n    var columnCallback = this.gridOptionsWrapper.getProcessSecondaryColDefFunc();\n    var groupCallback = this.gridOptionsWrapper.getProcessSecondaryColGroupDefFunc();\n\n    if (!columnCallback && !groupCallback) {\n      return undefined;\n    }\n\n    var searchForColDefs = function (colDefs2) {\n      colDefs2.forEach(function (abstractColDef) {\n        var isGroup = exists(abstractColDef.children);\n\n        if (isGroup) {\n          var colGroupDef = abstractColDef;\n\n          if (groupCallback) {\n            groupCallback(colGroupDef);\n          }\n\n          searchForColDefs(colGroupDef.children);\n        } else {\n          var colDef = abstractColDef;\n\n          if (columnCallback) {\n            columnCallback(colDef);\n          }\n        }\n      });\n    };\n\n    if (colDefs) {\n      searchForColDefs(colDefs);\n    }\n  }; // called from: setColumnState, setColumnDefs, setSecondaryColumns\n\n\n  ColumnModel.prototype.updateGridColumns = function () {\n    var _this = this;\n\n    if (this.gridColsArePrimary) {\n      this.lastPrimaryOrder = this.gridColumns;\n    }\n\n    if (this.secondaryColumns && this.secondaryBalancedTree) {\n      this.gridBalancedTree = this.secondaryBalancedTree.slice();\n      this.gridHeaderRowCount = this.secondaryHeaderRowCount;\n      this.gridColumns = this.secondaryColumns.slice();\n      this.gridColsArePrimary = false;\n    } else if (this.primaryColumns) {\n      this.gridBalancedTree = this.primaryColumnTree.slice();\n      this.gridHeaderRowCount = this.primaryHeaderRowCount;\n      this.gridColumns = this.primaryColumns.slice();\n      this.gridColsArePrimary = true; // updateGridColumns gets called after user adds a row group. we want to maintain the order of the columns\n      // when this happens (eg if user moved a column) rather than revert back to the original column order.\n      // likewise if changing in/out of pivot mode, we want to maintain the order of the primary cols\n\n      this.orderGridColsLikeLastPrimary();\n    }\n\n    this.addAutoGroupToGridColumns();\n    this.gridColumns = this.putFixedColumnsFirst(this.gridColumns);\n    this.setupQuickFilterColumns();\n    this.clearDisplayedAndViewportColumns();\n    this.colSpanActive = this.checkColSpanActiveInCols(this.gridColumns);\n    this.gridColumnsMap = {};\n    this.gridColumns.forEach(function (col) {\n      return _this.gridColumnsMap[col.getId()] = col;\n    });\n    this.setAutoHeightActive();\n    var event = {\n      type: Events.EVENT_GRID_COLUMNS_CHANGED,\n      api: this.gridApi,\n      columnApi: this.columnApi\n    };\n    this.eventService.dispatchEvent(event);\n  };\n\n  ColumnModel.prototype.setAutoHeightActive = function () {\n    this.autoHeightActive = this.gridColumns.filter(function (col) {\n      return col.getColDef().autoHeight;\n    }).length > 0;\n\n    if (this.autoHeightActive) {\n      this.autoHeightActiveAtLeastOnce = true;\n      var rowModelType = this.rowModel.getType();\n      var supportedRowModel = rowModelType === Constants.ROW_MODEL_TYPE_CLIENT_SIDE || rowModelType === Constants.ROW_MODEL_TYPE_SERVER_SIDE;\n\n      if (!supportedRowModel) {\n        var message_1 = 'AG Grid - autoHeight columns only work with Client Side Row Model and Server Side Row Model.';\n        doOnce(function () {\n          return console.warn(message_1);\n        }, 'autoHeightActive.wrongRowModel');\n      }\n    }\n  };\n\n  ColumnModel.prototype.orderGridColsLikeLastPrimary = function () {\n    if (missing(this.lastPrimaryOrder)) {\n      return;\n    }\n\n    var lastPrimaryOrderMapped = convertToMap(this.lastPrimaryOrder.map(function (col, index) {\n      return [col, index];\n    })); // only do the sort if at least one column is accounted for. columns will be not accounted for\n    // if changing from secondary to primary columns\n\n    var noColsFound = true;\n    this.gridColumns.forEach(function (col) {\n      if (lastPrimaryOrderMapped.has(col)) {\n        noColsFound = false;\n      }\n    });\n\n    if (noColsFound) {\n      return;\n    } // order cols in the same order as before. we need to make sure that all\n    // cols still exists, so filter out any that no longer exist.\n\n\n    var gridColsMap = convertToMap(this.gridColumns.map(function (col) {\n      return [col, true];\n    }));\n    var oldColsOrdered = this.lastPrimaryOrder.filter(function (col) {\n      return gridColsMap.has(col);\n    });\n    var oldColsMap = convertToMap(oldColsOrdered.map(function (col) {\n      return [col, true];\n    }));\n    var newColsOrdered = this.gridColumns.filter(function (col) {\n      return !oldColsMap.has(col);\n    }); // add in the new columns, at the end (if no group), or at the end of the group (if a group)\n\n    var newGridColumns = oldColsOrdered.slice();\n    newColsOrdered.forEach(function (newCol) {\n      var parent = newCol.getOriginalParent(); // if no parent, means we are not grouping, so just add the column to the end\n\n      if (!parent) {\n        newGridColumns.push(newCol);\n        return;\n      } // find the group the column belongs to. if no siblings at the current level (eg col in group on it's\n      // own) then go up one level and look for siblings there.\n\n\n      var siblings = [];\n\n      while (!siblings.length && parent) {\n        var leafCols = parent.getLeafColumns();\n        leafCols.forEach(function (leafCol) {\n          var presentInNewGriColumns = newGridColumns.indexOf(leafCol) >= 0;\n          var noYetInSiblings = siblings.indexOf(leafCol) < 0;\n\n          if (presentInNewGriColumns && noYetInSiblings) {\n            siblings.push(leafCol);\n          }\n        });\n        parent = parent.getOriginalParent();\n      } // if no siblings exist at any level, this means the col is in a group (or parent groups) on it's own\n\n\n      if (!siblings.length) {\n        newGridColumns.push(newCol);\n        return;\n      } // find index of last column in the group\n\n\n      var indexes = siblings.map(function (col) {\n        return newGridColumns.indexOf(col);\n      });\n      var lastIndex = Math.max.apply(Math, indexes);\n      insertIntoArray(newGridColumns, newCol, lastIndex + 1);\n    });\n    this.gridColumns = newGridColumns;\n  };\n\n  ColumnModel.prototype.isPrimaryColumnGroupsPresent = function () {\n    return this.primaryHeaderRowCount > 1;\n  }; // if we are using autoGroupCols, then they should be included for quick filter. this covers the\n  // following scenarios:\n  // a) user provides 'field' into autoGroupCol of normal grid, so now because a valid col to filter leafs on\n  // b) using tree data and user depends on autoGroupCol for first col, and we also want to filter on this\n  //    (tree data is a bit different, as parent rows can be filtered on, unlike row grouping)\n\n\n  ColumnModel.prototype.setupQuickFilterColumns = function () {\n    if (this.groupAutoColumns) {\n      this.columnsForQuickFilter = (this.primaryColumns || []).concat(this.groupAutoColumns);\n    } else if (this.primaryColumns) {\n      this.columnsForQuickFilter = this.primaryColumns;\n    }\n  };\n\n  ColumnModel.prototype.putFixedColumnsFirst = function (cols) {\n    var locked = cols.filter(function (c) {\n      return c.getColDef().lockPosition;\n    });\n    var unlocked = cols.filter(function (c) {\n      return !c.getColDef().lockPosition;\n    });\n    return locked.concat(unlocked);\n  };\n\n  ColumnModel.prototype.addAutoGroupToGridColumns = function () {\n    // add in auto-group here\n    this.createGroupAutoColumnsIfNeeded();\n\n    if (missing(this.groupAutoColumns)) {\n      return;\n    }\n\n    this.gridColumns = this.groupAutoColumns ? this.groupAutoColumns.concat(this.gridColumns) : this.gridColumns;\n    var autoColBalancedTree = this.columnFactory.createForAutoGroups(this.groupAutoColumns, this.gridBalancedTree);\n    this.gridBalancedTree = autoColBalancedTree.concat(this.gridBalancedTree);\n  }; // gets called after we copy down grid columns, to make sure any part of the gui\n  // that tries to draw, eg the header, it will get empty lists of columns rather\n  // than stale columns. for example, the header will received gridColumnsChanged\n  // event, so will try and draw, but it will draw successfully when it acts on the\n  // virtualColumnsChanged event\n\n\n  ColumnModel.prototype.clearDisplayedAndViewportColumns = function () {\n    this.displayedTreeLeft = [];\n    this.displayedTreeRight = [];\n    this.displayedTreeCentre = [];\n    this.viewportRowLeft = {};\n    this.viewportRowRight = {};\n    this.viewportRowCenter = {};\n    this.displayedColumnsLeft = [];\n    this.displayedColumnsRight = [];\n    this.displayedColumnsCenter = [];\n    this.displayedColumns = [];\n    this.viewportColumns = [];\n  };\n\n  ColumnModel.prototype.updateGroupsAndDisplayedColumns = function (source) {\n    this.updateOpenClosedVisibilityInColumnGroups();\n    this.deriveDisplayedColumns(source);\n    this.refreshFlexedColumns();\n    this.extractViewport();\n    this.updateBodyWidths(); // this event is picked up by the gui, headerRenderer and rowRenderer, to recalculate what columns to display\n\n    var event = {\n      type: Events.EVENT_DISPLAYED_COLUMNS_CHANGED,\n      api: this.gridApi,\n      columnApi: this.columnApi\n    };\n    this.eventService.dispatchEvent(event);\n  };\n\n  ColumnModel.prototype.deriveDisplayedColumns = function (source) {\n    this.derivedDisplayedColumnsFromDisplayedTree(this.displayedTreeLeft, this.displayedColumnsLeft);\n    this.derivedDisplayedColumnsFromDisplayedTree(this.displayedTreeCentre, this.displayedColumnsCenter);\n    this.derivedDisplayedColumnsFromDisplayedTree(this.displayedTreeRight, this.displayedColumnsRight);\n    this.joinDisplayedColumns();\n    this.setLeftValues(source);\n    this.displayedAutoHeightCols = this.displayedColumns.filter(function (col) {\n      return col.getColDef().autoHeight;\n    });\n  };\n\n  ColumnModel.prototype.isAutoRowHeightActive = function () {\n    return this.autoHeightActive;\n  };\n\n  ColumnModel.prototype.wasAutoRowHeightEverActive = function () {\n    return this.autoHeightActiveAtLeastOnce;\n  };\n\n  ColumnModel.prototype.joinDisplayedColumns = function () {\n    if (this.gridOptionsWrapper.isEnableRtl()) {\n      this.displayedColumns = this.displayedColumnsRight.concat(this.displayedColumnsCenter).concat(this.displayedColumnsLeft);\n    } else {\n      this.displayedColumns = this.displayedColumnsLeft.concat(this.displayedColumnsCenter).concat(this.displayedColumnsRight);\n    }\n  }; // sets the left pixel position of each column\n\n\n  ColumnModel.prototype.setLeftValues = function (source) {\n    this.setLeftValuesOfColumns(source);\n    this.setLeftValuesOfGroups();\n  };\n\n  ColumnModel.prototype.setLeftValuesOfColumns = function (source) {\n    var _this = this;\n\n    if (!this.primaryColumns) {\n      return;\n    } // go through each list of displayed columns\n\n\n    var allColumns = this.primaryColumns.slice(0); // let totalColumnWidth = this.getWidthOfColsInList()\n\n    var doingRtl = this.gridOptionsWrapper.isEnableRtl();\n    [this.displayedColumnsLeft, this.displayedColumnsRight, this.displayedColumnsCenter].forEach(function (columns) {\n      if (doingRtl) {\n        // when doing RTL, we start at the top most pixel (ie RHS) and work backwards\n        var left_1 = _this.getWidthOfColsInList(columns);\n\n        columns.forEach(function (column) {\n          left_1 -= column.getActualWidth();\n          column.setLeft(left_1, source);\n        });\n      } else {\n        // otherwise normal LTR, we start at zero\n        var left_2 = 0;\n        columns.forEach(function (column) {\n          column.setLeft(left_2, source);\n          left_2 += column.getActualWidth();\n        });\n      }\n\n      removeAllFromArray(allColumns, columns);\n    }); // items left in allColumns are columns not displayed, so remove the left position. this is\n    // important for the rows, as if a col is made visible, then taken out, then made visible again,\n    // we don't want the animation of the cell floating in from the old position, whatever that was.\n\n    allColumns.forEach(function (column) {\n      column.setLeft(null, source);\n    });\n  };\n\n  ColumnModel.prototype.setLeftValuesOfGroups = function () {\n    // a groups left value is the lest left value of it's children\n    [this.displayedTreeLeft, this.displayedTreeRight, this.displayedTreeCentre].forEach(function (columns) {\n      columns.forEach(function (column) {\n        if (column instanceof ColumnGroup) {\n          var columnGroup = column;\n          columnGroup.checkLeft();\n        }\n      });\n    });\n  };\n\n  ColumnModel.prototype.derivedDisplayedColumnsFromDisplayedTree = function (tree, columns) {\n    columns.length = 0;\n    this.columnUtils.depthFirstDisplayedColumnTreeSearch(tree, function (child) {\n      if (child instanceof Column) {\n        columns.push(child);\n      }\n    });\n  };\n\n  ColumnModel.prototype.extractViewportColumns = function () {\n    if (this.suppressColumnVirtualisation) {\n      // no virtualisation, so don't filter\n      this.viewportColumnsCenter = this.displayedColumnsCenter;\n    } else {\n      // filter out what should be visible\n      this.viewportColumnsCenter = this.filterOutColumnsWithinViewport();\n    }\n\n    this.viewportColumns = this.viewportColumnsCenter.concat(this.displayedColumnsLeft).concat(this.displayedColumnsRight);\n  };\n\n  ColumnModel.prototype.getVirtualHeaderGroupRow = function (type, dept) {\n    var result;\n\n    switch (type) {\n      case Constants.PINNED_LEFT:\n        result = this.viewportRowLeft[dept];\n        break;\n\n      case Constants.PINNED_RIGHT:\n        result = this.viewportRowRight[dept];\n        break;\n\n      default:\n        result = this.viewportRowCenter[dept];\n        break;\n    }\n\n    if (missing(result)) {\n      result = [];\n    }\n\n    return result;\n  };\n\n  ColumnModel.prototype.extractViewportRows = function () {\n    // go through each group, see if any of it's cols are displayed, and if yes,\n    // then this group is included\n    this.viewportRowLeft = {};\n    this.viewportRowRight = {};\n    this.viewportRowCenter = {}; // for easy lookup when building the groups.\n\n    var virtualColIds = {};\n    this.viewportColumns.forEach(function (col) {\n      return virtualColIds[col.getId()] = true;\n    });\n\n    var testGroup = function (children, result, dept) {\n      var returnValue = false;\n\n      for (var i = 0; i < children.length; i++) {\n        // see if this item is within viewport\n        var child = children[i];\n        var addThisItem = false;\n\n        if (child instanceof Column) {\n          // for column, test if column is included\n          addThisItem = virtualColIds[child.getId()] === true;\n        } else {\n          // if group, base decision on children\n          var columnGroup = child;\n          var displayedChildren = columnGroup.getDisplayedChildren();\n\n          if (displayedChildren) {\n            addThisItem = testGroup(displayedChildren, result, dept + 1);\n          }\n        }\n\n        if (addThisItem) {\n          returnValue = true;\n\n          if (!result[dept]) {\n            result[dept] = [];\n          }\n\n          result[dept].push(child);\n        }\n      }\n\n      return returnValue;\n    };\n\n    testGroup(this.displayedTreeLeft, this.viewportRowLeft, 0);\n    testGroup(this.displayedTreeRight, this.viewportRowRight, 0);\n    testGroup(this.displayedTreeCentre, this.viewportRowCenter, 0);\n  };\n\n  ColumnModel.prototype.extractViewport = function () {\n    this.extractViewportColumns();\n    this.extractViewportRows();\n  };\n\n  ColumnModel.prototype.filterOutColumnsWithinViewport = function () {\n    return this.displayedColumnsCenter.filter(this.isColumnInViewport.bind(this));\n  };\n\n  ColumnModel.prototype.refreshFlexedColumns = function (params) {\n    var _this = this;\n\n    if (params === void 0) {\n      params = {};\n    }\n\n    var source = params.source ? params.source : 'flex';\n\n    if (params.viewportWidth != null) {\n      this.flexViewportWidth = params.viewportWidth;\n    }\n\n    if (!this.flexViewportWidth) {\n      return [];\n    } // If the grid has left-over space, divide it between flexing columns in proportion to their flex value.\n    // A \"flexing column\" is one that has a 'flex' value set and is not currently being constrained by its\n    // minWidth or maxWidth rules.\n\n\n    var flexAfterDisplayIndex = -1;\n\n    if (params.resizingCols) {\n      params.resizingCols.forEach(function (col) {\n        var indexOfCol = _this.displayedColumnsCenter.indexOf(col);\n\n        if (flexAfterDisplayIndex < indexOfCol) {\n          flexAfterDisplayIndex = indexOfCol;\n        }\n      });\n    }\n\n    var isColFlex = function (col) {\n      var afterResizingCols = _this.displayedColumnsCenter.indexOf(col) > flexAfterDisplayIndex;\n      return col.getFlex() && afterResizingCols;\n    };\n\n    var knownWidthColumns = this.displayedColumnsCenter.filter(function (col) {\n      return !isColFlex(col);\n    });\n    var flexingColumns = this.displayedColumnsCenter.filter(function (col) {\n      return isColFlex(col);\n    });\n    var changedColumns = [];\n\n    if (!flexingColumns.length) {\n      return [];\n    }\n\n    var flexingColumnSizes = [];\n    var spaceForFlexingColumns;\n\n    outer: while (true) {\n      var totalFlex = flexingColumns.reduce(function (count, col) {\n        return count + col.getFlex();\n      }, 0);\n      spaceForFlexingColumns = this.flexViewportWidth - this.getWidthOfColsInList(knownWidthColumns);\n\n      for (var i = 0; i < flexingColumns.length; i++) {\n        var col = flexingColumns[i];\n        var widthByFlexRule = spaceForFlexingColumns * col.getFlex() / totalFlex;\n        var constrainedWidth = 0;\n        var minWidth = col.getMinWidth();\n        var maxWidth = col.getMaxWidth();\n\n        if (exists(minWidth) && widthByFlexRule < minWidth) {\n          constrainedWidth = minWidth;\n        } else if (exists(maxWidth) && widthByFlexRule > maxWidth) {\n          constrainedWidth = maxWidth;\n        }\n\n        if (constrainedWidth) {\n          // This column is not in fact flexing as it is being constrained to a specific size\n          // so remove it from the list of flexing columns and start again\n          col.setActualWidth(constrainedWidth, source);\n          removeFromArray(flexingColumns, col);\n          changedColumns.push(col);\n          knownWidthColumns.push(col);\n          continue outer;\n        }\n\n        flexingColumnSizes[i] = Math.round(widthByFlexRule);\n      }\n\n      break;\n    }\n\n    var remainingSpace = spaceForFlexingColumns;\n    flexingColumns.forEach(function (col, i) {\n      col.setActualWidth(Math.min(flexingColumnSizes[i], remainingSpace), source);\n      changedColumns.push(col);\n      remainingSpace -= flexingColumnSizes[i];\n    });\n\n    if (!params.skipSetLeft) {\n      this.setLeftValues(source);\n    }\n\n    if (params.updateBodyWidths) {\n      this.updateBodyWidths();\n    }\n\n    if (params.fireResizedEvent) {\n      this.fireColumnResizedEvent(changedColumns, true, source, flexingColumns);\n    } // if the user sets rowData directly into GridOptions, then the row data is set before\n    // grid is attached to the DOM. this means the columns are not flexed, and then the rows\n    // have the wrong height (as they depend on column widths). so once the columns have\n    // been flexed for the first time (only happens once grid is attached to DOM, as dependency\n    // on getting the grid width, which only happens after attached after ResizeObserver fires)\n    // we get get rows to re-calc their heights.\n\n\n    if (!this.flexColsCalculatedAtLestOnce) {\n      if (this.gridOptionsWrapper.isRowModelDefault()) {\n        this.rowModel.resetRowHeights();\n      }\n\n      this.flexColsCalculatedAtLestOnce = true;\n    }\n\n    return flexingColumns;\n  }; // called from api\n\n\n  ColumnModel.prototype.sizeColumnsToFit = function (gridWidth, source, silent) {\n    if (source === void 0) {\n      source = \"sizeColumnsToFit\";\n    } // avoid divide by zero\n\n\n    var allDisplayedColumns = this.getAllDisplayedColumns();\n\n    if (gridWidth <= 0 || !allDisplayedColumns.length) {\n      return;\n    }\n\n    var colsToSpread = [];\n    var colsToNotSpread = [];\n    allDisplayedColumns.forEach(function (column) {\n      if (column.getColDef().suppressSizeToFit === true) {\n        colsToNotSpread.push(column);\n      } else {\n        colsToSpread.push(column);\n      }\n    }); // make a copy of the cols that are going to be resized\n\n    var colsToFireEventFor = colsToSpread.slice(0);\n    var finishedResizing = false;\n\n    var moveToNotSpread = function (column) {\n      removeFromArray(colsToSpread, column);\n      colsToNotSpread.push(column);\n    }; // resetting cols to their original width makes the sizeColumnsToFit more deterministic,\n    // rather than depending on the current size of the columns. most users call sizeColumnsToFit\n    // immediately after grid is created, so will make no difference. however if application is calling\n    // sizeColumnsToFit repeatedly (eg after column group is opened / closed repeatedly) we don't want\n    // the columns to start shrinking / growing over time.\n    //\n    // NOTE: the process below will assign values to `this.actualWidth` of each column without firing events\n    // for this reason we need to manually fire resize events after the resize has been done for each column.\n\n\n    colsToSpread.forEach(function (column) {\n      return column.resetActualWidth(source);\n    });\n\n    while (!finishedResizing) {\n      finishedResizing = true;\n      var availablePixels = gridWidth - this.getWidthOfColsInList(colsToNotSpread);\n\n      if (availablePixels <= 0) {\n        // no width, set everything to minimum\n        colsToSpread.forEach(function (column) {\n          column.setMinimum(source);\n        });\n      } else {\n        var scale = availablePixels / this.getWidthOfColsInList(colsToSpread); // we set the pixels for the last col based on what's left, as otherwise\n        // we could be a pixel or two short or extra because of rounding errors.\n\n        var pixelsForLastCol = availablePixels; // backwards through loop, as we are removing items as we go\n\n        for (var i = colsToSpread.length - 1; i >= 0; i--) {\n          var column = colsToSpread[i];\n          var minWidth = column.getMinWidth();\n          var maxWidth = column.getMaxWidth();\n          var newWidth = Math.round(column.getActualWidth() * scale);\n\n          if (exists(minWidth) && newWidth < minWidth) {\n            newWidth = minWidth;\n            moveToNotSpread(column);\n            finishedResizing = false;\n          } else if (exists(maxWidth) && column.isGreaterThanMax(newWidth)) {\n            newWidth = maxWidth;\n            moveToNotSpread(column);\n            finishedResizing = false;\n          } else if (i === 0) {\n            // if this is the last column\n            newWidth = pixelsForLastCol;\n          }\n\n          column.setActualWidth(newWidth, source, true);\n          pixelsForLastCol -= newWidth;\n        }\n      }\n    } // see notes above\n\n\n    colsToFireEventFor.forEach(function (col) {\n      col.fireColumnWidthChangedEvent(source);\n    });\n    this.setLeftValues(source);\n    this.updateBodyWidths();\n\n    if (silent) {\n      return;\n    }\n\n    this.fireColumnResizedEvent(colsToFireEventFor, true, source);\n  };\n\n  ColumnModel.prototype.buildDisplayedTrees = function (visibleColumns) {\n    var leftVisibleColumns = [];\n    var rightVisibleColumns = [];\n    var centerVisibleColumns = [];\n    visibleColumns.forEach(function (column) {\n      switch (column.getPinned()) {\n        case \"left\":\n          leftVisibleColumns.push(column);\n          break;\n\n        case \"right\":\n          rightVisibleColumns.push(column);\n          break;\n\n        default:\n          centerVisibleColumns.push(column);\n          break;\n      }\n    });\n    var groupInstanceIdCreator = new GroupInstanceIdCreator();\n    this.displayedTreeLeft = this.displayedGroupCreator.createDisplayedGroups(leftVisibleColumns, this.gridBalancedTree, groupInstanceIdCreator, Constants.PINNED_LEFT, this.displayedTreeLeft);\n    this.displayedTreeRight = this.displayedGroupCreator.createDisplayedGroups(rightVisibleColumns, this.gridBalancedTree, groupInstanceIdCreator, Constants.PINNED_RIGHT, this.displayedTreeRight);\n    this.displayedTreeCentre = this.displayedGroupCreator.createDisplayedGroups(centerVisibleColumns, this.gridBalancedTree, groupInstanceIdCreator, null, this.displayedTreeCentre);\n    this.updateDisplayedMap();\n  };\n\n  ColumnModel.prototype.updateDisplayedMap = function () {\n    var _this = this;\n\n    this.displayedColumnsAndGroupsMap = {};\n\n    var func = function (child) {\n      _this.displayedColumnsAndGroupsMap[child.getUniqueId()] = child;\n    };\n\n    this.columnUtils.depthFirstAllColumnTreeSearch(this.displayedTreeCentre, func);\n    this.columnUtils.depthFirstAllColumnTreeSearch(this.displayedTreeLeft, func);\n    this.columnUtils.depthFirstAllColumnTreeSearch(this.displayedTreeRight, func);\n  };\n\n  ColumnModel.prototype.isDisplayed = function (item) {\n    var fromMap = this.displayedColumnsAndGroupsMap[item.getUniqueId()]; // check for reference, in case new column / group with same id is now present\n\n    return fromMap === item;\n  };\n\n  ColumnModel.prototype.updateOpenClosedVisibilityInColumnGroups = function () {\n    var allColumnGroups = this.getAllDisplayedTrees();\n    this.columnUtils.depthFirstAllColumnTreeSearch(allColumnGroups, function (child) {\n      if (child instanceof ColumnGroup) {\n        var columnGroup = child;\n        columnGroup.calculateDisplayedColumns();\n      }\n    });\n  };\n\n  ColumnModel.prototype.getGroupAutoColumns = function () {\n    return this.groupAutoColumns;\n  };\n\n  ColumnModel.prototype.createGroupAutoColumnsIfNeeded = function () {\n    if (!this.autoGroupsNeedBuilding) {\n      return;\n    }\n\n    this.autoGroupsNeedBuilding = false;\n    var groupFullWidthRow = this.gridOptionsWrapper.isGroupUseEntireRow(this.pivotMode); // we need to allow suppressing auto-column separately for group and pivot as the normal situation\n    // is CSRM and user provides group column themselves for normal view, but when they go into pivot the\n    // columns are generated by the grid so no opportunity for user to provide group column. so need a way\n    // to suppress auto-col for grouping only, and not pivot.\n    // however if using Viewport RM or SSRM and user is providing the columns, the user may wish full control\n    // of the group column in this instance.\n\n    var suppressAutoColumn = this.pivotMode ? this.gridOptionsWrapper.isPivotSuppressAutoColumn() : this.gridOptionsWrapper.isGroupSuppressAutoColumn();\n    var groupingActive = this.rowGroupColumns.length > 0 || this.usingTreeData;\n    var needAutoColumns = groupingActive && !suppressAutoColumn && !groupFullWidthRow;\n\n    if (needAutoColumns) {\n      var newAutoGroupCols = this.autoGroupColService.createAutoGroupColumns(this.rowGroupColumns);\n      var autoColsDifferent = !this.autoColsEqual(newAutoGroupCols, this.groupAutoColumns); // we force recreate when suppressColumnStateEvents changes, so new group cols pick up the new\n      // definitions. otherwise we could ignore the new cols because they appear to be the same.\n\n      if (autoColsDifferent || this.forceRecreateAutoGroups) {\n        this.groupAutoColumns = newAutoGroupCols;\n      }\n    } else {\n      this.groupAutoColumns = null;\n    }\n  };\n\n  ColumnModel.prototype.autoColsEqual = function (colsA, colsB) {\n    return areEqual(colsA, colsB, function (a, b) {\n      return a.getColId() === b.getColId();\n    });\n  };\n\n  ColumnModel.prototype.getWidthOfColsInList = function (columnList) {\n    return columnList.reduce(function (width, col) {\n      return width + col.getActualWidth();\n    }, 0);\n  };\n\n  ColumnModel.prototype.getGridBalancedTree = function () {\n    return this.gridBalancedTree;\n  };\n\n  ColumnModel.prototype.hasFloatingFilters = function () {\n    if (!this.gridColumns) {\n      return false;\n    }\n\n    var res = this.gridColumns.some(function (col) {\n      return col.getColDef().floatingFilter;\n    });\n    return res;\n  };\n\n  ColumnModel.prototype.getFirstDisplayedColumn = function () {\n    var isRtl = this.gridOptionsWrapper.isEnableRtl();\n    var queryOrder = ['getDisplayedLeftColumns', 'getDisplayedCenterColumns', 'getDisplayedRightColumns'];\n\n    if (isRtl) {\n      queryOrder.reverse();\n    }\n\n    for (var i = 0; i < queryOrder.length; i++) {\n      var container = this[queryOrder[i]]();\n\n      if (container.length) {\n        return isRtl ? last(container) : container[0];\n      }\n    }\n\n    return null;\n  };\n\n  __decorate([Autowired('expressionService')], ColumnModel.prototype, \"expressionService\", void 0);\n\n  __decorate([Autowired('columnFactory')], ColumnModel.prototype, \"columnFactory\", void 0);\n\n  __decorate([Autowired('displayedGroupCreator')], ColumnModel.prototype, \"displayedGroupCreator\", void 0);\n\n  __decorate([Autowired('autoWidthCalculator')], ColumnModel.prototype, \"autoWidthCalculator\", void 0);\n\n  __decorate([Autowired('columnUtils')], ColumnModel.prototype, \"columnUtils\", void 0);\n\n  __decorate([Autowired('columnAnimationService')], ColumnModel.prototype, \"columnAnimationService\", void 0);\n\n  __decorate([Autowired('autoGroupColService')], ColumnModel.prototype, \"autoGroupColService\", void 0);\n\n  __decorate([Optional('aggFuncService')], ColumnModel.prototype, \"aggFuncService\", void 0);\n\n  __decorate([Optional('valueCache')], ColumnModel.prototype, \"valueCache\", void 0);\n\n  __decorate([Optional('animationFrameService')], ColumnModel.prototype, \"animationFrameService\", void 0);\n\n  __decorate([Autowired('rowModel')], ColumnModel.prototype, \"rowModel\", void 0);\n\n  __decorate([Autowired('columnApi')], ColumnModel.prototype, \"columnApi\", void 0);\n\n  __decorate([Autowired('gridApi')], ColumnModel.prototype, \"gridApi\", void 0);\n\n  __decorate([Autowired('sortController')], ColumnModel.prototype, \"sortController\", void 0);\n\n  __decorate([Autowired('columnDefFactory')], ColumnModel.prototype, \"columnDefFactory\", void 0);\n\n  __decorate([PostConstruct], ColumnModel.prototype, \"init\", null);\n\n  __decorate([__param(0, Qualifier('loggerFactory'))], ColumnModel.prototype, \"setBeans\", null);\n\n  ColumnModel = __decorate([Bean('columnModel')], ColumnModel);\n  return ColumnModel;\n}(BeanStub);\n\nexport { ColumnModel };","map":{"version":3,"sources":["/Users/rongxuan/Desktop/reactmap/reactmap/node_modules/@ag-grid-community/core/dist/es6/columns/columnModel.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","__spreadArrays","s","il","k","a","j","jl","ColumnGroup","Column","Events","BeanStub","ProvidedColumnGroup","GroupInstanceIdCreator","Autowired","Bean","Optional","PostConstruct","Qualifier","Constants","areEqual","last","removeFromArray","moveInArray","filter","includes","insertIntoArray","removeAllFromArray","missingOrEmpty","exists","missing","find","attrToBoolean","attrToNumber","camelCaseToHumanText","startsWith","convertToMap","doOnce","ColumnModel","_super","_this","apply","primaryHeaderRowCount","secondaryHeaderRowCount","secondaryColumnsPresent","gridHeaderRowCount","displayedColumnsLeft","displayedColumnsRight","displayedColumnsCenter","displayedColumns","displayedColumnsAndGroupsMap","viewportColumns","viewportColumnsCenter","autoHeightActiveAtLeastOnce","rowGroupColumns","valueColumns","pivotColumns","ready","autoGroupsNeedBuilding","forceRecreateAutoGroups","pivotMode","bodyWidth","leftWidth","rightWidth","bodyWidthDirty","colDefVersion","flexColsCalculatedAtLestOnce","init","suppressColumnVirtualisation","gridOptionsWrapper","isSuppressColumnVirtualisation","isPivotMode","isPivotSettingAllowed","usingTreeData","isTreeData","addManagedListener","onAutoGroupColumnDefChanged","bind","updateGridColumns","updateDisplayedColumns","getColDefVersion","setColumnDefs","columnDefs","source","colsPreviouslyExisted","raiseEventsFunc","compareColumnStatesAndRaiseEvents","valueCache","expire","oldPrimaryColumns","primaryColumns","oldPrimaryTree","primaryColumnTree","balancedTreeResult","columnFactory","createColumnTree","columnTree","treeDept","getColumnsFromTree","primaryColumnsMap","forEach","col","getId","extractRowGroupColumns","extractPivotColumns","extractValueColumns","gridColsArePrimary","isMaintainColumnOrder","orderGridColumnsLikePrimary","checkViewportColumns","dispatchEverythingChanged","dispatchNewColumnsLoaded","newColumnsLoadedEvent","type","EVENT_NEW_COLUMNS_LOADED","api","gridApi","columnApi","eventService","dispatchEvent","eventEverythingChanged","EVENT_COLUMN_EVERYTHING_CHANGED","gridColumns","sort","colA","colB","primaryIndexA","indexOf","primaryIndexB","indexAPresent","indexBPresent","gridIndexA","gridIndexB","getAllDisplayedAutoHeightCols","displayedAutoHeightCols","setViewport","isEnableRtl","viewportLeft","scrollPosition","scrollWidth","viewportRight","getDisplayedColumnsStartingAt","column","currentColumn","columns","push","getDisplayedColAfter","hashBefore","map","join","extractViewport","hashAfter","event_1","EVENT_VIRTUAL_COLUMNS_CHANGED","setViewportPosition","pivot","console","warn","setPivotMode","event","EVENT_COLUMN_PIVOT_MODE_CHANGED","getSecondaryPivotColumn","pivotKeys","valueColKey","secondaryColumns","valueColumnToFind","getPrimaryColumn","foundColumn","thisPivotKeys","getColDef","pivotValueColumn","pivotKeyMatches","pivotValueMatches","setBeans","loggerFactory","logger","setFirstRightAndLastLeftPinned","lastLeft","firstRight","setLastLeftPinned","setFirstRightPinned","autoSizeColumns","keys","skipHeader","animationFrameService","flushAllFrames","columnsAutosized","changesThisTimeAround","isSkipHeaderOnAutoSize","actionOnGridColumns","preferredWidth","autoWidthCalculator","getPreferredWidthForColumn","newWidth","normaliseColumnWidth","setActualWidth","fireColumnResizedEvent","finished","flexColumns","event_2","EVENT_COLUMN_RESIZED","autoSizeColumn","autoSizeAllColumns","allDisplayedColumns","getAllDisplayedColumns","rootColumns","result","recursiveFindColumns","childColumns","child","getChildren","getAllDisplayedTrees","displayedTreeLeft","displayedTreeRight","displayedTreeCentre","concat","getPrimaryColumnTree","getHeaderRowCount","getDisplayedTreeLeft","getDisplayedTreeRight","getDisplayedTreeCentre","isColumnDisplayed","getViewportColumns","getDisplayedLeftColumnsForRow","rowNode","colSpanActive","getDisplayedColumnsForRow","getDisplayedRightColumnsForRow","filterCallback","emptySpaceBeforeColumn","lastConsideredCol","_loop_1","maxAllowedColSpan","colSpan","Math","min","getColSpan","columnsToCheckFilter","colsToRemove","filterPasses","colForFilter","gapBeforeColumn","out_i_1","getViewportCenterColumnsForRow","left","getLeft","isColumnInViewport","getAriaColumnIndex","getAllGridColumns","autoHeight","columnLeft","columnRight","getActualWidth","leftBounds","rightBounds","columnToMuchLeft","columnToMuchRight","getDisplayedColumnsLeftWidth","getWidthOfColsInList","getDisplayedColumnsRightWidth","updatePrimaryColumnList","masterList","actionIsAdd","columnCallback","eventType","atLeastOne","columnToAdd","setRowGroupColumns","colKeys","setPrimaryColumnList","EVENT_COLUMN_ROW_GROUP_CHANGED","setRowGroupActive","active","isRowGroupActive","isSuppressMakeColumnVisibleAfterUnGroup","setVisible","addRowGroupColumn","addRowGroupColumns","removeRowGroupColumns","removeRowGroupColumn","addPivotColumns","setPivotActive","EVENT_COLUMN_PIVOT_CHANGED","setPivotColumns","added","addPivotColumn","removePivotColumns","removePivotColumn","eventName","fireColumnEvent","setValueColumns","EVENT_COLUMN_VALUE_CHANGED","setValueActive","isValueActive","getAggFunc","initialAggFunc","aggFuncService","getDefaultAggFunc","setAggFunc","addValueColumns","addValueColumn","colKey","removeValueColumn","removeValueColumns","minWidth","getMinWidth","maxWidth","getMaxWidth","isGreaterThanMax","getPrimaryOrGridColumn","getGridColumn","setColumnWidths","columnWidths","shiftKey","sets","columnWidth","width","ratios","defaultIsShift","getColResizeDefault","otherCol","widthDiff","otherColWidth","resizeColumnSets","checkMinAndMaxWidthsForSet","columnResizeSet","minWidthAccumulated","maxWidthAccumulated","maxWidthActive","minWidthPasses","maxWidthPasses","resizeSets","passMinMaxCheck","every","changedCols","allResizedCols","set","newWidths","finishedCols","finishedColsGrew","loopCount","_loop_2","error","subsetCols","subsetRatioTotal","pixelsToDistribute","index","thisColFinished","ratioThisCol","ratioScale","lastCol","colNewWidth","round","state_1","atLeastOneColChanged","flexedCols","refreshFlexedColumns","resizingCols","skipSetLeft","setLeftValues","updateBodyWidths","colsForEvent","setColumnAggFunc","aggFunc","moveRowGroupColumn","fromIndex","toIndex","splice","moveColumns","columnsToMoveKeys","columnAnimationService","start","columnsToMove","getGridColumns","failedRules","doesMovePassRules","EVENT_COLUMN_MOVED","finish","proposedColumnOrder","slice","doesMovePassMarryChildren","doesMovePassLockedPositions","sortColumnsLikeGridColumns","cols","notAllColsInGridColumns","indexA","indexB","foundNonLocked","rulePassed","lockPosition","allColumnsCopy","columnUtils","depthFirstOriginalTreeSearch","gridBalancedTree","columnGroup","colGroupDef","getColGroupDef","marryChildren","newIndexes","getLeafColumns","newColIndex","maxIndex","max","minIndex","spread","maxSpread","moveColumn","moveColumnByIndex","getColumnDefs","lastPrimaryOrder","columnDefFactory","buildColumnDefs","getBodyContainerWidth","getContainerWidth","pinned","PINNED_LEFT","PINNED_RIGHT","newBodyWidth","newLeftWidth","newRightWidth","atLeastOneChanged","event_3","EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED","getValueColumns","getPivotColumns","isPivotActive","getRowGroupColumns","getDisplayedCenterColumns","getDisplayedLeftColumns","getDisplayedRightColumns","getDisplayedColumns","getAllPrimaryColumns","getSecondaryColumns","getAllColumnsForQuickFilter","columnsForQuickFilter","isEmpty","isRowGroupEmpty","setColumnVisible","visible","setColumnsVisible","isVisible","EVENT_COLUMN_VISIBLE","setColumnPinned","setColumnsPinned","getDomLayout","actualPinned","getPinned","setPinned","EVENT_COLUMN_PINNED","action","createEvent","updatedColumns","resultOfAction","event_4","getDisplayedColBefore","oldIndex","getDisplayedGroupAfter","getDisplayedGroupAtDirection","getDisplayedGroupBefore","direction","requiredLevel","getOriginalColumnGroup","getLevel","getPaddingLevel","colGroupLeafColumns","getDisplayedLeafColumns","getDisplayColMethod","groupPointer","getColumnGroupAtLevel","level","getParent","originalGroupLevel","groupPointerLevel","groupPointerOriginalColumnGroup","isPinningLeft","isPinningRight","getPrimaryAndSecondaryAndAutoColumns","groupAutoColumns","createStateItemFromColumn","rowGroupIndex","pivotIndex","getSort","sortIndex","getSortIndex","flex","getFlex","res","colId","getColId","hide","rowGroup","getColumnState","isAlive","colsForState","orderColumnStateList","getPrimaryAndAutoGroupCols","columnStateList","gridColumnIdMap","itemA","itemB","posA","has","get","posB","resetColumnState","columnStates","letRowGroupIndex","letPivotIndex","colsToProcess","getValueOrNull","colDef","initialSort","initialSortIndex","initialHide","initialPinned","initialWidth","initialFlex","initialRowGroupIndex","initialRowGroup","initialPivotIndex","initialPivot","stateItem","applyColumnState","state","applyOrder","params","columnsWithNoState","success","rowGroupIndexes","pivotIndexes","autoGroupColumnStates","previousRowGroupCols","previousPivotCols","groupAutoColumnId","GROUP_AUTO_COLUMN_ID","isAutoGroupColumn","syncColumnWithStateItem","defaultState","applyDefaultsFunc","comparator","indexes","oldList","aHasIndex","bHasIndex","oldIndexA","oldIndexB","aHasOldIndex","bHasOldIndex","autoGroupColsCopy","autoCol","getAutoColumn","applyOrderAfterApplyState","newOrder","processedColIds","gridColumnsMap","item","putFixedColumnsFirst","startState","columnStateBefore","columnStateBeforeMap","isSuppressColumnStateEvents","raiseWhenListsDifferent","colsBefore","colsAfter","idMapper","beforeList","afterList","unchanged","getChangedColumns","changedPredicate","changedColumns","colStateBefore","columnIdMapper","valueChangePredicate","cs","oldActive","activeChanged","aggFuncChanged","changedValues","resizeChangePredicate","pinnedChangePredicate","raiseColumnPinnedEvent","visibilityChangePredicate","raiseColumnVisibleEvent","sortChangePredicate","sortController","dispatchSortChangedEvents","raiseColumnMovedEvent","getCommonValue","valueGetter","undefined","firstValue","colStateAfter","colStateAfterMapped","colsIntersectIds","beforeFiltered","afterFiltered","movedColumns","csAfter","csBefore","gridCol","getValue","key1","key2","stateAny","defaultAny","obj","value1","value2","calculated","minColWidth","calculateColMinWidth","setFlex","noFlexThisCol","SORT_DESC","SORT_ASC","setSort","setSortIndex","_a","_b","getColumns","columnLookupCallback","foundColumns","getColumnWithValidation","getColumn","columnList","columnMap","columnsMatch","groupCol","columnMatches","colDefMatches","idMatches","getDisplayNameForColumn","location","includeAggFunc","headerName","getHeaderName","wrapHeaderNameWithAggFunc","getDisplayNameForOriginalColumnGroup","originalColumnGroup","getDisplayNameForColumnGroup","headerValueGetter","getApi","context","getContext","expressionService","evaluate","field","isSuppressAggFuncInHeader","pivotActiveOnThisColumn","aggFuncFound","measureActive","aggregationPresent","aggFuncString","localeTextFunc","getLocaleTextFunc","aggFuncStringTranslated","getColumnGroup","instanceId","allColumnGroups","checkInstanceId","depthFirstAllColumnTreeSearch","matched","getGroupId","getInstanceId","isReady","extractColumns","flag","previousCols","setFlagFunc","getIndexFunc","getInitialIndexFunc","getValueFunc","getInitialValueFunc","colsWithIndex","colsWithValue","colIsNew","value","initialValue","initialIndex","include","valuePresent","indexPresent","initialValuePresent","initialIndexPresent","useIndex","getIndexForCol","defaultIndex","resetColumnGroupState","stateItems","groupState","groupId","open","openByDefault","setColumnGroupState","getColumnGroupState","columnGroupState","node","isExpanded","impactedGroups","groupKey","newValue","log","setExpanded","updateGroupsAndDisplayedColumns","EVENT_COLUMN_GROUP_OPENED","setColumnGroupOpened","keyAsString","calculateColumnsForDisplay","columnsForDisplay","isAutoGroupCol","isValueCol","checkColSpanActiveInCols","calculateColumnsForGroupDisplay","groupDisplayColumns","checkFunc","showRowGroup","getGroupDisplayColumns","buildDisplayedTrees","isSecondaryColumnsPresent","setSecondaryColumns","colDefs","newColsPresent","processSecondaryColumnDefinitions","secondaryBalancedTree","getProcessSecondaryColDefFunc","groupCallback","getProcessSecondaryColGroupDefFunc","searchForColDefs","colDefs2","abstractColDef","isGroup","children","orderGridColsLikeLastPrimary","addAutoGroupToGridColumns","setupQuickFilterColumns","clearDisplayedAndViewportColumns","setAutoHeightActive","EVENT_GRID_COLUMNS_CHANGED","autoHeightActive","rowModelType","rowModel","getType","supportedRowModel","ROW_MODEL_TYPE_CLIENT_SIDE","ROW_MODEL_TYPE_SERVER_SIDE","message_1","lastPrimaryOrderMapped","noColsFound","gridColsMap","oldColsOrdered","oldColsMap","newColsOrdered","newGridColumns","newCol","parent","getOriginalParent","siblings","leafCols","leafCol","presentInNewGriColumns","noYetInSiblings","lastIndex","isPrimaryColumnGroupsPresent","locked","unlocked","createGroupAutoColumnsIfNeeded","autoColBalancedTree","createForAutoGroups","viewportRowLeft","viewportRowRight","viewportRowCenter","updateOpenClosedVisibilityInColumnGroups","deriveDisplayedColumns","EVENT_DISPLAYED_COLUMNS_CHANGED","derivedDisplayedColumnsFromDisplayedTree","joinDisplayedColumns","isAutoRowHeightActive","wasAutoRowHeightEverActive","setLeftValuesOfColumns","setLeftValuesOfGroups","allColumns","doingRtl","left_1","setLeft","left_2","checkLeft","tree","depthFirstDisplayedColumnTreeSearch","extractViewportColumns","filterOutColumnsWithinViewport","getVirtualHeaderGroupRow","dept","extractViewportRows","virtualColIds","testGroup","returnValue","addThisItem","displayedChildren","getDisplayedChildren","viewportWidth","flexViewportWidth","flexAfterDisplayIndex","indexOfCol","isColFlex","afterResizingCols","knownWidthColumns","flexingColumns","flexingColumnSizes","spaceForFlexingColumns","outer","totalFlex","reduce","count","widthByFlexRule","constrainedWidth","remainingSpace","fireResizedEvent","isRowModelDefault","resetRowHeights","sizeColumnsToFit","gridWidth","silent","colsToSpread","colsToNotSpread","suppressSizeToFit","colsToFireEventFor","finishedResizing","moveToNotSpread","resetActualWidth","availablePixels","setMinimum","scale","pixelsForLastCol","fireColumnWidthChangedEvent","visibleColumns","leftVisibleColumns","rightVisibleColumns","centerVisibleColumns","groupInstanceIdCreator","displayedGroupCreator","createDisplayedGroups","updateDisplayedMap","func","getUniqueId","isDisplayed","fromMap","calculateDisplayedColumns","getGroupAutoColumns","groupFullWidthRow","isGroupUseEntireRow","suppressAutoColumn","isPivotSuppressAutoColumn","isGroupSuppressAutoColumn","groupingActive","needAutoColumns","newAutoGroupCols","autoGroupColService","createAutoGroupColumns","autoColsDifferent","autoColsEqual","colsA","colsB","getGridBalancedTree","hasFloatingFilters","some","floatingFilter","getFirstDisplayedColumn","isRtl","queryOrder","reverse","container"],"mappings":"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","sourcesContent":["/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v26.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { ColumnGroup } from '../entities/columnGroup';\nimport { Column } from '../entities/column';\nimport { Events } from '../events';\nimport { BeanStub } from \"../context/beanStub\";\nimport { ProvidedColumnGroup } from '../entities/providedColumnGroup';\nimport { GroupInstanceIdCreator } from './groupInstanceIdCreator';\nimport { Autowired, Bean, Optional, PostConstruct, Qualifier } from '../context/context';\nimport { Constants } from '../constants/constants';\nimport { areEqual, last, removeFromArray, moveInArray, filter, includes, insertIntoArray, removeAllFromArray } from '../utils/array';\nimport { missingOrEmpty, exists, missing, find, attrToBoolean, attrToNumber } from '../utils/generic';\nimport { camelCaseToHumanText, startsWith } from '../utils/string';\nimport { convertToMap } from '../utils/map';\nimport { doOnce } from '../utils/function';\nvar ColumnModel = /** @class */ (function (_super) {\n    __extends(ColumnModel, _super);\n    function ColumnModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        // header row count, based on user provided columns\n        _this.primaryHeaderRowCount = 0;\n        _this.secondaryHeaderRowCount = 0;\n        _this.secondaryColumnsPresent = false;\n        // header row count, either above, or based on pivoting if we are pivoting\n        _this.gridHeaderRowCount = 0;\n        // leave level columns of the displayed trees\n        _this.displayedColumnsLeft = [];\n        _this.displayedColumnsRight = [];\n        _this.displayedColumnsCenter = [];\n        // all three lists above combined\n        _this.displayedColumns = [];\n        // for fast lookup, to see if a column or group is still displayed\n        _this.displayedColumnsAndGroupsMap = {};\n        // all columns to be rendered\n        _this.viewportColumns = [];\n        // all columns to be rendered in the centre\n        _this.viewportColumnsCenter = [];\n        _this.autoHeightActiveAtLeastOnce = false;\n        _this.rowGroupColumns = [];\n        _this.valueColumns = [];\n        _this.pivotColumns = [];\n        _this.ready = false;\n        _this.autoGroupsNeedBuilding = false;\n        _this.forceRecreateAutoGroups = false;\n        _this.pivotMode = false;\n        _this.bodyWidth = 0;\n        _this.leftWidth = 0;\n        _this.rightWidth = 0;\n        _this.bodyWidthDirty = true;\n        _this.colDefVersion = 0;\n        _this.flexColsCalculatedAtLestOnce = false;\n        return _this;\n    }\n    ColumnModel.prototype.init = function () {\n        this.suppressColumnVirtualisation = this.gridOptionsWrapper.isSuppressColumnVirtualisation();\n        var pivotMode = this.gridOptionsWrapper.isPivotMode();\n        if (this.isPivotSettingAllowed(pivotMode)) {\n            this.pivotMode = pivotMode;\n        }\n        this.usingTreeData = this.gridOptionsWrapper.isTreeData();\n        this.addManagedListener(this.gridOptionsWrapper, 'autoGroupColumnDef', this.onAutoGroupColumnDefChanged.bind(this));\n    };\n    ColumnModel.prototype.onAutoGroupColumnDefChanged = function () {\n        this.autoGroupsNeedBuilding = true;\n        this.forceRecreateAutoGroups = true;\n        this.updateGridColumns();\n        this.updateDisplayedColumns('gridOptionsChanged');\n    };\n    ColumnModel.prototype.getColDefVersion = function () {\n        return this.colDefVersion;\n    };\n    ColumnModel.prototype.setColumnDefs = function (columnDefs, source) {\n        var _this = this;\n        if (source === void 0) { source = 'api'; }\n        var colsPreviouslyExisted = !!this.columnDefs;\n        this.colDefVersion++;\n        var raiseEventsFunc = this.compareColumnStatesAndRaiseEvents(source);\n        this.columnDefs = columnDefs;\n        // always invalidate cache on changing columns, as the column id's for the new columns\n        // could overlap with the old id's, so the cache would return old values for new columns.\n        this.valueCache.expire();\n        // NOTE ==================\n        // we should be destroying the existing columns and groups if they exist, for example, the original column\n        // group adds a listener to the columns, it should be also removing the listeners\n        this.autoGroupsNeedBuilding = true;\n        var oldPrimaryColumns = this.primaryColumns;\n        var oldPrimaryTree = this.primaryColumnTree;\n        var balancedTreeResult = this.columnFactory.createColumnTree(columnDefs, true, oldPrimaryTree);\n        this.primaryColumnTree = balancedTreeResult.columnTree;\n        this.primaryHeaderRowCount = balancedTreeResult.treeDept + 1;\n        this.primaryColumns = this.getColumnsFromTree(this.primaryColumnTree);\n        this.primaryColumnsMap = {};\n        this.primaryColumns.forEach(function (col) { return _this.primaryColumnsMap[col.getId()] = col; });\n        this.extractRowGroupColumns(source, oldPrimaryColumns);\n        this.extractPivotColumns(source, oldPrimaryColumns);\n        this.extractValueColumns(source, oldPrimaryColumns);\n        this.ready = true;\n        this.updateGridColumns();\n        if (colsPreviouslyExisted && this.gridColsArePrimary && !this.gridOptionsWrapper.isMaintainColumnOrder()) {\n            this.orderGridColumnsLikePrimary();\n        }\n        this.updateDisplayedColumns(source);\n        this.checkViewportColumns();\n        // this event is not used by AG Grid, but left here for backwards compatibility,\n        // in case applications use it\n        this.dispatchEverythingChanged(source);\n        raiseEventsFunc();\n        this.dispatchNewColumnsLoaded();\n    };\n    ColumnModel.prototype.dispatchNewColumnsLoaded = function () {\n        var newColumnsLoadedEvent = {\n            type: Events.EVENT_NEW_COLUMNS_LOADED,\n            api: this.gridApi,\n            columnApi: this.columnApi\n        };\n        this.eventService.dispatchEvent(newColumnsLoadedEvent);\n    };\n    // this event is legacy, no grid code listens to it. instead the grid listens to New Columns Loaded\n    ColumnModel.prototype.dispatchEverythingChanged = function (source) {\n        if (source === void 0) { source = 'api'; }\n        var eventEverythingChanged = {\n            type: Events.EVENT_COLUMN_EVERYTHING_CHANGED,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n        this.eventService.dispatchEvent(eventEverythingChanged);\n    };\n    ColumnModel.prototype.orderGridColumnsLikePrimary = function () {\n        var _this = this;\n        var primaryColumns = this.primaryColumns;\n        if (!primaryColumns) {\n            return;\n        }\n        this.gridColumns.sort(function (colA, colB) {\n            var primaryIndexA = primaryColumns.indexOf(colA);\n            var primaryIndexB = primaryColumns.indexOf(colB);\n            // if both cols are present in primary, then we just return the position,\n            // so position is maintained.\n            var indexAPresent = primaryIndexA >= 0;\n            var indexBPresent = primaryIndexB >= 0;\n            if (indexAPresent && indexBPresent) {\n                return primaryIndexA - primaryIndexB;\n            }\n            if (indexAPresent) {\n                // B is auto group column, so put B first\n                return 1;\n            }\n            if (indexBPresent) {\n                // A is auto group column, so put A first\n                return -1;\n            }\n            // otherwise both A and B are auto-group columns. so we just keep the order\n            // as they were already in.\n            var gridIndexA = _this.gridColumns.indexOf(colA);\n            var gridIndexB = _this.gridColumns.indexOf(colB);\n            return gridIndexA - gridIndexB;\n        });\n    };\n    ColumnModel.prototype.getAllDisplayedAutoHeightCols = function () {\n        return this.displayedAutoHeightCols;\n    };\n    ColumnModel.prototype.setViewport = function () {\n        if (this.gridOptionsWrapper.isEnableRtl()) {\n            this.viewportLeft = this.bodyWidth - this.scrollPosition - this.scrollWidth;\n            this.viewportRight = this.bodyWidth - this.scrollPosition;\n        }\n        else {\n            this.viewportLeft = this.scrollPosition;\n            this.viewportRight = this.scrollWidth + this.scrollPosition;\n        }\n    };\n    // used by clipboard service, to know what columns to paste into\n    ColumnModel.prototype.getDisplayedColumnsStartingAt = function (column) {\n        var currentColumn = column;\n        var columns = [];\n        while (currentColumn != null) {\n            columns.push(currentColumn);\n            currentColumn = this.getDisplayedColAfter(currentColumn);\n        }\n        return columns;\n    };\n    // checks what columns are currently displayed due to column virtualisation. fires an event\n    // if the list of columns has changed.\n    // + setColumnWidth(), setViewportPosition(), setColumnDefs(), sizeColumnsToFit()\n    ColumnModel.prototype.checkViewportColumns = function () {\n        // check displayCenterColumnTree exists first, as it won't exist when grid is initialising\n        if (this.displayedColumnsCenter == null) {\n            return;\n        }\n        var hashBefore = this.viewportColumns.map(function (column) { return column.getId(); }).join('#');\n        this.extractViewport();\n        var hashAfter = this.viewportColumns.map(function (column) { return column.getId(); }).join('#');\n        if (hashBefore !== hashAfter) {\n            var event_1 = {\n                type: Events.EVENT_VIRTUAL_COLUMNS_CHANGED,\n                api: this.gridApi,\n                columnApi: this.columnApi\n            };\n            this.eventService.dispatchEvent(event_1);\n        }\n    };\n    ColumnModel.prototype.setViewportPosition = function (scrollWidth, scrollPosition) {\n        if (scrollWidth !== this.scrollWidth || scrollPosition !== this.scrollPosition || this.bodyWidthDirty) {\n            this.scrollWidth = scrollWidth;\n            this.scrollPosition = scrollPosition;\n            // we need to call setVirtualViewportLeftAndRight() at least once after the body width changes,\n            // as the viewport can stay the same, but in RTL, if body width changes, we need to work out the\n            // virtual columns again\n            this.bodyWidthDirty = true;\n            this.setViewport();\n            if (this.ready) {\n                this.checkViewportColumns();\n            }\n        }\n    };\n    ColumnModel.prototype.isPivotMode = function () {\n        return this.pivotMode;\n    };\n    ColumnModel.prototype.isPivotSettingAllowed = function (pivot) {\n        if (pivot && this.gridOptionsWrapper.isTreeData()) {\n            console.warn(\"AG Grid: Pivot mode not available in conjunction Tree Data i.e. 'gridOptions.treeData: true'\");\n            return false;\n        }\n        return true;\n    };\n    ColumnModel.prototype.setPivotMode = function (pivotMode, source) {\n        if (source === void 0) { source = 'api'; }\n        if (pivotMode === this.pivotMode || !this.isPivotSettingAllowed(this.pivotMode)) {\n            return;\n        }\n        this.pivotMode = pivotMode;\n        // we need to update grid columns to cover the scenario where user has groupSuppressAutoColumn=true, as\n        // this means we don't use auto group column UNLESS we are in pivot mode (it's mandatory in pivot mode),\n        // so need to updateGridColumn() to check it autoGroupCol needs to be added / removed\n        this.autoGroupsNeedBuilding = true;\n        this.updateGridColumns();\n        this.updateDisplayedColumns(source);\n        var event = {\n            type: Events.EVENT_COLUMN_PIVOT_MODE_CHANGED,\n            api: this.gridApi,\n            columnApi: this.columnApi\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    ColumnModel.prototype.getSecondaryPivotColumn = function (pivotKeys, valueColKey) {\n        if (!this.secondaryColumnsPresent || !this.secondaryColumns) {\n            return null;\n        }\n        var valueColumnToFind = this.getPrimaryColumn(valueColKey);\n        var foundColumn = null;\n        this.secondaryColumns.forEach(function (column) {\n            var thisPivotKeys = column.getColDef().pivotKeys;\n            var pivotValueColumn = column.getColDef().pivotValueColumn;\n            var pivotKeyMatches = areEqual(thisPivotKeys, pivotKeys);\n            var pivotValueMatches = pivotValueColumn === valueColumnToFind;\n            if (pivotKeyMatches && pivotValueMatches) {\n                foundColumn = column;\n            }\n        });\n        return foundColumn;\n    };\n    ColumnModel.prototype.setBeans = function (loggerFactory) {\n        this.logger = loggerFactory.create('columnModel');\n    };\n    ColumnModel.prototype.setFirstRightAndLastLeftPinned = function (source) {\n        var lastLeft;\n        var firstRight;\n        if (this.gridOptionsWrapper.isEnableRtl()) {\n            lastLeft = this.displayedColumnsLeft ? this.displayedColumnsLeft[0] : null;\n            firstRight = this.displayedColumnsRight ? last(this.displayedColumnsRight) : null;\n        }\n        else {\n            lastLeft = this.displayedColumnsLeft ? last(this.displayedColumnsLeft) : null;\n            firstRight = this.displayedColumnsRight ? this.displayedColumnsRight[0] : null;\n        }\n        this.gridColumns.forEach(function (column) {\n            column.setLastLeftPinned(column === lastLeft, source);\n            column.setFirstRightPinned(column === firstRight, source);\n        });\n    };\n    ColumnModel.prototype.autoSizeColumns = function (keys, skipHeader, source) {\n        // because of column virtualisation, we can only do this function on columns that are\n        // actually rendered, as non-rendered columns (outside the viewport and not rendered\n        // due to column virtualisation) are not present. this can result in all rendered columns\n        // getting narrowed, which in turn introduces more rendered columns on the RHS which\n        // did not get autosized in the original run, leaving the visible grid with columns on\n        // the LHS sized, but RHS no. so we keep looping through the visible columns until\n        // no more cols are available (rendered) to be resized\n        var _this = this;\n        if (source === void 0) { source = \"api\"; }\n        // we autosize after animation frames finish in case any cell renderers need to complete first. this can\n        // happen eg if client code is calling api.autoSizeAllColumns() straight after grid is initialised, but grid\n        // hasn't fully drawn out all the cells yet (due to cell renderers in animation frames).\n        this.animationFrameService.flushAllFrames();\n        // keep track of which cols we have resized in here\n        var columnsAutosized = [];\n        // initialise with anything except 0 so that while loop executes at least once\n        var changesThisTimeAround = -1;\n        if (skipHeader == null) {\n            skipHeader = this.gridOptionsWrapper.isSkipHeaderOnAutoSize();\n        }\n        while (changesThisTimeAround !== 0) {\n            changesThisTimeAround = 0;\n            this.actionOnGridColumns(keys, function (column) {\n                // if already autosized, skip it\n                if (columnsAutosized.indexOf(column) >= 0) {\n                    return false;\n                }\n                // get how wide this col should be\n                var preferredWidth = _this.autoWidthCalculator.getPreferredWidthForColumn(column, skipHeader);\n                // preferredWidth = -1 if this col is not on the screen\n                if (preferredWidth > 0) {\n                    var newWidth = _this.normaliseColumnWidth(column, preferredWidth);\n                    column.setActualWidth(newWidth, source);\n                    columnsAutosized.push(column);\n                    changesThisTimeAround++;\n                }\n                return true;\n            }, source);\n        }\n        this.fireColumnResizedEvent(columnsAutosized, true, 'autosizeColumns');\n    };\n    ColumnModel.prototype.fireColumnResizedEvent = function (columns, finished, source, flexColumns) {\n        if (flexColumns === void 0) { flexColumns = null; }\n        if (columns && columns.length) {\n            var event_2 = {\n                type: Events.EVENT_COLUMN_RESIZED,\n                columns: columns,\n                column: columns.length === 1 ? columns[0] : null,\n                flexColumns: flexColumns,\n                finished: finished,\n                api: this.gridApi,\n                columnApi: this.columnApi,\n                source: source\n            };\n            this.eventService.dispatchEvent(event_2);\n        }\n    };\n    ColumnModel.prototype.autoSizeColumn = function (key, skipHeader, source) {\n        if (source === void 0) { source = \"api\"; }\n        if (key) {\n            this.autoSizeColumns([key], skipHeader, source);\n        }\n    };\n    ColumnModel.prototype.autoSizeAllColumns = function (skipHeader, source) {\n        if (source === void 0) { source = \"api\"; }\n        var allDisplayedColumns = this.getAllDisplayedColumns();\n        this.autoSizeColumns(allDisplayedColumns, skipHeader, source);\n    };\n    ColumnModel.prototype.getColumnsFromTree = function (rootColumns) {\n        var result = [];\n        var recursiveFindColumns = function (childColumns) {\n            for (var i = 0; i < childColumns.length; i++) {\n                var child = childColumns[i];\n                if (child instanceof Column) {\n                    result.push(child);\n                }\n                else if (child instanceof ProvidedColumnGroup) {\n                    recursiveFindColumns(child.getChildren());\n                }\n            }\n        };\n        recursiveFindColumns(rootColumns);\n        return result;\n    };\n    ColumnModel.prototype.getAllDisplayedTrees = function () {\n        if (this.displayedTreeLeft && this.displayedTreeRight && this.displayedTreeCentre) {\n            return this.displayedTreeLeft\n                .concat(this.displayedTreeCentre)\n                .concat(this.displayedTreeRight);\n        }\n        return null;\n    };\n    // + columnSelectPanel\n    ColumnModel.prototype.getPrimaryColumnTree = function () {\n        return this.primaryColumnTree;\n    };\n    // + gridPanel -> for resizing the body and setting top margin\n    ColumnModel.prototype.getHeaderRowCount = function () {\n        return this.gridHeaderRowCount;\n    };\n    // + headerRenderer -> setting pinned body width\n    ColumnModel.prototype.getDisplayedTreeLeft = function () {\n        return this.displayedTreeLeft;\n    };\n    // + headerRenderer -> setting pinned body width\n    ColumnModel.prototype.getDisplayedTreeRight = function () {\n        return this.displayedTreeRight;\n    };\n    // + headerRenderer -> setting pinned body width\n    ColumnModel.prototype.getDisplayedTreeCentre = function () {\n        return this.displayedTreeCentre;\n    };\n    // gridPanel -> ensureColumnVisible\n    ColumnModel.prototype.isColumnDisplayed = function (column) {\n        return this.getAllDisplayedColumns().indexOf(column) >= 0;\n    };\n    // + csvCreator\n    ColumnModel.prototype.getAllDisplayedColumns = function () {\n        return this.displayedColumns;\n    };\n    ColumnModel.prototype.getViewportColumns = function () {\n        return this.viewportColumns;\n    };\n    ColumnModel.prototype.getDisplayedLeftColumnsForRow = function (rowNode) {\n        if (!this.colSpanActive) {\n            return this.displayedColumnsLeft;\n        }\n        return this.getDisplayedColumnsForRow(rowNode, this.displayedColumnsLeft);\n    };\n    ColumnModel.prototype.getDisplayedRightColumnsForRow = function (rowNode) {\n        if (!this.colSpanActive) {\n            return this.displayedColumnsRight;\n        }\n        return this.getDisplayedColumnsForRow(rowNode, this.displayedColumnsRight);\n    };\n    ColumnModel.prototype.getDisplayedColumnsForRow = function (rowNode, displayedColumns, filterCallback, emptySpaceBeforeColumn) {\n        var result = [];\n        var lastConsideredCol = null;\n        var _loop_1 = function (i) {\n            var col = displayedColumns[i];\n            var maxAllowedColSpan = displayedColumns.length - i;\n            var colSpan = Math.min(col.getColSpan(rowNode), maxAllowedColSpan);\n            var columnsToCheckFilter = [col];\n            if (colSpan > 1) {\n                var colsToRemove = colSpan - 1;\n                for (var j = 1; j <= colsToRemove; j++) {\n                    columnsToCheckFilter.push(displayedColumns[i + j]);\n                }\n                i += colsToRemove;\n            }\n            // see which cols we should take out for column virtualisation\n            var filterPasses;\n            if (filterCallback) {\n                // if user provided a callback, means some columns may not be in the viewport.\n                // the user will NOT provide a callback if we are talking about pinned areas,\n                // as pinned areas have no horizontal scroll and do not virtualise the columns.\n                // if lots of columns, that means column spanning, and we set filterPasses = true\n                // if one or more of the columns spanned pass the filter.\n                filterPasses = false;\n                columnsToCheckFilter.forEach(function (colForFilter) {\n                    if (filterCallback(colForFilter)) {\n                        filterPasses = true;\n                    }\n                });\n            }\n            else {\n                filterPasses = true;\n            }\n            if (filterPasses) {\n                if (result.length === 0 && lastConsideredCol) {\n                    var gapBeforeColumn = emptySpaceBeforeColumn ? emptySpaceBeforeColumn(col) : false;\n                    if (gapBeforeColumn) {\n                        result.push(lastConsideredCol);\n                    }\n                }\n                result.push(col);\n            }\n            lastConsideredCol = col;\n            out_i_1 = i;\n        };\n        var out_i_1;\n        for (var i = 0; i < displayedColumns.length; i++) {\n            _loop_1(i);\n            i = out_i_1;\n        }\n        return result;\n    };\n    // + rowRenderer\n    // if we are not column spanning, this just returns back the virtual centre columns,\n    // however if we are column spanning, then different rows can have different virtual\n    // columns, so we have to work out the list for each individual row.\n    ColumnModel.prototype.getViewportCenterColumnsForRow = function (rowNode) {\n        var _this = this;\n        if (!this.colSpanActive) {\n            return this.viewportColumnsCenter;\n        }\n        var emptySpaceBeforeColumn = function (col) {\n            var left = col.getLeft();\n            return exists(left) && left > _this.viewportLeft;\n        };\n        // if doing column virtualisation, then we filter based on the viewport.\n        var filterCallback = this.suppressColumnVirtualisation ? null : this.isColumnInViewport.bind(this);\n        return this.getDisplayedColumnsForRow(rowNode, this.displayedColumnsCenter, filterCallback, emptySpaceBeforeColumn);\n    };\n    ColumnModel.prototype.getAriaColumnIndex = function (col) {\n        return this.getAllGridColumns().indexOf(col) + 1;\n    };\n    ColumnModel.prototype.isColumnInViewport = function (col) {\n        // we never filter out autoHeight columns, as we need them in the DOM for calculating Auto Height\n        if (col.getColDef().autoHeight) {\n            return true;\n        }\n        var columnLeft = col.getLeft() || 0;\n        var columnRight = columnLeft + col.getActualWidth();\n        // adding 200 for buffer size, so some cols off viewport are rendered.\n        // this helps horizontal scrolling so user rarely sees white space (unless\n        // they scroll horizontally fast). however we are conservative, as the more\n        // buffer the slower the vertical redraw speed\n        var leftBounds = this.viewportLeft - 200;\n        var rightBounds = this.viewportRight + 200;\n        var columnToMuchLeft = columnLeft < leftBounds && columnRight < leftBounds;\n        var columnToMuchRight = columnLeft > rightBounds && columnRight > rightBounds;\n        return !columnToMuchLeft && !columnToMuchRight;\n    };\n    // used by:\n    // + angularGrid -> setting pinned body width\n    // note: this should be cached\n    ColumnModel.prototype.getDisplayedColumnsLeftWidth = function () {\n        return this.getWidthOfColsInList(this.displayedColumnsLeft);\n    };\n    // note: this should be cached\n    ColumnModel.prototype.getDisplayedColumnsRightWidth = function () {\n        return this.getWidthOfColsInList(this.displayedColumnsRight);\n    };\n    ColumnModel.prototype.updatePrimaryColumnList = function (keys, masterList, actionIsAdd, columnCallback, eventType, source) {\n        var _this = this;\n        if (source === void 0) { source = \"api\"; }\n        if (!keys || missingOrEmpty(keys)) {\n            return;\n        }\n        var atLeastOne = false;\n        keys.forEach(function (key) {\n            var columnToAdd = _this.getPrimaryColumn(key);\n            if (!columnToAdd) {\n                return;\n            }\n            if (actionIsAdd) {\n                if (masterList.indexOf(columnToAdd) >= 0) {\n                    return;\n                }\n                masterList.push(columnToAdd);\n            }\n            else {\n                if (masterList.indexOf(columnToAdd) < 0) {\n                    return;\n                }\n                removeFromArray(masterList, columnToAdd);\n            }\n            columnCallback(columnToAdd);\n            atLeastOne = true;\n        });\n        if (!atLeastOne) {\n            return;\n        }\n        if (this.autoGroupsNeedBuilding) {\n            this.updateGridColumns();\n        }\n        this.updateDisplayedColumns(source);\n        var event = {\n            type: eventType,\n            columns: masterList,\n            column: masterList.length === 1 ? masterList[0] : null,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    ColumnModel.prototype.setRowGroupColumns = function (colKeys, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.autoGroupsNeedBuilding = true;\n        this.setPrimaryColumnList(colKeys, this.rowGroupColumns, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.setRowGroupActive.bind(this), source);\n    };\n    ColumnModel.prototype.setRowGroupActive = function (active, column, source) {\n        if (active === column.isRowGroupActive()) {\n            return;\n        }\n        column.setRowGroupActive(active, source);\n        if (!active && !this.gridOptionsWrapper.isSuppressMakeColumnVisibleAfterUnGroup()) {\n            column.setVisible(true, source);\n        }\n    };\n    ColumnModel.prototype.addRowGroupColumn = function (key, source) {\n        if (source === void 0) { source = \"api\"; }\n        if (key) {\n            this.addRowGroupColumns([key], source);\n        }\n    };\n    ColumnModel.prototype.addRowGroupColumns = function (keys, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.autoGroupsNeedBuilding = true;\n        this.updatePrimaryColumnList(keys, this.rowGroupColumns, true, this.setRowGroupActive.bind(this, true), Events.EVENT_COLUMN_ROW_GROUP_CHANGED, source);\n    };\n    ColumnModel.prototype.removeRowGroupColumns = function (keys, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.autoGroupsNeedBuilding = true;\n        this.updatePrimaryColumnList(keys, this.rowGroupColumns, false, this.setRowGroupActive.bind(this, false), Events.EVENT_COLUMN_ROW_GROUP_CHANGED, source);\n    };\n    ColumnModel.prototype.removeRowGroupColumn = function (key, source) {\n        if (source === void 0) { source = \"api\"; }\n        if (key) {\n            this.removeRowGroupColumns([key], source);\n        }\n    };\n    ColumnModel.prototype.addPivotColumns = function (keys, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.updatePrimaryColumnList(keys, this.pivotColumns, true, function (column) { return column.setPivotActive(true, source); }, Events.EVENT_COLUMN_PIVOT_CHANGED, source);\n    };\n    ColumnModel.prototype.setPivotColumns = function (colKeys, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.setPrimaryColumnList(colKeys, this.pivotColumns, Events.EVENT_COLUMN_PIVOT_CHANGED, function (added, column) {\n            column.setPivotActive(added, source);\n        }, source);\n    };\n    ColumnModel.prototype.addPivotColumn = function (key, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.addPivotColumns([key], source);\n    };\n    ColumnModel.prototype.removePivotColumns = function (keys, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.updatePrimaryColumnList(keys, this.pivotColumns, false, function (column) { return column.setPivotActive(false, source); }, Events.EVENT_COLUMN_PIVOT_CHANGED, source);\n    };\n    ColumnModel.prototype.removePivotColumn = function (key, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.removePivotColumns([key], source);\n    };\n    ColumnModel.prototype.setPrimaryColumnList = function (colKeys, masterList, eventName, columnCallback, source) {\n        var _this = this;\n        masterList.length = 0;\n        if (exists(colKeys)) {\n            colKeys.forEach(function (key) {\n                var column = _this.getPrimaryColumn(key);\n                if (column) {\n                    masterList.push(column);\n                }\n            });\n        }\n        (this.primaryColumns || []).forEach(function (column) {\n            var added = masterList.indexOf(column) >= 0;\n            columnCallback(added, column);\n        });\n        if (this.autoGroupsNeedBuilding) {\n            this.updateGridColumns();\n        }\n        this.updateDisplayedColumns(source);\n        this.fireColumnEvent(eventName, masterList, source);\n    };\n    ColumnModel.prototype.setValueColumns = function (colKeys, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.setPrimaryColumnList(colKeys, this.valueColumns, Events.EVENT_COLUMN_VALUE_CHANGED, this.setValueActive.bind(this), source);\n    };\n    ColumnModel.prototype.setValueActive = function (active, column, source) {\n        if (active === column.isValueActive()) {\n            return;\n        }\n        column.setValueActive(active, source);\n        if (active && !column.getAggFunc()) {\n            var initialAggFunc = this.aggFuncService.getDefaultAggFunc(column);\n            column.setAggFunc(initialAggFunc);\n        }\n    };\n    ColumnModel.prototype.addValueColumns = function (keys, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.updatePrimaryColumnList(keys, this.valueColumns, true, this.setValueActive.bind(this, true), Events.EVENT_COLUMN_VALUE_CHANGED, source);\n    };\n    ColumnModel.prototype.addValueColumn = function (colKey, source) {\n        if (source === void 0) { source = \"api\"; }\n        if (colKey) {\n            this.addValueColumns([colKey], source);\n        }\n    };\n    ColumnModel.prototype.removeValueColumn = function (colKey, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.removeValueColumns([colKey], source);\n    };\n    ColumnModel.prototype.removeValueColumns = function (keys, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.updatePrimaryColumnList(keys, this.valueColumns, false, this.setValueActive.bind(this, false), Events.EVENT_COLUMN_VALUE_CHANGED, source);\n    };\n    // returns the width we can set to this col, taking into consideration min and max widths\n    ColumnModel.prototype.normaliseColumnWidth = function (column, newWidth) {\n        var minWidth = column.getMinWidth();\n        if (exists(minWidth) && newWidth < minWidth) {\n            newWidth = minWidth;\n        }\n        var maxWidth = column.getMaxWidth();\n        if (exists(maxWidth) && column.isGreaterThanMax(newWidth)) {\n            newWidth = maxWidth;\n        }\n        return newWidth;\n    };\n    ColumnModel.prototype.getPrimaryOrGridColumn = function (key) {\n        var column = this.getPrimaryColumn(key);\n        return column || this.getGridColumn(key);\n    };\n    ColumnModel.prototype.setColumnWidths = function (columnWidths, shiftKey, // @takeFromAdjacent - if user has 'shift' pressed, then pixels are taken from adjacent column\n    finished, // @finished - ends up in the event, tells the user if more events are to come\n    source) {\n        var _this = this;\n        if (source === void 0) { source = \"api\"; }\n        var sets = [];\n        columnWidths.forEach(function (columnWidth) {\n            var col = _this.getPrimaryOrGridColumn(columnWidth.key);\n            if (!col) {\n                return;\n            }\n            sets.push({\n                width: columnWidth.newWidth,\n                ratios: [1],\n                columns: [col]\n            });\n            // if user wants to do shift resize by default, then we invert the shift operation\n            var defaultIsShift = _this.gridOptionsWrapper.getColResizeDefault() === 'shift';\n            if (defaultIsShift) {\n                shiftKey = !shiftKey;\n            }\n            if (shiftKey) {\n                var otherCol = _this.getDisplayedColAfter(col);\n                if (!otherCol) {\n                    return;\n                }\n                var widthDiff = col.getActualWidth() - columnWidth.newWidth;\n                var otherColWidth = otherCol.getActualWidth() + widthDiff;\n                sets.push({\n                    width: otherColWidth,\n                    ratios: [1],\n                    columns: [otherCol]\n                });\n            }\n        });\n        if (sets.length === 0) {\n            return;\n        }\n        this.resizeColumnSets(sets, finished, source);\n    };\n    ColumnModel.prototype.checkMinAndMaxWidthsForSet = function (columnResizeSet) {\n        var columns = columnResizeSet.columns, width = columnResizeSet.width;\n        // every col has a min width, so sum them all up and see if we have enough room\n        // for all the min widths\n        var minWidthAccumulated = 0;\n        var maxWidthAccumulated = 0;\n        var maxWidthActive = true;\n        columns.forEach(function (col) {\n            var minWidth = col.getMinWidth();\n            minWidthAccumulated += minWidth || 0;\n            var maxWidth = col.getMaxWidth();\n            if (exists(maxWidth) && maxWidth > 0) {\n                maxWidthAccumulated += maxWidth;\n            }\n            else {\n                // if at least one columns has no max width, it means the group of columns\n                // then has no max width, as at least one column can take as much width as possible\n                maxWidthActive = false;\n            }\n        });\n        var minWidthPasses = width >= minWidthAccumulated;\n        var maxWidthPasses = !maxWidthActive || (width <= maxWidthAccumulated);\n        return minWidthPasses && maxWidthPasses;\n    };\n    // method takes sets of columns and resizes them. either all sets will be resized, or nothing\n    // be resized. this is used for example when user tries to resize a group and holds shift key,\n    // then both the current group (grows), and the adjacent group (shrinks), will get resized,\n    // so that's two sets for this method.\n    ColumnModel.prototype.resizeColumnSets = function (resizeSets, finished, source) {\n        var _this = this;\n        var passMinMaxCheck = !resizeSets || resizeSets.every(function (columnResizeSet) { return _this.checkMinAndMaxWidthsForSet(columnResizeSet); });\n        if (!passMinMaxCheck) {\n            // even though we are not going to resize beyond min/max size, we still need to raise event when finished\n            if (finished) {\n                var columns = resizeSets && resizeSets.length > 0 ? resizeSets[0].columns : null;\n                this.fireColumnResizedEvent(columns, finished, source);\n            }\n            return; // don't resize!\n        }\n        var changedCols = [];\n        var allResizedCols = [];\n        resizeSets.forEach(function (set) {\n            var width = set.width, columns = set.columns, ratios = set.ratios;\n            // keep track of pixels used, and last column gets the remaining,\n            // to cater for rounding errors, and min width adjustments\n            var newWidths = {};\n            var finishedCols = {};\n            columns.forEach(function (col) { return allResizedCols.push(col); });\n            // the loop below goes through each col. if a col exceeds it's min/max width,\n            // it then gets set to its min/max width and the column is removed marked as 'finished'\n            // and the calculation is done again leaving this column out. take for example columns\n            // {A, width: 50, maxWidth: 100}\n            // {B, width: 50}\n            // {C, width: 50}\n            // and then the set is set to width 600 - on the first pass the grid tries to set each column\n            // to 200. it checks A and sees 200 > 100 and so sets the width to 100. col A is then marked\n            // as 'finished' and the calculation is done again with the remaining cols B and C, which end up\n            // splitting the remaining 500 pixels.\n            var finishedColsGrew = true;\n            var loopCount = 0;\n            var _loop_2 = function () {\n                loopCount++;\n                if (loopCount > 1000) {\n                    // this should never happen, but in the future, someone might introduce a bug here,\n                    // so we stop the browser from hanging and report bug properly\n                    console.error('AG Grid: infinite loop in resizeColumnSets');\n                    return \"break\";\n                }\n                finishedColsGrew = false;\n                var subsetCols = [];\n                var subsetRatioTotal = 0;\n                var pixelsToDistribute = width;\n                columns.forEach(function (col, index) {\n                    var thisColFinished = finishedCols[col.getId()];\n                    if (thisColFinished) {\n                        pixelsToDistribute -= newWidths[col.getId()];\n                    }\n                    else {\n                        subsetCols.push(col);\n                        var ratioThisCol = ratios[index];\n                        subsetRatioTotal += ratioThisCol;\n                    }\n                });\n                // because we are not using all of the ratios (cols can be missing),\n                // we scale the ratio. if all columns are included, then subsetRatioTotal=1,\n                // and so the ratioScale will be 1.\n                var ratioScale = 1 / subsetRatioTotal;\n                subsetCols.forEach(function (col, index) {\n                    var lastCol = index === (subsetCols.length - 1);\n                    var colNewWidth;\n                    if (lastCol) {\n                        colNewWidth = pixelsToDistribute;\n                    }\n                    else {\n                        colNewWidth = Math.round(ratios[index] * width * ratioScale);\n                        pixelsToDistribute -= colNewWidth;\n                    }\n                    var minWidth = col.getMinWidth();\n                    var maxWidth = col.getMaxWidth();\n                    if (exists(minWidth) && colNewWidth < minWidth) {\n                        colNewWidth = minWidth;\n                        finishedCols[col.getId()] = true;\n                        finishedColsGrew = true;\n                    }\n                    else if (exists(maxWidth) && maxWidth > 0 && colNewWidth > maxWidth) {\n                        colNewWidth = maxWidth;\n                        finishedCols[col.getId()] = true;\n                        finishedColsGrew = true;\n                    }\n                    newWidths[col.getId()] = colNewWidth;\n                });\n            };\n            while (finishedColsGrew) {\n                var state_1 = _loop_2();\n                if (state_1 === \"break\")\n                    break;\n            }\n            columns.forEach(function (col) {\n                var newWidth = newWidths[col.getId()];\n                if (col.getActualWidth() !== newWidth) {\n                    col.setActualWidth(newWidth, source);\n                    changedCols.push(col);\n                }\n            });\n        });\n        // if no cols changed, then no need to update more or send event.\n        var atLeastOneColChanged = changedCols.length > 0;\n        var flexedCols = this.refreshFlexedColumns({ resizingCols: allResizedCols, skipSetLeft: true });\n        if (atLeastOneColChanged) {\n            this.setLeftValues(source);\n            this.updateBodyWidths();\n            this.checkViewportColumns();\n        }\n        // check for change first, to avoid unnecessary firing of events\n        // however we always fire 'finished' events. this is important\n        // when groups are resized, as if the group is changing slowly,\n        // eg 1 pixel at a time, then each change will fire change events\n        // in all the columns in the group, but only one with get the pixel.\n        var colsForEvent = allResizedCols.concat(flexedCols);\n        if (atLeastOneColChanged || finished) {\n            this.fireColumnResizedEvent(colsForEvent, finished, source, flexedCols);\n        }\n    };\n    ColumnModel.prototype.setColumnAggFunc = function (key, aggFunc, source) {\n        if (source === void 0) { source = \"api\"; }\n        if (!key) {\n            return;\n        }\n        var column = this.getPrimaryColumn(key);\n        if (!column) {\n            return;\n        }\n        column.setAggFunc(aggFunc);\n        this.fireColumnEvent(Events.EVENT_COLUMN_VALUE_CHANGED, [column], source);\n    };\n    ColumnModel.prototype.fireColumnEvent = function (type, columns, source) {\n        var event = {\n            type: type,\n            columns: columns,\n            column: (columns && columns.length == 1) ? columns[0] : null,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    ColumnModel.prototype.moveRowGroupColumn = function (fromIndex, toIndex, source) {\n        if (source === void 0) { source = \"api\"; }\n        var column = this.rowGroupColumns[fromIndex];\n        this.rowGroupColumns.splice(fromIndex, 1);\n        this.rowGroupColumns.splice(toIndex, 0, column);\n        var event = {\n            type: Events.EVENT_COLUMN_ROW_GROUP_CHANGED,\n            columns: this.rowGroupColumns,\n            column: this.rowGroupColumns.length === 1 ? this.rowGroupColumns[0] : null,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    ColumnModel.prototype.moveColumns = function (columnsToMoveKeys, toIndex, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.columnAnimationService.start();\n        if (toIndex > this.gridColumns.length - columnsToMoveKeys.length) {\n            console.warn('AG Grid: tried to insert columns in invalid location, toIndex = ' + toIndex);\n            console.warn('AG Grid: remember that you should not count the moving columns when calculating the new index');\n            return;\n        }\n        // we want to pull all the columns out first and put them into an ordered list\n        var columnsToMove = this.getGridColumns(columnsToMoveKeys);\n        var failedRules = !this.doesMovePassRules(columnsToMove, toIndex);\n        if (failedRules) {\n            return;\n        }\n        moveInArray(this.gridColumns, columnsToMove, toIndex);\n        this.updateDisplayedColumns(source);\n        var event = {\n            type: Events.EVENT_COLUMN_MOVED,\n            columns: columnsToMove,\n            column: columnsToMove.length === 1 ? columnsToMove[0] : null,\n            toIndex: toIndex,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n        this.eventService.dispatchEvent(event);\n        this.columnAnimationService.finish();\n    };\n    ColumnModel.prototype.doesMovePassRules = function (columnsToMove, toIndex) {\n        // make a copy of what the grid columns would look like after the move\n        var proposedColumnOrder = this.gridColumns.slice();\n        moveInArray(proposedColumnOrder, columnsToMove, toIndex);\n        // then check that the new proposed order of the columns passes all rules\n        if (!this.doesMovePassMarryChildren(proposedColumnOrder)) {\n            return false;\n        }\n        if (!this.doesMovePassLockedPositions(proposedColumnOrder)) {\n            return false;\n        }\n        return true;\n    };\n    // returns the provided cols sorted in same order as they appear in grid columns. eg if grid columns\n    // contains [a,b,c,d,e] and col passed is [e,a] then the passed cols are sorted into [a,e]\n    ColumnModel.prototype.sortColumnsLikeGridColumns = function (cols) {\n        var _this = this;\n        if (!cols || cols.length <= 1) {\n            return;\n        }\n        var notAllColsInGridColumns = cols.filter(function (c) { return _this.gridColumns.indexOf(c) < 0; }).length > 0;\n        if (notAllColsInGridColumns) {\n            return;\n        }\n        cols.sort(function (a, b) {\n            var indexA = _this.gridColumns.indexOf(a);\n            var indexB = _this.gridColumns.indexOf(b);\n            return indexA - indexB;\n        });\n    };\n    ColumnModel.prototype.doesMovePassLockedPositions = function (proposedColumnOrder) {\n        var foundNonLocked = false;\n        var rulePassed = true;\n        // go though the cols, see if any non-locked appear before any locked\n        proposedColumnOrder.forEach(function (col) {\n            if (col.getColDef().lockPosition) {\n                if (foundNonLocked) {\n                    rulePassed = false;\n                }\n            }\n            else {\n                foundNonLocked = true;\n            }\n        });\n        return rulePassed;\n    };\n    ColumnModel.prototype.doesMovePassMarryChildren = function (allColumnsCopy) {\n        var rulePassed = true;\n        this.columnUtils.depthFirstOriginalTreeSearch(null, this.gridBalancedTree, function (child) {\n            if (!(child instanceof ProvidedColumnGroup)) {\n                return;\n            }\n            var columnGroup = child;\n            var colGroupDef = columnGroup.getColGroupDef();\n            var marryChildren = colGroupDef && colGroupDef.marryChildren;\n            if (!marryChildren) {\n                return;\n            }\n            var newIndexes = [];\n            columnGroup.getLeafColumns().forEach(function (col) {\n                var newColIndex = allColumnsCopy.indexOf(col);\n                newIndexes.push(newColIndex);\n            });\n            var maxIndex = Math.max.apply(Math, newIndexes);\n            var minIndex = Math.min.apply(Math, newIndexes);\n            // spread is how far the first column in this group is away from the last column\n            var spread = maxIndex - minIndex;\n            var maxSpread = columnGroup.getLeafColumns().length - 1;\n            // if the columns\n            if (spread > maxSpread) {\n                rulePassed = false;\n            }\n            // console.log(`maxIndex = ${maxIndex}, minIndex = ${minIndex}, spread = ${spread}, maxSpread = ${maxSpread}, fail = ${spread > (count-1)}`)\n            // console.log(allColumnsCopy.map( col => col.getColDef().field).join(','));\n        });\n        return rulePassed;\n    };\n    ColumnModel.prototype.moveColumn = function (key, toIndex, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.moveColumns([key], toIndex, source);\n    };\n    ColumnModel.prototype.moveColumnByIndex = function (fromIndex, toIndex, source) {\n        if (source === void 0) { source = \"api\"; }\n        var column = this.gridColumns[fromIndex];\n        this.moveColumn(column, toIndex, source);\n    };\n    ColumnModel.prototype.getColumnDefs = function () {\n        var _this = this;\n        if (!this.primaryColumns) {\n            return;\n        }\n        var cols = this.primaryColumns.slice();\n        if (this.gridColsArePrimary) {\n            cols.sort(function (a, b) { return _this.gridColumns.indexOf(a) - _this.gridColumns.indexOf(b); });\n        }\n        else if (this.lastPrimaryOrder) {\n            cols.sort(function (a, b) { return _this.lastPrimaryOrder.indexOf(a) - _this.lastPrimaryOrder.indexOf(b); });\n        }\n        return this.columnDefFactory.buildColumnDefs(cols, this.rowGroupColumns, this.pivotColumns);\n    };\n    // used by:\n    // + angularGrid -> for setting body width\n    // + rowController -> setting main row widths (when inserting and resizing)\n    // need to cache this\n    ColumnModel.prototype.getBodyContainerWidth = function () {\n        return this.bodyWidth;\n    };\n    ColumnModel.prototype.getContainerWidth = function (pinned) {\n        switch (pinned) {\n            case Constants.PINNED_LEFT:\n                return this.leftWidth;\n            case Constants.PINNED_RIGHT:\n                return this.rightWidth;\n            default:\n                return this.bodyWidth;\n        }\n    };\n    // after setColumnWidth or updateGroupsAndDisplayedColumns\n    ColumnModel.prototype.updateBodyWidths = function () {\n        var newBodyWidth = this.getWidthOfColsInList(this.displayedColumnsCenter);\n        var newLeftWidth = this.getWidthOfColsInList(this.displayedColumnsLeft);\n        var newRightWidth = this.getWidthOfColsInList(this.displayedColumnsRight);\n        // this is used by virtual col calculation, for RTL only, as a change to body width can impact displayed\n        // columns, due to RTL inverting the y coordinates\n        this.bodyWidthDirty = this.bodyWidth !== newBodyWidth;\n        var atLeastOneChanged = this.bodyWidth !== newBodyWidth || this.leftWidth !== newLeftWidth || this.rightWidth !== newRightWidth;\n        if (atLeastOneChanged) {\n            this.bodyWidth = newBodyWidth;\n            this.leftWidth = newLeftWidth;\n            this.rightWidth = newRightWidth;\n            // when this fires, it is picked up by the gridPanel, which ends up in\n            // gridPanel calling setWidthAndScrollPosition(), which in turn calls setViewportPosition()\n            var event_3 = {\n                type: Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED,\n                api: this.gridApi,\n                columnApi: this.columnApi\n            };\n            this.eventService.dispatchEvent(event_3);\n        }\n    };\n    // + rowController\n    ColumnModel.prototype.getValueColumns = function () {\n        return this.valueColumns ? this.valueColumns : [];\n    };\n    // + rowController\n    ColumnModel.prototype.getPivotColumns = function () {\n        return this.pivotColumns ? this.pivotColumns : [];\n    };\n    // + clientSideRowModel\n    ColumnModel.prototype.isPivotActive = function () {\n        return this.pivotColumns && this.pivotColumns.length > 0 && this.pivotMode;\n    };\n    // + toolPanel\n    ColumnModel.prototype.getRowGroupColumns = function () {\n        return this.rowGroupColumns ? this.rowGroupColumns : [];\n    };\n    // + rowController -> while inserting rows\n    ColumnModel.prototype.getDisplayedCenterColumns = function () {\n        return this.displayedColumnsCenter;\n    };\n    // + rowController -> while inserting rows\n    ColumnModel.prototype.getDisplayedLeftColumns = function () {\n        return this.displayedColumnsLeft;\n    };\n    ColumnModel.prototype.getDisplayedRightColumns = function () {\n        return this.displayedColumnsRight;\n    };\n    ColumnModel.prototype.getDisplayedColumns = function (type) {\n        switch (type) {\n            case Constants.PINNED_LEFT:\n                return this.getDisplayedLeftColumns();\n            case Constants.PINNED_RIGHT:\n                return this.getDisplayedRightColumns();\n            default:\n                return this.getDisplayedCenterColumns();\n        }\n    };\n    // used by:\n    // + clientSideRowController -> sorting, building quick filter text\n    // + headerRenderer -> sorting (clearing icon)\n    ColumnModel.prototype.getAllPrimaryColumns = function () {\n        return this.primaryColumns ? this.primaryColumns.slice() : null;\n    };\n    ColumnModel.prototype.getSecondaryColumns = function () {\n        return this.secondaryColumns ? this.secondaryColumns.slice() : null;\n    };\n    ColumnModel.prototype.getAllColumnsForQuickFilter = function () {\n        return this.columnsForQuickFilter;\n    };\n    // + moveColumnController\n    ColumnModel.prototype.getAllGridColumns = function () {\n        return this.gridColumns;\n    };\n    ColumnModel.prototype.isEmpty = function () {\n        return missingOrEmpty(this.gridColumns);\n    };\n    ColumnModel.prototype.isRowGroupEmpty = function () {\n        return missingOrEmpty(this.rowGroupColumns);\n    };\n    ColumnModel.prototype.setColumnVisible = function (key, visible, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.setColumnsVisible([key], visible, source);\n    };\n    ColumnModel.prototype.setColumnsVisible = function (keys, visible, source) {\n        var _this = this;\n        if (visible === void 0) { visible = false; }\n        if (source === void 0) { source = \"api\"; }\n        this.columnAnimationService.start();\n        this.actionOnGridColumns(keys, function (column) {\n            if (column.isVisible() !== visible) {\n                column.setVisible(visible, source);\n                return true;\n            }\n            return false;\n        }, source, function () {\n            var event = {\n                type: Events.EVENT_COLUMN_VISIBLE,\n                visible: visible,\n                column: null,\n                columns: null,\n                api: _this.gridApi,\n                columnApi: _this.columnApi,\n                source: source\n            };\n            return event;\n        });\n        this.columnAnimationService.finish();\n    };\n    ColumnModel.prototype.setColumnPinned = function (key, pinned, source) {\n        if (source === void 0) { source = \"api\"; }\n        if (key) {\n            this.setColumnsPinned([key], pinned, source);\n        }\n    };\n    ColumnModel.prototype.setColumnsPinned = function (keys, pinned, source) {\n        var _this = this;\n        if (source === void 0) { source = \"api\"; }\n        if (this.gridOptionsWrapper.getDomLayout() === 'print') {\n            console.warn(\"Changing the column pinning status is not allowed with domLayout='print'\");\n            return;\n        }\n        this.columnAnimationService.start();\n        var actualPinned;\n        if (pinned === true || pinned === Constants.PINNED_LEFT) {\n            actualPinned = Constants.PINNED_LEFT;\n        }\n        else if (pinned === Constants.PINNED_RIGHT) {\n            actualPinned = Constants.PINNED_RIGHT;\n        }\n        else {\n            actualPinned = null;\n        }\n        this.actionOnGridColumns(keys, function (col) {\n            if (col.getPinned() !== actualPinned) {\n                col.setPinned(actualPinned);\n                return true;\n            }\n            return false;\n        }, source, function () {\n            var event = {\n                type: Events.EVENT_COLUMN_PINNED,\n                pinned: actualPinned,\n                column: null,\n                columns: null,\n                api: _this.gridApi,\n                columnApi: _this.columnApi,\n                source: source\n            };\n            return event;\n        });\n        this.columnAnimationService.finish();\n    };\n    // does an action on a set of columns. provides common functionality for looking up the\n    // columns based on key, getting a list of effected columns, and then updated the event\n    // with either one column (if it was just one col) or a list of columns\n    // used by: autoResize, setVisible, setPinned\n    ColumnModel.prototype.actionOnGridColumns = function (// the column keys this action will be on\n    keys, \n    // the action to do - if this returns false, the column was skipped\n    // and won't be included in the event\n    action, \n    // should return back a column event of the right type\n    source, createEvent) {\n        var _this = this;\n        if (missingOrEmpty(keys)) {\n            return;\n        }\n        var updatedColumns = [];\n        keys.forEach(function (key) {\n            var column = _this.getGridColumn(key);\n            if (!column) {\n                return;\n            }\n            // need to check for false with type (ie !== instead of !=)\n            // as not returning anything (undefined) would also be false\n            var resultOfAction = action(column);\n            if (resultOfAction !== false) {\n                updatedColumns.push(column);\n            }\n        });\n        if (!updatedColumns.length) {\n            return;\n        }\n        this.updateDisplayedColumns(source);\n        if (exists(createEvent) && createEvent) {\n            var event_4 = createEvent();\n            event_4.columns = updatedColumns;\n            event_4.column = updatedColumns.length === 1 ? updatedColumns[0] : null;\n            this.eventService.dispatchEvent(event_4);\n        }\n    };\n    ColumnModel.prototype.getDisplayedColBefore = function (col) {\n        var allDisplayedColumns = this.getAllDisplayedColumns();\n        var oldIndex = allDisplayedColumns.indexOf(col);\n        if (oldIndex > 0) {\n            return allDisplayedColumns[oldIndex - 1];\n        }\n        return null;\n    };\n    // used by:\n    // + rowRenderer -> for navigation\n    ColumnModel.prototype.getDisplayedColAfter = function (col) {\n        var allDisplayedColumns = this.getAllDisplayedColumns();\n        var oldIndex = allDisplayedColumns.indexOf(col);\n        if (oldIndex < (allDisplayedColumns.length - 1)) {\n            return allDisplayedColumns[oldIndex + 1];\n        }\n        return null;\n    };\n    ColumnModel.prototype.getDisplayedGroupAfter = function (columnGroup) {\n        return this.getDisplayedGroupAtDirection(columnGroup, 'After');\n    };\n    ColumnModel.prototype.getDisplayedGroupBefore = function (columnGroup) {\n        return this.getDisplayedGroupAtDirection(columnGroup, 'Before');\n    };\n    ColumnModel.prototype.getDisplayedGroupAtDirection = function (columnGroup, direction) {\n        // pick the last displayed column in this group\n        var requiredLevel = columnGroup.getOriginalColumnGroup().getLevel() + columnGroup.getPaddingLevel();\n        var colGroupLeafColumns = columnGroup.getDisplayedLeafColumns();\n        var col = direction === 'After' ? last(colGroupLeafColumns) : colGroupLeafColumns[0];\n        var getDisplayColMethod = \"getDisplayedCol\" + direction;\n        while (true) {\n            // keep moving to the next col, until we get to another group\n            var column = this[getDisplayColMethod](col);\n            if (!column) {\n                return null;\n            }\n            var groupPointer = this.getColumnGroupAtLevel(column, requiredLevel);\n            if (groupPointer !== columnGroup) {\n                return groupPointer;\n            }\n        }\n    };\n    ColumnModel.prototype.getColumnGroupAtLevel = function (column, level) {\n        // get group at same level as the one we are looking for\n        var groupPointer = column.getParent();\n        var originalGroupLevel;\n        var groupPointerLevel;\n        while (true) {\n            var groupPointerOriginalColumnGroup = groupPointer.getOriginalColumnGroup();\n            originalGroupLevel = groupPointerOriginalColumnGroup.getLevel();\n            groupPointerLevel = groupPointer.getPaddingLevel();\n            if (originalGroupLevel + groupPointerLevel <= level) {\n                break;\n            }\n            groupPointer = groupPointer.getParent();\n        }\n        return groupPointer;\n    };\n    ColumnModel.prototype.isPinningLeft = function () {\n        return this.displayedColumnsLeft.length > 0;\n    };\n    ColumnModel.prototype.isPinningRight = function () {\n        return this.displayedColumnsRight.length > 0;\n    };\n    ColumnModel.prototype.getPrimaryAndSecondaryAndAutoColumns = function () {\n        var result = this.primaryColumns ? this.primaryColumns.slice(0) : [];\n        if (this.groupAutoColumns && exists(this.groupAutoColumns)) {\n            this.groupAutoColumns.forEach(function (col) { return result.push(col); });\n        }\n        if (this.secondaryColumnsPresent && this.secondaryColumns) {\n            this.secondaryColumns.forEach(function (column) { return result.push(column); });\n        }\n        return result;\n    };\n    ColumnModel.prototype.createStateItemFromColumn = function (column) {\n        var rowGroupIndex = column.isRowGroupActive() ? this.rowGroupColumns.indexOf(column) : null;\n        var pivotIndex = column.isPivotActive() ? this.pivotColumns.indexOf(column) : null;\n        var aggFunc = column.isValueActive() ? column.getAggFunc() : null;\n        var sort = column.getSort() != null ? column.getSort() : null;\n        var sortIndex = column.getSortIndex() != null ? column.getSortIndex() : null;\n        var flex = column.getFlex() != null && column.getFlex() > 0 ? column.getFlex() : null;\n        var res = {\n            colId: column.getColId(),\n            width: column.getActualWidth(),\n            hide: !column.isVisible(),\n            pinned: column.getPinned(),\n            sort: sort,\n            sortIndex: sortIndex,\n            aggFunc: aggFunc,\n            rowGroup: column.isRowGroupActive(),\n            rowGroupIndex: rowGroupIndex,\n            pivot: column.isPivotActive(),\n            pivotIndex: pivotIndex,\n            flex: flex\n        };\n        return res;\n    };\n    ColumnModel.prototype.getColumnState = function () {\n        if (missing(this.primaryColumns) || !this.isAlive()) {\n            return [];\n        }\n        var colsForState = this.getPrimaryAndSecondaryAndAutoColumns();\n        var res = colsForState.map(this.createStateItemFromColumn.bind(this));\n        if (!this.pivotMode) {\n            this.orderColumnStateList(res);\n        }\n        return res;\n    };\n    ColumnModel.prototype.getPrimaryAndAutoGroupCols = function () {\n        if (!this.groupAutoColumns) {\n            return this.primaryColumns;\n        }\n        return __spreadArrays((this.primaryColumns || []), this.groupAutoColumns);\n    };\n    ColumnModel.prototype.orderColumnStateList = function (columnStateList) {\n        // for fast looking, store the index of each column\n        var gridColumnIdMap = convertToMap(this.gridColumns.map(function (col, index) { return [col.getColId(), index]; }));\n        columnStateList.sort(function (itemA, itemB) {\n            var posA = gridColumnIdMap.has(itemA.colId) ? gridColumnIdMap.get(itemA.colId) : -1;\n            var posB = gridColumnIdMap.has(itemB.colId) ? gridColumnIdMap.get(itemB.colId) : -1;\n            return posA - posB;\n        });\n    };\n    ColumnModel.prototype.resetColumnState = function (source) {\n        // NOTE = there is one bug here that no customer has noticed - if a column has colDef.lockPosition,\n        // this is ignored  below when ordering the cols. to work, we should always put lockPosition cols first.\n        // As a work around, developers should just put lockPosition columns first in their colDef list.\n        if (source === void 0) { source = \"api\"; }\n        // we can't use 'allColumns' as the order might of messed up, so get the primary ordered list\n        var primaryColumns = this.getColumnsFromTree(this.primaryColumnTree);\n        var columnStates = [];\n        // we start at 1000, so if user has mix of rowGroup and group specified, it will work with both.\n        // eg IF user has ColA.rowGroupIndex=0, ColB.rowGroupIndex=1, ColC.rowGroup=true,\n        // THEN result will be ColA.rowGroupIndex=0, ColB.rowGroupIndex=1, ColC.rowGroup=1000\n        var letRowGroupIndex = 1000;\n        var letPivotIndex = 1000;\n        var colsToProcess = [];\n        if (this.groupAutoColumns) {\n            colsToProcess = colsToProcess.concat(this.groupAutoColumns);\n        }\n        if (primaryColumns) {\n            colsToProcess = colsToProcess.concat(primaryColumns);\n        }\n        colsToProcess.forEach(function (column) {\n            var getValueOrNull = function (a, b) { return a != null ? a : b != null ? b : null; };\n            var colDef = column.getColDef();\n            var sort = getValueOrNull(colDef.sort, colDef.initialSort);\n            var sortIndex = getValueOrNull(colDef.sortIndex, colDef.initialSortIndex);\n            var hide = getValueOrNull(colDef.hide, colDef.initialHide);\n            var pinned = getValueOrNull(colDef.pinned, colDef.initialPinned);\n            var width = getValueOrNull(colDef.width, colDef.initialWidth);\n            var flex = getValueOrNull(colDef.flex, colDef.initialFlex);\n            var rowGroupIndex = getValueOrNull(colDef.rowGroupIndex, colDef.initialRowGroupIndex);\n            var rowGroup = getValueOrNull(colDef.rowGroup, colDef.initialRowGroup);\n            if (rowGroupIndex == null && (rowGroup == null || rowGroup == false)) {\n                rowGroupIndex = null;\n                rowGroup = null;\n            }\n            var pivotIndex = getValueOrNull(colDef.pivotIndex, colDef.initialPivotIndex);\n            var pivot = getValueOrNull(colDef.pivot, colDef.initialPivot);\n            if (pivotIndex == null && (pivot == null || pivot == false)) {\n                pivotIndex = null;\n                pivot = null;\n            }\n            var aggFunc = getValueOrNull(colDef.aggFunc, colDef.initialAggFunc);\n            var stateItem = {\n                colId: column.getColId(),\n                sort: sort,\n                sortIndex: sortIndex,\n                hide: hide,\n                pinned: pinned,\n                width: width,\n                flex: flex,\n                rowGroup: rowGroup,\n                rowGroupIndex: rowGroupIndex,\n                pivot: pivot,\n                pivotIndex: pivotIndex,\n                aggFunc: aggFunc,\n            };\n            if (missing(rowGroupIndex) && rowGroup) {\n                stateItem.rowGroupIndex = letRowGroupIndex++;\n            }\n            if (missing(pivotIndex) && pivot) {\n                stateItem.pivotIndex = letPivotIndex++;\n            }\n            columnStates.push(stateItem);\n        });\n        this.applyColumnState({ state: columnStates, applyOrder: true }, source);\n    };\n    ColumnModel.prototype.applyColumnState = function (params, source) {\n        var _this = this;\n        if (source === void 0) { source = \"api\"; }\n        if (missingOrEmpty(this.primaryColumns)) {\n            return false;\n        }\n        if (params && params.state && !params.state.forEach) {\n            console.warn('AG Grid: applyColumnState() - the state attribute should be an array, however an array was not found. Please provide an array of items (one for each col you want to change) for state.');\n            return false;\n        }\n        this.columnAnimationService.start();\n        var raiseEventsFunc = this.compareColumnStatesAndRaiseEvents(source);\n        this.autoGroupsNeedBuilding = true;\n        // at the end below, this list will have all columns we got no state for\n        var columnsWithNoState = this.primaryColumns.slice();\n        var success = true;\n        var rowGroupIndexes = {};\n        var pivotIndexes = {};\n        var autoGroupColumnStates = [];\n        var previousRowGroupCols = this.rowGroupColumns.slice();\n        var previousPivotCols = this.pivotColumns.slice();\n        if (params.state) {\n            params.state.forEach(function (state) {\n                var groupAutoColumnId = Constants.GROUP_AUTO_COLUMN_ID;\n                var colId = state.colId || '';\n                // auto group columns are re-created so deferring syncing with ColumnState\n                var isAutoGroupColumn = startsWith(colId, groupAutoColumnId);\n                if (isAutoGroupColumn) {\n                    autoGroupColumnStates.push(state);\n                    return;\n                }\n                var column = _this.getPrimaryColumn(colId);\n                if (!column) {\n                    // we don't log the failure, as it's possible the user is applying that has extra\n                    // cols in it. for example they could of save while row-grouping (so state includes\n                    // auto-group column) and then applied state when not grouping (so the auto-group\n                    // column would be in the state but no used).\n                    success = false;\n                }\n                else {\n                    _this.syncColumnWithStateItem(column, state, params.defaultState, rowGroupIndexes, pivotIndexes, false, source);\n                    removeFromArray(columnsWithNoState, column);\n                }\n            });\n        }\n        // anything left over, we got no data for, so add in the column as non-value, non-rowGroup and hidden\n        var applyDefaultsFunc = function (col) {\n            return _this.syncColumnWithStateItem(col, null, params.defaultState, rowGroupIndexes, pivotIndexes, false, source);\n        };\n        columnsWithNoState.forEach(applyDefaultsFunc);\n        // sort the lists according to the indexes that were provided\n        var comparator = function (indexes, oldList, colA, colB) {\n            var indexA = indexes[colA.getId()];\n            var indexB = indexes[colB.getId()];\n            var aHasIndex = indexA != null;\n            var bHasIndex = indexB != null;\n            if (aHasIndex && bHasIndex) {\n                // both a and b are new cols with index, so sort on index\n                return indexA - indexB;\n            }\n            if (aHasIndex) {\n                // a has an index, so it should be before a\n                return -1;\n            }\n            if (bHasIndex) {\n                // b has an index, so it should be before a\n                return 1;\n            }\n            var oldIndexA = oldList.indexOf(colA);\n            var oldIndexB = oldList.indexOf(colB);\n            var aHasOldIndex = oldIndexA >= 0;\n            var bHasOldIndex = oldIndexB >= 0;\n            if (aHasOldIndex && bHasOldIndex) {\n                // both a and b are old cols, so sort based on last order\n                return oldIndexA - oldIndexB;\n            }\n            if (aHasOldIndex) {\n                // a is old, b is new, so b is first\n                return -1;\n            }\n            // this bit does matter, means both are new cols\n            // but without index or that b is old and a is new\n            return 1;\n        };\n        this.rowGroupColumns.sort(comparator.bind(this, rowGroupIndexes, previousRowGroupCols));\n        this.pivotColumns.sort(comparator.bind(this, pivotIndexes, previousPivotCols));\n        this.updateGridColumns();\n        // sync newly created auto group columns with ColumnState\n        var autoGroupColsCopy = this.groupAutoColumns ? this.groupAutoColumns.slice() : [];\n        autoGroupColumnStates.forEach(function (stateItem) {\n            var autoCol = _this.getAutoColumn(stateItem.colId);\n            removeFromArray(autoGroupColsCopy, autoCol);\n            _this.syncColumnWithStateItem(autoCol, stateItem, params.defaultState, null, null, true, source);\n        });\n        // autogroup cols with nothing else, apply the default\n        autoGroupColsCopy.forEach(applyDefaultsFunc);\n        this.applyOrderAfterApplyState(params);\n        this.updateDisplayedColumns(source);\n        this.dispatchEverythingChanged(source);\n        raiseEventsFunc();\n        this.columnAnimationService.finish();\n        return success;\n    };\n    ColumnModel.prototype.applyOrderAfterApplyState = function (params) {\n        if (!this.gridColsArePrimary || !params.applyOrder || !params.state) {\n            return;\n        }\n        var newOrder = [];\n        var processedColIds = {};\n        var gridColumnsMap = {};\n        this.gridColumns.forEach(function (col) { return gridColumnsMap[col.getId()] = col; });\n        params.state.forEach(function (item) {\n            if (!item.colId || processedColIds[item.colId]) {\n                return;\n            }\n            var col = gridColumnsMap[item.colId];\n            if (col) {\n                newOrder.push(col);\n                processedColIds[item.colId] = true;\n            }\n        });\n        // add in all other columns\n        this.gridColumns.forEach(function (col) {\n            if (!processedColIds[col.getColId()]) {\n                newOrder.push(col);\n            }\n        });\n        // this is already done in updateGridColumns, however we changed the order above (to match the order of the state\n        // columns) so we need to do it again. we could of put logic into the order above to take into account fixed\n        // columns, however if we did then we would have logic for updating fixed columns twice. reusing the logic here\n        // is less sexy for the code here, but it keeps consistency.\n        newOrder = this.putFixedColumnsFirst(newOrder);\n        if (!this.doesMovePassMarryChildren(newOrder)) {\n            console.warn('AG Grid: Applying column order broke a group where columns should be married together. Applying new order has been discarded.');\n            return;\n        }\n        this.gridColumns = newOrder;\n    };\n    ColumnModel.prototype.compareColumnStatesAndRaiseEvents = function (source) {\n        var _this = this;\n        // if no columns to begin with, then it means we are setting columns for the first time, so\n        // there should be no events fired to show differences in columns.\n        var colsPreviouslyExisted = !!this.columnDefs;\n        if (!colsPreviouslyExisted) {\n            return function () { };\n        }\n        var startState = {\n            rowGroupColumns: this.rowGroupColumns.slice(),\n            pivotColumns: this.pivotColumns.slice(),\n            valueColumns: this.valueColumns.slice()\n        };\n        var columnStateBefore = this.getColumnState();\n        var columnStateBeforeMap = {};\n        columnStateBefore.forEach(function (col) {\n            columnStateBeforeMap[col.colId] = col;\n        });\n        return function () {\n            if (_this.gridOptionsWrapper.isSuppressColumnStateEvents()) {\n                return;\n            }\n            var colsForState = _this.getPrimaryAndAutoGroupCols();\n            // raises generic ColumnEvents where all columns are returned rather than what has changed\n            var raiseWhenListsDifferent = function (eventType, colsBefore, colsAfter, idMapper) {\n                var beforeList = colsBefore.map(idMapper);\n                var afterList = colsAfter.map(idMapper);\n                var unchanged = areEqual(beforeList, afterList);\n                if (unchanged) {\n                    return;\n                }\n                // returning all columns rather than what has changed!\n                var event = {\n                    type: eventType,\n                    columns: colsAfter,\n                    column: colsAfter.length === 1 ? colsAfter[0] : null,\n                    api: _this.gridApi,\n                    columnApi: _this.columnApi,\n                    source: source\n                };\n                _this.eventService.dispatchEvent(event);\n            };\n            // determines which columns have changed according to supplied predicate\n            var getChangedColumns = function (changedPredicate) {\n                var changedColumns = [];\n                (colsForState || []).forEach(function (column) {\n                    var colStateBefore = columnStateBeforeMap[column.getColId()];\n                    if (colStateBefore && changedPredicate(colStateBefore, column)) {\n                        changedColumns.push(column);\n                    }\n                });\n                return changedColumns;\n            };\n            var columnIdMapper = function (c) { return c.getColId(); };\n            raiseWhenListsDifferent(Events.EVENT_COLUMN_ROW_GROUP_CHANGED, startState.rowGroupColumns, _this.rowGroupColumns, columnIdMapper);\n            raiseWhenListsDifferent(Events.EVENT_COLUMN_PIVOT_CHANGED, startState.pivotColumns, _this.pivotColumns, columnIdMapper);\n            var valueChangePredicate = function (cs, c) {\n                var oldActive = cs.aggFunc != null;\n                var activeChanged = oldActive != c.isValueActive();\n                // we only check aggFunc if the agg is active\n                var aggFuncChanged = oldActive && cs.aggFunc != c.getAggFunc();\n                return activeChanged || aggFuncChanged;\n            };\n            var changedValues = getChangedColumns(valueChangePredicate);\n            if (changedValues.length > 0) {\n                // we pass all value columns, now the ones that changed. this is the same\n                // as pivot and rowGroup cols, but different to all other properties below.\n                // this is more for backwards compatibility, as it's always been this way.\n                // really it should be the other way, as the order of the cols makes no difference\n                // for valueColumns (apart from displaying them in the tool panel).\n                _this.fireColumnEvent(Events.EVENT_COLUMN_VALUE_CHANGED, _this.valueColumns, source);\n            }\n            var resizeChangePredicate = function (cs, c) { return cs.width != c.getActualWidth(); };\n            _this.fireColumnResizedEvent(getChangedColumns(resizeChangePredicate), true, source);\n            var pinnedChangePredicate = function (cs, c) { return cs.pinned != c.getPinned(); };\n            _this.raiseColumnPinnedEvent(getChangedColumns(pinnedChangePredicate), source);\n            var visibilityChangePredicate = function (cs, c) { return cs.hide == c.isVisible(); };\n            _this.raiseColumnVisibleEvent(getChangedColumns(visibilityChangePredicate), source);\n            var sortChangePredicate = function (cs, c) { return cs.sort != c.getSort() || cs.sortIndex != c.getSortIndex(); };\n            if (getChangedColumns(sortChangePredicate).length > 0) {\n                _this.sortController.dispatchSortChangedEvents();\n            }\n            // special handling for moved column events\n            _this.raiseColumnMovedEvent(columnStateBefore, source);\n        };\n    };\n    ColumnModel.prototype.raiseColumnPinnedEvent = function (changedColumns, source) {\n        if (!changedColumns.length) {\n            return;\n        }\n        // if just one column, we use this, otherwise we don't include the col\n        var column = changedColumns.length === 1 ? changedColumns[0] : null;\n        // only include visible if it's common in all columns\n        var pinned = this.getCommonValue(changedColumns, function (col) { return col.getPinned(); });\n        var event = {\n            type: Events.EVENT_COLUMN_PINNED,\n            // mistake in typing, 'undefined' should be allowed, as 'null' means 'not pinned'\n            pinned: pinned != null ? pinned : null,\n            columns: changedColumns,\n            column: column,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    ColumnModel.prototype.getCommonValue = function (cols, valueGetter) {\n        if (!cols || cols.length == 0) {\n            return undefined;\n        }\n        // compare each value to the first value. if nothing differs, then value is common so return it.\n        var firstValue = valueGetter(cols[0]);\n        for (var i = 1; i < cols.length; i++) {\n            if (firstValue !== valueGetter(cols[i])) {\n                // values differ, no common value\n                return undefined;\n            }\n        }\n        return firstValue;\n    };\n    ColumnModel.prototype.raiseColumnVisibleEvent = function (changedColumns, source) {\n        if (!changedColumns.length) {\n            return;\n        }\n        // if just one column, we use this, otherwise we don't include the col\n        var column = changedColumns.length === 1 ? changedColumns[0] : null;\n        // only include visible if it's common in all columns\n        var visible = this.getCommonValue(changedColumns, function (col) { return col.isVisible(); });\n        var event = {\n            type: Events.EVENT_COLUMN_VISIBLE,\n            visible: visible,\n            columns: changedColumns,\n            column: column,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    ColumnModel.prototype.raiseColumnMovedEvent = function (colStateBefore, source) {\n        // we are only interested in columns that were both present and visible before and after\n        var _this = this;\n        var colStateAfter = this.getColumnState();\n        var colStateAfterMapped = {};\n        colStateAfter.forEach(function (s) { return colStateAfterMapped[s.colId] = s; });\n        // get id's of cols in both before and after lists\n        var colsIntersectIds = {};\n        colStateBefore.forEach(function (s) {\n            if (colStateAfterMapped[s.colId]) {\n                colsIntersectIds[s.colId] = true;\n            }\n        });\n        // filter state lists, so we only have cols that were present before and after\n        var beforeFiltered = filter(colStateBefore, function (c) { return colsIntersectIds[c.colId]; });\n        var afterFiltered = filter(colStateAfter, function (c) { return colsIntersectIds[c.colId]; });\n        // see if any cols are in a different location\n        var movedColumns = [];\n        afterFiltered.forEach(function (csAfter, index) {\n            var csBefore = beforeFiltered && beforeFiltered[index];\n            if (csBefore && csBefore.colId !== csAfter.colId) {\n                var gridCol = _this.getGridColumn(csBefore.colId);\n                if (gridCol) {\n                    movedColumns.push(gridCol);\n                }\n            }\n        });\n        if (!movedColumns.length) {\n            return;\n        }\n        var event = {\n            type: Events.EVENT_COLUMN_MOVED,\n            columns: movedColumns,\n            column: null,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    ColumnModel.prototype.syncColumnWithStateItem = function (column, stateItem, defaultState, rowGroupIndexes, pivotIndexes, autoCol, source) {\n        if (!column) {\n            return;\n        }\n        var getValue = function (key1, key2) {\n            var stateAny = stateItem;\n            var defaultAny = defaultState;\n            var obj = { value1: undefined, value2: undefined };\n            var calculated = false;\n            if (stateAny) {\n                if (stateAny[key1] !== undefined) {\n                    obj.value1 = stateAny[key1];\n                    calculated = true;\n                }\n                if (exists(key2) && stateAny[key2] !== undefined) {\n                    obj.value2 = stateAny[key2];\n                    calculated = true;\n                }\n            }\n            if (!calculated && defaultAny) {\n                if (defaultAny[key1] !== undefined) {\n                    obj.value1 = defaultAny[key1];\n                }\n                if (exists(key2) && defaultAny[key2] !== undefined) {\n                    obj.value2 = defaultAny[key2];\n                }\n            }\n            return obj;\n        };\n        // following ensures we are left with boolean true or false, eg converts (null, undefined, 0) all to true\n        var hide = getValue('hide').value1;\n        if (hide !== undefined) {\n            column.setVisible(!hide, source);\n        }\n        // sets pinned to 'left' or 'right'\n        var pinned = getValue('pinned').value1;\n        if (pinned !== undefined) {\n            column.setPinned(pinned);\n        }\n        // if width provided and valid, use it, otherwise stick with the old width\n        var minColWidth = this.columnUtils.calculateColMinWidth(column.getColDef());\n        // flex\n        var flex = getValue('flex').value1;\n        if (flex !== undefined) {\n            column.setFlex(flex);\n        }\n        // width - we only set width if column is not flexing\n        var noFlexThisCol = column.getFlex() <= 0;\n        if (noFlexThisCol) {\n            // both null and undefined means we skip, as it's not possible to 'clear' width (a column must have a width)\n            var width = getValue('width').value1;\n            if (width != null) {\n                if (minColWidth != null && width >= minColWidth) {\n                    column.setActualWidth(width, source);\n                }\n            }\n        }\n        var sort = getValue('sort').value1;\n        if (sort !== undefined) {\n            if (sort === Constants.SORT_DESC || sort === Constants.SORT_ASC) {\n                column.setSort(sort);\n            }\n            else {\n                column.setSort(undefined);\n            }\n        }\n        var sortIndex = getValue('sortIndex').value1;\n        if (sortIndex !== undefined) {\n            column.setSortIndex(sortIndex);\n        }\n        // we do not do aggFunc, rowGroup or pivot for auto cols, as you can't do these with auto col\n        if (autoCol) {\n            return;\n        }\n        var aggFunc = getValue('aggFunc').value1;\n        if (aggFunc !== undefined) {\n            if (typeof aggFunc === 'string') {\n                column.setAggFunc(aggFunc);\n                if (!column.isValueActive()) {\n                    column.setValueActive(true, source);\n                    this.valueColumns.push(column);\n                }\n            }\n            else {\n                if (exists(aggFunc)) {\n                    console.warn('AG Grid: stateItem.aggFunc must be a string. if using your own aggregation ' +\n                        'functions, register the functions first before using them in get/set state. This is because it is ' +\n                        'intended for the column state to be stored and retrieved as simple JSON.');\n                }\n                // Note: we do not call column.setAggFunc(null), so that next time we aggregate\n                // by this column (eg drag teh column to the agg section int he toolpanel) it will\n                // default to the last aggregation function.\n                if (column.isValueActive()) {\n                    column.setValueActive(false, source);\n                    removeFromArray(this.valueColumns, column);\n                }\n            }\n        }\n        var _a = getValue('rowGroup', 'rowGroupIndex'), rowGroup = _a.value1, rowGroupIndex = _a.value2;\n        if (rowGroup !== undefined || rowGroupIndex !== undefined) {\n            if (typeof rowGroupIndex === 'number' || rowGroup) {\n                if (!column.isRowGroupActive()) {\n                    column.setRowGroupActive(true, source);\n                    this.rowGroupColumns.push(column);\n                }\n                if (rowGroupIndexes && typeof rowGroupIndex === 'number') {\n                    rowGroupIndexes[column.getId()] = rowGroupIndex;\n                }\n            }\n            else {\n                if (column.isRowGroupActive()) {\n                    column.setRowGroupActive(false, source);\n                    removeFromArray(this.rowGroupColumns, column);\n                }\n            }\n        }\n        var _b = getValue('pivot', 'pivotIndex'), pivot = _b.value1, pivotIndex = _b.value2;\n        if (pivot !== undefined || pivotIndex !== undefined) {\n            if (typeof pivotIndex === 'number' || pivot) {\n                if (!column.isPivotActive()) {\n                    column.setPivotActive(true, source);\n                    this.pivotColumns.push(column);\n                }\n                if (pivotIndexes && typeof pivotIndex === 'number') {\n                    pivotIndexes[column.getId()] = pivotIndex;\n                }\n            }\n            else {\n                if (column.isPivotActive()) {\n                    column.setPivotActive(false, source);\n                    removeFromArray(this.pivotColumns, column);\n                }\n            }\n        }\n    };\n    ColumnModel.prototype.getGridColumns = function (keys) {\n        return this.getColumns(keys, this.getGridColumn.bind(this));\n    };\n    ColumnModel.prototype.getColumns = function (keys, columnLookupCallback) {\n        var foundColumns = [];\n        if (keys) {\n            keys.forEach(function (key) {\n                var column = columnLookupCallback(key);\n                if (column) {\n                    foundColumns.push(column);\n                }\n            });\n        }\n        return foundColumns;\n    };\n    // used by growGroupPanel\n    ColumnModel.prototype.getColumnWithValidation = function (key) {\n        if (key == null) {\n            return null;\n        }\n        var column = this.getGridColumn(key);\n        if (!column) {\n            console.warn('AG Grid: could not find column ' + key);\n        }\n        return column;\n    };\n    ColumnModel.prototype.getPrimaryColumn = function (key) {\n        if (!this.primaryColumns) {\n            return null;\n        }\n        return this.getColumn(key, this.primaryColumns, this.primaryColumnsMap);\n    };\n    ColumnModel.prototype.getGridColumn = function (key) {\n        return this.getColumn(key, this.gridColumns, this.gridColumnsMap);\n    };\n    ColumnModel.prototype.getColumn = function (key, columnList, columnMap) {\n        if (!key) {\n            return null;\n        }\n        // most of the time this method gets called the key is a string, so we put this shortcut in\n        // for performance reasons, to see if we can match for ID (it doesn't do auto columns, that's done below)\n        if (typeof key == 'string' && columnMap[key]) {\n            return columnMap[key];\n        }\n        for (var i = 0; i < columnList.length; i++) {\n            if (this.columnsMatch(columnList[i], key)) {\n                return columnList[i];\n            }\n        }\n        return this.getAutoColumn(key);\n    };\n    ColumnModel.prototype.getAutoColumn = function (key) {\n        var _this = this;\n        if (!this.groupAutoColumns ||\n            !exists(this.groupAutoColumns) ||\n            missing(this.groupAutoColumns)) {\n            return null;\n        }\n        return find(this.groupAutoColumns, function (groupCol) { return _this.columnsMatch(groupCol, key); });\n    };\n    ColumnModel.prototype.columnsMatch = function (column, key) {\n        var columnMatches = column === key;\n        var colDefMatches = column.getColDef() === key;\n        var idMatches = column.getColId() == key;\n        return columnMatches || colDefMatches || idMatches;\n    };\n    ColumnModel.prototype.getDisplayNameForColumn = function (column, location, includeAggFunc) {\n        if (includeAggFunc === void 0) { includeAggFunc = false; }\n        if (!column) {\n            return null;\n        }\n        var headerName = this.getHeaderName(column.getColDef(), column, null, null, location);\n        if (includeAggFunc) {\n            return this.wrapHeaderNameWithAggFunc(column, headerName);\n        }\n        return headerName;\n    };\n    ColumnModel.prototype.getDisplayNameForOriginalColumnGroup = function (columnGroup, originalColumnGroup, location) {\n        var colGroupDef = originalColumnGroup ? originalColumnGroup.getColGroupDef() : null;\n        if (colGroupDef) {\n            return this.getHeaderName(colGroupDef, null, columnGroup, originalColumnGroup, location);\n        }\n        return null;\n    };\n    ColumnModel.prototype.getDisplayNameForColumnGroup = function (columnGroup, location) {\n        return this.getDisplayNameForOriginalColumnGroup(columnGroup, columnGroup.getOriginalColumnGroup(), location);\n    };\n    // location is where the column is going to appear, ie who is calling us\n    ColumnModel.prototype.getHeaderName = function (colDef, column, columnGroup, originalColumnGroup, location) {\n        var headerValueGetter = colDef.headerValueGetter;\n        if (headerValueGetter) {\n            var params = {\n                colDef: colDef,\n                column: column,\n                columnGroup: columnGroup,\n                originalColumnGroup: originalColumnGroup,\n                location: location,\n                api: this.gridOptionsWrapper.getApi(),\n                context: this.gridOptionsWrapper.getContext()\n            };\n            if (typeof headerValueGetter === 'function') {\n                // valueGetter is a function, so just call it\n                return headerValueGetter(params);\n            }\n            else if (typeof headerValueGetter === 'string') {\n                // valueGetter is an expression, so execute the expression\n                return this.expressionService.evaluate(headerValueGetter, params);\n            }\n            console.warn('ag-grid: headerValueGetter must be a function or a string');\n            return '';\n        }\n        else if (colDef.headerName != null) {\n            return colDef.headerName;\n        }\n        else if (colDef.field) {\n            return camelCaseToHumanText(colDef.field);\n        }\n        return '';\n    };\n    ColumnModel.prototype.wrapHeaderNameWithAggFunc = function (column, headerName) {\n        if (this.gridOptionsWrapper.isSuppressAggFuncInHeader()) {\n            return headerName;\n        }\n        // only columns with aggregation active can have aggregations\n        var pivotValueColumn = column.getColDef().pivotValueColumn;\n        var pivotActiveOnThisColumn = exists(pivotValueColumn);\n        var aggFunc = null;\n        var aggFuncFound;\n        // otherwise we have a measure that is active, and we are doing aggregation on it\n        if (pivotActiveOnThisColumn) {\n            aggFunc = pivotValueColumn ? pivotValueColumn.getAggFunc() : null;\n            aggFuncFound = true;\n        }\n        else {\n            var measureActive = column.isValueActive();\n            var aggregationPresent = this.pivotMode || !this.isRowGroupEmpty();\n            if (measureActive && aggregationPresent) {\n                aggFunc = column.getAggFunc();\n                aggFuncFound = true;\n            }\n            else {\n                aggFuncFound = false;\n            }\n        }\n        if (aggFuncFound) {\n            var aggFuncString = (typeof aggFunc === 'string') ? aggFunc : 'func';\n            var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();\n            var aggFuncStringTranslated = localeTextFunc(aggFuncString, aggFuncString);\n            return aggFuncStringTranslated + \"(\" + headerName + \")\";\n        }\n        return headerName;\n    };\n    // returns the group with matching colId and instanceId. If instanceId is missing,\n    // matches only on the colId.\n    ColumnModel.prototype.getColumnGroup = function (colId, instanceId) {\n        if (!colId) {\n            return null;\n        }\n        if (colId instanceof ColumnGroup) {\n            return colId;\n        }\n        var allColumnGroups = this.getAllDisplayedTrees();\n        var checkInstanceId = typeof instanceId === 'number';\n        var result = null;\n        this.columnUtils.depthFirstAllColumnTreeSearch(allColumnGroups, function (child) {\n            if (child instanceof ColumnGroup) {\n                var columnGroup = child;\n                var matched = void 0;\n                if (checkInstanceId) {\n                    matched = colId === columnGroup.getGroupId() && instanceId === columnGroup.getInstanceId();\n                }\n                else {\n                    matched = colId === columnGroup.getGroupId();\n                }\n                if (matched) {\n                    result = columnGroup;\n                }\n            }\n        });\n        return result;\n    };\n    ColumnModel.prototype.isReady = function () {\n        return this.ready;\n    };\n    ColumnModel.prototype.extractValueColumns = function (source, oldPrimaryColumns) {\n        this.valueColumns = this.extractColumns(oldPrimaryColumns, this.valueColumns, function (col, flag) { return col.setValueActive(flag, source); }, \n        // aggFunc doesn't have index variant, cos order of value cols doesn't matter, so always return null\n        function () { return undefined; }, function () { return undefined; }, \n        // aggFunc is a string, so return it's existence\n        function (colDef) {\n            var aggFunc = colDef.aggFunc;\n            // null or empty string means clear\n            if (aggFunc === null || aggFunc === '') {\n                return null;\n            }\n            if (aggFunc === undefined) {\n                return;\n            }\n            return !!aggFunc;\n        }, function (colDef) {\n            // return false if any of the following: null, undefined, empty string\n            return colDef.initialAggFunc != null && colDef.initialAggFunc != '';\n        });\n        // all new columns added will have aggFunc missing, so set it to what is in the colDef\n        this.valueColumns.forEach(function (col) {\n            var colDef = col.getColDef();\n            // if aggFunc provided, we always override, as reactive property\n            if (colDef.aggFunc != null && colDef.aggFunc != '') {\n                col.setAggFunc(colDef.aggFunc);\n            }\n            else {\n                // otherwise we use initialAggFunc only if no agg func set - which happens when new column only\n                if (!col.getAggFunc()) {\n                    col.setAggFunc(colDef.initialAggFunc);\n                }\n            }\n        });\n    };\n    ColumnModel.prototype.extractRowGroupColumns = function (source, oldPrimaryColumns) {\n        this.rowGroupColumns = this.extractColumns(oldPrimaryColumns, this.rowGroupColumns, function (col, flag) { return col.setRowGroupActive(flag, source); }, function (colDef) { return colDef.rowGroupIndex; }, function (colDef) { return colDef.initialRowGroupIndex; }, function (colDef) { return colDef.rowGroup; }, function (colDef) { return colDef.initialRowGroup; });\n    };\n    ColumnModel.prototype.extractColumns = function (oldPrimaryColumns, previousCols, setFlagFunc, getIndexFunc, getInitialIndexFunc, getValueFunc, getInitialValueFunc) {\n        if (oldPrimaryColumns === void 0) { oldPrimaryColumns = []; }\n        if (previousCols === void 0) { previousCols = []; }\n        var colsWithIndex = [];\n        var colsWithValue = [];\n        // go though all cols.\n        // if value, change\n        // if default only, change only if new\n        (this.primaryColumns || []).forEach(function (col) {\n            var colIsNew = oldPrimaryColumns.indexOf(col) < 0;\n            var colDef = col.getColDef();\n            var value = attrToBoolean(getValueFunc(colDef));\n            var initialValue = attrToBoolean(getInitialValueFunc(colDef));\n            var index = attrToNumber(getIndexFunc(colDef));\n            var initialIndex = attrToNumber(getInitialIndexFunc(colDef));\n            var include;\n            var valuePresent = value !== undefined;\n            var indexPresent = index !== undefined;\n            var initialValuePresent = initialValue !== undefined;\n            var initialIndexPresent = initialIndex !== undefined;\n            if (valuePresent) {\n                include = value; // boolean value is guaranteed as attrToBoolean() is used above\n            }\n            else if (indexPresent) {\n                if (index === null) {\n                    // if col is new we don't want to use the default / initial if index is set to null. Similarly,\n                    // we don't want to include the property for existing columns, i.e. we want to 'clear' it.\n                    include = false;\n                }\n                else {\n                    // note that 'null >= 0' evaluates to true which means 'rowGroupIndex = null' would enable row\n                    // grouping if the null check didn't exist above.\n                    include = index >= 0;\n                }\n            }\n            else {\n                if (colIsNew) {\n                    // as no value or index is 'present' we use the default / initial when col is new\n                    if (initialValuePresent) {\n                        include = initialValue;\n                    }\n                    else if (initialIndexPresent) {\n                        include = initialIndex != null && initialIndex >= 0;\n                    }\n                    else {\n                        include = false;\n                    }\n                }\n                else {\n                    // otherwise include it if included last time, e.g. if we are extracting row group cols and this col\n                    // is an existing row group col (i.e. it exists in 'previousCols') then we should include it.\n                    include = previousCols.indexOf(col) >= 0;\n                }\n            }\n            if (include) {\n                var useIndex = colIsNew ? (index != null || initialIndex != null) : index != null;\n                useIndex ? colsWithIndex.push(col) : colsWithValue.push(col);\n            }\n        });\n        var getIndexForCol = function (col) {\n            var index = getIndexFunc(col.getColDef());\n            var defaultIndex = getInitialIndexFunc(col.getColDef());\n            return index != null ? index : defaultIndex;\n        };\n        // sort cols with index, and add these first\n        colsWithIndex.sort(function (colA, colB) {\n            var indexA = getIndexForCol(colA);\n            var indexB = getIndexForCol(colB);\n            if (indexA === indexB) {\n                return 0;\n            }\n            if (indexA < indexB) {\n                return -1;\n            }\n            return 1;\n        });\n        var res = [].concat(colsWithIndex);\n        // second add columns that were there before and in the same order as they were before,\n        // so we are preserving order of current grouping of columns that simply have rowGroup=true\n        previousCols.forEach(function (col) {\n            if (colsWithValue.indexOf(col) >= 0) {\n                res.push(col);\n            }\n        });\n        // lastly put in all remaining cols\n        colsWithValue.forEach(function (col) {\n            if (res.indexOf(col) < 0) {\n                res.push(col);\n            }\n        });\n        // set flag=false for removed cols\n        previousCols.forEach(function (col) {\n            if (res.indexOf(col) < 0) {\n                setFlagFunc(col, false);\n            }\n        });\n        // set flag=true for newly added cols\n        res.forEach(function (col) {\n            if (previousCols.indexOf(col) < 0) {\n                setFlagFunc(col, true);\n            }\n        });\n        return res;\n    };\n    ColumnModel.prototype.extractPivotColumns = function (source, oldPrimaryColumns) {\n        this.pivotColumns = this.extractColumns(oldPrimaryColumns, this.pivotColumns, function (col, flag) { return col.setPivotActive(flag, source); }, function (colDef) { return colDef.pivotIndex; }, function (colDef) { return colDef.initialPivotIndex; }, function (colDef) { return colDef.pivot; }, function (colDef) { return colDef.initialPivot; });\n    };\n    ColumnModel.prototype.resetColumnGroupState = function (source) {\n        if (source === void 0) { source = \"api\"; }\n        var stateItems = [];\n        this.columnUtils.depthFirstOriginalTreeSearch(null, this.primaryColumnTree, function (child) {\n            if (child instanceof ProvidedColumnGroup) {\n                var colGroupDef = child.getColGroupDef();\n                var groupState = {\n                    groupId: child.getGroupId(),\n                    open: !colGroupDef ? undefined : colGroupDef.openByDefault\n                };\n                stateItems.push(groupState);\n            }\n        });\n        this.setColumnGroupState(stateItems, source);\n    };\n    ColumnModel.prototype.getColumnGroupState = function () {\n        var columnGroupState = [];\n        this.columnUtils.depthFirstOriginalTreeSearch(null, this.gridBalancedTree, function (node) {\n            if (node instanceof ProvidedColumnGroup) {\n                var originalColumnGroup = node;\n                columnGroupState.push({\n                    groupId: originalColumnGroup.getGroupId(),\n                    open: originalColumnGroup.isExpanded()\n                });\n            }\n        });\n        return columnGroupState;\n    };\n    ColumnModel.prototype.setColumnGroupState = function (stateItems, source) {\n        var _this = this;\n        if (source === void 0) { source = \"api\"; }\n        this.columnAnimationService.start();\n        var impactedGroups = [];\n        stateItems.forEach(function (stateItem) {\n            var groupKey = stateItem.groupId;\n            var newValue = stateItem.open;\n            var originalColumnGroup = _this.getOriginalColumnGroup(groupKey);\n            if (!originalColumnGroup) {\n                return;\n            }\n            if (originalColumnGroup.isExpanded() === newValue) {\n                return;\n            }\n            _this.logger.log('columnGroupOpened(' + originalColumnGroup.getGroupId() + ',' + newValue + ')');\n            originalColumnGroup.setExpanded(newValue);\n            impactedGroups.push(originalColumnGroup);\n        });\n        this.updateGroupsAndDisplayedColumns(source);\n        this.setFirstRightAndLastLeftPinned(source);\n        impactedGroups.forEach(function (originalColumnGroup) {\n            var event = {\n                type: Events.EVENT_COLUMN_GROUP_OPENED,\n                columnGroup: originalColumnGroup,\n                api: _this.gridApi,\n                columnApi: _this.columnApi\n            };\n            _this.eventService.dispatchEvent(event);\n        });\n        this.columnAnimationService.finish();\n    };\n    // called by headerRenderer - when a header is opened or closed\n    ColumnModel.prototype.setColumnGroupOpened = function (key, newValue, source) {\n        if (source === void 0) { source = \"api\"; }\n        var keyAsString;\n        if (key instanceof ProvidedColumnGroup) {\n            keyAsString = key.getId();\n        }\n        else {\n            keyAsString = key || '';\n        }\n        this.setColumnGroupState([{ groupId: keyAsString, open: newValue }], source);\n    };\n    ColumnModel.prototype.getOriginalColumnGroup = function (key) {\n        if (key instanceof ProvidedColumnGroup) {\n            return key;\n        }\n        if (typeof key !== 'string') {\n            console.error('AG Grid: group key must be a string');\n        }\n        // otherwise, search for the column group by id\n        var res = null;\n        this.columnUtils.depthFirstOriginalTreeSearch(null, this.gridBalancedTree, function (node) {\n            if (node instanceof ProvidedColumnGroup) {\n                var originalColumnGroup = node;\n                if (originalColumnGroup.getId() === key) {\n                    res = originalColumnGroup;\n                }\n            }\n        });\n        return res;\n    };\n    ColumnModel.prototype.calculateColumnsForDisplay = function () {\n        var _this = this;\n        var columnsForDisplay;\n        if (this.pivotMode && !this.secondaryColumnsPresent) {\n            // pivot mode is on, but we are not pivoting, so we only\n            // show columns we are aggregating on\n            columnsForDisplay = this.gridColumns.filter(function (column) {\n                var isAutoGroupCol = _this.groupAutoColumns && includes(_this.groupAutoColumns, column);\n                var isValueCol = _this.valueColumns && includes(_this.valueColumns, column);\n                return isAutoGroupCol || isValueCol;\n            });\n        }\n        else {\n            // otherwise continue as normal. this can be working on the primary\n            // or secondary columns, whatever the gridColumns are set to\n            columnsForDisplay = this.gridColumns.filter(function (column) {\n                // keep col if a) it's auto-group or b) it's visible\n                var isAutoGroupCol = _this.groupAutoColumns && includes(_this.groupAutoColumns, column);\n                return isAutoGroupCol || column.isVisible();\n            });\n        }\n        return columnsForDisplay;\n    };\n    ColumnModel.prototype.checkColSpanActiveInCols = function (columns) {\n        var result = false;\n        columns.forEach(function (col) {\n            if (exists(col.getColDef().colSpan)) {\n                result = true;\n            }\n        });\n        return result;\n    };\n    ColumnModel.prototype.calculateColumnsForGroupDisplay = function () {\n        var _this = this;\n        this.groupDisplayColumns = [];\n        var checkFunc = function (col) {\n            var colDef = col.getColDef();\n            if (colDef && exists(colDef.showRowGroup)) {\n                _this.groupDisplayColumns.push(col);\n            }\n        };\n        this.gridColumns.forEach(checkFunc);\n        if (this.groupAutoColumns) {\n            this.groupAutoColumns.forEach(checkFunc);\n        }\n    };\n    ColumnModel.prototype.getGroupDisplayColumns = function () {\n        return this.groupDisplayColumns;\n    };\n    ColumnModel.prototype.updateDisplayedColumns = function (source) {\n        var columnsForDisplay = this.calculateColumnsForDisplay();\n        this.buildDisplayedTrees(columnsForDisplay);\n        this.calculateColumnsForGroupDisplay();\n        // also called when group opened/closed\n        this.updateGroupsAndDisplayedColumns(source);\n        // also called when group opened/closed\n        this.setFirstRightAndLastLeftPinned(source);\n    };\n    ColumnModel.prototype.isSecondaryColumnsPresent = function () {\n        return this.secondaryColumnsPresent;\n    };\n    ColumnModel.prototype.setSecondaryColumns = function (colDefs, source) {\n        if (source === void 0) { source = \"api\"; }\n        var newColsPresent = colDefs && colDefs.length > 0;\n        // if not cols passed, and we had to cols anyway, then do nothing\n        if (!newColsPresent && !this.secondaryColumnsPresent) {\n            return;\n        }\n        if (newColsPresent) {\n            this.processSecondaryColumnDefinitions(colDefs);\n            var balancedTreeResult = this.columnFactory.createColumnTree(colDefs, false);\n            this.secondaryBalancedTree = balancedTreeResult.columnTree;\n            this.secondaryHeaderRowCount = balancedTreeResult.treeDept + 1;\n            this.secondaryColumns = this.getColumnsFromTree(this.secondaryBalancedTree);\n            this.secondaryColumnsPresent = true;\n        }\n        else {\n            this.secondaryBalancedTree = null;\n            this.secondaryHeaderRowCount = -1;\n            this.secondaryColumns = null;\n            this.secondaryColumnsPresent = false;\n        }\n        this.updateGridColumns();\n        this.updateDisplayedColumns(source);\n    };\n    ColumnModel.prototype.processSecondaryColumnDefinitions = function (colDefs) {\n        var columnCallback = this.gridOptionsWrapper.getProcessSecondaryColDefFunc();\n        var groupCallback = this.gridOptionsWrapper.getProcessSecondaryColGroupDefFunc();\n        if (!columnCallback && !groupCallback) {\n            return undefined;\n        }\n        var searchForColDefs = function (colDefs2) {\n            colDefs2.forEach(function (abstractColDef) {\n                var isGroup = exists(abstractColDef.children);\n                if (isGroup) {\n                    var colGroupDef = abstractColDef;\n                    if (groupCallback) {\n                        groupCallback(colGroupDef);\n                    }\n                    searchForColDefs(colGroupDef.children);\n                }\n                else {\n                    var colDef = abstractColDef;\n                    if (columnCallback) {\n                        columnCallback(colDef);\n                    }\n                }\n            });\n        };\n        if (colDefs) {\n            searchForColDefs(colDefs);\n        }\n    };\n    // called from: setColumnState, setColumnDefs, setSecondaryColumns\n    ColumnModel.prototype.updateGridColumns = function () {\n        var _this = this;\n        if (this.gridColsArePrimary) {\n            this.lastPrimaryOrder = this.gridColumns;\n        }\n        if (this.secondaryColumns && this.secondaryBalancedTree) {\n            this.gridBalancedTree = this.secondaryBalancedTree.slice();\n            this.gridHeaderRowCount = this.secondaryHeaderRowCount;\n            this.gridColumns = this.secondaryColumns.slice();\n            this.gridColsArePrimary = false;\n        }\n        else if (this.primaryColumns) {\n            this.gridBalancedTree = this.primaryColumnTree.slice();\n            this.gridHeaderRowCount = this.primaryHeaderRowCount;\n            this.gridColumns = this.primaryColumns.slice();\n            this.gridColsArePrimary = true;\n            // updateGridColumns gets called after user adds a row group. we want to maintain the order of the columns\n            // when this happens (eg if user moved a column) rather than revert back to the original column order.\n            // likewise if changing in/out of pivot mode, we want to maintain the order of the primary cols\n            this.orderGridColsLikeLastPrimary();\n        }\n        this.addAutoGroupToGridColumns();\n        this.gridColumns = this.putFixedColumnsFirst(this.gridColumns);\n        this.setupQuickFilterColumns();\n        this.clearDisplayedAndViewportColumns();\n        this.colSpanActive = this.checkColSpanActiveInCols(this.gridColumns);\n        this.gridColumnsMap = {};\n        this.gridColumns.forEach(function (col) { return _this.gridColumnsMap[col.getId()] = col; });\n        this.setAutoHeightActive();\n        var event = {\n            type: Events.EVENT_GRID_COLUMNS_CHANGED,\n            api: this.gridApi,\n            columnApi: this.columnApi\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    ColumnModel.prototype.setAutoHeightActive = function () {\n        this.autoHeightActive = this.gridColumns.filter(function (col) { return col.getColDef().autoHeight; }).length > 0;\n        if (this.autoHeightActive) {\n            this.autoHeightActiveAtLeastOnce = true;\n            var rowModelType = this.rowModel.getType();\n            var supportedRowModel = rowModelType === Constants.ROW_MODEL_TYPE_CLIENT_SIDE || rowModelType === Constants.ROW_MODEL_TYPE_SERVER_SIDE;\n            if (!supportedRowModel) {\n                var message_1 = 'AG Grid - autoHeight columns only work with Client Side Row Model and Server Side Row Model.';\n                doOnce(function () { return console.warn(message_1); }, 'autoHeightActive.wrongRowModel');\n            }\n        }\n    };\n    ColumnModel.prototype.orderGridColsLikeLastPrimary = function () {\n        if (missing(this.lastPrimaryOrder)) {\n            return;\n        }\n        var lastPrimaryOrderMapped = convertToMap(this.lastPrimaryOrder.map(function (col, index) { return [col, index]; }));\n        // only do the sort if at least one column is accounted for. columns will be not accounted for\n        // if changing from secondary to primary columns\n        var noColsFound = true;\n        this.gridColumns.forEach(function (col) {\n            if (lastPrimaryOrderMapped.has(col)) {\n                noColsFound = false;\n            }\n        });\n        if (noColsFound) {\n            return;\n        }\n        // order cols in the same order as before. we need to make sure that all\n        // cols still exists, so filter out any that no longer exist.\n        var gridColsMap = convertToMap(this.gridColumns.map(function (col) { return [col, true]; }));\n        var oldColsOrdered = this.lastPrimaryOrder.filter(function (col) { return gridColsMap.has(col); });\n        var oldColsMap = convertToMap(oldColsOrdered.map(function (col) { return [col, true]; }));\n        var newColsOrdered = this.gridColumns.filter(function (col) { return !oldColsMap.has(col); });\n        // add in the new columns, at the end (if no group), or at the end of the group (if a group)\n        var newGridColumns = oldColsOrdered.slice();\n        newColsOrdered.forEach(function (newCol) {\n            var parent = newCol.getOriginalParent();\n            // if no parent, means we are not grouping, so just add the column to the end\n            if (!parent) {\n                newGridColumns.push(newCol);\n                return;\n            }\n            // find the group the column belongs to. if no siblings at the current level (eg col in group on it's\n            // own) then go up one level and look for siblings there.\n            var siblings = [];\n            while (!siblings.length && parent) {\n                var leafCols = parent.getLeafColumns();\n                leafCols.forEach(function (leafCol) {\n                    var presentInNewGriColumns = newGridColumns.indexOf(leafCol) >= 0;\n                    var noYetInSiblings = siblings.indexOf(leafCol) < 0;\n                    if (presentInNewGriColumns && noYetInSiblings) {\n                        siblings.push(leafCol);\n                    }\n                });\n                parent = parent.getOriginalParent();\n            }\n            // if no siblings exist at any level, this means the col is in a group (or parent groups) on it's own\n            if (!siblings.length) {\n                newGridColumns.push(newCol);\n                return;\n            }\n            // find index of last column in the group\n            var indexes = siblings.map(function (col) { return newGridColumns.indexOf(col); });\n            var lastIndex = Math.max.apply(Math, indexes);\n            insertIntoArray(newGridColumns, newCol, lastIndex + 1);\n        });\n        this.gridColumns = newGridColumns;\n    };\n    ColumnModel.prototype.isPrimaryColumnGroupsPresent = function () {\n        return this.primaryHeaderRowCount > 1;\n    };\n    // if we are using autoGroupCols, then they should be included for quick filter. this covers the\n    // following scenarios:\n    // a) user provides 'field' into autoGroupCol of normal grid, so now because a valid col to filter leafs on\n    // b) using tree data and user depends on autoGroupCol for first col, and we also want to filter on this\n    //    (tree data is a bit different, as parent rows can be filtered on, unlike row grouping)\n    ColumnModel.prototype.setupQuickFilterColumns = function () {\n        if (this.groupAutoColumns) {\n            this.columnsForQuickFilter = (this.primaryColumns || []).concat(this.groupAutoColumns);\n        }\n        else if (this.primaryColumns) {\n            this.columnsForQuickFilter = this.primaryColumns;\n        }\n    };\n    ColumnModel.prototype.putFixedColumnsFirst = function (cols) {\n        var locked = cols.filter(function (c) { return c.getColDef().lockPosition; });\n        var unlocked = cols.filter(function (c) { return !c.getColDef().lockPosition; });\n        return locked.concat(unlocked);\n    };\n    ColumnModel.prototype.addAutoGroupToGridColumns = function () {\n        // add in auto-group here\n        this.createGroupAutoColumnsIfNeeded();\n        if (missing(this.groupAutoColumns)) {\n            return;\n        }\n        this.gridColumns = this.groupAutoColumns ? this.groupAutoColumns.concat(this.gridColumns) : this.gridColumns;\n        var autoColBalancedTree = this.columnFactory.createForAutoGroups(this.groupAutoColumns, this.gridBalancedTree);\n        this.gridBalancedTree = autoColBalancedTree.concat(this.gridBalancedTree);\n    };\n    // gets called after we copy down grid columns, to make sure any part of the gui\n    // that tries to draw, eg the header, it will get empty lists of columns rather\n    // than stale columns. for example, the header will received gridColumnsChanged\n    // event, so will try and draw, but it will draw successfully when it acts on the\n    // virtualColumnsChanged event\n    ColumnModel.prototype.clearDisplayedAndViewportColumns = function () {\n        this.displayedTreeLeft = [];\n        this.displayedTreeRight = [];\n        this.displayedTreeCentre = [];\n        this.viewportRowLeft = {};\n        this.viewportRowRight = {};\n        this.viewportRowCenter = {};\n        this.displayedColumnsLeft = [];\n        this.displayedColumnsRight = [];\n        this.displayedColumnsCenter = [];\n        this.displayedColumns = [];\n        this.viewportColumns = [];\n    };\n    ColumnModel.prototype.updateGroupsAndDisplayedColumns = function (source) {\n        this.updateOpenClosedVisibilityInColumnGroups();\n        this.deriveDisplayedColumns(source);\n        this.refreshFlexedColumns();\n        this.extractViewport();\n        this.updateBodyWidths();\n        // this event is picked up by the gui, headerRenderer and rowRenderer, to recalculate what columns to display\n        var event = {\n            type: Events.EVENT_DISPLAYED_COLUMNS_CHANGED,\n            api: this.gridApi,\n            columnApi: this.columnApi\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    ColumnModel.prototype.deriveDisplayedColumns = function (source) {\n        this.derivedDisplayedColumnsFromDisplayedTree(this.displayedTreeLeft, this.displayedColumnsLeft);\n        this.derivedDisplayedColumnsFromDisplayedTree(this.displayedTreeCentre, this.displayedColumnsCenter);\n        this.derivedDisplayedColumnsFromDisplayedTree(this.displayedTreeRight, this.displayedColumnsRight);\n        this.joinDisplayedColumns();\n        this.setLeftValues(source);\n        this.displayedAutoHeightCols = this.displayedColumns.filter(function (col) { return col.getColDef().autoHeight; });\n    };\n    ColumnModel.prototype.isAutoRowHeightActive = function () {\n        return this.autoHeightActive;\n    };\n    ColumnModel.prototype.wasAutoRowHeightEverActive = function () {\n        return this.autoHeightActiveAtLeastOnce;\n    };\n    ColumnModel.prototype.joinDisplayedColumns = function () {\n        if (this.gridOptionsWrapper.isEnableRtl()) {\n            this.displayedColumns = this.displayedColumnsRight\n                .concat(this.displayedColumnsCenter)\n                .concat(this.displayedColumnsLeft);\n        }\n        else {\n            this.displayedColumns = this.displayedColumnsLeft\n                .concat(this.displayedColumnsCenter)\n                .concat(this.displayedColumnsRight);\n        }\n    };\n    // sets the left pixel position of each column\n    ColumnModel.prototype.setLeftValues = function (source) {\n        this.setLeftValuesOfColumns(source);\n        this.setLeftValuesOfGroups();\n    };\n    ColumnModel.prototype.setLeftValuesOfColumns = function (source) {\n        var _this = this;\n        if (!this.primaryColumns) {\n            return;\n        }\n        // go through each list of displayed columns\n        var allColumns = this.primaryColumns.slice(0);\n        // let totalColumnWidth = this.getWidthOfColsInList()\n        var doingRtl = this.gridOptionsWrapper.isEnableRtl();\n        [\n            this.displayedColumnsLeft,\n            this.displayedColumnsRight,\n            this.displayedColumnsCenter\n        ].forEach(function (columns) {\n            if (doingRtl) {\n                // when doing RTL, we start at the top most pixel (ie RHS) and work backwards\n                var left_1 = _this.getWidthOfColsInList(columns);\n                columns.forEach(function (column) {\n                    left_1 -= column.getActualWidth();\n                    column.setLeft(left_1, source);\n                });\n            }\n            else {\n                // otherwise normal LTR, we start at zero\n                var left_2 = 0;\n                columns.forEach(function (column) {\n                    column.setLeft(left_2, source);\n                    left_2 += column.getActualWidth();\n                });\n            }\n            removeAllFromArray(allColumns, columns);\n        });\n        // items left in allColumns are columns not displayed, so remove the left position. this is\n        // important for the rows, as if a col is made visible, then taken out, then made visible again,\n        // we don't want the animation of the cell floating in from the old position, whatever that was.\n        allColumns.forEach(function (column) {\n            column.setLeft(null, source);\n        });\n    };\n    ColumnModel.prototype.setLeftValuesOfGroups = function () {\n        // a groups left value is the lest left value of it's children\n        [\n            this.displayedTreeLeft,\n            this.displayedTreeRight,\n            this.displayedTreeCentre\n        ].forEach(function (columns) {\n            columns.forEach(function (column) {\n                if (column instanceof ColumnGroup) {\n                    var columnGroup = column;\n                    columnGroup.checkLeft();\n                }\n            });\n        });\n    };\n    ColumnModel.prototype.derivedDisplayedColumnsFromDisplayedTree = function (tree, columns) {\n        columns.length = 0;\n        this.columnUtils.depthFirstDisplayedColumnTreeSearch(tree, function (child) {\n            if (child instanceof Column) {\n                columns.push(child);\n            }\n        });\n    };\n    ColumnModel.prototype.extractViewportColumns = function () {\n        if (this.suppressColumnVirtualisation) {\n            // no virtualisation, so don't filter\n            this.viewportColumnsCenter = this.displayedColumnsCenter;\n        }\n        else {\n            // filter out what should be visible\n            this.viewportColumnsCenter = this.filterOutColumnsWithinViewport();\n        }\n        this.viewportColumns = this.viewportColumnsCenter\n            .concat(this.displayedColumnsLeft)\n            .concat(this.displayedColumnsRight);\n    };\n    ColumnModel.prototype.getVirtualHeaderGroupRow = function (type, dept) {\n        var result;\n        switch (type) {\n            case Constants.PINNED_LEFT:\n                result = this.viewportRowLeft[dept];\n                break;\n            case Constants.PINNED_RIGHT:\n                result = this.viewportRowRight[dept];\n                break;\n            default:\n                result = this.viewportRowCenter[dept];\n                break;\n        }\n        if (missing(result)) {\n            result = [];\n        }\n        return result;\n    };\n    ColumnModel.prototype.extractViewportRows = function () {\n        // go through each group, see if any of it's cols are displayed, and if yes,\n        // then this group is included\n        this.viewportRowLeft = {};\n        this.viewportRowRight = {};\n        this.viewportRowCenter = {};\n        // for easy lookup when building the groups.\n        var virtualColIds = {};\n        this.viewportColumns.forEach(function (col) { return virtualColIds[col.getId()] = true; });\n        var testGroup = function (children, result, dept) {\n            var returnValue = false;\n            for (var i = 0; i < children.length; i++) {\n                // see if this item is within viewport\n                var child = children[i];\n                var addThisItem = false;\n                if (child instanceof Column) {\n                    // for column, test if column is included\n                    addThisItem = virtualColIds[child.getId()] === true;\n                }\n                else {\n                    // if group, base decision on children\n                    var columnGroup = child;\n                    var displayedChildren = columnGroup.getDisplayedChildren();\n                    if (displayedChildren) {\n                        addThisItem = testGroup(displayedChildren, result, dept + 1);\n                    }\n                }\n                if (addThisItem) {\n                    returnValue = true;\n                    if (!result[dept]) {\n                        result[dept] = [];\n                    }\n                    result[dept].push(child);\n                }\n            }\n            return returnValue;\n        };\n        testGroup(this.displayedTreeLeft, this.viewportRowLeft, 0);\n        testGroup(this.displayedTreeRight, this.viewportRowRight, 0);\n        testGroup(this.displayedTreeCentre, this.viewportRowCenter, 0);\n    };\n    ColumnModel.prototype.extractViewport = function () {\n        this.extractViewportColumns();\n        this.extractViewportRows();\n    };\n    ColumnModel.prototype.filterOutColumnsWithinViewport = function () {\n        return this.displayedColumnsCenter.filter(this.isColumnInViewport.bind(this));\n    };\n    ColumnModel.prototype.refreshFlexedColumns = function (params) {\n        var _this = this;\n        if (params === void 0) { params = {}; }\n        var source = params.source ? params.source : 'flex';\n        if (params.viewportWidth != null) {\n            this.flexViewportWidth = params.viewportWidth;\n        }\n        if (!this.flexViewportWidth) {\n            return [];\n        }\n        // If the grid has left-over space, divide it between flexing columns in proportion to their flex value.\n        // A \"flexing column\" is one that has a 'flex' value set and is not currently being constrained by its\n        // minWidth or maxWidth rules.\n        var flexAfterDisplayIndex = -1;\n        if (params.resizingCols) {\n            params.resizingCols.forEach(function (col) {\n                var indexOfCol = _this.displayedColumnsCenter.indexOf(col);\n                if (flexAfterDisplayIndex < indexOfCol) {\n                    flexAfterDisplayIndex = indexOfCol;\n                }\n            });\n        }\n        var isColFlex = function (col) {\n            var afterResizingCols = _this.displayedColumnsCenter.indexOf(col) > flexAfterDisplayIndex;\n            return col.getFlex() && afterResizingCols;\n        };\n        var knownWidthColumns = this.displayedColumnsCenter.filter(function (col) { return !isColFlex(col); });\n        var flexingColumns = this.displayedColumnsCenter.filter(function (col) { return isColFlex(col); });\n        var changedColumns = [];\n        if (!flexingColumns.length) {\n            return [];\n        }\n        var flexingColumnSizes = [];\n        var spaceForFlexingColumns;\n        outer: while (true) {\n            var totalFlex = flexingColumns.reduce(function (count, col) { return count + col.getFlex(); }, 0);\n            spaceForFlexingColumns = this.flexViewportWidth - this.getWidthOfColsInList(knownWidthColumns);\n            for (var i = 0; i < flexingColumns.length; i++) {\n                var col = flexingColumns[i];\n                var widthByFlexRule = spaceForFlexingColumns * col.getFlex() / totalFlex;\n                var constrainedWidth = 0;\n                var minWidth = col.getMinWidth();\n                var maxWidth = col.getMaxWidth();\n                if (exists(minWidth) && widthByFlexRule < minWidth) {\n                    constrainedWidth = minWidth;\n                }\n                else if (exists(maxWidth) && widthByFlexRule > maxWidth) {\n                    constrainedWidth = maxWidth;\n                }\n                if (constrainedWidth) {\n                    // This column is not in fact flexing as it is being constrained to a specific size\n                    // so remove it from the list of flexing columns and start again\n                    col.setActualWidth(constrainedWidth, source);\n                    removeFromArray(flexingColumns, col);\n                    changedColumns.push(col);\n                    knownWidthColumns.push(col);\n                    continue outer;\n                }\n                flexingColumnSizes[i] = Math.round(widthByFlexRule);\n            }\n            break;\n        }\n        var remainingSpace = spaceForFlexingColumns;\n        flexingColumns.forEach(function (col, i) {\n            col.setActualWidth(Math.min(flexingColumnSizes[i], remainingSpace), source);\n            changedColumns.push(col);\n            remainingSpace -= flexingColumnSizes[i];\n        });\n        if (!params.skipSetLeft) {\n            this.setLeftValues(source);\n        }\n        if (params.updateBodyWidths) {\n            this.updateBodyWidths();\n        }\n        if (params.fireResizedEvent) {\n            this.fireColumnResizedEvent(changedColumns, true, source, flexingColumns);\n        }\n        // if the user sets rowData directly into GridOptions, then the row data is set before\n        // grid is attached to the DOM. this means the columns are not flexed, and then the rows\n        // have the wrong height (as they depend on column widths). so once the columns have\n        // been flexed for the first time (only happens once grid is attached to DOM, as dependency\n        // on getting the grid width, which only happens after attached after ResizeObserver fires)\n        // we get get rows to re-calc their heights.\n        if (!this.flexColsCalculatedAtLestOnce) {\n            if (this.gridOptionsWrapper.isRowModelDefault()) {\n                this.rowModel.resetRowHeights();\n            }\n            this.flexColsCalculatedAtLestOnce = true;\n        }\n        return flexingColumns;\n    };\n    // called from api\n    ColumnModel.prototype.sizeColumnsToFit = function (gridWidth, source, silent) {\n        if (source === void 0) { source = \"sizeColumnsToFit\"; }\n        // avoid divide by zero\n        var allDisplayedColumns = this.getAllDisplayedColumns();\n        if (gridWidth <= 0 || !allDisplayedColumns.length) {\n            return;\n        }\n        var colsToSpread = [];\n        var colsToNotSpread = [];\n        allDisplayedColumns.forEach(function (column) {\n            if (column.getColDef().suppressSizeToFit === true) {\n                colsToNotSpread.push(column);\n            }\n            else {\n                colsToSpread.push(column);\n            }\n        });\n        // make a copy of the cols that are going to be resized\n        var colsToFireEventFor = colsToSpread.slice(0);\n        var finishedResizing = false;\n        var moveToNotSpread = function (column) {\n            removeFromArray(colsToSpread, column);\n            colsToNotSpread.push(column);\n        };\n        // resetting cols to their original width makes the sizeColumnsToFit more deterministic,\n        // rather than depending on the current size of the columns. most users call sizeColumnsToFit\n        // immediately after grid is created, so will make no difference. however if application is calling\n        // sizeColumnsToFit repeatedly (eg after column group is opened / closed repeatedly) we don't want\n        // the columns to start shrinking / growing over time.\n        //\n        // NOTE: the process below will assign values to `this.actualWidth` of each column without firing events\n        // for this reason we need to manually fire resize events after the resize has been done for each column.\n        colsToSpread.forEach(function (column) { return column.resetActualWidth(source); });\n        while (!finishedResizing) {\n            finishedResizing = true;\n            var availablePixels = gridWidth - this.getWidthOfColsInList(colsToNotSpread);\n            if (availablePixels <= 0) {\n                // no width, set everything to minimum\n                colsToSpread.forEach(function (column) {\n                    column.setMinimum(source);\n                });\n            }\n            else {\n                var scale = availablePixels / this.getWidthOfColsInList(colsToSpread);\n                // we set the pixels for the last col based on what's left, as otherwise\n                // we could be a pixel or two short or extra because of rounding errors.\n                var pixelsForLastCol = availablePixels;\n                // backwards through loop, as we are removing items as we go\n                for (var i = colsToSpread.length - 1; i >= 0; i--) {\n                    var column = colsToSpread[i];\n                    var minWidth = column.getMinWidth();\n                    var maxWidth = column.getMaxWidth();\n                    var newWidth = Math.round(column.getActualWidth() * scale);\n                    if (exists(minWidth) && newWidth < minWidth) {\n                        newWidth = minWidth;\n                        moveToNotSpread(column);\n                        finishedResizing = false;\n                    }\n                    else if (exists(maxWidth) && column.isGreaterThanMax(newWidth)) {\n                        newWidth = maxWidth;\n                        moveToNotSpread(column);\n                        finishedResizing = false;\n                    }\n                    else if (i === 0) { // if this is the last column\n                        newWidth = pixelsForLastCol;\n                    }\n                    column.setActualWidth(newWidth, source, true);\n                    pixelsForLastCol -= newWidth;\n                }\n            }\n        }\n        // see notes above\n        colsToFireEventFor.forEach(function (col) {\n            col.fireColumnWidthChangedEvent(source);\n        });\n        this.setLeftValues(source);\n        this.updateBodyWidths();\n        if (silent) {\n            return;\n        }\n        this.fireColumnResizedEvent(colsToFireEventFor, true, source);\n    };\n    ColumnModel.prototype.buildDisplayedTrees = function (visibleColumns) {\n        var leftVisibleColumns = [];\n        var rightVisibleColumns = [];\n        var centerVisibleColumns = [];\n        visibleColumns.forEach(function (column) {\n            switch (column.getPinned()) {\n                case \"left\":\n                    leftVisibleColumns.push(column);\n                    break;\n                case \"right\":\n                    rightVisibleColumns.push(column);\n                    break;\n                default:\n                    centerVisibleColumns.push(column);\n                    break;\n            }\n        });\n        var groupInstanceIdCreator = new GroupInstanceIdCreator();\n        this.displayedTreeLeft = this.displayedGroupCreator.createDisplayedGroups(leftVisibleColumns, this.gridBalancedTree, groupInstanceIdCreator, Constants.PINNED_LEFT, this.displayedTreeLeft);\n        this.displayedTreeRight = this.displayedGroupCreator.createDisplayedGroups(rightVisibleColumns, this.gridBalancedTree, groupInstanceIdCreator, Constants.PINNED_RIGHT, this.displayedTreeRight);\n        this.displayedTreeCentre = this.displayedGroupCreator.createDisplayedGroups(centerVisibleColumns, this.gridBalancedTree, groupInstanceIdCreator, null, this.displayedTreeCentre);\n        this.updateDisplayedMap();\n    };\n    ColumnModel.prototype.updateDisplayedMap = function () {\n        var _this = this;\n        this.displayedColumnsAndGroupsMap = {};\n        var func = function (child) {\n            _this.displayedColumnsAndGroupsMap[child.getUniqueId()] = child;\n        };\n        this.columnUtils.depthFirstAllColumnTreeSearch(this.displayedTreeCentre, func);\n        this.columnUtils.depthFirstAllColumnTreeSearch(this.displayedTreeLeft, func);\n        this.columnUtils.depthFirstAllColumnTreeSearch(this.displayedTreeRight, func);\n    };\n    ColumnModel.prototype.isDisplayed = function (item) {\n        var fromMap = this.displayedColumnsAndGroupsMap[item.getUniqueId()];\n        // check for reference, in case new column / group with same id is now present\n        return fromMap === item;\n    };\n    ColumnModel.prototype.updateOpenClosedVisibilityInColumnGroups = function () {\n        var allColumnGroups = this.getAllDisplayedTrees();\n        this.columnUtils.depthFirstAllColumnTreeSearch(allColumnGroups, function (child) {\n            if (child instanceof ColumnGroup) {\n                var columnGroup = child;\n                columnGroup.calculateDisplayedColumns();\n            }\n        });\n    };\n    ColumnModel.prototype.getGroupAutoColumns = function () {\n        return this.groupAutoColumns;\n    };\n    ColumnModel.prototype.createGroupAutoColumnsIfNeeded = function () {\n        if (!this.autoGroupsNeedBuilding) {\n            return;\n        }\n        this.autoGroupsNeedBuilding = false;\n        var groupFullWidthRow = this.gridOptionsWrapper.isGroupUseEntireRow(this.pivotMode);\n        // we need to allow suppressing auto-column separately for group and pivot as the normal situation\n        // is CSRM and user provides group column themselves for normal view, but when they go into pivot the\n        // columns are generated by the grid so no opportunity for user to provide group column. so need a way\n        // to suppress auto-col for grouping only, and not pivot.\n        // however if using Viewport RM or SSRM and user is providing the columns, the user may wish full control\n        // of the group column in this instance.\n        var suppressAutoColumn = this.pivotMode ?\n            this.gridOptionsWrapper.isPivotSuppressAutoColumn() : this.gridOptionsWrapper.isGroupSuppressAutoColumn();\n        var groupingActive = this.rowGroupColumns.length > 0 || this.usingTreeData;\n        var needAutoColumns = groupingActive && !suppressAutoColumn && !groupFullWidthRow;\n        if (needAutoColumns) {\n            var newAutoGroupCols = this.autoGroupColService.createAutoGroupColumns(this.rowGroupColumns);\n            var autoColsDifferent = !this.autoColsEqual(newAutoGroupCols, this.groupAutoColumns);\n            // we force recreate when suppressColumnStateEvents changes, so new group cols pick up the new\n            // definitions. otherwise we could ignore the new cols because they appear to be the same.\n            if (autoColsDifferent || this.forceRecreateAutoGroups) {\n                this.groupAutoColumns = newAutoGroupCols;\n            }\n        }\n        else {\n            this.groupAutoColumns = null;\n        }\n    };\n    ColumnModel.prototype.autoColsEqual = function (colsA, colsB) {\n        return areEqual(colsA, colsB, function (a, b) { return a.getColId() === b.getColId(); });\n    };\n    ColumnModel.prototype.getWidthOfColsInList = function (columnList) {\n        return columnList.reduce(function (width, col) { return width + col.getActualWidth(); }, 0);\n    };\n    ColumnModel.prototype.getGridBalancedTree = function () {\n        return this.gridBalancedTree;\n    };\n    ColumnModel.prototype.hasFloatingFilters = function () {\n        if (!this.gridColumns) {\n            return false;\n        }\n        var res = this.gridColumns.some(function (col) { return col.getColDef().floatingFilter; });\n        return res;\n    };\n    ColumnModel.prototype.getFirstDisplayedColumn = function () {\n        var isRtl = this.gridOptionsWrapper.isEnableRtl();\n        var queryOrder = [\n            'getDisplayedLeftColumns',\n            'getDisplayedCenterColumns',\n            'getDisplayedRightColumns'\n        ];\n        if (isRtl) {\n            queryOrder.reverse();\n        }\n        for (var i = 0; i < queryOrder.length; i++) {\n            var container = this[queryOrder[i]]();\n            if (container.length) {\n                return isRtl ? last(container) : container[0];\n            }\n        }\n        return null;\n    };\n    __decorate([\n        Autowired('expressionService')\n    ], ColumnModel.prototype, \"expressionService\", void 0);\n    __decorate([\n        Autowired('columnFactory')\n    ], ColumnModel.prototype, \"columnFactory\", void 0);\n    __decorate([\n        Autowired('displayedGroupCreator')\n    ], ColumnModel.prototype, \"displayedGroupCreator\", void 0);\n    __decorate([\n        Autowired('autoWidthCalculator')\n    ], ColumnModel.prototype, \"autoWidthCalculator\", void 0);\n    __decorate([\n        Autowired('columnUtils')\n    ], ColumnModel.prototype, \"columnUtils\", void 0);\n    __decorate([\n        Autowired('columnAnimationService')\n    ], ColumnModel.prototype, \"columnAnimationService\", void 0);\n    __decorate([\n        Autowired('autoGroupColService')\n    ], ColumnModel.prototype, \"autoGroupColService\", void 0);\n    __decorate([\n        Optional('aggFuncService')\n    ], ColumnModel.prototype, \"aggFuncService\", void 0);\n    __decorate([\n        Optional('valueCache')\n    ], ColumnModel.prototype, \"valueCache\", void 0);\n    __decorate([\n        Optional('animationFrameService')\n    ], ColumnModel.prototype, \"animationFrameService\", void 0);\n    __decorate([\n        Autowired('rowModel')\n    ], ColumnModel.prototype, \"rowModel\", void 0);\n    __decorate([\n        Autowired('columnApi')\n    ], ColumnModel.prototype, \"columnApi\", void 0);\n    __decorate([\n        Autowired('gridApi')\n    ], ColumnModel.prototype, \"gridApi\", void 0);\n    __decorate([\n        Autowired('sortController')\n    ], ColumnModel.prototype, \"sortController\", void 0);\n    __decorate([\n        Autowired('columnDefFactory')\n    ], ColumnModel.prototype, \"columnDefFactory\", void 0);\n    __decorate([\n        PostConstruct\n    ], ColumnModel.prototype, \"init\", null);\n    __decorate([\n        __param(0, Qualifier('loggerFactory'))\n    ], ColumnModel.prototype, \"setBeans\", null);\n    ColumnModel = __decorate([\n        Bean('columnModel')\n    ], ColumnModel);\n    return ColumnModel;\n}(BeanStub));\nexport { ColumnModel };\n"]},"metadata":{},"sourceType":"module"}