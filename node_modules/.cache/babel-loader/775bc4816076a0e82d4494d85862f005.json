{"ast":null,"code":"/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v26.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nimport { missing, exists, values } from './generic';\nimport { forEach } from './array';\nexport function iterateObject(object, callback) {\n  if (object == null) {\n    return;\n  }\n\n  if (Array.isArray(object)) {\n    forEach(object, function (value, index) {\n      return callback(\"\" + index, value);\n    });\n  } else {\n    forEach(Object.keys(object), function (key) {\n      return callback(key, object[key]);\n    });\n  }\n}\nexport function cloneObject(object) {\n  var copy = {};\n  var keys = Object.keys(object);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var value = object[key];\n    copy[key] = value;\n  }\n\n  return copy;\n}\nexport function deepCloneObject(object) {\n  return JSON.parse(JSON.stringify(object));\n} // returns copy of an object, doing a deep clone of any objects with that object.\n// this is used for eg creating copies of Column Definitions, where we want to\n// deep copy all objects, but do not want to deep copy functions (eg when user provides\n// a function or class for colDef.cellRenderer)\n\nexport function deepCloneDefinition(object, keysToSkip) {\n  if (!object) {\n    return;\n  }\n\n  var obj = object;\n  var res = {};\n  Object.keys(obj).forEach(function (key) {\n    if (keysToSkip && keysToSkip.indexOf(key) >= 0) {\n      return;\n    }\n\n    var value = obj[key]; // 'simple object' means a bunch of key/value pairs, eg {filter: 'myFilter'}. it does\n    // NOT include the following:\n    // 1) arrays\n    // 2) functions or classes (eg ColumnAPI instance)\n\n    var sourceIsSimpleObject = isNonNullObject(value) && value.constructor === Object;\n\n    if (sourceIsSimpleObject) {\n      res[key] = deepCloneDefinition(value);\n    } else {\n      res[key] = value;\n    }\n  });\n  return res;\n}\nexport function getProperty(object, key) {\n  return object[key];\n}\nexport function setProperty(object, key, value) {\n  object[key] = value;\n}\n/**\n * Will copy the specified properties from `source` into the equivalent properties on `target`, ignoring properties with\n * a value of `undefined`.\n */\n\nexport function copyPropertiesIfPresent(source, target) {\n  var properties = [];\n\n  for (var _i = 2; _i < arguments.length; _i++) {\n    properties[_i - 2] = arguments[_i];\n  }\n\n  forEach(properties, function (p) {\n    return copyPropertyIfPresent(source, target, p);\n  });\n}\n/**\n * Will copy the specified property from `source` into the equivalent property on `target`, unless the property has a\n * value of `undefined`. If a transformation is provided, it will be applied to the value before being set on `target`.\n */\n\nexport function copyPropertyIfPresent(source, target, property, transform) {\n  var value = getProperty(source, property);\n\n  if (value !== undefined) {\n    setProperty(target, property, transform ? transform(value) : value);\n  }\n}\nexport function getAllKeysInObjects(objects) {\n  var allValues = {};\n  objects.filter(function (obj) {\n    return obj != null;\n  }).forEach(function (obj) {\n    forEach(Object.keys(obj), function (key) {\n      return allValues[key] = null;\n    });\n  });\n  return Object.keys(allValues);\n}\nexport function getAllValuesInObject(obj) {\n  if (!obj) {\n    return [];\n  }\n\n  var anyObject = Object;\n\n  if (typeof anyObject.values === 'function') {\n    return anyObject.values(obj);\n  }\n\n  var ret = [];\n\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key) && obj.propertyIsEnumerable(key)) {\n      ret.push(obj[key]);\n    }\n  }\n\n  return ret;\n}\nexport function mergeDeep(dest, source, copyUndefined, makeCopyOfSimpleObjects) {\n  if (copyUndefined === void 0) {\n    copyUndefined = true;\n  }\n\n  if (makeCopyOfSimpleObjects === void 0) {\n    makeCopyOfSimpleObjects = false;\n  }\n\n  if (!exists(source)) {\n    return;\n  }\n\n  iterateObject(source, function (key, sourceValue) {\n    var destValue = dest[key];\n\n    if (destValue === sourceValue) {\n      return;\n    } // when creating params, we don't want to just copy objects over. otherwise merging ColDefs (eg DefaultColDef\n    // and Column Types) would result in params getting shared between objects.\n    // by putting an empty value into destValue first, it means we end up copying over values from\n    // the source object, rather than just copying in the source object in it's entirety.\n\n\n    if (makeCopyOfSimpleObjects) {\n      var objectIsDueToBeCopied = destValue == null && sourceValue != null;\n\n      if (objectIsDueToBeCopied) {\n        // 'simple object' means a bunch of key/value pairs, eg {filter: 'myFilter'}, as opposed\n        // to a Class instance (such as ColumnAPI instance).\n        var sourceIsSimpleObject = typeof sourceValue === 'object' && sourceValue.constructor === Object;\n        var dontCopy = sourceIsSimpleObject;\n\n        if (dontCopy) {\n          destValue = {};\n          dest[key] = destValue;\n        }\n      }\n    }\n\n    if (isNonNullObject(sourceValue) && isNonNullObject(destValue) && !Array.isArray(destValue)) {\n      mergeDeep(destValue, sourceValue, copyUndefined, makeCopyOfSimpleObjects);\n    } else if (copyUndefined || sourceValue !== undefined) {\n      dest[key] = sourceValue;\n    }\n  });\n}\nexport function assign(object) {\n  var sources = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    sources[_i - 1] = arguments[_i];\n  }\n\n  forEach(sources, function (source) {\n    return iterateObject(source, function (key, value) {\n      return object[key] = value;\n    });\n  });\n  return object;\n}\nexport function missingOrEmptyObject(value) {\n  return missing(value) || Object.keys(value).length === 0;\n}\nexport function get(source, expression, defaultValue) {\n  if (source == null) {\n    return defaultValue;\n  }\n\n  var keys = expression.split('.');\n  var objectToRead = source;\n\n  while (keys.length > 1) {\n    objectToRead = objectToRead[keys.shift()];\n\n    if (objectToRead == null) {\n      return defaultValue;\n    }\n  }\n\n  var value = objectToRead[keys[0]];\n  return value != null ? value : defaultValue;\n}\nexport function set(target, expression, value) {\n  if (target == null) {\n    return;\n  }\n\n  var keys = expression.split('.');\n  var objectToUpdate = target;\n\n  while (keys.length > 1) {\n    objectToUpdate = objectToUpdate[keys.shift()];\n\n    if (objectToUpdate == null) {\n      return;\n    }\n  }\n\n  objectToUpdate[keys[0]] = value;\n}\nexport function deepFreeze(object) {\n  Object.freeze(object);\n  forEach(values(object), function (v) {\n    if (isNonNullObject(v) || typeof v === 'function') {\n      deepFreeze(v);\n    }\n  });\n  return object;\n}\nexport function getValueUsingField(data, field, fieldContainsDots) {\n  if (!field || !data) {\n    return;\n  } // if no '.', then it's not a deep value\n\n\n  if (!fieldContainsDots) {\n    return data[field];\n  } // otherwise it is a deep value, so need to dig for it\n\n\n  var fields = field.split('.');\n  var currentObject = data;\n\n  for (var i = 0; i < fields.length; i++) {\n    if (currentObject == null) {\n      return undefined;\n    }\n\n    currentObject = currentObject[fields[i]];\n  }\n\n  return currentObject;\n} // used by ColumnAPI and GridAPI to remove all references, so keeping grid in memory resulting in a\n// memory leak if user is not disposing of the GridAPI or ColumnApi references\n\nexport function removeAllReferences(obj, objectName) {\n  Object.keys(obj).forEach(function (key) {\n    var value = obj[key]; // we want to replace all the @autowired services, which are objects. any simple types (boolean, string etc)\n    // we don't care about\n\n    if (typeof value === 'object') {\n      obj[key] = undefined;\n    }\n  });\n  var proto = Object.getPrototypeOf(obj);\n  var properties = {};\n  Object.keys(proto).forEach(function (key) {\n    var value = proto[key]; // leave all basic types - this is needed for GridAPI to leave the \"destroyed: boolean\" attribute alone\n\n    if (typeof value === 'function') {\n      var func = function () {\n        console.warn(\"AG Grid: \" + objectName + \" function \" + key + \"() cannot be called as the grid has been destroyed.\\n                     Please don't call grid API functions on destroyed grids - as a matter of fact you shouldn't\\n                     be keeping the API reference, your application has a memory leak! Remove the API reference\\n                     when the grid is destroyed.\");\n      };\n\n      properties[key] = {\n        value: func,\n        writable: true\n      };\n    }\n  });\n  Object.defineProperties(obj, properties);\n}\nexport function isNonNullObject(value) {\n  return typeof value === 'object' && value !== null;\n}","map":{"version":3,"sources":["/Users/rongxuan/Desktop/reactmap/reactmap/node_modules/@ag-grid-community/core/dist/es6/utils/object.js"],"names":["missing","exists","values","forEach","iterateObject","object","callback","Array","isArray","value","index","Object","keys","key","cloneObject","copy","i","length","deepCloneObject","JSON","parse","stringify","deepCloneDefinition","keysToSkip","obj","res","indexOf","sourceIsSimpleObject","isNonNullObject","constructor","getProperty","setProperty","copyPropertiesIfPresent","source","target","properties","_i","arguments","p","copyPropertyIfPresent","property","transform","undefined","getAllKeysInObjects","objects","allValues","filter","getAllValuesInObject","anyObject","ret","hasOwnProperty","propertyIsEnumerable","push","mergeDeep","dest","copyUndefined","makeCopyOfSimpleObjects","sourceValue","destValue","objectIsDueToBeCopied","dontCopy","assign","sources","missingOrEmptyObject","get","expression","defaultValue","split","objectToRead","shift","set","objectToUpdate","deepFreeze","freeze","v","getValueUsingField","data","field","fieldContainsDots","fields","currentObject","removeAllReferences","objectName","proto","getPrototypeOf","func","console","warn","writable","defineProperties"],"mappings":"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","sourcesContent":["/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v26.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nimport { missing, exists, values } from './generic';\nimport { forEach } from './array';\nexport function iterateObject(object, callback) {\n    if (object == null) {\n        return;\n    }\n    if (Array.isArray(object)) {\n        forEach(object, function (value, index) { return callback(\"\" + index, value); });\n    }\n    else {\n        forEach(Object.keys(object), function (key) { return callback(key, object[key]); });\n    }\n}\nexport function cloneObject(object) {\n    var copy = {};\n    var keys = Object.keys(object);\n    for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var value = object[key];\n        copy[key] = value;\n    }\n    return copy;\n}\nexport function deepCloneObject(object) {\n    return JSON.parse(JSON.stringify(object));\n}\n// returns copy of an object, doing a deep clone of any objects with that object.\n// this is used for eg creating copies of Column Definitions, where we want to\n// deep copy all objects, but do not want to deep copy functions (eg when user provides\n// a function or class for colDef.cellRenderer)\nexport function deepCloneDefinition(object, keysToSkip) {\n    if (!object) {\n        return;\n    }\n    var obj = object;\n    var res = {};\n    Object.keys(obj).forEach(function (key) {\n        if (keysToSkip && keysToSkip.indexOf(key) >= 0) {\n            return;\n        }\n        var value = obj[key];\n        // 'simple object' means a bunch of key/value pairs, eg {filter: 'myFilter'}. it does\n        // NOT include the following:\n        // 1) arrays\n        // 2) functions or classes (eg ColumnAPI instance)\n        var sourceIsSimpleObject = isNonNullObject(value) && value.constructor === Object;\n        if (sourceIsSimpleObject) {\n            res[key] = deepCloneDefinition(value);\n        }\n        else {\n            res[key] = value;\n        }\n    });\n    return res;\n}\nexport function getProperty(object, key) {\n    return object[key];\n}\nexport function setProperty(object, key, value) {\n    object[key] = value;\n}\n/**\n * Will copy the specified properties from `source` into the equivalent properties on `target`, ignoring properties with\n * a value of `undefined`.\n */\nexport function copyPropertiesIfPresent(source, target) {\n    var properties = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        properties[_i - 2] = arguments[_i];\n    }\n    forEach(properties, function (p) { return copyPropertyIfPresent(source, target, p); });\n}\n/**\n * Will copy the specified property from `source` into the equivalent property on `target`, unless the property has a\n * value of `undefined`. If a transformation is provided, it will be applied to the value before being set on `target`.\n */\nexport function copyPropertyIfPresent(source, target, property, transform) {\n    var value = getProperty(source, property);\n    if (value !== undefined) {\n        setProperty(target, property, transform ? transform(value) : value);\n    }\n}\nexport function getAllKeysInObjects(objects) {\n    var allValues = {};\n    objects.filter(function (obj) { return obj != null; }).forEach(function (obj) {\n        forEach(Object.keys(obj), function (key) { return allValues[key] = null; });\n    });\n    return Object.keys(allValues);\n}\nexport function getAllValuesInObject(obj) {\n    if (!obj) {\n        return [];\n    }\n    var anyObject = Object;\n    if (typeof anyObject.values === 'function') {\n        return anyObject.values(obj);\n    }\n    var ret = [];\n    for (var key in obj) {\n        if (obj.hasOwnProperty(key) && obj.propertyIsEnumerable(key)) {\n            ret.push(obj[key]);\n        }\n    }\n    return ret;\n}\nexport function mergeDeep(dest, source, copyUndefined, makeCopyOfSimpleObjects) {\n    if (copyUndefined === void 0) { copyUndefined = true; }\n    if (makeCopyOfSimpleObjects === void 0) { makeCopyOfSimpleObjects = false; }\n    if (!exists(source)) {\n        return;\n    }\n    iterateObject(source, function (key, sourceValue) {\n        var destValue = dest[key];\n        if (destValue === sourceValue) {\n            return;\n        }\n        // when creating params, we don't want to just copy objects over. otherwise merging ColDefs (eg DefaultColDef\n        // and Column Types) would result in params getting shared between objects.\n        // by putting an empty value into destValue first, it means we end up copying over values from\n        // the source object, rather than just copying in the source object in it's entirety.\n        if (makeCopyOfSimpleObjects) {\n            var objectIsDueToBeCopied = destValue == null && sourceValue != null;\n            if (objectIsDueToBeCopied) {\n                // 'simple object' means a bunch of key/value pairs, eg {filter: 'myFilter'}, as opposed\n                // to a Class instance (such as ColumnAPI instance).\n                var sourceIsSimpleObject = typeof sourceValue === 'object' && sourceValue.constructor === Object;\n                var dontCopy = sourceIsSimpleObject;\n                if (dontCopy) {\n                    destValue = {};\n                    dest[key] = destValue;\n                }\n            }\n        }\n        if (isNonNullObject(sourceValue) && isNonNullObject(destValue) && !Array.isArray(destValue)) {\n            mergeDeep(destValue, sourceValue, copyUndefined, makeCopyOfSimpleObjects);\n        }\n        else if (copyUndefined || sourceValue !== undefined) {\n            dest[key] = sourceValue;\n        }\n    });\n}\nexport function assign(object) {\n    var sources = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        sources[_i - 1] = arguments[_i];\n    }\n    forEach(sources, function (source) { return iterateObject(source, function (key, value) { return object[key] = value; }); });\n    return object;\n}\nexport function missingOrEmptyObject(value) {\n    return missing(value) || Object.keys(value).length === 0;\n}\nexport function get(source, expression, defaultValue) {\n    if (source == null) {\n        return defaultValue;\n    }\n    var keys = expression.split('.');\n    var objectToRead = source;\n    while (keys.length > 1) {\n        objectToRead = objectToRead[keys.shift()];\n        if (objectToRead == null) {\n            return defaultValue;\n        }\n    }\n    var value = objectToRead[keys[0]];\n    return value != null ? value : defaultValue;\n}\nexport function set(target, expression, value) {\n    if (target == null) {\n        return;\n    }\n    var keys = expression.split('.');\n    var objectToUpdate = target;\n    while (keys.length > 1) {\n        objectToUpdate = objectToUpdate[keys.shift()];\n        if (objectToUpdate == null) {\n            return;\n        }\n    }\n    objectToUpdate[keys[0]] = value;\n}\nexport function deepFreeze(object) {\n    Object.freeze(object);\n    forEach(values(object), function (v) {\n        if (isNonNullObject(v) || typeof v === 'function') {\n            deepFreeze(v);\n        }\n    });\n    return object;\n}\nexport function getValueUsingField(data, field, fieldContainsDots) {\n    if (!field || !data) {\n        return;\n    }\n    // if no '.', then it's not a deep value\n    if (!fieldContainsDots) {\n        return data[field];\n    }\n    // otherwise it is a deep value, so need to dig for it\n    var fields = field.split('.');\n    var currentObject = data;\n    for (var i = 0; i < fields.length; i++) {\n        if (currentObject == null) {\n            return undefined;\n        }\n        currentObject = currentObject[fields[i]];\n    }\n    return currentObject;\n}\n// used by ColumnAPI and GridAPI to remove all references, so keeping grid in memory resulting in a\n// memory leak if user is not disposing of the GridAPI or ColumnApi references\nexport function removeAllReferences(obj, objectName) {\n    Object.keys(obj).forEach(function (key) {\n        var value = obj[key];\n        // we want to replace all the @autowired services, which are objects. any simple types (boolean, string etc)\n        // we don't care about\n        if (typeof value === 'object') {\n            obj[key] = undefined;\n        }\n    });\n    var proto = Object.getPrototypeOf(obj);\n    var properties = {};\n    Object.keys(proto).forEach(function (key) {\n        var value = proto[key];\n        // leave all basic types - this is needed for GridAPI to leave the \"destroyed: boolean\" attribute alone\n        if (typeof value === 'function') {\n            var func = function () {\n                console.warn(\"AG Grid: \" + objectName + \" function \" + key + \"() cannot be called as the grid has been destroyed.\\n                     Please don't call grid API functions on destroyed grids - as a matter of fact you shouldn't\\n                     be keeping the API reference, your application has a memory leak! Remove the API reference\\n                     when the grid is destroyed.\");\n            };\n            properties[key] = { value: func, writable: true };\n        }\n    });\n    Object.defineProperties(obj, properties);\n}\nexport function isNonNullObject(value) {\n    return typeof value === 'object' && value !== null;\n}\n"]},"metadata":{},"sourceType":"module"}