{"ast":null,"code":"var createDecoder = require('./decoder');\n\nfunction dbfHeader(data) {\n  var out = {};\n  out.lastUpdated = new Date(data.readUInt8(1) + 1900, data.readUInt8(2), data.readUInt8(3));\n  out.records = data.readUInt32LE(4);\n  out.headerLen = data.readUInt16LE(8);\n  out.recLen = data.readUInt16LE(10);\n  return out;\n}\n\nfunction dbfRowHeader(data, headerLen, decoder) {\n  var out = [];\n  var offset = 32;\n\n  while (offset < headerLen) {\n    out.push({\n      name: decoder(data.slice(offset, offset + 11)),\n      dataType: String.fromCharCode(data.readUInt8(offset + 11)),\n      len: data.readUInt8(offset + 16),\n      decimal: data.readUInt8(offset + 17)\n    });\n\n    if (data.readUInt8(offset + 32) === 13) {\n      break;\n    } else {\n      offset += 32;\n    }\n  }\n\n  return out;\n}\n\nfunction rowFuncs(buffer, offset, len, type, decoder) {\n  var data = buffer.slice(offset, offset + len);\n  var textData = decoder(data);\n\n  switch (type) {\n    case 'N':\n    case 'F':\n    case 'O':\n      return parseFloat(textData, 10);\n\n    case 'D':\n      return new Date(textData.slice(0, 4), parseInt(textData.slice(4, 6), 10) - 1, textData.slice(6, 8));\n\n    case 'L':\n      return textData.toLowerCase() === 'y' || textData.toLowerCase() === 't';\n\n    default:\n      return textData;\n  }\n}\n\nfunction parseRow(buffer, offset, rowHeaders, decoder) {\n  var out = {};\n  var i = 0;\n  var len = rowHeaders.length;\n  var field;\n  var header;\n\n  while (i < len) {\n    header = rowHeaders[i];\n    field = rowFuncs(buffer, offset, header.len, header.dataType, decoder);\n    offset += header.len;\n\n    if (typeof field !== 'undefined') {\n      out[header.name] = field;\n    }\n\n    i++;\n  }\n\n  return out;\n}\n\nmodule.exports = function (buffer, encoding) {\n  var decoder = createDecoder(encoding);\n  var header = dbfHeader(buffer);\n  var rowHeaders = dbfRowHeader(buffer, header.headerLen - 1, decoder);\n  var offset = (rowHeaders.length + 1 << 5) + 2;\n  var recLen = header.recLen;\n  var records = header.records;\n  var out = [];\n\n  while (records) {\n    out.push(parseRow(buffer, offset, rowHeaders, decoder));\n    offset += recLen;\n    records--;\n  }\n\n  return out;\n};","map":{"version":3,"sources":["/Users/rongxuan/Desktop/reactmap/reactmap/node_modules/parsedbf/index.js"],"names":["createDecoder","require","dbfHeader","data","out","lastUpdated","Date","readUInt8","records","readUInt32LE","headerLen","readUInt16LE","recLen","dbfRowHeader","decoder","offset","push","name","slice","dataType","String","fromCharCode","len","decimal","rowFuncs","buffer","type","textData","parseFloat","parseInt","toLowerCase","parseRow","rowHeaders","i","length","field","header","module","exports","encoding"],"mappings":"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","sourcesContent":["var createDecoder = require('./decoder');\nfunction dbfHeader(data) {\n  var out = {};\n  out.lastUpdated = new Date(data.readUInt8(1) + 1900, data.readUInt8(2), data.readUInt8(3));\n  out.records = data.readUInt32LE(4);\n  out.headerLen = data.readUInt16LE(8);\n  out.recLen = data.readUInt16LE(10);\n  return out;\n}\n\nfunction dbfRowHeader(data, headerLen, decoder) {\n  var out = [];\n  var offset = 32;\n  while (offset < headerLen) {\n    out.push({\n      name: decoder(data.slice(offset, offset + 11)),\n      dataType: String.fromCharCode(data.readUInt8(offset + 11)),\n      len: data.readUInt8(offset + 16),\n      decimal: data.readUInt8(offset + 17)\n    });\n    if (data.readUInt8(offset + 32) === 13) {\n      break;\n    } else {\n      offset += 32;\n    }\n  }\n  return out;\n}\n\nfunction rowFuncs(buffer, offset, len, type, decoder) {\n  var data = buffer.slice(offset, offset + len);\n  var textData = decoder(data);\n  switch (type) {\n    case 'N':\n    case 'F':\n    case 'O':\n      return parseFloat(textData, 10);\n    case 'D':\n      return new Date(textData.slice(0, 4), parseInt(textData.slice(4, 6), 10) - 1, textData.slice(6, 8));\n    case 'L':\n      return textData.toLowerCase() === 'y' || textData.toLowerCase() === 't';\n    default:\n      return textData;\n  }\n}\n\nfunction parseRow(buffer, offset, rowHeaders, decoder) {\n  var out = {};\n  var i = 0;\n  var len = rowHeaders.length;\n  var field;\n  var header;\n  while (i < len) {\n    header = rowHeaders[i];\n    field = rowFuncs(buffer, offset, header.len, header.dataType, decoder);\n    offset += header.len;\n    if (typeof field !== 'undefined') {\n      out[header.name] = field;\n    }\n    i++;\n  }\n  return out;\n}\n\nmodule.exports = function(buffer, encoding) {\n  var decoder = createDecoder(encoding);\n  var header = dbfHeader(buffer);\n  var rowHeaders = dbfRowHeader(buffer, header.headerLen - 1, decoder);\n\n  var offset = ((rowHeaders.length + 1) << 5) + 2;\n  var recLen = header.recLen;\n  var records = header.records;\n  var out = [];\n  while (records) {\n    out.push(parseRow(buffer, offset, rowHeaders, decoder));\n    offset += recLen;\n    records--;\n  }\n  return out;\n};\n"]},"metadata":{},"sourceType":"script"}