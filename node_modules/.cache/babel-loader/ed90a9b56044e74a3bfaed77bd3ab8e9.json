{"ast":null,"code":"/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v26.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\n\nimport { Bean, Qualifier } from \"./context/context\";\n\nvar EventService =\n/** @class */\nfunction () {\n  function EventService() {\n    this.allSyncListeners = new Map();\n    this.allAsyncListeners = new Map();\n    this.globalSyncListeners = new Set();\n    this.globalAsyncListeners = new Set();\n    this.asyncFunctionsQueue = [];\n    this.scheduled = false; // using an object performs better than a Set for the number of different events we have\n\n    this.firedEvents = {};\n  } // because this class is used both inside the context and outside the context, we do not\n  // use autowired attributes, as that would be confusing, as sometimes the attributes\n  // would be wired, and sometimes not.\n  //\n  // the global event servers used by AG Grid is autowired by the context once, and this\n  // setBeans method gets called once.\n  //\n  // the times when this class is used outside of the context (eg RowNode has an instance of this\n  // class) then it is not a bean, and this setBeans method is not called.\n\n\n  EventService.prototype.setBeans = function (loggerFactory, gridOptionsWrapper, frameworkOverrides, globalEventListener) {\n    if (globalEventListener === void 0) {\n      globalEventListener = null;\n    }\n\n    this.frameworkOverrides = frameworkOverrides;\n\n    if (globalEventListener) {\n      var async = gridOptionsWrapper.useAsyncEvents();\n      this.addGlobalListener(globalEventListener, async);\n    }\n  };\n\n  EventService.prototype.getListeners = function (eventType, async, autoCreateListenerCollection) {\n    var listenerMap = async ? this.allAsyncListeners : this.allSyncListeners;\n    var listeners = listenerMap.get(eventType); // Note: 'autoCreateListenerCollection' should only be 'true' if a listener is about to be added. For instance\n    // getListeners() is also called during event dispatch even though no listeners are added. This measure protects\n    // against 'memory bloat' as empty collections will prevent the RowNode's event service from being removed after\n    // the RowComp is destroyed, see noRegisteredListenersExist() below.\n\n    if (!listeners && autoCreateListenerCollection) {\n      listeners = new Set();\n      listenerMap.set(eventType, listeners);\n    }\n\n    return listeners;\n  };\n\n  EventService.prototype.noRegisteredListenersExist = function () {\n    return this.allSyncListeners.size === 0 && this.allAsyncListeners.size === 0 && this.globalSyncListeners.size === 0 && this.globalAsyncListeners.size === 0;\n  };\n\n  EventService.prototype.addEventListener = function (eventType, listener, async) {\n    if (async === void 0) {\n      async = false;\n    }\n\n    this.getListeners(eventType, async, true).add(listener);\n  };\n\n  EventService.prototype.removeEventListener = function (eventType, listener, async) {\n    if (async === void 0) {\n      async = false;\n    }\n\n    var listeners = this.getListeners(eventType, async, false);\n\n    if (!listeners) {\n      return;\n    }\n\n    listeners.delete(listener);\n\n    if (listeners.size === 0) {\n      var listenerMap = async ? this.allAsyncListeners : this.allSyncListeners;\n      listenerMap.delete(eventType);\n    }\n  };\n\n  EventService.prototype.addGlobalListener = function (listener, async) {\n    if (async === void 0) {\n      async = false;\n    }\n\n    (async ? this.globalAsyncListeners : this.globalSyncListeners).add(listener);\n  };\n\n  EventService.prototype.removeGlobalListener = function (listener, async) {\n    if (async === void 0) {\n      async = false;\n    }\n\n    (async ? this.globalAsyncListeners : this.globalSyncListeners).delete(listener);\n  };\n\n  EventService.prototype.dispatchEvent = function (event) {\n    this.dispatchToListeners(event, true);\n    this.dispatchToListeners(event, false);\n    this.firedEvents[event.type] = true;\n  };\n\n  EventService.prototype.dispatchEventOnce = function (event) {\n    if (!this.firedEvents[event.type]) {\n      this.dispatchEvent(event);\n    }\n  };\n\n  EventService.prototype.dispatchToListeners = function (event, async) {\n    var _this = this;\n\n    var eventType = event.type;\n\n    var processEventListeners = function (listeners) {\n      return listeners.forEach(function (listener) {\n        if (async) {\n          _this.dispatchAsync(function () {\n            return listener(event);\n          });\n        } else {\n          listener(event);\n        }\n      });\n    };\n\n    var listeners = this.getListeners(eventType, async, false);\n\n    if (listeners) {\n      processEventListeners(listeners);\n    }\n\n    var globalListeners = async ? this.globalAsyncListeners : this.globalSyncListeners;\n    globalListeners.forEach(function (listener) {\n      if (async) {\n        _this.dispatchAsync(function () {\n          return _this.frameworkOverrides.dispatchEvent(eventType, function () {\n            return listener(eventType, event);\n          }, true);\n        });\n      } else {\n        _this.frameworkOverrides.dispatchEvent(eventType, function () {\n          return listener(eventType, event);\n        }, true);\n      }\n    });\n  }; // this gets called inside the grid's thread, for each event that it\n  // wants to set async. the grid then batches the events into one setTimeout()\n  // because setTimeout() is an expensive operation. ideally we would have\n  // each event in it's own setTimeout(), but we batch for performance.\n\n\n  EventService.prototype.dispatchAsync = function (func) {\n    // add to the queue for executing later in the next VM turn\n    this.asyncFunctionsQueue.push(func); // check if timeout is already scheduled. the first time the grid calls\n    // this within it's thread turn, this should be false, so it will schedule\n    // the 'flush queue' method the first time it comes here. then the flag is\n    // set to 'true' so it will know it's already scheduled for subsequent calls.\n\n    if (!this.scheduled) {\n      // if not scheduled, schedule one\n      window.setTimeout(this.flushAsyncQueue.bind(this), 0); // mark that it is scheduled\n\n      this.scheduled = true;\n    }\n  }; // this happens in the next VM turn only, and empties the queue of events\n\n\n  EventService.prototype.flushAsyncQueue = function () {\n    this.scheduled = false; // we take a copy, because the event listener could be using\n    // the grid, which would cause more events, which would be potentially\n    // added to the queue, so safe to take a copy, the new events will\n    // get executed in a later VM turn rather than risk updating the\n    // queue as we are flushing it.\n\n    var queueCopy = this.asyncFunctionsQueue.slice();\n    this.asyncFunctionsQueue = []; // execute the queue\n\n    queueCopy.forEach(function (func) {\n      return func();\n    });\n  };\n\n  __decorate([__param(0, Qualifier('loggerFactory')), __param(1, Qualifier('gridOptionsWrapper')), __param(2, Qualifier('frameworkOverrides')), __param(3, Qualifier('globalEventListener'))], EventService.prototype, \"setBeans\", null);\n\n  EventService = __decorate([Bean('eventService')], EventService);\n  return EventService;\n}();\n\nexport { EventService };","map":{"version":3,"sources":["/Users/rongxuan/Desktop/reactmap/reactmap/node_modules/@ag-grid-community/core/dist/es6/eventService.js"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","Bean","Qualifier","EventService","allSyncListeners","Map","allAsyncListeners","globalSyncListeners","Set","globalAsyncListeners","asyncFunctionsQueue","scheduled","firedEvents","prototype","setBeans","loggerFactory","gridOptionsWrapper","frameworkOverrides","globalEventListener","async","useAsyncEvents","addGlobalListener","getListeners","eventType","autoCreateListenerCollection","listenerMap","listeners","get","set","noRegisteredListenersExist","size","addEventListener","listener","add","removeEventListener","delete","removeGlobalListener","dispatchEvent","event","dispatchToListeners","type","dispatchEventOnce","_this","processEventListeners","forEach","dispatchAsync","globalListeners","func","push","window","setTimeout","flushAsyncQueue","bind","queueCopy","slice"],"mappings":"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","sourcesContent":["/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v26.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { Bean, Qualifier } from \"./context/context\";\nvar EventService = /** @class */ (function () {\n    function EventService() {\n        this.allSyncListeners = new Map();\n        this.allAsyncListeners = new Map();\n        this.globalSyncListeners = new Set();\n        this.globalAsyncListeners = new Set();\n        this.asyncFunctionsQueue = [];\n        this.scheduled = false;\n        // using an object performs better than a Set for the number of different events we have\n        this.firedEvents = {};\n    }\n    // because this class is used both inside the context and outside the context, we do not\n    // use autowired attributes, as that would be confusing, as sometimes the attributes\n    // would be wired, and sometimes not.\n    //\n    // the global event servers used by AG Grid is autowired by the context once, and this\n    // setBeans method gets called once.\n    //\n    // the times when this class is used outside of the context (eg RowNode has an instance of this\n    // class) then it is not a bean, and this setBeans method is not called.\n    EventService.prototype.setBeans = function (loggerFactory, gridOptionsWrapper, frameworkOverrides, globalEventListener) {\n        if (globalEventListener === void 0) { globalEventListener = null; }\n        this.frameworkOverrides = frameworkOverrides;\n        if (globalEventListener) {\n            var async = gridOptionsWrapper.useAsyncEvents();\n            this.addGlobalListener(globalEventListener, async);\n        }\n    };\n    EventService.prototype.getListeners = function (eventType, async, autoCreateListenerCollection) {\n        var listenerMap = async ? this.allAsyncListeners : this.allSyncListeners;\n        var listeners = listenerMap.get(eventType);\n        // Note: 'autoCreateListenerCollection' should only be 'true' if a listener is about to be added. For instance\n        // getListeners() is also called during event dispatch even though no listeners are added. This measure protects\n        // against 'memory bloat' as empty collections will prevent the RowNode's event service from being removed after\n        // the RowComp is destroyed, see noRegisteredListenersExist() below.\n        if (!listeners && autoCreateListenerCollection) {\n            listeners = new Set();\n            listenerMap.set(eventType, listeners);\n        }\n        return listeners;\n    };\n    EventService.prototype.noRegisteredListenersExist = function () {\n        return this.allSyncListeners.size === 0 && this.allAsyncListeners.size === 0 &&\n            this.globalSyncListeners.size === 0 && this.globalAsyncListeners.size === 0;\n    };\n    EventService.prototype.addEventListener = function (eventType, listener, async) {\n        if (async === void 0) { async = false; }\n        this.getListeners(eventType, async, true).add(listener);\n    };\n    EventService.prototype.removeEventListener = function (eventType, listener, async) {\n        if (async === void 0) { async = false; }\n        var listeners = this.getListeners(eventType, async, false);\n        if (!listeners) {\n            return;\n        }\n        listeners.delete(listener);\n        if (listeners.size === 0) {\n            var listenerMap = async ? this.allAsyncListeners : this.allSyncListeners;\n            listenerMap.delete(eventType);\n        }\n    };\n    EventService.prototype.addGlobalListener = function (listener, async) {\n        if (async === void 0) { async = false; }\n        (async ? this.globalAsyncListeners : this.globalSyncListeners).add(listener);\n    };\n    EventService.prototype.removeGlobalListener = function (listener, async) {\n        if (async === void 0) { async = false; }\n        (async ? this.globalAsyncListeners : this.globalSyncListeners).delete(listener);\n    };\n    EventService.prototype.dispatchEvent = function (event) {\n        this.dispatchToListeners(event, true);\n        this.dispatchToListeners(event, false);\n        this.firedEvents[event.type] = true;\n    };\n    EventService.prototype.dispatchEventOnce = function (event) {\n        if (!this.firedEvents[event.type]) {\n            this.dispatchEvent(event);\n        }\n    };\n    EventService.prototype.dispatchToListeners = function (event, async) {\n        var _this = this;\n        var eventType = event.type;\n        var processEventListeners = function (listeners) { return listeners.forEach(function (listener) {\n            if (async) {\n                _this.dispatchAsync(function () { return listener(event); });\n            }\n            else {\n                listener(event);\n            }\n        }); };\n        var listeners = this.getListeners(eventType, async, false);\n        if (listeners) {\n            processEventListeners(listeners);\n        }\n        var globalListeners = async ? this.globalAsyncListeners : this.globalSyncListeners;\n        globalListeners.forEach(function (listener) {\n            if (async) {\n                _this.dispatchAsync(function () { return _this.frameworkOverrides.dispatchEvent(eventType, function () { return listener(eventType, event); }, true); });\n            }\n            else {\n                _this.frameworkOverrides.dispatchEvent(eventType, function () { return listener(eventType, event); }, true);\n            }\n        });\n    };\n    // this gets called inside the grid's thread, for each event that it\n    // wants to set async. the grid then batches the events into one setTimeout()\n    // because setTimeout() is an expensive operation. ideally we would have\n    // each event in it's own setTimeout(), but we batch for performance.\n    EventService.prototype.dispatchAsync = function (func) {\n        // add to the queue for executing later in the next VM turn\n        this.asyncFunctionsQueue.push(func);\n        // check if timeout is already scheduled. the first time the grid calls\n        // this within it's thread turn, this should be false, so it will schedule\n        // the 'flush queue' method the first time it comes here. then the flag is\n        // set to 'true' so it will know it's already scheduled for subsequent calls.\n        if (!this.scheduled) {\n            // if not scheduled, schedule one\n            window.setTimeout(this.flushAsyncQueue.bind(this), 0);\n            // mark that it is scheduled\n            this.scheduled = true;\n        }\n    };\n    // this happens in the next VM turn only, and empties the queue of events\n    EventService.prototype.flushAsyncQueue = function () {\n        this.scheduled = false;\n        // we take a copy, because the event listener could be using\n        // the grid, which would cause more events, which would be potentially\n        // added to the queue, so safe to take a copy, the new events will\n        // get executed in a later VM turn rather than risk updating the\n        // queue as we are flushing it.\n        var queueCopy = this.asyncFunctionsQueue.slice();\n        this.asyncFunctionsQueue = [];\n        // execute the queue\n        queueCopy.forEach(function (func) { return func(); });\n    };\n    __decorate([\n        __param(0, Qualifier('loggerFactory')),\n        __param(1, Qualifier('gridOptionsWrapper')),\n        __param(2, Qualifier('frameworkOverrides')),\n        __param(3, Qualifier('globalEventListener'))\n    ], EventService.prototype, \"setBeans\", null);\n    EventService = __decorate([\n        Bean('eventService')\n    ], EventService);\n    return EventService;\n}());\nexport { EventService };\n"]},"metadata":{},"sourceType":"module"}