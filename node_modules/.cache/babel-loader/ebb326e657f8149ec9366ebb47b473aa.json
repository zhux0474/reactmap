{"ast":null,"code":"/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v26.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\n/**\n * If value is undefined, null or blank, returns null, otherwise returns the value\n * @param {T} value\n * @returns {T | null}\n */\nexport function makeNull(value) {\n  if (value == null || value === '') {\n    return null;\n  }\n\n  return value;\n}\nexport function exists(value, allowEmptyString) {\n  if (allowEmptyString === void 0) {\n    allowEmptyString = false;\n  }\n\n  return value != null && (value !== '' || allowEmptyString);\n}\nexport function missing(value) {\n  return !exists(value);\n}\nexport function missingOrEmpty(value) {\n  return value == null || value.length === 0;\n}\nexport function toStringOrNull(value) {\n  return value != null && typeof value.toString === 'function' ? value.toString() : null;\n} // for parsing html attributes, where we want empty strings and missing attributes to be undefined\n\nexport function attrToNumber(value) {\n  if (value === undefined) {\n    // undefined or empty means ignore the value\n    return;\n  }\n\n  if (value === null || value === '') {\n    // null or blank means clear\n    return null;\n  }\n\n  if (typeof value === 'number') {\n    return isNaN(value) ? undefined : value;\n  }\n\n  var valueParsed = parseInt(value, 10);\n  return isNaN(valueParsed) ? undefined : valueParsed;\n} // for parsing html attributes, where we want empty strings and missing attributes to be undefined\n\nexport function attrToBoolean(value) {\n  if (value === undefined) {\n    // undefined or empty means ignore the value\n    return;\n  }\n\n  if (value === null || value === '') {\n    // null means clear\n    return false;\n  }\n\n  if (typeof value === 'boolean') {\n    // if simple boolean, return the boolean\n    return value;\n  } // if equal to the string 'true' (ignoring case) then return true\n\n\n  return /true/i.test(value);\n} // for parsing html attributes, where we want empty strings and missing attributes to be undefined\n\nexport function attrToString(value) {\n  if (value == null || value === '') {\n    return;\n  }\n\n  return value;\n}\n/** @deprecated */\n\nexport function referenceCompare(left, right) {\n  if (left == null && right == null) {\n    return true;\n  }\n\n  if (left == null && right != null) {\n    return false;\n  }\n\n  if (left != null && right == null) {\n    return false;\n  }\n\n  return left === right;\n}\nexport function jsonEquals(val1, val2) {\n  var val1Json = val1 ? JSON.stringify(val1) : null;\n  var val2Json = val2 ? JSON.stringify(val2) : null;\n  return val1Json === val2Json;\n}\nexport function defaultComparator(valueA, valueB, accentedCompare) {\n  if (accentedCompare === void 0) {\n    accentedCompare = false;\n  }\n\n  var valueAMissing = valueA == null;\n  var valueBMissing = valueB == null; // this is for aggregations sum and avg, where the result can be a number that is wrapped.\n  // if we didn't do this, then the toString() value would be used, which would result in\n  // the strings getting used instead of the numbers.\n\n  if (valueA && valueA.toNumber) {\n    valueA = valueA.toNumber();\n  }\n\n  if (valueB && valueB.toNumber) {\n    valueB = valueB.toNumber();\n  }\n\n  if (valueAMissing && valueBMissing) {\n    return 0;\n  }\n\n  if (valueAMissing) {\n    return -1;\n  }\n\n  if (valueBMissing) {\n    return 1;\n  }\n\n  function doQuickCompare(a, b) {\n    return a > b ? 1 : a < b ? -1 : 0;\n  }\n\n  if (typeof valueA !== 'string') {\n    return doQuickCompare(valueA, valueB);\n  }\n\n  if (!accentedCompare) {\n    return doQuickCompare(valueA, valueB);\n  }\n\n  try {\n    // using local compare also allows chinese comparisons\n    return valueA.localeCompare(valueB);\n  } catch (e) {\n    // if something wrong with localeCompare, eg not supported\n    // by browser, then just continue with the quick one\n    return doQuickCompare(valueA, valueB);\n  }\n}\nexport function find(collection, predicate, value) {\n  if (collection === null || collection === undefined) {\n    return null;\n  }\n\n  if (!Array.isArray(collection)) {\n    var objToArray = values(collection);\n    return find(objToArray, predicate, value);\n  }\n\n  var collectionAsArray = collection;\n  var firstMatchingItem = null;\n\n  for (var i = 0; i < collectionAsArray.length; i++) {\n    var item = collectionAsArray[i];\n\n    if (typeof predicate === 'string') {\n      if (item[predicate] === value) {\n        firstMatchingItem = item;\n        break;\n      }\n    } else {\n      var callback = predicate;\n\n      if (callback(item)) {\n        firstMatchingItem = item;\n        break;\n      }\n    }\n  }\n\n  return firstMatchingItem;\n}\nexport function values(object) {\n  if (object instanceof Set || object instanceof Map) {\n    var arr_1 = [];\n    object.forEach(function (value) {\n      return arr_1.push(value);\n    });\n    return arr_1;\n  }\n\n  return Object.keys(object).map(function (key) {\n    return object[key];\n  });\n}","map":{"version":3,"sources":["/Users/rongxuan/Desktop/reactmap/reactmap/node_modules/@ag-grid-community/core/dist/es6/utils/generic.js"],"names":["makeNull","value","exists","allowEmptyString","missing","missingOrEmpty","length","toStringOrNull","toString","attrToNumber","undefined","isNaN","valueParsed","parseInt","attrToBoolean","test","attrToString","referenceCompare","left","right","jsonEquals","val1","val2","val1Json","JSON","stringify","val2Json","defaultComparator","valueA","valueB","accentedCompare","valueAMissing","valueBMissing","toNumber","doQuickCompare","a","b","localeCompare","e","find","collection","predicate","Array","isArray","objToArray","values","collectionAsArray","firstMatchingItem","i","item","callback","object","Set","Map","arr_1","forEach","push","Object","keys","map","key"],"mappings":"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","sourcesContent":["/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v26.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n/**\n * If value is undefined, null or blank, returns null, otherwise returns the value\n * @param {T} value\n * @returns {T | null}\n */\nexport function makeNull(value) {\n    if (value == null || value === '') {\n        return null;\n    }\n    return value;\n}\nexport function exists(value, allowEmptyString) {\n    if (allowEmptyString === void 0) { allowEmptyString = false; }\n    return value != null && (value !== '' || allowEmptyString);\n}\nexport function missing(value) {\n    return !exists(value);\n}\nexport function missingOrEmpty(value) {\n    return value == null || value.length === 0;\n}\nexport function toStringOrNull(value) {\n    return value != null && typeof value.toString === 'function' ? value.toString() : null;\n}\n// for parsing html attributes, where we want empty strings and missing attributes to be undefined\nexport function attrToNumber(value) {\n    if (value === undefined) {\n        // undefined or empty means ignore the value\n        return;\n    }\n    if (value === null || value === '') {\n        // null or blank means clear\n        return null;\n    }\n    if (typeof value === 'number') {\n        return isNaN(value) ? undefined : value;\n    }\n    var valueParsed = parseInt(value, 10);\n    return isNaN(valueParsed) ? undefined : valueParsed;\n}\n// for parsing html attributes, where we want empty strings and missing attributes to be undefined\nexport function attrToBoolean(value) {\n    if (value === undefined) {\n        // undefined or empty means ignore the value\n        return;\n    }\n    if (value === null || value === '') {\n        // null means clear\n        return false;\n    }\n    if (typeof value === 'boolean') {\n        // if simple boolean, return the boolean\n        return value;\n    }\n    // if equal to the string 'true' (ignoring case) then return true\n    return (/true/i).test(value);\n}\n// for parsing html attributes, where we want empty strings and missing attributes to be undefined\nexport function attrToString(value) {\n    if (value == null || value === '') {\n        return;\n    }\n    return value;\n}\n/** @deprecated */\nexport function referenceCompare(left, right) {\n    if (left == null && right == null) {\n        return true;\n    }\n    if (left == null && right != null) {\n        return false;\n    }\n    if (left != null && right == null) {\n        return false;\n    }\n    return left === right;\n}\nexport function jsonEquals(val1, val2) {\n    var val1Json = val1 ? JSON.stringify(val1) : null;\n    var val2Json = val2 ? JSON.stringify(val2) : null;\n    return val1Json === val2Json;\n}\nexport function defaultComparator(valueA, valueB, accentedCompare) {\n    if (accentedCompare === void 0) { accentedCompare = false; }\n    var valueAMissing = valueA == null;\n    var valueBMissing = valueB == null;\n    // this is for aggregations sum and avg, where the result can be a number that is wrapped.\n    // if we didn't do this, then the toString() value would be used, which would result in\n    // the strings getting used instead of the numbers.\n    if (valueA && valueA.toNumber) {\n        valueA = valueA.toNumber();\n    }\n    if (valueB && valueB.toNumber) {\n        valueB = valueB.toNumber();\n    }\n    if (valueAMissing && valueBMissing) {\n        return 0;\n    }\n    if (valueAMissing) {\n        return -1;\n    }\n    if (valueBMissing) {\n        return 1;\n    }\n    function doQuickCompare(a, b) {\n        return (a > b ? 1 : (a < b ? -1 : 0));\n    }\n    if (typeof valueA !== 'string') {\n        return doQuickCompare(valueA, valueB);\n    }\n    if (!accentedCompare) {\n        return doQuickCompare(valueA, valueB);\n    }\n    try {\n        // using local compare also allows chinese comparisons\n        return valueA.localeCompare(valueB);\n    }\n    catch (e) {\n        // if something wrong with localeCompare, eg not supported\n        // by browser, then just continue with the quick one\n        return doQuickCompare(valueA, valueB);\n    }\n}\nexport function find(collection, predicate, value) {\n    if (collection === null || collection === undefined) {\n        return null;\n    }\n    if (!Array.isArray(collection)) {\n        var objToArray = values(collection);\n        return find(objToArray, predicate, value);\n    }\n    var collectionAsArray = collection;\n    var firstMatchingItem = null;\n    for (var i = 0; i < collectionAsArray.length; i++) {\n        var item = collectionAsArray[i];\n        if (typeof predicate === 'string') {\n            if (item[predicate] === value) {\n                firstMatchingItem = item;\n                break;\n            }\n        }\n        else {\n            var callback = predicate;\n            if (callback(item)) {\n                firstMatchingItem = item;\n                break;\n            }\n        }\n    }\n    return firstMatchingItem;\n}\nexport function values(object) {\n    if (object instanceof Set || object instanceof Map) {\n        var arr_1 = [];\n        object.forEach(function (value) { return arr_1.push(value); });\n        return arr_1;\n    }\n    return Object.keys(object).map(function (key) { return object[key]; });\n}\n"]},"metadata":{},"sourceType":"module"}