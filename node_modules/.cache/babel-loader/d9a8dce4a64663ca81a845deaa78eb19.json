{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { _, Autowired, Bean, PostConstruct, BeanStub } from \"@ag-grid-community/core\";\n\nvar SortService =\n/** @class */\nfunction (_super) {\n  __extends(SortService, _super);\n\n  function SortService() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  SortService.prototype.init = function () {\n    this.postSortFunc = this.gridOptionsWrapper.getPostSortFunc();\n  };\n\n  SortService.prototype.sort = function (sortOptions, sortActive, deltaSort, dirtyLeafNodes, changedPath, noAggregations, sortContainsGroupColumns) {\n    var _this = this;\n\n    var groupMaintainOrder = this.gridOptionsWrapper.isGroupMaintainOrder();\n\n    var groupColumnsPresent = _.some(this.columnModel.getAllGridColumns(), function (c) {\n      return c.isRowGroupActive();\n    });\n\n    var callback = function (rowNode) {\n      // we clear out the 'pull down open parents' first, as the values mix up the sorting\n      _this.pullDownGroupDataForHideOpenParents(rowNode.childrenAfterFilter, true); // Javascript sort is non deterministic when all the array items are equals, ie Comparator always returns 0,\n      // so to ensure the array keeps its order, add an additional sorting condition manually, in this case we\n      // are going to inspect the original array position. This is what sortedRowNodes is for.\n\n\n      if (sortActive) {\n        // when 'groupMaintainOrder' is enabled we skip sorting groups unless we are sorting on group columns\n        var skipSortingGroups = groupMaintainOrder && groupColumnsPresent && !rowNode.leafGroup && !sortContainsGroupColumns;\n\n        if (skipSortingGroups) {\n          rowNode.childrenAfterSort = rowNode.childrenAfterFilter.slice(0);\n        } else {\n          rowNode.childrenAfterSort = deltaSort ? _this.doDeltaSort(rowNode, sortOptions, dirtyLeafNodes, changedPath, noAggregations) : _this.rowNodeSorter.doFullSort(rowNode.childrenAfterFilter, sortOptions);\n        }\n      } else {\n        rowNode.childrenAfterSort = rowNode.childrenAfterFilter.slice(0);\n      }\n\n      if (rowNode.sibling) {\n        rowNode.sibling.childrenAfterSort = rowNode.childrenAfterSort;\n      }\n\n      _this.updateChildIndexes(rowNode);\n\n      if (_this.postSortFunc) {\n        _this.postSortFunc(rowNode.childrenAfterSort);\n      }\n    };\n\n    if (changedPath) {\n      changedPath.forEachChangedNodeDepthFirst(callback);\n    }\n\n    this.updateGroupDataForHideOpenParents(changedPath);\n  };\n\n  SortService.prototype.mapNodeToSortedNode = function (rowNode, pos) {\n    return {\n      currentPos: pos,\n      rowNode: rowNode\n    };\n  };\n\n  SortService.prototype.doDeltaSort = function (rowNode, sortOptions, dirtyLeafNodes, changedPath, noAggregations) {\n    // clean nodes will be a list of all row nodes that remain in the set\n    // and ordered. we start with the old sorted set and take out any nodes\n    // that were removed or changed (but not added, added doesn't make sense,\n    // if a node was added, there is no way it could be here from last time).\n    var cleanNodes = rowNode.childrenAfterSort.filter(function (node) {\n      // take out all nodes that were changed as part of the current transaction.\n      // a changed node could a) be in a different sort position or b) may\n      // no longer be in this set as the changed node may not pass filtering,\n      // or be in a different group.\n      var passesDirtyNodesCheck = !dirtyLeafNodes[node.id]; // also remove group nodes in the changed path, as they can have different aggregate\n      // values which could impact the sort order.\n      // note: changed path is not active if a) no value columns or b) no transactions. it is never\n      // (b) in deltaSort as we only do deltaSort for transactions. for (a) if no value columns, then\n      // there is no value in the group that could of changed (ie no aggregate values)\n\n      var passesChangedPathCheck = noAggregations || changedPath && changedPath.canSkip(node);\n      return passesDirtyNodesCheck && passesChangedPathCheck;\n    }).map(this.mapNodeToSortedNode.bind(this)); // for fast access below, we map them\n\n    var cleanNodesMapped = {};\n    cleanNodes.forEach(function (sortedRowNode) {\n      return cleanNodesMapped[sortedRowNode.rowNode.id] = sortedRowNode.rowNode;\n    }); // these are all nodes that need to be placed\n\n    var changedNodes = rowNode.childrenAfterFilter // ignore nodes in the clean list\n    .filter(function (node) {\n      return !cleanNodesMapped[node.id];\n    }).map(this.mapNodeToSortedNode.bind(this)); // sort changed nodes. note that we don't need to sort cleanNodes as they are\n    // already sorted from last time.\n\n    changedNodes.sort(this.rowNodeSorter.compareRowNodes.bind(this, sortOptions));\n    var result;\n\n    if (changedNodes.length === 0) {\n      result = cleanNodes;\n    } else if (cleanNodes.length === 0) {\n      result = changedNodes;\n    } else {\n      result = this.mergeSortedArrays(sortOptions, cleanNodes, changedNodes);\n    }\n\n    return result.map(function (item) {\n      return item.rowNode;\n    });\n  }; // Merge two sorted arrays into each other\n\n\n  SortService.prototype.mergeSortedArrays = function (sortOptions, arr1, arr2) {\n    var res = [];\n    var i = 0;\n    var j = 0; // Traverse both array, adding them in order\n\n    while (i < arr1.length && j < arr2.length) {\n      // Check if current element of first\n      // array is smaller than current element\n      // of second array. If yes, store first\n      // array element and increment first array\n      // index. Otherwise do same with second array\n      var compareResult = this.rowNodeSorter.compareRowNodes(sortOptions, arr1[i], arr2[j]);\n\n      if (compareResult < 0) {\n        res.push(arr1[i++]);\n      } else {\n        res.push(arr2[j++]);\n      }\n    } // add remaining from arr1\n\n\n    while (i < arr1.length) {\n      res.push(arr1[i++]);\n    } // add remaining from arr2\n\n\n    while (j < arr2.length) {\n      res.push(arr2[j++]);\n    }\n\n    return res;\n  };\n\n  SortService.prototype.updateChildIndexes = function (rowNode) {\n    if (_.missing(rowNode.childrenAfterSort)) {\n      return;\n    }\n\n    var listToSort = rowNode.childrenAfterSort;\n\n    for (var i = 0; i < listToSort.length; i++) {\n      var child = listToSort[i];\n      var firstChild = i === 0;\n      var lastChild = i === rowNode.childrenAfterSort.length - 1;\n      child.setFirstChild(firstChild);\n      child.setLastChild(lastChild);\n      child.setChildIndex(i);\n    }\n  };\n\n  SortService.prototype.updateGroupDataForHideOpenParents = function (changedPath) {\n    var _this = this;\n\n    if (!this.gridOptionsWrapper.isGroupHideOpenParents()) {\n      return;\n    }\n\n    if (this.gridOptionsWrapper.isTreeData()) {\n      var msg_1 = \"AG Grid: The property hideOpenParents dose not work with Tree Data. This is because Tree Data has values at the group level, it doesn't make sense to hide them (as opposed to Row Grouping, which only has Aggregated Values at the group level).\";\n\n      _.doOnce(function () {\n        return console.warn(msg_1);\n      }, 'sortService.hideOpenParentsWithTreeData');\n\n      return false;\n    } // recurse breadth first over group nodes after sort to 'pull down' group data to child groups\n\n\n    var callback = function (rowNode) {\n      _this.pullDownGroupDataForHideOpenParents(rowNode.childrenAfterSort, false);\n\n      rowNode.childrenAfterSort.forEach(function (child) {\n        if (child.hasChildren()) {\n          callback(child);\n        }\n      });\n    };\n\n    if (changedPath) {\n      changedPath.executeFromRootNode(function (rowNode) {\n        return callback(rowNode);\n      });\n    }\n  };\n\n  SortService.prototype.pullDownGroupDataForHideOpenParents = function (rowNodes, clearOperation) {\n    var _this = this;\n\n    if (!this.gridOptionsWrapper.isGroupHideOpenParents() || _.missing(rowNodes)) {\n      return;\n    }\n\n    rowNodes.forEach(function (childRowNode) {\n      var groupDisplayCols = _this.columnModel.getGroupDisplayColumns();\n\n      groupDisplayCols.forEach(function (groupDisplayCol) {\n        var showRowGroup = groupDisplayCol.getColDef().showRowGroup;\n\n        if (typeof showRowGroup !== 'string') {\n          console.error('AG Grid: groupHideOpenParents only works when specifying specific columns for colDef.showRowGroup');\n          return;\n        }\n\n        var displayingGroupKey = showRowGroup;\n\n        var rowGroupColumn = _this.columnModel.getPrimaryColumn(displayingGroupKey);\n\n        var thisRowNodeMatches = rowGroupColumn === childRowNode.rowGroupColumn;\n\n        if (thisRowNodeMatches) {\n          return;\n        }\n\n        if (clearOperation) {\n          // if doing a clear operation, we clear down the value for every possible group column\n          childRowNode.setGroupValue(groupDisplayCol.getId(), undefined);\n        } else {\n          // if doing a set operation, we set only where the pull down is to occur\n          var parentToStealFrom = childRowNode.getFirstChildOfFirstChild(rowGroupColumn);\n\n          if (parentToStealFrom) {\n            childRowNode.setGroupValue(groupDisplayCol.getId(), parentToStealFrom.key);\n          }\n        }\n      });\n    });\n  };\n\n  __decorate([Autowired('columnModel')], SortService.prototype, \"columnModel\", void 0);\n\n  __decorate([Autowired('rowNodeSorter')], SortService.prototype, \"rowNodeSorter\", void 0);\n\n  __decorate([PostConstruct], SortService.prototype, \"init\", null);\n\n  SortService = __decorate([Bean('sortService')], SortService);\n  return SortService;\n}(BeanStub);\n\nexport { SortService };","map":{"version":3,"sources":["/Users/rongxuan/Desktop/reactmap/reactmap/node_modules/@ag-grid-community/client-side-row-model/dist/es6/clientSideRowModel/sortService.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","_","Autowired","Bean","PostConstruct","BeanStub","SortService","_super","apply","init","postSortFunc","gridOptionsWrapper","getPostSortFunc","sort","sortOptions","sortActive","deltaSort","dirtyLeafNodes","changedPath","noAggregations","sortContainsGroupColumns","_this","groupMaintainOrder","isGroupMaintainOrder","groupColumnsPresent","some","columnModel","getAllGridColumns","isRowGroupActive","callback","rowNode","pullDownGroupDataForHideOpenParents","childrenAfterFilter","skipSortingGroups","leafGroup","childrenAfterSort","slice","doDeltaSort","rowNodeSorter","doFullSort","sibling","updateChildIndexes","forEachChangedNodeDepthFirst","updateGroupDataForHideOpenParents","mapNodeToSortedNode","pos","currentPos","cleanNodes","filter","node","passesDirtyNodesCheck","id","passesChangedPathCheck","canSkip","map","bind","cleanNodesMapped","forEach","sortedRowNode","changedNodes","compareRowNodes","result","mergeSortedArrays","item","arr1","arr2","res","j","compareResult","push","missing","listToSort","child","firstChild","lastChild","setFirstChild","setLastChild","setChildIndex","isGroupHideOpenParents","isTreeData","msg_1","doOnce","console","warn","hasChildren","executeFromRootNode","rowNodes","clearOperation","childRowNode","groupDisplayCols","getGroupDisplayColumns","groupDisplayCol","showRowGroup","getColDef","error","displayingGroupKey","rowGroupColumn","getPrimaryColumn","thisRowNodeMatches","setGroupValue","getId","undefined","parentToStealFrom","getFirstChildOfFirstChild"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { _, Autowired, Bean, PostConstruct, BeanStub } from \"@ag-grid-community/core\";\nvar SortService = /** @class */ (function (_super) {\n    __extends(SortService, _super);\n    function SortService() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    SortService.prototype.init = function () {\n        this.postSortFunc = this.gridOptionsWrapper.getPostSortFunc();\n    };\n    SortService.prototype.sort = function (sortOptions, sortActive, deltaSort, dirtyLeafNodes, changedPath, noAggregations, sortContainsGroupColumns) {\n        var _this = this;\n        var groupMaintainOrder = this.gridOptionsWrapper.isGroupMaintainOrder();\n        var groupColumnsPresent = _.some(this.columnModel.getAllGridColumns(), function (c) { return c.isRowGroupActive(); });\n        var callback = function (rowNode) {\n            // we clear out the 'pull down open parents' first, as the values mix up the sorting\n            _this.pullDownGroupDataForHideOpenParents(rowNode.childrenAfterFilter, true);\n            // Javascript sort is non deterministic when all the array items are equals, ie Comparator always returns 0,\n            // so to ensure the array keeps its order, add an additional sorting condition manually, in this case we\n            // are going to inspect the original array position. This is what sortedRowNodes is for.\n            if (sortActive) {\n                // when 'groupMaintainOrder' is enabled we skip sorting groups unless we are sorting on group columns\n                var skipSortingGroups = groupMaintainOrder && groupColumnsPresent && !rowNode.leafGroup && !sortContainsGroupColumns;\n                if (skipSortingGroups) {\n                    rowNode.childrenAfterSort = rowNode.childrenAfterFilter.slice(0);\n                }\n                else {\n                    rowNode.childrenAfterSort = deltaSort ?\n                        _this.doDeltaSort(rowNode, sortOptions, dirtyLeafNodes, changedPath, noAggregations)\n                        : _this.rowNodeSorter.doFullSort(rowNode.childrenAfterFilter, sortOptions);\n                }\n            }\n            else {\n                rowNode.childrenAfterSort = rowNode.childrenAfterFilter.slice(0);\n            }\n            if (rowNode.sibling) {\n                rowNode.sibling.childrenAfterSort = rowNode.childrenAfterSort;\n            }\n            _this.updateChildIndexes(rowNode);\n            if (_this.postSortFunc) {\n                _this.postSortFunc(rowNode.childrenAfterSort);\n            }\n        };\n        if (changedPath) {\n            changedPath.forEachChangedNodeDepthFirst(callback);\n        }\n        this.updateGroupDataForHideOpenParents(changedPath);\n    };\n    SortService.prototype.mapNodeToSortedNode = function (rowNode, pos) {\n        return { currentPos: pos, rowNode: rowNode };\n    };\n    SortService.prototype.doDeltaSort = function (rowNode, sortOptions, dirtyLeafNodes, changedPath, noAggregations) {\n        // clean nodes will be a list of all row nodes that remain in the set\n        // and ordered. we start with the old sorted set and take out any nodes\n        // that were removed or changed (but not added, added doesn't make sense,\n        // if a node was added, there is no way it could be here from last time).\n        var cleanNodes = rowNode.childrenAfterSort\n            .filter(function (node) {\n            // take out all nodes that were changed as part of the current transaction.\n            // a changed node could a) be in a different sort position or b) may\n            // no longer be in this set as the changed node may not pass filtering,\n            // or be in a different group.\n            var passesDirtyNodesCheck = !dirtyLeafNodes[node.id];\n            // also remove group nodes in the changed path, as they can have different aggregate\n            // values which could impact the sort order.\n            // note: changed path is not active if a) no value columns or b) no transactions. it is never\n            // (b) in deltaSort as we only do deltaSort for transactions. for (a) if no value columns, then\n            // there is no value in the group that could of changed (ie no aggregate values)\n            var passesChangedPathCheck = noAggregations || (changedPath && changedPath.canSkip(node));\n            return passesDirtyNodesCheck && passesChangedPathCheck;\n        })\n            .map(this.mapNodeToSortedNode.bind(this));\n        // for fast access below, we map them\n        var cleanNodesMapped = {};\n        cleanNodes.forEach(function (sortedRowNode) { return cleanNodesMapped[sortedRowNode.rowNode.id] = sortedRowNode.rowNode; });\n        // these are all nodes that need to be placed\n        var changedNodes = rowNode.childrenAfterFilter\n            // ignore nodes in the clean list\n            .filter(function (node) { return !cleanNodesMapped[node.id]; })\n            .map(this.mapNodeToSortedNode.bind(this));\n        // sort changed nodes. note that we don't need to sort cleanNodes as they are\n        // already sorted from last time.\n        changedNodes.sort(this.rowNodeSorter.compareRowNodes.bind(this, sortOptions));\n        var result;\n        if (changedNodes.length === 0) {\n            result = cleanNodes;\n        }\n        else if (cleanNodes.length === 0) {\n            result = changedNodes;\n        }\n        else {\n            result = this.mergeSortedArrays(sortOptions, cleanNodes, changedNodes);\n        }\n        return result.map(function (item) { return item.rowNode; });\n    };\n    // Merge two sorted arrays into each other\n    SortService.prototype.mergeSortedArrays = function (sortOptions, arr1, arr2) {\n        var res = [];\n        var i = 0;\n        var j = 0;\n        // Traverse both array, adding them in order\n        while (i < arr1.length && j < arr2.length) {\n            // Check if current element of first\n            // array is smaller than current element\n            // of second array. If yes, store first\n            // array element and increment first array\n            // index. Otherwise do same with second array\n            var compareResult = this.rowNodeSorter.compareRowNodes(sortOptions, arr1[i], arr2[j]);\n            if (compareResult < 0) {\n                res.push(arr1[i++]);\n            }\n            else {\n                res.push(arr2[j++]);\n            }\n        }\n        // add remaining from arr1\n        while (i < arr1.length) {\n            res.push(arr1[i++]);\n        }\n        // add remaining from arr2\n        while (j < arr2.length) {\n            res.push(arr2[j++]);\n        }\n        return res;\n    };\n    SortService.prototype.updateChildIndexes = function (rowNode) {\n        if (_.missing(rowNode.childrenAfterSort)) {\n            return;\n        }\n        var listToSort = rowNode.childrenAfterSort;\n        for (var i = 0; i < listToSort.length; i++) {\n            var child = listToSort[i];\n            var firstChild = i === 0;\n            var lastChild = i === rowNode.childrenAfterSort.length - 1;\n            child.setFirstChild(firstChild);\n            child.setLastChild(lastChild);\n            child.setChildIndex(i);\n        }\n    };\n    SortService.prototype.updateGroupDataForHideOpenParents = function (changedPath) {\n        var _this = this;\n        if (!this.gridOptionsWrapper.isGroupHideOpenParents()) {\n            return;\n        }\n        if (this.gridOptionsWrapper.isTreeData()) {\n            var msg_1 = \"AG Grid: The property hideOpenParents dose not work with Tree Data. This is because Tree Data has values at the group level, it doesn't make sense to hide them (as opposed to Row Grouping, which only has Aggregated Values at the group level).\";\n            _.doOnce(function () { return console.warn(msg_1); }, 'sortService.hideOpenParentsWithTreeData');\n            return false;\n        }\n        // recurse breadth first over group nodes after sort to 'pull down' group data to child groups\n        var callback = function (rowNode) {\n            _this.pullDownGroupDataForHideOpenParents(rowNode.childrenAfterSort, false);\n            rowNode.childrenAfterSort.forEach(function (child) {\n                if (child.hasChildren()) {\n                    callback(child);\n                }\n            });\n        };\n        if (changedPath) {\n            changedPath.executeFromRootNode(function (rowNode) { return callback(rowNode); });\n        }\n    };\n    SortService.prototype.pullDownGroupDataForHideOpenParents = function (rowNodes, clearOperation) {\n        var _this = this;\n        if (!this.gridOptionsWrapper.isGroupHideOpenParents() || _.missing(rowNodes)) {\n            return;\n        }\n        rowNodes.forEach(function (childRowNode) {\n            var groupDisplayCols = _this.columnModel.getGroupDisplayColumns();\n            groupDisplayCols.forEach(function (groupDisplayCol) {\n                var showRowGroup = groupDisplayCol.getColDef().showRowGroup;\n                if (typeof showRowGroup !== 'string') {\n                    console.error('AG Grid: groupHideOpenParents only works when specifying specific columns for colDef.showRowGroup');\n                    return;\n                }\n                var displayingGroupKey = showRowGroup;\n                var rowGroupColumn = _this.columnModel.getPrimaryColumn(displayingGroupKey);\n                var thisRowNodeMatches = rowGroupColumn === childRowNode.rowGroupColumn;\n                if (thisRowNodeMatches) {\n                    return;\n                }\n                if (clearOperation) {\n                    // if doing a clear operation, we clear down the value for every possible group column\n                    childRowNode.setGroupValue(groupDisplayCol.getId(), undefined);\n                }\n                else {\n                    // if doing a set operation, we set only where the pull down is to occur\n                    var parentToStealFrom = childRowNode.getFirstChildOfFirstChild(rowGroupColumn);\n                    if (parentToStealFrom) {\n                        childRowNode.setGroupValue(groupDisplayCol.getId(), parentToStealFrom.key);\n                    }\n                }\n            });\n        });\n    };\n    __decorate([\n        Autowired('columnModel')\n    ], SortService.prototype, \"columnModel\", void 0);\n    __decorate([\n        Autowired('rowNodeSorter')\n    ], SortService.prototype, \"rowNodeSorter\", void 0);\n    __decorate([\n        PostConstruct\n    ], SortService.prototype, \"init\", null);\n    SortService = __decorate([\n        Bean('sortService')\n    ], SortService);\n    return SortService;\n}(BeanStub));\nexport { SortService };\n"]},"metadata":{},"sourceType":"module"}