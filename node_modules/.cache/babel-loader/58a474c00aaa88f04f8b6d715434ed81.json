{"ast":null,"code":"/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v26.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\n/**\n * Gets called by: a) ClientSideNodeManager and b) GroupStage to do sorting.\n * when in ClientSideNodeManager we always have indexes (as this sorts the items the\n * user provided) but when in GroupStage, the nodes can contain filler nodes that\n * don't have order id's\n * @param {RowNode[]} rowNodes\n * @param {Object} rowNodeOrder\n */\nexport function sortRowNodesByOrder(rowNodes, rowNodeOrder) {\n  if (!rowNodes) {\n    return;\n  }\n\n  var comparator = function (nodeA, nodeB) {\n    var positionA = rowNodeOrder[nodeA.id];\n    var positionB = rowNodeOrder[nodeB.id];\n    var aHasIndex = positionA !== undefined;\n    var bHasIndex = positionB !== undefined;\n    var bothNodesAreUserNodes = aHasIndex && bHasIndex;\n    var bothNodesAreFillerNodes = !aHasIndex && !bHasIndex;\n\n    if (bothNodesAreUserNodes) {\n      // when comparing two nodes the user has provided, they always\n      // have indexes\n      return positionA - positionB;\n    }\n\n    if (bothNodesAreFillerNodes) {\n      // when comparing two filler nodes, we have no index to compare them\n      // against, however we want this sorting to be deterministic, so that\n      // the rows don't jump around as the user does delta updates. so we\n      // want the same sort result. so we use the __objectId - which doesn't make sense\n      // from a sorting point of view, but does give consistent behaviour between\n      // calls. otherwise groups jump around as delta updates are done.\n      // note: previously here we used nodeId, however this gave a strange order\n      // as string ordering of numbers is wrong, so using id based on creation order\n      // as least gives better looking order.\n      return nodeA.__objectId - nodeB.__objectId;\n    }\n\n    if (aHasIndex) {\n      return 1;\n    }\n\n    return -1;\n  }; // check if the list first needs sorting\n\n\n  var rowNodeA;\n  var rowNodeB;\n  var atLeastOneOutOfOrder = false;\n\n  for (var i = 0; i < rowNodes.length - 1; i++) {\n    rowNodeA = rowNodes[i];\n    rowNodeB = rowNodes[i + 1];\n\n    if (comparator(rowNodeA, rowNodeB) > 0) {\n      atLeastOneOutOfOrder = true;\n      break;\n    }\n  }\n\n  if (atLeastOneOutOfOrder) {\n    rowNodes.sort(comparator);\n  }\n}\nexport function traverseNodesWithKey(nodes, callback) {\n  var keyParts = [];\n  recursiveSearchNodes(nodes);\n\n  function recursiveSearchNodes(currentNodes) {\n    if (!currentNodes) {\n      return;\n    }\n\n    currentNodes.forEach(function (node) {\n      // also checking for children for tree data\n      if (node.group || node.hasChildren()) {\n        keyParts.push(node.key);\n        var key = keyParts.join('|');\n        callback(node, key);\n        recursiveSearchNodes(node.childrenAfterGroup);\n        keyParts.pop();\n      }\n    });\n  }\n}","map":{"version":3,"sources":["/Users/rongxuan/Desktop/reactmap/reactmap/node_modules/@ag-grid-community/core/dist/es6/utils/rowNode.js"],"names":["sortRowNodesByOrder","rowNodes","rowNodeOrder","comparator","nodeA","nodeB","positionA","id","positionB","aHasIndex","undefined","bHasIndex","bothNodesAreUserNodes","bothNodesAreFillerNodes","__objectId","rowNodeA","rowNodeB","atLeastOneOutOfOrder","i","length","sort","traverseNodesWithKey","nodes","callback","keyParts","recursiveSearchNodes","currentNodes","forEach","node","group","hasChildren","push","key","join","childrenAfterGroup","pop"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,mBAAT,CAA6BC,QAA7B,EAAuCC,YAAvC,EAAqD;AACxD,MAAI,CAACD,QAAL,EAAe;AACX;AACH;;AACD,MAAIE,UAAU,GAAG,UAAUC,KAAV,EAAiBC,KAAjB,EAAwB;AACrC,QAAIC,SAAS,GAAGJ,YAAY,CAACE,KAAK,CAACG,EAAP,CAA5B;AACA,QAAIC,SAAS,GAAGN,YAAY,CAACG,KAAK,CAACE,EAAP,CAA5B;AACA,QAAIE,SAAS,GAAGH,SAAS,KAAKI,SAA9B;AACA,QAAIC,SAAS,GAAGH,SAAS,KAAKE,SAA9B;AACA,QAAIE,qBAAqB,GAAGH,SAAS,IAAIE,SAAzC;AACA,QAAIE,uBAAuB,GAAG,CAACJ,SAAD,IAAc,CAACE,SAA7C;;AACA,QAAIC,qBAAJ,EAA2B;AACvB;AACA;AACA,aAAON,SAAS,GAAGE,SAAnB;AACH;;AACD,QAAIK,uBAAJ,EAA6B;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAOT,KAAK,CAACU,UAAN,GAAmBT,KAAK,CAACS,UAAhC;AACH;;AACD,QAAIL,SAAJ,EAAe;AACX,aAAO,CAAP;AACH;;AACD,WAAO,CAAC,CAAR;AACH,GA5BD,CAJwD,CAiCxD;;;AACA,MAAIM,QAAJ;AACA,MAAIC,QAAJ;AACA,MAAIC,oBAAoB,GAAG,KAA3B;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGjB,QAAQ,CAACkB,MAAT,GAAkB,CAAtC,EAAyCD,CAAC,EAA1C,EAA8C;AAC1CH,IAAAA,QAAQ,GAAGd,QAAQ,CAACiB,CAAD,CAAnB;AACAF,IAAAA,QAAQ,GAAGf,QAAQ,CAACiB,CAAC,GAAG,CAAL,CAAnB;;AACA,QAAIf,UAAU,CAACY,QAAD,EAAWC,QAAX,CAAV,GAAiC,CAArC,EAAwC;AACpCC,MAAAA,oBAAoB,GAAG,IAAvB;AACA;AACH;AACJ;;AACD,MAAIA,oBAAJ,EAA0B;AACtBhB,IAAAA,QAAQ,CAACmB,IAAT,CAAcjB,UAAd;AACH;AACJ;AACD,OAAO,SAASkB,oBAAT,CAA8BC,KAA9B,EAAqCC,QAArC,EAA+C;AAClD,MAAIC,QAAQ,GAAG,EAAf;AACAC,EAAAA,oBAAoB,CAACH,KAAD,CAApB;;AACA,WAASG,oBAAT,CAA8BC,YAA9B,EAA4C;AACxC,QAAI,CAACA,YAAL,EAAmB;AACf;AACH;;AACDA,IAAAA,YAAY,CAACC,OAAb,CAAqB,UAAUC,IAAV,EAAgB;AACjC;AACA,UAAIA,IAAI,CAACC,KAAL,IAAcD,IAAI,CAACE,WAAL,EAAlB,EAAsC;AAClCN,QAAAA,QAAQ,CAACO,IAAT,CAAcH,IAAI,CAACI,GAAnB;AACA,YAAIA,GAAG,GAAGR,QAAQ,CAACS,IAAT,CAAc,GAAd,CAAV;AACAV,QAAAA,QAAQ,CAACK,IAAD,EAAOI,GAAP,CAAR;AACAP,QAAAA,oBAAoB,CAACG,IAAI,CAACM,kBAAN,CAApB;AACAV,QAAAA,QAAQ,CAACW,GAAT;AACH;AACJ,KATD;AAUH;AACJ","sourcesContent":["/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v26.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n/**\n * Gets called by: a) ClientSideNodeManager and b) GroupStage to do sorting.\n * when in ClientSideNodeManager we always have indexes (as this sorts the items the\n * user provided) but when in GroupStage, the nodes can contain filler nodes that\n * don't have order id's\n * @param {RowNode[]} rowNodes\n * @param {Object} rowNodeOrder\n */\nexport function sortRowNodesByOrder(rowNodes, rowNodeOrder) {\n    if (!rowNodes) {\n        return;\n    }\n    var comparator = function (nodeA, nodeB) {\n        var positionA = rowNodeOrder[nodeA.id];\n        var positionB = rowNodeOrder[nodeB.id];\n        var aHasIndex = positionA !== undefined;\n        var bHasIndex = positionB !== undefined;\n        var bothNodesAreUserNodes = aHasIndex && bHasIndex;\n        var bothNodesAreFillerNodes = !aHasIndex && !bHasIndex;\n        if (bothNodesAreUserNodes) {\n            // when comparing two nodes the user has provided, they always\n            // have indexes\n            return positionA - positionB;\n        }\n        if (bothNodesAreFillerNodes) {\n            // when comparing two filler nodes, we have no index to compare them\n            // against, however we want this sorting to be deterministic, so that\n            // the rows don't jump around as the user does delta updates. so we\n            // want the same sort result. so we use the __objectId - which doesn't make sense\n            // from a sorting point of view, but does give consistent behaviour between\n            // calls. otherwise groups jump around as delta updates are done.\n            // note: previously here we used nodeId, however this gave a strange order\n            // as string ordering of numbers is wrong, so using id based on creation order\n            // as least gives better looking order.\n            return nodeA.__objectId - nodeB.__objectId;\n        }\n        if (aHasIndex) {\n            return 1;\n        }\n        return -1;\n    };\n    // check if the list first needs sorting\n    var rowNodeA;\n    var rowNodeB;\n    var atLeastOneOutOfOrder = false;\n    for (var i = 0; i < rowNodes.length - 1; i++) {\n        rowNodeA = rowNodes[i];\n        rowNodeB = rowNodes[i + 1];\n        if (comparator(rowNodeA, rowNodeB) > 0) {\n            atLeastOneOutOfOrder = true;\n            break;\n        }\n    }\n    if (atLeastOneOutOfOrder) {\n        rowNodes.sort(comparator);\n    }\n}\nexport function traverseNodesWithKey(nodes, callback) {\n    var keyParts = [];\n    recursiveSearchNodes(nodes);\n    function recursiveSearchNodes(currentNodes) {\n        if (!currentNodes) {\n            return;\n        }\n        currentNodes.forEach(function (node) {\n            // also checking for children for tree data\n            if (node.group || node.hasChildren()) {\n                keyParts.push(node.key);\n                var key = keyParts.join('|');\n                callback(node, key);\n                recursiveSearchNodes(node.childrenAfterGroup);\n                keyParts.pop();\n            }\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"module"}