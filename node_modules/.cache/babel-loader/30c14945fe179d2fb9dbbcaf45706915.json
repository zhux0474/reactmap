{"ast":null,"code":"/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v26.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { ColumnGroup } from \"../entities/columnGroup\";\nimport { ProvidedColumnGroup } from \"../entities/providedColumnGroup\";\nimport { Bean } from \"../context/context\";\nimport { BeanStub } from \"../context/beanStub\";\nimport { last } from \"../utils/array\";\nimport { exists } from \"../utils/generic\"; // takes in a list of columns, as specified by the column definitions, and returns column groups\n\nvar DisplayedGroupCreator =\n/** @class */\nfunction (_super) {\n  __extends(DisplayedGroupCreator, _super);\n\n  function DisplayedGroupCreator() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  DisplayedGroupCreator.prototype.createDisplayedGroups = function ( // all displayed columns sorted - this is the columns the grid should show\n  sortedVisibleColumns, // the tree of columns, as provided by the users, used to know what groups columns roll up into\n  balancedColumnTree, // creates unique id's for the group\n  groupInstanceIdCreator, // whether it's left, right or center col\n  pinned, // we try to reuse old groups if we can, to allow gui to do animation\n  oldDisplayedGroups) {\n    var _this = this;\n\n    var result = [];\n    var previousRealPath;\n    var previousOriginalPath;\n    var oldColumnsMapped = this.mapOldGroupsById(oldDisplayedGroups); // go through each column, then do a bottom up comparison to the previous column, and start\n    // to share groups if they converge at any point.\n\n    sortedVisibleColumns.forEach(function (currentColumn) {\n      var currentOriginalPath = _this.getOriginalPathForColumn(balancedColumnTree, currentColumn);\n\n      var currentRealPath = [];\n      var firstColumn = !previousOriginalPath;\n\n      for (var i = 0; i < currentOriginalPath.length; i++) {\n        if (firstColumn || currentOriginalPath[i] !== previousOriginalPath[i]) {\n          // new group needed\n          var newGroup = _this.createColumnGroup(currentOriginalPath[i], groupInstanceIdCreator, oldColumnsMapped, pinned);\n\n          currentRealPath[i] = newGroup; // if top level, add to result, otherwise add to parent\n\n          if (i == 0) {\n            result.push(newGroup);\n          } else {\n            currentRealPath[i - 1].addChild(newGroup);\n          }\n        } else {\n          // reuse old group\n          currentRealPath[i] = previousRealPath[i];\n        }\n      }\n\n      var noColumnGroups = currentRealPath.length === 0;\n\n      if (noColumnGroups) {\n        // if we are not grouping, then the result of the above is an empty\n        // path (no groups), and we just add the column to the root list.\n        result.push(currentColumn);\n      } else {\n        var leafGroup = last(currentRealPath);\n        leafGroup.addChild(currentColumn);\n      }\n\n      previousRealPath = currentRealPath;\n      previousOriginalPath = currentOriginalPath;\n    });\n    this.setupParentsIntoColumns(result, null);\n    return result;\n  };\n\n  DisplayedGroupCreator.prototype.createColumnGroup = function (originalGroup, groupInstanceIdCreator, oldColumnsMapped, pinned) {\n    var groupId = originalGroup.getGroupId();\n    var instanceId = groupInstanceIdCreator.getInstanceIdForKey(groupId);\n    var uniqueId = ColumnGroup.createUniqueId(groupId, instanceId);\n    var columnGroup = oldColumnsMapped[uniqueId]; // if the user is setting new colDefs, it is possible that the id's overlap, and we\n    // would have a false match from above. so we double check we are talking about the\n    // same original column group.\n\n    if (columnGroup && columnGroup.getOriginalColumnGroup() !== originalGroup) {\n      columnGroup = null;\n    }\n\n    if (exists(columnGroup)) {\n      // clean out the old column group here, as we will be adding children into it again\n      columnGroup.reset();\n    } else {\n      columnGroup = new ColumnGroup(originalGroup, groupId, instanceId, pinned);\n      this.context.createBean(columnGroup);\n    }\n\n    return columnGroup;\n  }; // returns back a 2d map of ColumnGroup as follows: groupId -> instanceId -> ColumnGroup\n\n\n  DisplayedGroupCreator.prototype.mapOldGroupsById = function (displayedGroups) {\n    var result = {};\n\n    var recursive = function (columnsOrGroups) {\n      columnsOrGroups.forEach(function (columnOrGroup) {\n        if (columnOrGroup instanceof ColumnGroup) {\n          var columnGroup = columnOrGroup;\n          result[columnOrGroup.getUniqueId()] = columnGroup;\n          recursive(columnGroup.getChildren());\n        }\n      });\n    };\n\n    if (displayedGroups) {\n      recursive(displayedGroups);\n    }\n\n    return result;\n  };\n\n  DisplayedGroupCreator.prototype.setupParentsIntoColumns = function (columnsOrGroups, parent) {\n    var _this = this;\n\n    columnsOrGroups.forEach(function (columnsOrGroup) {\n      columnsOrGroup.setParent(parent);\n\n      if (columnsOrGroup instanceof ColumnGroup) {\n        var columnGroup = columnsOrGroup;\n\n        _this.setupParentsIntoColumns(columnGroup.getChildren(), columnGroup);\n      }\n    });\n  };\n\n  DisplayedGroupCreator.prototype.getOriginalPathForColumn = function (balancedColumnTree, column) {\n    var result = [];\n    var found = false;\n\n    var recursePath = function (columnTree, dept) {\n      for (var i = 0; i < columnTree.length; i++) {\n        // quit the search, so 'result' is kept with the found result\n        if (found) {\n          return;\n        }\n\n        var node = columnTree[i];\n\n        if (node instanceof ProvidedColumnGroup) {\n          var nextNode = node;\n          recursePath(nextNode.getChildren(), dept + 1);\n          result[dept] = node;\n        } else if (node === column) {\n          found = true;\n        }\n      }\n    };\n\n    recursePath(balancedColumnTree, 0); // it's possible we didn't find a path. this happens if the column is generated\n    // by the grid (auto-group), in that the definition didn't come from the client. in this case,\n    // we create a fake original path.\n\n    if (found) {\n      return result;\n    }\n\n    console.warn('could not get path');\n    return null;\n  };\n\n  DisplayedGroupCreator = __decorate([Bean('displayedGroupCreator')], DisplayedGroupCreator);\n  return DisplayedGroupCreator;\n}(BeanStub);\n\nexport { DisplayedGroupCreator };","map":{"version":3,"sources":["/Users/rongxuan/Desktop/reactmap/reactmap/node_modules/@ag-grid-community/core/dist/es6/columns/displayedGroupCreator.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","ColumnGroup","ProvidedColumnGroup","Bean","BeanStub","last","exists","DisplayedGroupCreator","_super","apply","createDisplayedGroups","sortedVisibleColumns","balancedColumnTree","groupInstanceIdCreator","pinned","oldDisplayedGroups","_this","result","previousRealPath","previousOriginalPath","oldColumnsMapped","mapOldGroupsById","forEach","currentColumn","currentOriginalPath","getOriginalPathForColumn","currentRealPath","firstColumn","newGroup","createColumnGroup","push","addChild","noColumnGroups","leafGroup","setupParentsIntoColumns","originalGroup","groupId","getGroupId","instanceId","getInstanceIdForKey","uniqueId","createUniqueId","columnGroup","getOriginalColumnGroup","reset","context","createBean","displayedGroups","recursive","columnsOrGroups","columnOrGroup","getUniqueId","getChildren","parent","columnsOrGroup","setParent","column","found","recursePath","columnTree","dept","node","nextNode","console","warn"],"mappings":"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","sourcesContent":["/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v26.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { ColumnGroup } from \"../entities/columnGroup\";\nimport { ProvidedColumnGroup } from \"../entities/providedColumnGroup\";\nimport { Bean } from \"../context/context\";\nimport { BeanStub } from \"../context/beanStub\";\nimport { last } from \"../utils/array\";\nimport { exists } from \"../utils/generic\";\n// takes in a list of columns, as specified by the column definitions, and returns column groups\nvar DisplayedGroupCreator = /** @class */ (function (_super) {\n    __extends(DisplayedGroupCreator, _super);\n    function DisplayedGroupCreator() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    DisplayedGroupCreator.prototype.createDisplayedGroups = function (\n    // all displayed columns sorted - this is the columns the grid should show\n    sortedVisibleColumns, \n    // the tree of columns, as provided by the users, used to know what groups columns roll up into\n    balancedColumnTree, \n    // creates unique id's for the group\n    groupInstanceIdCreator, \n    // whether it's left, right or center col\n    pinned, \n    // we try to reuse old groups if we can, to allow gui to do animation\n    oldDisplayedGroups) {\n        var _this = this;\n        var result = [];\n        var previousRealPath;\n        var previousOriginalPath;\n        var oldColumnsMapped = this.mapOldGroupsById(oldDisplayedGroups);\n        // go through each column, then do a bottom up comparison to the previous column, and start\n        // to share groups if they converge at any point.\n        sortedVisibleColumns.forEach(function (currentColumn) {\n            var currentOriginalPath = _this.getOriginalPathForColumn(balancedColumnTree, currentColumn);\n            var currentRealPath = [];\n            var firstColumn = !previousOriginalPath;\n            for (var i = 0; i < currentOriginalPath.length; i++) {\n                if (firstColumn || currentOriginalPath[i] !== previousOriginalPath[i]) {\n                    // new group needed\n                    var newGroup = _this.createColumnGroup(currentOriginalPath[i], groupInstanceIdCreator, oldColumnsMapped, pinned);\n                    currentRealPath[i] = newGroup;\n                    // if top level, add to result, otherwise add to parent\n                    if (i == 0) {\n                        result.push(newGroup);\n                    }\n                    else {\n                        currentRealPath[i - 1].addChild(newGroup);\n                    }\n                }\n                else {\n                    // reuse old group\n                    currentRealPath[i] = previousRealPath[i];\n                }\n            }\n            var noColumnGroups = currentRealPath.length === 0;\n            if (noColumnGroups) {\n                // if we are not grouping, then the result of the above is an empty\n                // path (no groups), and we just add the column to the root list.\n                result.push(currentColumn);\n            }\n            else {\n                var leafGroup = last(currentRealPath);\n                leafGroup.addChild(currentColumn);\n            }\n            previousRealPath = currentRealPath;\n            previousOriginalPath = currentOriginalPath;\n        });\n        this.setupParentsIntoColumns(result, null);\n        return result;\n    };\n    DisplayedGroupCreator.prototype.createColumnGroup = function (originalGroup, groupInstanceIdCreator, oldColumnsMapped, pinned) {\n        var groupId = originalGroup.getGroupId();\n        var instanceId = groupInstanceIdCreator.getInstanceIdForKey(groupId);\n        var uniqueId = ColumnGroup.createUniqueId(groupId, instanceId);\n        var columnGroup = oldColumnsMapped[uniqueId];\n        // if the user is setting new colDefs, it is possible that the id's overlap, and we\n        // would have a false match from above. so we double check we are talking about the\n        // same original column group.\n        if (columnGroup && columnGroup.getOriginalColumnGroup() !== originalGroup) {\n            columnGroup = null;\n        }\n        if (exists(columnGroup)) {\n            // clean out the old column group here, as we will be adding children into it again\n            columnGroup.reset();\n        }\n        else {\n            columnGroup = new ColumnGroup(originalGroup, groupId, instanceId, pinned);\n            this.context.createBean(columnGroup);\n        }\n        return columnGroup;\n    };\n    // returns back a 2d map of ColumnGroup as follows: groupId -> instanceId -> ColumnGroup\n    DisplayedGroupCreator.prototype.mapOldGroupsById = function (displayedGroups) {\n        var result = {};\n        var recursive = function (columnsOrGroups) {\n            columnsOrGroups.forEach(function (columnOrGroup) {\n                if (columnOrGroup instanceof ColumnGroup) {\n                    var columnGroup = columnOrGroup;\n                    result[columnOrGroup.getUniqueId()] = columnGroup;\n                    recursive(columnGroup.getChildren());\n                }\n            });\n        };\n        if (displayedGroups) {\n            recursive(displayedGroups);\n        }\n        return result;\n    };\n    DisplayedGroupCreator.prototype.setupParentsIntoColumns = function (columnsOrGroups, parent) {\n        var _this = this;\n        columnsOrGroups.forEach(function (columnsOrGroup) {\n            columnsOrGroup.setParent(parent);\n            if (columnsOrGroup instanceof ColumnGroup) {\n                var columnGroup = columnsOrGroup;\n                _this.setupParentsIntoColumns(columnGroup.getChildren(), columnGroup);\n            }\n        });\n    };\n    DisplayedGroupCreator.prototype.getOriginalPathForColumn = function (balancedColumnTree, column) {\n        var result = [];\n        var found = false;\n        var recursePath = function (columnTree, dept) {\n            for (var i = 0; i < columnTree.length; i++) {\n                // quit the search, so 'result' is kept with the found result\n                if (found) {\n                    return;\n                }\n                var node = columnTree[i];\n                if (node instanceof ProvidedColumnGroup) {\n                    var nextNode = node;\n                    recursePath(nextNode.getChildren(), dept + 1);\n                    result[dept] = node;\n                }\n                else if (node === column) {\n                    found = true;\n                }\n            }\n        };\n        recursePath(balancedColumnTree, 0);\n        // it's possible we didn't find a path. this happens if the column is generated\n        // by the grid (auto-group), in that the definition didn't come from the client. in this case,\n        // we create a fake original path.\n        if (found) {\n            return result;\n        }\n        console.warn('could not get path');\n        return null;\n    };\n    DisplayedGroupCreator = __decorate([\n        Bean('displayedGroupCreator')\n    ], DisplayedGroupCreator);\n    return DisplayedGroupCreator;\n}(BeanStub));\nexport { DisplayedGroupCreator };\n"]},"metadata":{},"sourceType":"module"}