{"ast":null,"code":"/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v26.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { Autowired, PostConstruct } from \"../context/context\";\nimport { BeanStub } from \"../context/beanStub\";\nimport { getInnerHeight, getScrollLeft, isRtlNegativeScroll, setScrollLeft } from \"../utils/dom\";\nimport { Events } from \"../eventKeys\";\nimport { debounce } from \"../utils/function\";\nimport { isIOSUserAgent } from \"../utils/browser\";\nimport { Constants } from \"../constants/constants\";\nimport { assign } from \"../utils/object\";\n\nvar GridBodyScrollFeature =\n/** @class */\nfunction (_super) {\n  __extends(GridBodyScrollFeature, _super);\n\n  function GridBodyScrollFeature(eBodyViewport) {\n    var _this = _super.call(this) || this;\n\n    _this.scrollLeft = -1;\n    _this.nextScrollTop = -1;\n    _this.scrollTop = -1;\n    _this.eBodyViewport = eBodyViewport;\n    _this.resetLastHorizontalScrollElementDebounced = debounce(_this.resetLastHorizontalScrollElement.bind(_this), 500);\n    return _this;\n  }\n\n  GridBodyScrollFeature.prototype.postConstruct = function () {\n    var _this = this;\n\n    this.enableRtl = this.gridOptionsWrapper.isEnableRtl();\n    this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onDisplayedColumnsWidthChanged.bind(this));\n    this.ctrlsService.whenReady(function (p) {\n      _this.centerRowContainerCon = p.centerRowContainerCtrl;\n\n      _this.onDisplayedColumnsWidthChanged();\n\n      _this.addScrollListener();\n    });\n  };\n\n  GridBodyScrollFeature.prototype.addScrollListener = function () {\n    var fakeHScroll = this.ctrlsService.getFakeHScrollCtrl();\n    this.addManagedListener(this.centerRowContainerCon.getViewportElement(), 'scroll', this.onCenterViewportScroll.bind(this));\n    this.addManagedListener(fakeHScroll.getViewport(), 'scroll', this.onFakeHorizontalScroll.bind(this));\n    var onVerticalScroll = this.gridOptionsWrapper.isDebounceVerticalScrollbar() ? debounce(this.onVerticalScroll.bind(this), 100) : this.onVerticalScroll.bind(this);\n    this.addManagedListener(this.eBodyViewport, 'scroll', onVerticalScroll);\n  };\n\n  GridBodyScrollFeature.prototype.onDisplayedColumnsWidthChanged = function () {\n    if (this.enableRtl) {\n      // because RTL is all backwards, a change in the width of the row\n      // can cause a change in the scroll position, without a scroll event,\n      // because the scroll position in RTL is a function that depends on\n      // the width. to be convinced of this, take out this line, enable RTL,\n      // scroll all the way to the left and then resize a column\n      this.horizontallyScrollHeaderCenterAndFloatingCenter();\n    }\n  };\n\n  GridBodyScrollFeature.prototype.horizontallyScrollHeaderCenterAndFloatingCenter = function (scrollLeft) {\n    if (scrollLeft === undefined) {\n      scrollLeft = this.centerRowContainerCon.getCenterViewportScrollLeft();\n    }\n\n    var offset = this.enableRtl ? scrollLeft : -scrollLeft;\n    var topCenterContainer = this.ctrlsService.getTopCenterRowContainerCtrl();\n    var bottomCenterContainer = this.ctrlsService.getBottomCenterRowContainerCtrl();\n    var fakeHScroll = this.ctrlsService.getFakeHScrollCtrl();\n    var centerHeaderContainer = this.ctrlsService.getHeaderRowContainerCtrl();\n    centerHeaderContainer.setHorizontalScroll(offset);\n    bottomCenterContainer.setContainerTranslateX(offset);\n    topCenterContainer.setContainerTranslateX(offset);\n    var partner = this.lastHorizontalScrollElement === this.centerRowContainerCon.getViewportElement() ? fakeHScroll.getViewport() : this.centerRowContainerCon.getViewportElement();\n    setScrollLeft(partner, Math.abs(scrollLeft), this.enableRtl);\n  };\n\n  GridBodyScrollFeature.prototype.isControllingScroll = function (eDiv) {\n    if (!this.lastHorizontalScrollElement) {\n      this.lastHorizontalScrollElement = eDiv;\n      return true;\n    }\n\n    return eDiv === this.lastHorizontalScrollElement;\n  };\n\n  GridBodyScrollFeature.prototype.onFakeHorizontalScroll = function () {\n    var fakeHScrollViewport = this.ctrlsService.getFakeHScrollCtrl().getViewport();\n\n    if (!this.isControllingScroll(fakeHScrollViewport)) {\n      return;\n    }\n\n    this.onBodyHorizontalScroll(fakeHScrollViewport);\n  };\n\n  GridBodyScrollFeature.prototype.onCenterViewportScroll = function () {\n    var centerContainerViewport = this.centerRowContainerCon.getViewportElement();\n\n    if (!this.isControllingScroll(centerContainerViewport)) {\n      return;\n    }\n\n    this.onBodyHorizontalScroll(centerContainerViewport);\n  };\n\n  GridBodyScrollFeature.prototype.onBodyHorizontalScroll = function (eSource) {\n    var centerContainerViewport = this.centerRowContainerCon.getViewportElement();\n    var scrollLeft = centerContainerViewport.scrollLeft;\n\n    if (this.shouldBlockScrollUpdate('horizontal', scrollLeft, true)) {\n      return;\n    } // we do Math.round() rather than Math.floor(), to mirror how scroll values are applied.\n    // eg if a scale is applied (ie user has zoomed the browser), then applying scroll=200\n    // could result in 199.88, which then floor(199.88) = 199, however round(199.88) = 200.\n    // initially Math.floor() was used, however this caused (almost) infinite loop with aligned grids,\n    // as the scroll would move 1px at at time bouncing from one grid to the next (eg one grid would cause\n    // scroll to 200px, the next to 199px, then the first back to 198px and so on).\n\n\n    this.doHorizontalScroll(Math.round(getScrollLeft(eSource, this.enableRtl)));\n    this.resetLastHorizontalScrollElementDebounced();\n  };\n\n  GridBodyScrollFeature.prototype.onVerticalScroll = function () {\n    var scrollTop = this.eBodyViewport.scrollTop;\n\n    if (this.shouldBlockScrollUpdate('vertical', scrollTop, true)) {\n      return;\n    }\n\n    this.animationFrameService.setScrollTop(scrollTop);\n    this.nextScrollTop = scrollTop;\n\n    if (this.gridOptionsWrapper.isSuppressAnimationFrame()) {\n      this.scrollTop = this.nextScrollTop;\n      this.redrawRowsAfterScroll();\n    } else {\n      this.animationFrameService.schedule();\n    }\n  };\n\n  GridBodyScrollFeature.prototype.resetLastHorizontalScrollElement = function () {\n    this.lastHorizontalScrollElement = null;\n  };\n\n  GridBodyScrollFeature.prototype.doHorizontalScroll = function (scrollLeft) {\n    var fakeHScrollViewport = this.ctrlsService.getFakeHScrollCtrl().getViewport();\n    var fakeScrollLeft = getScrollLeft(fakeHScrollViewport, this.enableRtl);\n\n    if (this.scrollLeft === scrollLeft && scrollLeft === fakeScrollLeft) {\n      return;\n    }\n\n    this.scrollLeft = scrollLeft;\n    this.fireScrollEvent('horizontal');\n    this.horizontallyScrollHeaderCenterAndFloatingCenter(scrollLeft);\n    this.onHorizontalViewportChanged();\n  };\n\n  GridBodyScrollFeature.prototype.fireScrollEvent = function (direction) {\n    var _this = this;\n\n    var bodyScrollEvent = {\n      type: Events.EVENT_BODY_SCROLL,\n      api: this.gridApi,\n      columnApi: this.columnApi,\n      direction: direction,\n      left: this.scrollLeft,\n      top: this.scrollTop\n    };\n    this.eventService.dispatchEvent(bodyScrollEvent);\n    window.clearTimeout(this.scrollTimer);\n    this.scrollTimer = undefined;\n    this.scrollTimer = window.setTimeout(function () {\n      var bodyScrollEndEvent = assign({}, bodyScrollEvent, {\n        type: Events.EVENT_BODY_SCROLL_END\n      });\n\n      _this.eventService.dispatchEvent(bodyScrollEndEvent);\n    }, 100);\n  };\n\n  GridBodyScrollFeature.prototype.shouldBlockScrollUpdate = function (direction, scrollTo, touchOnly) {\n    // touch devices allow elastic scroll - which temporally scrolls the panel outside of the viewport\n    // (eg user uses touch to go to the left of the grid, but drags past the left, the rows will actually\n    // scroll past the left until the user releases the mouse). when this happens, we want ignore the scroll,\n    // as otherwise it was causing the rows and header to flicker.\n    if (touchOnly === void 0) {\n      touchOnly = false;\n    } // sometimes when scrolling, we got values that extended the maximum scroll allowed. we used to\n    // ignore these scrolls. problem is the max scroll position could be skipped (eg the previous scroll event\n    // could be 10px before the max position, and then current scroll event could be 20px after the max position).\n    // if we just ignored the last event, we would be setting the scroll to 10px before the max position, when in\n    // actual fact the user has exceeded the max scroll and thus scroll should be set to the max.\n\n\n    if (touchOnly && !isIOSUserAgent()) {\n      return false;\n    }\n\n    if (direction === 'vertical') {\n      var clientHeight = getInnerHeight(this.eBodyViewport);\n      var scrollHeight = this.eBodyViewport.scrollHeight;\n\n      if (scrollTo < 0 || scrollTo + clientHeight > scrollHeight) {\n        return true;\n      }\n    }\n\n    if (direction === 'horizontal') {\n      var clientWidth = this.centerRowContainerCon.getCenterWidth();\n      var scrollWidth = this.centerRowContainerCon.getViewportElement().scrollWidth;\n\n      if (this.enableRtl && isRtlNegativeScroll()) {\n        if (scrollTo > 0) {\n          return true;\n        }\n      } else if (scrollTo < 0) {\n        return true;\n      }\n\n      if (Math.abs(scrollTo) + clientWidth > scrollWidth) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  GridBodyScrollFeature.prototype.redrawRowsAfterScroll = function () {\n    this.fireScrollEvent('vertical');\n  };\n\n  GridBodyScrollFeature.prototype.onHorizontalViewportChanged = function () {\n    this.centerRowContainerCon.onHorizontalViewportChanged();\n  }; // this is to cater for AG-3274, where grid is removed from the dom and then inserted back in again.\n  // (which happens with some implementations of tabbing). this can result in horizontal scroll getting\n  // reset back to the left, however no scroll event is fired. so we need to get header to also scroll\n  // back to the left to be kept in sync.\n  // adding and removing the grid from the DOM both resets the scroll position and\n  // triggers a resize event, so notify listeners if the scroll position has changed\n\n\n  GridBodyScrollFeature.prototype.checkScrollLeft = function () {\n    if (this.scrollLeft !== this.centerRowContainerCon.getCenterViewportScrollLeft()) {\n      this.onBodyHorizontalScroll(this.centerRowContainerCon.getViewportElement());\n    }\n  };\n\n  GridBodyScrollFeature.prototype.executeAnimationFrameScroll = function () {\n    var frameNeeded = this.scrollTop != this.nextScrollTop;\n\n    if (frameNeeded) {\n      this.scrollTop = this.nextScrollTop;\n      this.redrawRowsAfterScroll();\n    }\n\n    return frameNeeded;\n  }; // called by scrollHorizontally method and alignedGridsService\n\n\n  GridBodyScrollFeature.prototype.setHorizontalScrollPosition = function (hScrollPosition) {\n    var minScrollLeft = 0;\n    var maxScrollLeft = this.centerRowContainerCon.getViewportElement().scrollWidth - this.centerRowContainerCon.getCenterWidth();\n\n    if (this.shouldBlockScrollUpdate('horizontal', hScrollPosition)) {\n      if (this.enableRtl && isRtlNegativeScroll()) {\n        hScrollPosition = hScrollPosition > 0 ? 0 : maxScrollLeft;\n      } else {\n        hScrollPosition = Math.min(Math.max(hScrollPosition, minScrollLeft), maxScrollLeft);\n      }\n    }\n\n    setScrollLeft(this.centerRowContainerCon.getViewportElement(), Math.abs(hScrollPosition), this.enableRtl); // we need to manually do the event handling (rather than wait for the event)\n    // for the alignedGridsService, as if we don't, the aligned grid service gets\n    // notified async, and then it's 'consuming' flag doesn't get used right, and\n    // we can end up with an infinite loop\n\n    this.doHorizontalScroll(hScrollPosition);\n  };\n\n  GridBodyScrollFeature.prototype.setVerticalScrollPosition = function (vScrollPosition) {\n    this.eBodyViewport.scrollTop = vScrollPosition;\n  };\n\n  GridBodyScrollFeature.prototype.getVScrollPosition = function () {\n    var result = {\n      top: this.eBodyViewport.scrollTop,\n      bottom: this.eBodyViewport.scrollTop + this.eBodyViewport.offsetHeight\n    };\n    return result;\n  };\n\n  GridBodyScrollFeature.prototype.getHScrollPosition = function () {\n    return this.centerRowContainerCon.getHScrollPosition();\n  };\n\n  GridBodyScrollFeature.prototype.isHorizontalScrollShowing = function () {\n    return this.centerRowContainerCon.isHorizontalScrollShowing();\n  }; // called by the headerRootComp and moveColumnController\n\n\n  GridBodyScrollFeature.prototype.scrollHorizontally = function (pixels) {\n    var oldScrollPosition = this.centerRowContainerCon.getViewportElement().scrollLeft;\n    this.setHorizontalScrollPosition(oldScrollPosition + pixels);\n    return this.centerRowContainerCon.getViewportElement().scrollLeft - oldScrollPosition;\n  }; // gets called by rowRenderer when new data loaded, as it will want to scroll to the top\n\n\n  GridBodyScrollFeature.prototype.scrollToTop = function () {\n    this.eBodyViewport.scrollTop = 0;\n  }; // Valid values for position are bottom, middle and top\n\n\n  GridBodyScrollFeature.prototype.ensureNodeVisible = function (comparator, position) {\n    if (position === void 0) {\n      position = null;\n    } // look for the node index we want to display\n\n\n    var rowCount = this.rowModel.getRowCount();\n    var comparatorIsAFunction = typeof comparator === 'function';\n    var indexToSelect = -1; // go through all the nodes, find the one we want to show\n\n    for (var i = 0; i < rowCount; i++) {\n      var node = this.rowModel.getRow(i);\n\n      if (comparatorIsAFunction) {\n        if (comparator(node)) {\n          indexToSelect = i;\n          break;\n        }\n      } else {\n        // check object equality against node and data\n        if (comparator === node || comparator === node.data) {\n          indexToSelect = i;\n          break;\n        }\n      }\n    }\n\n    if (indexToSelect >= 0) {\n      this.ensureIndexVisible(indexToSelect, position);\n    }\n  }; // Valid values for position are bottom, middle and top\n  // position should be {'top','middle','bottom', or undefined/null}.\n  // if undefined/null, then the grid will to the minimal amount of scrolling,\n  // eg if grid needs to scroll up, it scrolls until row is on top,\n  //    if grid needs to scroll down, it scrolls until row is on bottom,\n  //    if row is already in view, grid does not scroll\n\n\n  GridBodyScrollFeature.prototype.ensureIndexVisible = function (index, position) {\n    // if for print or auto height, everything is always visible\n    if (this.gridOptionsWrapper.getDomLayout() === Constants.DOM_LAYOUT_PRINT) {\n      return;\n    }\n\n    var rowCount = this.paginationProxy.getRowCount();\n\n    if (typeof index !== 'number' || index < 0 || index >= rowCount) {\n      console.warn('invalid row index for ensureIndexVisible: ' + index);\n      return;\n    }\n\n    var isPaging = this.gridOptionsWrapper.isPagination();\n    var paginationPanelEnabled = isPaging && !this.gridOptionsWrapper.isSuppressPaginationPanel();\n\n    if (!paginationPanelEnabled) {\n      this.paginationProxy.goToPageWithIndex(index);\n    }\n\n    var rowNode = this.paginationProxy.getRow(index);\n    var rowGotShiftedDuringOperation;\n\n    do {\n      var startingRowTop = rowNode.rowTop;\n      var startingRowHeight = rowNode.rowHeight;\n      var paginationOffset = this.paginationProxy.getPixelOffset();\n      var rowTopPixel = rowNode.rowTop - paginationOffset;\n      var rowBottomPixel = rowTopPixel + rowNode.rowHeight;\n      var scrollPosition = this.getVScrollPosition();\n      var heightOffset = this.heightScaler.getDivStretchOffset();\n      var vScrollTop = scrollPosition.top + heightOffset;\n      var vScrollBottom = scrollPosition.bottom + heightOffset;\n      var viewportHeight = vScrollBottom - vScrollTop; // work out the pixels for top, middle and bottom up front,\n      // make the if/else below easier to read\n\n      var pxTop = this.heightScaler.getScrollPositionForPixel(rowTopPixel);\n      var pxBottom = this.heightScaler.getScrollPositionForPixel(rowBottomPixel - viewportHeight); // make sure if middle, the row is not outside the top of the grid\n\n      var pxMiddle = Math.min((pxTop + pxBottom) / 2, rowTopPixel);\n      var rowBelowViewport = vScrollTop > rowTopPixel;\n      var rowAboveViewport = vScrollBottom < rowBottomPixel;\n      var newScrollPosition = null;\n\n      if (position === 'top') {\n        newScrollPosition = pxTop;\n      } else if (position === 'bottom') {\n        newScrollPosition = pxBottom;\n      } else if (position === 'middle') {\n        newScrollPosition = pxMiddle;\n      } else if (rowBelowViewport) {\n        // if row is before, scroll up with row at top\n        newScrollPosition = pxTop;\n      } else if (rowAboveViewport) {\n        // if row is below, scroll down with row at bottom\n        newScrollPosition = pxBottom;\n      }\n\n      if (newScrollPosition !== null) {\n        this.eBodyViewport.scrollTop = newScrollPosition;\n        this.rowRenderer.redrawAfterScroll();\n      } // the row can get shifted if during the rendering (during rowRenderer.redrawAfterScroll()),\n      // the height of a row changes due to lazy calculation of row heights when using\n      // colDef.autoHeight or gridOptions.getRowHeight.\n      // if row was shifted, then the position we scrolled to is incorrect.\n\n\n      rowGotShiftedDuringOperation = startingRowTop !== rowNode.rowTop || startingRowHeight !== rowNode.rowHeight;\n    } while (rowGotShiftedDuringOperation); // so when we return back to user, the cells have rendered\n\n\n    this.animationFrameService.flushAllFrames();\n  };\n\n  GridBodyScrollFeature.prototype.ensureColumnVisible = function (key) {\n    var column = this.columnModel.getGridColumn(key);\n\n    if (!column) {\n      return;\n    } // calling ensureColumnVisible on a pinned column doesn't make sense\n\n\n    if (column.isPinned()) {\n      return;\n    } // defensive\n\n\n    if (!this.columnModel.isColumnDisplayed(column)) {\n      return;\n    }\n\n    var colLeftPixel = column.getLeft();\n    var colRightPixel = colLeftPixel + column.getActualWidth();\n    var viewportWidth = this.centerRowContainerCon.getCenterWidth();\n    var scrollPosition = this.centerRowContainerCon.getCenterViewportScrollLeft();\n    var bodyWidth = this.columnModel.getBodyContainerWidth();\n    var viewportLeftPixel;\n    var viewportRightPixel; // the logic of working out left and right viewport px is both here and in the ColumnController,\n    // need to refactor it out to one place\n\n    if (this.enableRtl) {\n      viewportLeftPixel = bodyWidth - scrollPosition - viewportWidth;\n      viewportRightPixel = bodyWidth - scrollPosition;\n    } else {\n      viewportLeftPixel = scrollPosition;\n      viewportRightPixel = viewportWidth + scrollPosition;\n    }\n\n    var viewportScrolledPastCol = viewportLeftPixel > colLeftPixel;\n    var viewportScrolledBeforeCol = viewportRightPixel < colRightPixel;\n    var colToSmallForViewport = viewportWidth < column.getActualWidth();\n    var alignColToLeft = viewportScrolledPastCol || colToSmallForViewport;\n    var alignColToRight = viewportScrolledBeforeCol;\n\n    if (alignColToLeft || alignColToRight) {\n      var newScrollPosition = void 0;\n\n      if (this.enableRtl) {\n        newScrollPosition = alignColToLeft ? bodyWidth - viewportWidth - colLeftPixel : bodyWidth - colRightPixel;\n      } else {\n        newScrollPosition = alignColToLeft ? colLeftPixel : colRightPixel - viewportWidth;\n      }\n\n      this.centerRowContainerCon.setCenterViewportScrollLeft(newScrollPosition);\n    } else {// otherwise, col is already in view, so do nothing\n    } // this will happen anyway, as the move will cause a 'scroll' event on the body, however\n    // it is possible that the ensureColumnVisible method is called from within AG Grid and\n    // the caller will need to have the columns rendered to continue, which will be before\n    // the event has been worked on (which is the case for cell navigation).\n\n\n    this.centerRowContainerCon.onHorizontalViewportChanged(); // so when we return back to user, the cells have rendered\n\n    this.animationFrameService.flushAllFrames();\n  };\n\n  __decorate([Autowired('ctrlsService')], GridBodyScrollFeature.prototype, \"ctrlsService\", void 0);\n\n  __decorate([Autowired('animationFrameService')], GridBodyScrollFeature.prototype, \"animationFrameService\", void 0);\n\n  __decorate([Autowired('columnApi')], GridBodyScrollFeature.prototype, \"columnApi\", void 0);\n\n  __decorate([Autowired('gridApi')], GridBodyScrollFeature.prototype, \"gridApi\", void 0);\n\n  __decorate([Autowired('paginationProxy')], GridBodyScrollFeature.prototype, \"paginationProxy\", void 0);\n\n  __decorate([Autowired('rowModel')], GridBodyScrollFeature.prototype, \"rowModel\", void 0);\n\n  __decorate([Autowired('rowContainerHeightService')], GridBodyScrollFeature.prototype, \"heightScaler\", void 0);\n\n  __decorate([Autowired('rowRenderer')], GridBodyScrollFeature.prototype, \"rowRenderer\", void 0);\n\n  __decorate([Autowired('columnModel')], GridBodyScrollFeature.prototype, \"columnModel\", void 0);\n\n  __decorate([PostConstruct], GridBodyScrollFeature.prototype, \"postConstruct\", null);\n\n  return GridBodyScrollFeature;\n}(BeanStub);\n\nexport { GridBodyScrollFeature };","map":{"version":3,"sources":["/Users/rongxuan/Desktop/reactmap/reactmap/node_modules/@ag-grid-community/core/dist/es6/gridBodyComp/gridBodyScrollFeature.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","Autowired","PostConstruct","BeanStub","getInnerHeight","getScrollLeft","isRtlNegativeScroll","setScrollLeft","Events","debounce","isIOSUserAgent","Constants","assign","GridBodyScrollFeature","_super","eBodyViewport","_this","call","scrollLeft","nextScrollTop","scrollTop","resetLastHorizontalScrollElementDebounced","resetLastHorizontalScrollElement","bind","postConstruct","enableRtl","gridOptionsWrapper","isEnableRtl","addManagedListener","eventService","EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED","onDisplayedColumnsWidthChanged","ctrlsService","whenReady","centerRowContainerCon","centerRowContainerCtrl","addScrollListener","fakeHScroll","getFakeHScrollCtrl","getViewportElement","onCenterViewportScroll","getViewport","onFakeHorizontalScroll","onVerticalScroll","isDebounceVerticalScrollbar","horizontallyScrollHeaderCenterAndFloatingCenter","undefined","getCenterViewportScrollLeft","offset","topCenterContainer","getTopCenterRowContainerCtrl","bottomCenterContainer","getBottomCenterRowContainerCtrl","centerHeaderContainer","getHeaderRowContainerCtrl","setHorizontalScroll","setContainerTranslateX","partner","lastHorizontalScrollElement","Math","abs","isControllingScroll","eDiv","fakeHScrollViewport","onBodyHorizontalScroll","centerContainerViewport","eSource","shouldBlockScrollUpdate","doHorizontalScroll","round","animationFrameService","setScrollTop","isSuppressAnimationFrame","redrawRowsAfterScroll","schedule","fakeScrollLeft","fireScrollEvent","onHorizontalViewportChanged","direction","bodyScrollEvent","type","EVENT_BODY_SCROLL","api","gridApi","columnApi","left","top","dispatchEvent","window","clearTimeout","scrollTimer","setTimeout","bodyScrollEndEvent","EVENT_BODY_SCROLL_END","scrollTo","touchOnly","clientHeight","scrollHeight","clientWidth","getCenterWidth","scrollWidth","checkScrollLeft","executeAnimationFrameScroll","frameNeeded","setHorizontalScrollPosition","hScrollPosition","minScrollLeft","maxScrollLeft","min","max","setVerticalScrollPosition","vScrollPosition","getVScrollPosition","result","bottom","offsetHeight","getHScrollPosition","isHorizontalScrollShowing","scrollHorizontally","pixels","oldScrollPosition","scrollToTop","ensureNodeVisible","comparator","position","rowCount","rowModel","getRowCount","comparatorIsAFunction","indexToSelect","node","getRow","data","ensureIndexVisible","index","getDomLayout","DOM_LAYOUT_PRINT","paginationProxy","console","warn","isPaging","isPagination","paginationPanelEnabled","isSuppressPaginationPanel","goToPageWithIndex","rowNode","rowGotShiftedDuringOperation","startingRowTop","rowTop","startingRowHeight","rowHeight","paginationOffset","getPixelOffset","rowTopPixel","rowBottomPixel","scrollPosition","heightOffset","heightScaler","getDivStretchOffset","vScrollTop","vScrollBottom","viewportHeight","pxTop","getScrollPositionForPixel","pxBottom","pxMiddle","rowBelowViewport","rowAboveViewport","newScrollPosition","rowRenderer","redrawAfterScroll","flushAllFrames","ensureColumnVisible","column","columnModel","getGridColumn","isPinned","isColumnDisplayed","colLeftPixel","getLeft","colRightPixel","getActualWidth","viewportWidth","bodyWidth","getBodyContainerWidth","viewportLeftPixel","viewportRightPixel","viewportScrolledPastCol","viewportScrolledBeforeCol","colToSmallForViewport","alignColToLeft","alignColToRight","setCenterViewportScrollLeft"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIA,SAAS,GAAI,QAAQ,KAAKA,SAAd,IAA6B,YAAY;AACrD,MAAIC,aAAa,GAAG,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AAChCF,IAAAA,aAAa,GAAGG,MAAM,CAACC,cAAP,IACX;AAAEC,MAAAA,SAAS,EAAE;AAAb,iBAA6BC,KAA7B,IAAsC,UAAUL,CAAV,EAAaC,CAAb,EAAgB;AAAED,MAAAA,CAAC,CAACI,SAAF,GAAcH,CAAd;AAAkB,KAD/D,IAEZ,UAAUD,CAAV,EAAaC,CAAb,EAAgB;AAAE,WAAK,IAAIK,CAAT,IAAcL,CAAd,EAAiB,IAAIA,CAAC,CAACM,cAAF,CAAiBD,CAAjB,CAAJ,EAAyBN,CAAC,CAACM,CAAD,CAAD,GAAOL,CAAC,CAACK,CAAD,CAAR;AAAc,KAF9E;;AAGA,WAAOP,aAAa,CAACC,CAAD,EAAIC,CAAJ,CAApB;AACH,GALD;;AAMA,SAAO,UAAUD,CAAV,EAAaC,CAAb,EAAgB;AACnBF,IAAAA,aAAa,CAACC,CAAD,EAAIC,CAAJ,CAAb;;AACA,aAASO,EAAT,GAAc;AAAE,WAAKC,WAAL,GAAmBT,CAAnB;AAAuB;;AACvCA,IAAAA,CAAC,CAACU,SAAF,GAAcT,CAAC,KAAK,IAAN,GAAaC,MAAM,CAACS,MAAP,CAAcV,CAAd,CAAb,IAAiCO,EAAE,CAACE,SAAH,GAAeT,CAAC,CAACS,SAAjB,EAA4B,IAAIF,EAAJ,EAA7D,CAAd;AACH,GAJD;AAKH,CAZ2C,EAA5C;;AAaA,IAAII,UAAU,GAAI,QAAQ,KAAKA,UAAd,IAA6B,UAAUC,UAAV,EAAsBC,MAAtB,EAA8BC,GAA9B,EAAmCC,IAAnC,EAAyC;AACnF,MAAIC,CAAC,GAAGC,SAAS,CAACC,MAAlB;AAAA,MAA0BC,CAAC,GAAGH,CAAC,GAAG,CAAJ,GAAQH,MAAR,GAAiBE,IAAI,KAAK,IAAT,GAAgBA,IAAI,GAAGd,MAAM,CAACmB,wBAAP,CAAgCP,MAAhC,EAAwCC,GAAxC,CAAvB,GAAsEC,IAArH;AAAA,MAA2HhB,CAA3H;AACA,MAAI,OAAOsB,OAAP,KAAmB,QAAnB,IAA+B,OAAOA,OAAO,CAACC,QAAf,KAA4B,UAA/D,EAA2EH,CAAC,GAAGE,OAAO,CAACC,QAAR,CAAiBV,UAAjB,EAA6BC,MAA7B,EAAqCC,GAArC,EAA0CC,IAA1C,CAAJ,CAA3E,KACK,KAAK,IAAIQ,CAAC,GAAGX,UAAU,CAACM,MAAX,GAAoB,CAAjC,EAAoCK,CAAC,IAAI,CAAzC,EAA4CA,CAAC,EAA7C,EAAiD,IAAIxB,CAAC,GAAGa,UAAU,CAACW,CAAD,CAAlB,EAAuBJ,CAAC,GAAG,CAACH,CAAC,GAAG,CAAJ,GAAQjB,CAAC,CAACoB,CAAD,CAAT,GAAeH,CAAC,GAAG,CAAJ,GAAQjB,CAAC,CAACc,MAAD,EAASC,GAAT,EAAcK,CAAd,CAAT,GAA4BpB,CAAC,CAACc,MAAD,EAASC,GAAT,CAA7C,KAA+DK,CAAnE;AAC7E,SAAOH,CAAC,GAAG,CAAJ,IAASG,CAAT,IAAclB,MAAM,CAACuB,cAAP,CAAsBX,MAAtB,EAA8BC,GAA9B,EAAmCK,CAAnC,CAAd,EAAqDA,CAA5D;AACH,CALD;;AAMA,SAASM,SAAT,EAAoBC,aAApB,QAAyC,oBAAzC;AACA,SAASC,QAAT,QAAyB,qBAAzB;AACA,SAASC,cAAT,EAAyBC,aAAzB,EAAwCC,mBAAxC,EAA6DC,aAA7D,QAAkF,cAAlF;AACA,SAASC,MAAT,QAAuB,cAAvB;AACA,SAASC,QAAT,QAAyB,mBAAzB;AACA,SAASC,cAAT,QAA+B,kBAA/B;AACA,SAASC,SAAT,QAA0B,wBAA1B;AACA,SAASC,MAAT,QAAuB,iBAAvB;;AACA,IAAIC,qBAAqB;AAAG;AAAe,UAAUC,MAAV,EAAkB;AACzDzC,EAAAA,SAAS,CAACwC,qBAAD,EAAwBC,MAAxB,CAAT;;AACA,WAASD,qBAAT,CAA+BE,aAA/B,EAA8C;AAC1C,QAAIC,KAAK,GAAGF,MAAM,CAACG,IAAP,CAAY,IAAZ,KAAqB,IAAjC;;AACAD,IAAAA,KAAK,CAACE,UAAN,GAAmB,CAAC,CAApB;AACAF,IAAAA,KAAK,CAACG,aAAN,GAAsB,CAAC,CAAvB;AACAH,IAAAA,KAAK,CAACI,SAAN,GAAkB,CAAC,CAAnB;AACAJ,IAAAA,KAAK,CAACD,aAAN,GAAsBA,aAAtB;AACAC,IAAAA,KAAK,CAACK,yCAAN,GAAkDZ,QAAQ,CAACO,KAAK,CAACM,gCAAN,CAAuCC,IAAvC,CAA4CP,KAA5C,CAAD,EAAqD,GAArD,CAA1D;AACA,WAAOA,KAAP;AACH;;AACDH,EAAAA,qBAAqB,CAAC5B,SAAtB,CAAgCuC,aAAhC,GAAgD,YAAY;AACxD,QAAIR,KAAK,GAAG,IAAZ;;AACA,SAAKS,SAAL,GAAiB,KAAKC,kBAAL,CAAwBC,WAAxB,EAAjB;AACA,SAAKC,kBAAL,CAAwB,KAAKC,YAA7B,EAA2CrB,MAAM,CAACsB,qCAAlD,EAAyF,KAAKC,8BAAL,CAAoCR,IAApC,CAAyC,IAAzC,CAAzF;AACA,SAAKS,YAAL,CAAkBC,SAAlB,CAA4B,UAAUpD,CAAV,EAAa;AACrCmC,MAAAA,KAAK,CAACkB,qBAAN,GAA8BrD,CAAC,CAACsD,sBAAhC;;AACAnB,MAAAA,KAAK,CAACe,8BAAN;;AACAf,MAAAA,KAAK,CAACoB,iBAAN;AACH,KAJD;AAKH,GATD;;AAUAvB,EAAAA,qBAAqB,CAAC5B,SAAtB,CAAgCmD,iBAAhC,GAAoD,YAAY;AAC5D,QAAIC,WAAW,GAAG,KAAKL,YAAL,CAAkBM,kBAAlB,EAAlB;AACA,SAAKV,kBAAL,CAAwB,KAAKM,qBAAL,CAA2BK,kBAA3B,EAAxB,EAAyE,QAAzE,EAAmF,KAAKC,sBAAL,CAA4BjB,IAA5B,CAAiC,IAAjC,CAAnF;AACA,SAAKK,kBAAL,CAAwBS,WAAW,CAACI,WAAZ,EAAxB,EAAmD,QAAnD,EAA6D,KAAKC,sBAAL,CAA4BnB,IAA5B,CAAiC,IAAjC,CAA7D;AACA,QAAIoB,gBAAgB,GAAG,KAAKjB,kBAAL,CAAwBkB,2BAAxB,KACnBnC,QAAQ,CAAC,KAAKkC,gBAAL,CAAsBpB,IAAtB,CAA2B,IAA3B,CAAD,EAAmC,GAAnC,CADW,GAEjB,KAAKoB,gBAAL,CAAsBpB,IAAtB,CAA2B,IAA3B,CAFN;AAGA,SAAKK,kBAAL,CAAwB,KAAKb,aAA7B,EAA4C,QAA5C,EAAsD4B,gBAAtD;AACH,GARD;;AASA9B,EAAAA,qBAAqB,CAAC5B,SAAtB,CAAgC8C,8BAAhC,GAAiE,YAAY;AACzE,QAAI,KAAKN,SAAT,EAAoB;AAChB;AACA;AACA;AACA;AACA;AACA,WAAKoB,+CAAL;AACH;AACJ,GATD;;AAUAhC,EAAAA,qBAAqB,CAAC5B,SAAtB,CAAgC4D,+CAAhC,GAAkF,UAAU3B,UAAV,EAAsB;AACpG,QAAIA,UAAU,KAAK4B,SAAnB,EAA8B;AAC1B5B,MAAAA,UAAU,GAAG,KAAKgB,qBAAL,CAA2Ba,2BAA3B,EAAb;AACH;;AACD,QAAIC,MAAM,GAAG,KAAKvB,SAAL,GAAiBP,UAAjB,GAA8B,CAACA,UAA5C;AACA,QAAI+B,kBAAkB,GAAG,KAAKjB,YAAL,CAAkBkB,4BAAlB,EAAzB;AACA,QAAIC,qBAAqB,GAAG,KAAKnB,YAAL,CAAkBoB,+BAAlB,EAA5B;AACA,QAAIf,WAAW,GAAG,KAAKL,YAAL,CAAkBM,kBAAlB,EAAlB;AACA,QAAIe,qBAAqB,GAAG,KAAKrB,YAAL,CAAkBsB,yBAAlB,EAA5B;AACAD,IAAAA,qBAAqB,CAACE,mBAAtB,CAA0CP,MAA1C;AACAG,IAAAA,qBAAqB,CAACK,sBAAtB,CAA6CR,MAA7C;AACAC,IAAAA,kBAAkB,CAACO,sBAAnB,CAA0CR,MAA1C;AACA,QAAIS,OAAO,GAAG,KAAKC,2BAAL,KAAqC,KAAKxB,qBAAL,CAA2BK,kBAA3B,EAArC,GACVF,WAAW,CAACI,WAAZ,EADU,GACkB,KAAKP,qBAAL,CAA2BK,kBAA3B,EADhC;AAEAhC,IAAAA,aAAa,CAACkD,OAAD,EAAUE,IAAI,CAACC,GAAL,CAAS1C,UAAT,CAAV,EAAgC,KAAKO,SAArC,CAAb;AACH,GAfD;;AAgBAZ,EAAAA,qBAAqB,CAAC5B,SAAtB,CAAgC4E,mBAAhC,GAAsD,UAAUC,IAAV,EAAgB;AAClE,QAAI,CAAC,KAAKJ,2BAAV,EAAuC;AACnC,WAAKA,2BAAL,GAAmCI,IAAnC;AACA,aAAO,IAAP;AACH;;AACD,WAAOA,IAAI,KAAK,KAAKJ,2BAArB;AACH,GAND;;AAOA7C,EAAAA,qBAAqB,CAAC5B,SAAtB,CAAgCyD,sBAAhC,GAAyD,YAAY;AACjE,QAAIqB,mBAAmB,GAAG,KAAK/B,YAAL,CAAkBM,kBAAlB,GAAuCG,WAAvC,EAA1B;;AACA,QAAI,CAAC,KAAKoB,mBAAL,CAAyBE,mBAAzB,CAAL,EAAoD;AAChD;AACH;;AACD,SAAKC,sBAAL,CAA4BD,mBAA5B;AACH,GAND;;AAOAlD,EAAAA,qBAAqB,CAAC5B,SAAtB,CAAgCuD,sBAAhC,GAAyD,YAAY;AACjE,QAAIyB,uBAAuB,GAAG,KAAK/B,qBAAL,CAA2BK,kBAA3B,EAA9B;;AACA,QAAI,CAAC,KAAKsB,mBAAL,CAAyBI,uBAAzB,CAAL,EAAwD;AACpD;AACH;;AACD,SAAKD,sBAAL,CAA4BC,uBAA5B;AACH,GAND;;AAOApD,EAAAA,qBAAqB,CAAC5B,SAAtB,CAAgC+E,sBAAhC,GAAyD,UAAUE,OAAV,EAAmB;AACxE,QAAID,uBAAuB,GAAG,KAAK/B,qBAAL,CAA2BK,kBAA3B,EAA9B;AACA,QAAIrB,UAAU,GAAG+C,uBAAuB,CAAC/C,UAAzC;;AACA,QAAI,KAAKiD,uBAAL,CAA6B,YAA7B,EAA2CjD,UAA3C,EAAuD,IAAvD,CAAJ,EAAkE;AAC9D;AACH,KALuE,CAMxE;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAKkD,kBAAL,CAAwBT,IAAI,CAACU,KAAL,CAAWhE,aAAa,CAAC6D,OAAD,EAAU,KAAKzC,SAAf,CAAxB,CAAxB;AACA,SAAKJ,yCAAL;AACH,GAdD;;AAeAR,EAAAA,qBAAqB,CAAC5B,SAAtB,CAAgC0D,gBAAhC,GAAmD,YAAY;AAC3D,QAAIvB,SAAS,GAAG,KAAKL,aAAL,CAAmBK,SAAnC;;AACA,QAAI,KAAK+C,uBAAL,CAA6B,UAA7B,EAAyC/C,SAAzC,EAAoD,IAApD,CAAJ,EAA+D;AAC3D;AACH;;AACD,SAAKkD,qBAAL,CAA2BC,YAA3B,CAAwCnD,SAAxC;AACA,SAAKD,aAAL,GAAqBC,SAArB;;AACA,QAAI,KAAKM,kBAAL,CAAwB8C,wBAAxB,EAAJ,EAAwD;AACpD,WAAKpD,SAAL,GAAiB,KAAKD,aAAtB;AACA,WAAKsD,qBAAL;AACH,KAHD,MAIK;AACD,WAAKH,qBAAL,CAA2BI,QAA3B;AACH;AACJ,GAdD;;AAeA7D,EAAAA,qBAAqB,CAAC5B,SAAtB,CAAgCqC,gCAAhC,GAAmE,YAAY;AAC3E,SAAKoC,2BAAL,GAAmC,IAAnC;AACH,GAFD;;AAGA7C,EAAAA,qBAAqB,CAAC5B,SAAtB,CAAgCmF,kBAAhC,GAAqD,UAAUlD,UAAV,EAAsB;AACvE,QAAI6C,mBAAmB,GAAG,KAAK/B,YAAL,CAAkBM,kBAAlB,GAAuCG,WAAvC,EAA1B;AACA,QAAIkC,cAAc,GAAGtE,aAAa,CAAC0D,mBAAD,EAAsB,KAAKtC,SAA3B,CAAlC;;AACA,QAAI,KAAKP,UAAL,KAAoBA,UAApB,IAAkCA,UAAU,KAAKyD,cAArD,EAAqE;AACjE;AACH;;AACD,SAAKzD,UAAL,GAAkBA,UAAlB;AACA,SAAK0D,eAAL,CAAqB,YAArB;AACA,SAAK/B,+CAAL,CAAqD3B,UAArD;AACA,SAAK2D,2BAAL;AACH,GAVD;;AAWAhE,EAAAA,qBAAqB,CAAC5B,SAAtB,CAAgC2F,eAAhC,GAAkD,UAAUE,SAAV,EAAqB;AACnE,QAAI9D,KAAK,GAAG,IAAZ;;AACA,QAAI+D,eAAe,GAAG;AAClBC,MAAAA,IAAI,EAAExE,MAAM,CAACyE,iBADK;AAElBC,MAAAA,GAAG,EAAE,KAAKC,OAFQ;AAGlBC,MAAAA,SAAS,EAAE,KAAKA,SAHE;AAIlBN,MAAAA,SAAS,EAAEA,SAJO;AAKlBO,MAAAA,IAAI,EAAE,KAAKnE,UALO;AAMlBoE,MAAAA,GAAG,EAAE,KAAKlE;AANQ,KAAtB;AAQA,SAAKS,YAAL,CAAkB0D,aAAlB,CAAgCR,eAAhC;AACAS,IAAAA,MAAM,CAACC,YAAP,CAAoB,KAAKC,WAAzB;AACA,SAAKA,WAAL,GAAmB5C,SAAnB;AACA,SAAK4C,WAAL,GAAmBF,MAAM,CAACG,UAAP,CAAkB,YAAY;AAC7C,UAAIC,kBAAkB,GAAGhF,MAAM,CAAC,EAAD,EAAKmE,eAAL,EAAsB;AACjDC,QAAAA,IAAI,EAAExE,MAAM,CAACqF;AADoC,OAAtB,CAA/B;;AAGA7E,MAAAA,KAAK,CAACa,YAAN,CAAmB0D,aAAnB,CAAiCK,kBAAjC;AACH,KALkB,EAKhB,GALgB,CAAnB;AAMH,GAnBD;;AAoBA/E,EAAAA,qBAAqB,CAAC5B,SAAtB,CAAgCkF,uBAAhC,GAA0D,UAAUW,SAAV,EAAqBgB,QAArB,EAA+BC,SAA/B,EAA0C;AAChG;AACA;AACA;AACA;AACA,QAAIA,SAAS,KAAK,KAAK,CAAvB,EAA0B;AAAEA,MAAAA,SAAS,GAAG,KAAZ;AAAoB,KALgD,CAMhG;AACA;AACA;AACA;AACA;;;AACA,QAAIA,SAAS,IAAI,CAACrF,cAAc,EAAhC,EAAoC;AAChC,aAAO,KAAP;AACH;;AACD,QAAIoE,SAAS,KAAK,UAAlB,EAA8B;AAC1B,UAAIkB,YAAY,GAAG5F,cAAc,CAAC,KAAKW,aAAN,CAAjC;AACA,UAAIkF,YAAY,GAAG,KAAKlF,aAAL,CAAmBkF,YAAtC;;AACA,UAAIH,QAAQ,GAAG,CAAX,IAAiBA,QAAQ,GAAGE,YAAX,GAA0BC,YAA/C,EAA8D;AAC1D,eAAO,IAAP;AACH;AACJ;;AACD,QAAInB,SAAS,KAAK,YAAlB,EAAgC;AAC5B,UAAIoB,WAAW,GAAG,KAAKhE,qBAAL,CAA2BiE,cAA3B,EAAlB;AACA,UAAIC,WAAW,GAAG,KAAKlE,qBAAL,CAA2BK,kBAA3B,GAAgD6D,WAAlE;;AACA,UAAI,KAAK3E,SAAL,IAAkBnB,mBAAmB,EAAzC,EAA6C;AACzC,YAAIwF,QAAQ,GAAG,CAAf,EAAkB;AACd,iBAAO,IAAP;AACH;AACJ,OAJD,MAKK,IAAIA,QAAQ,GAAG,CAAf,EAAkB;AACnB,eAAO,IAAP;AACH;;AACD,UAAInC,IAAI,CAACC,GAAL,CAASkC,QAAT,IAAqBI,WAArB,GAAmCE,WAAvC,EAAoD;AAChD,eAAO,IAAP;AACH;AACJ;;AACD,WAAO,KAAP;AACH,GArCD;;AAsCAvF,EAAAA,qBAAqB,CAAC5B,SAAtB,CAAgCwF,qBAAhC,GAAwD,YAAY;AAChE,SAAKG,eAAL,CAAqB,UAArB;AACH,GAFD;;AAGA/D,EAAAA,qBAAqB,CAAC5B,SAAtB,CAAgC4F,2BAAhC,GAA8D,YAAY;AACtE,SAAK3C,qBAAL,CAA2B2C,2BAA3B;AACH,GAFD,CAtLyD,CAyLzD;AACA;AACA;AACA;AACA;AACA;;;AACAhE,EAAAA,qBAAqB,CAAC5B,SAAtB,CAAgCoH,eAAhC,GAAkD,YAAY;AAC1D,QAAI,KAAKnF,UAAL,KAAoB,KAAKgB,qBAAL,CAA2Ba,2BAA3B,EAAxB,EAAkF;AAC9E,WAAKiB,sBAAL,CAA4B,KAAK9B,qBAAL,CAA2BK,kBAA3B,EAA5B;AACH;AACJ,GAJD;;AAKA1B,EAAAA,qBAAqB,CAAC5B,SAAtB,CAAgCqH,2BAAhC,GAA8D,YAAY;AACtE,QAAIC,WAAW,GAAG,KAAKnF,SAAL,IAAkB,KAAKD,aAAzC;;AACA,QAAIoF,WAAJ,EAAiB;AACb,WAAKnF,SAAL,GAAiB,KAAKD,aAAtB;AACA,WAAKsD,qBAAL;AACH;;AACD,WAAO8B,WAAP;AACH,GAPD,CApMyD,CA4MzD;;;AACA1F,EAAAA,qBAAqB,CAAC5B,SAAtB,CAAgCuH,2BAAhC,GAA8D,UAAUC,eAAV,EAA2B;AACrF,QAAIC,aAAa,GAAG,CAApB;AACA,QAAIC,aAAa,GAAG,KAAKzE,qBAAL,CAA2BK,kBAA3B,GAAgD6D,WAAhD,GAA8D,KAAKlE,qBAAL,CAA2BiE,cAA3B,EAAlF;;AACA,QAAI,KAAKhC,uBAAL,CAA6B,YAA7B,EAA2CsC,eAA3C,CAAJ,EAAiE;AAC7D,UAAI,KAAKhF,SAAL,IAAkBnB,mBAAmB,EAAzC,EAA6C;AACzCmG,QAAAA,eAAe,GAAGA,eAAe,GAAG,CAAlB,GAAsB,CAAtB,GAA0BE,aAA5C;AACH,OAFD,MAGK;AACDF,QAAAA,eAAe,GAAG9C,IAAI,CAACiD,GAAL,CAASjD,IAAI,CAACkD,GAAL,CAASJ,eAAT,EAA0BC,aAA1B,CAAT,EAAmDC,aAAnD,CAAlB;AACH;AACJ;;AACDpG,IAAAA,aAAa,CAAC,KAAK2B,qBAAL,CAA2BK,kBAA3B,EAAD,EAAkDoB,IAAI,CAACC,GAAL,CAAS6C,eAAT,CAAlD,EAA6E,KAAKhF,SAAlF,CAAb,CAXqF,CAYrF;AACA;AACA;AACA;;AACA,SAAK2C,kBAAL,CAAwBqC,eAAxB;AACH,GAjBD;;AAkBA5F,EAAAA,qBAAqB,CAAC5B,SAAtB,CAAgC6H,yBAAhC,GAA4D,UAAUC,eAAV,EAA2B;AACnF,SAAKhG,aAAL,CAAmBK,SAAnB,GAA+B2F,eAA/B;AACH,GAFD;;AAGAlG,EAAAA,qBAAqB,CAAC5B,SAAtB,CAAgC+H,kBAAhC,GAAqD,YAAY;AAC7D,QAAIC,MAAM,GAAG;AACT3B,MAAAA,GAAG,EAAE,KAAKvE,aAAL,CAAmBK,SADf;AAET8F,MAAAA,MAAM,EAAE,KAAKnG,aAAL,CAAmBK,SAAnB,GAA+B,KAAKL,aAAL,CAAmBoG;AAFjD,KAAb;AAIA,WAAOF,MAAP;AACH,GAND;;AAOApG,EAAAA,qBAAqB,CAAC5B,SAAtB,CAAgCmI,kBAAhC,GAAqD,YAAY;AAC7D,WAAO,KAAKlF,qBAAL,CAA2BkF,kBAA3B,EAAP;AACH,GAFD;;AAGAvG,EAAAA,qBAAqB,CAAC5B,SAAtB,CAAgCoI,yBAAhC,GAA4D,YAAY;AACpE,WAAO,KAAKnF,qBAAL,CAA2BmF,yBAA3B,EAAP;AACH,GAFD,CA5OyD,CA+OzD;;;AACAxG,EAAAA,qBAAqB,CAAC5B,SAAtB,CAAgCqI,kBAAhC,GAAqD,UAAUC,MAAV,EAAkB;AACnE,QAAIC,iBAAiB,GAAG,KAAKtF,qBAAL,CAA2BK,kBAA3B,GAAgDrB,UAAxE;AACA,SAAKsF,2BAAL,CAAiCgB,iBAAiB,GAAGD,MAArD;AACA,WAAO,KAAKrF,qBAAL,CAA2BK,kBAA3B,GAAgDrB,UAAhD,GAA6DsG,iBAApE;AACH,GAJD,CAhPyD,CAqPzD;;;AACA3G,EAAAA,qBAAqB,CAAC5B,SAAtB,CAAgCwI,WAAhC,GAA8C,YAAY;AACtD,SAAK1G,aAAL,CAAmBK,SAAnB,GAA+B,CAA/B;AACH,GAFD,CAtPyD,CAyPzD;;;AACAP,EAAAA,qBAAqB,CAAC5B,SAAtB,CAAgCyI,iBAAhC,GAAoD,UAAUC,UAAV,EAAsBC,QAAtB,EAAgC;AAChF,QAAIA,QAAQ,KAAK,KAAK,CAAtB,EAAyB;AAAEA,MAAAA,QAAQ,GAAG,IAAX;AAAkB,KADmC,CAEhF;;;AACA,QAAIC,QAAQ,GAAG,KAAKC,QAAL,CAAcC,WAAd,EAAf;AACA,QAAIC,qBAAqB,GAAG,OAAOL,UAAP,KAAsB,UAAlD;AACA,QAAIM,aAAa,GAAG,CAAC,CAArB,CALgF,CAMhF;;AACA,SAAK,IAAIlI,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG8H,QAApB,EAA8B9H,CAAC,EAA/B,EAAmC;AAC/B,UAAImI,IAAI,GAAG,KAAKJ,QAAL,CAAcK,MAAd,CAAqBpI,CAArB,CAAX;;AACA,UAAIiI,qBAAJ,EAA2B;AACvB,YAAIL,UAAU,CAACO,IAAD,CAAd,EAAsB;AAClBD,UAAAA,aAAa,GAAGlI,CAAhB;AACA;AACH;AACJ,OALD,MAMK;AACD;AACA,YAAI4H,UAAU,KAAKO,IAAf,IAAuBP,UAAU,KAAKO,IAAI,CAACE,IAA/C,EAAqD;AACjDH,UAAAA,aAAa,GAAGlI,CAAhB;AACA;AACH;AACJ;AACJ;;AACD,QAAIkI,aAAa,IAAI,CAArB,EAAwB;AACpB,WAAKI,kBAAL,CAAwBJ,aAAxB,EAAuCL,QAAvC;AACH;AACJ,GA1BD,CA1PyD,CAqRzD;AACA;AACA;AACA;AACA;AACA;;;AACA/G,EAAAA,qBAAqB,CAAC5B,SAAtB,CAAgCoJ,kBAAhC,GAAqD,UAAUC,KAAV,EAAiBV,QAAjB,EAA2B;AAC5E;AACA,QAAI,KAAKlG,kBAAL,CAAwB6G,YAAxB,OAA2C5H,SAAS,CAAC6H,gBAAzD,EAA2E;AACvE;AACH;;AACD,QAAIX,QAAQ,GAAG,KAAKY,eAAL,CAAqBV,WAArB,EAAf;;AACA,QAAI,OAAOO,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,GAAG,CAArC,IAA0CA,KAAK,IAAIT,QAAvD,EAAiE;AAC7Da,MAAAA,OAAO,CAACC,IAAR,CAAa,+CAA+CL,KAA5D;AACA;AACH;;AACD,QAAIM,QAAQ,GAAG,KAAKlH,kBAAL,CAAwBmH,YAAxB,EAAf;AACA,QAAIC,sBAAsB,GAAGF,QAAQ,IAAI,CAAC,KAAKlH,kBAAL,CAAwBqH,yBAAxB,EAA1C;;AACA,QAAI,CAACD,sBAAL,EAA6B;AACzB,WAAKL,eAAL,CAAqBO,iBAArB,CAAuCV,KAAvC;AACH;;AACD,QAAIW,OAAO,GAAG,KAAKR,eAAL,CAAqBN,MAArB,CAA4BG,KAA5B,CAAd;AACA,QAAIY,4BAAJ;;AACA,OAAG;AACC,UAAIC,cAAc,GAAGF,OAAO,CAACG,MAA7B;AACA,UAAIC,iBAAiB,GAAGJ,OAAO,CAACK,SAAhC;AACA,UAAIC,gBAAgB,GAAG,KAAKd,eAAL,CAAqBe,cAArB,EAAvB;AACA,UAAIC,WAAW,GAAGR,OAAO,CAACG,MAAR,GAAiBG,gBAAnC;AACA,UAAIG,cAAc,GAAGD,WAAW,GAAGR,OAAO,CAACK,SAA3C;AACA,UAAIK,cAAc,GAAG,KAAK3C,kBAAL,EAArB;AACA,UAAI4C,YAAY,GAAG,KAAKC,YAAL,CAAkBC,mBAAlB,EAAnB;AACA,UAAIC,UAAU,GAAGJ,cAAc,CAACrE,GAAf,GAAqBsE,YAAtC;AACA,UAAII,aAAa,GAAGL,cAAc,CAACzC,MAAf,GAAwB0C,YAA5C;AACA,UAAIK,cAAc,GAAGD,aAAa,GAAGD,UAArC,CAVD,CAWC;AACA;;AACA,UAAIG,KAAK,GAAG,KAAKL,YAAL,CAAkBM,yBAAlB,CAA4CV,WAA5C,CAAZ;AACA,UAAIW,QAAQ,GAAG,KAAKP,YAAL,CAAkBM,yBAAlB,CAA4CT,cAAc,GAAGO,cAA7D,CAAf,CAdD,CAeC;;AACA,UAAII,QAAQ,GAAG1G,IAAI,CAACiD,GAAL,CAAS,CAACsD,KAAK,GAAGE,QAAT,IAAqB,CAA9B,EAAiCX,WAAjC,CAAf;AACA,UAAIa,gBAAgB,GAAGP,UAAU,GAAGN,WAApC;AACA,UAAIc,gBAAgB,GAAGP,aAAa,GAAGN,cAAvC;AACA,UAAIc,iBAAiB,GAAG,IAAxB;;AACA,UAAI5C,QAAQ,KAAK,KAAjB,EAAwB;AACpB4C,QAAAA,iBAAiB,GAAGN,KAApB;AACH,OAFD,MAGK,IAAItC,QAAQ,KAAK,QAAjB,EAA2B;AAC5B4C,QAAAA,iBAAiB,GAAGJ,QAApB;AACH,OAFI,MAGA,IAAIxC,QAAQ,KAAK,QAAjB,EAA2B;AAC5B4C,QAAAA,iBAAiB,GAAGH,QAApB;AACH,OAFI,MAGA,IAAIC,gBAAJ,EAAsB;AACvB;AACAE,QAAAA,iBAAiB,GAAGN,KAApB;AACH,OAHI,MAIA,IAAIK,gBAAJ,EAAsB;AACvB;AACAC,QAAAA,iBAAiB,GAAGJ,QAApB;AACH;;AACD,UAAII,iBAAiB,KAAK,IAA1B,EAAgC;AAC5B,aAAKzJ,aAAL,CAAmBK,SAAnB,GAA+BoJ,iBAA/B;AACA,aAAKC,WAAL,CAAiBC,iBAAjB;AACH,OAxCF,CAyCC;AACA;AACA;AACA;;;AACAxB,MAAAA,4BAA4B,GAAIC,cAAc,KAAKF,OAAO,CAACG,MAA5B,IACvBC,iBAAiB,KAAKJ,OAAO,CAACK,SADtC;AAEH,KA/CD,QA+CSJ,4BA/CT,EAjB4E,CAiE5E;;;AACA,SAAK5E,qBAAL,CAA2BqG,cAA3B;AACH,GAnED;;AAoEA9J,EAAAA,qBAAqB,CAAC5B,SAAtB,CAAgC2L,mBAAhC,GAAsD,UAAUtL,GAAV,EAAe;AACjE,QAAIuL,MAAM,GAAG,KAAKC,WAAL,CAAiBC,aAAjB,CAA+BzL,GAA/B,CAAb;;AACA,QAAI,CAACuL,MAAL,EAAa;AACT;AACH,KAJgE,CAKjE;;;AACA,QAAIA,MAAM,CAACG,QAAP,EAAJ,EAAuB;AACnB;AACH,KARgE,CASjE;;;AACA,QAAI,CAAC,KAAKF,WAAL,CAAiBG,iBAAjB,CAAmCJ,MAAnC,CAAL,EAAiD;AAC7C;AACH;;AACD,QAAIK,YAAY,GAAGL,MAAM,CAACM,OAAP,EAAnB;AACA,QAAIC,aAAa,GAAGF,YAAY,GAAGL,MAAM,CAACQ,cAAP,EAAnC;AACA,QAAIC,aAAa,GAAG,KAAKpJ,qBAAL,CAA2BiE,cAA3B,EAApB;AACA,QAAIwD,cAAc,GAAG,KAAKzH,qBAAL,CAA2Ba,2BAA3B,EAArB;AACA,QAAIwI,SAAS,GAAG,KAAKT,WAAL,CAAiBU,qBAAjB,EAAhB;AACA,QAAIC,iBAAJ;AACA,QAAIC,kBAAJ,CAnBiE,CAoBjE;AACA;;AACA,QAAI,KAAKjK,SAAT,EAAoB;AAChBgK,MAAAA,iBAAiB,GAAGF,SAAS,GAAG5B,cAAZ,GAA6B2B,aAAjD;AACAI,MAAAA,kBAAkB,GAAGH,SAAS,GAAG5B,cAAjC;AACH,KAHD,MAIK;AACD8B,MAAAA,iBAAiB,GAAG9B,cAApB;AACA+B,MAAAA,kBAAkB,GAAGJ,aAAa,GAAG3B,cAArC;AACH;;AACD,QAAIgC,uBAAuB,GAAGF,iBAAiB,GAAGP,YAAlD;AACA,QAAIU,yBAAyB,GAAGF,kBAAkB,GAAGN,aAArD;AACA,QAAIS,qBAAqB,GAAGP,aAAa,GAAGT,MAAM,CAACQ,cAAP,EAA5C;AACA,QAAIS,cAAc,GAAGH,uBAAuB,IAAIE,qBAAhD;AACA,QAAIE,eAAe,GAAGH,yBAAtB;;AACA,QAAIE,cAAc,IAAIC,eAAtB,EAAuC;AACnC,UAAIvB,iBAAiB,GAAG,KAAK,CAA7B;;AACA,UAAI,KAAK/I,SAAT,EAAoB;AAChB+I,QAAAA,iBAAiB,GAAGsB,cAAc,GAAIP,SAAS,GAAGD,aAAZ,GAA4BJ,YAAhC,GAAiDK,SAAS,GAAGH,aAA/F;AACH,OAFD,MAGK;AACDZ,QAAAA,iBAAiB,GAAGsB,cAAc,GAAGZ,YAAH,GAAmBE,aAAa,GAAGE,aAArE;AACH;;AACD,WAAKpJ,qBAAL,CAA2B8J,2BAA3B,CAAuDxB,iBAAvD;AACH,KATD,MAUK,CACD;AACH,KA/CgE,CAgDjE;AACA;AACA;AACA;;;AACA,SAAKtI,qBAAL,CAA2B2C,2BAA3B,GApDiE,CAqDjE;;AACA,SAAKP,qBAAL,CAA2BqG,cAA3B;AACH,GAvDD;;AAwDAxL,EAAAA,UAAU,CAAC,CACPc,SAAS,CAAC,cAAD,CADF,CAAD,EAEPY,qBAAqB,CAAC5B,SAFf,EAE0B,cAF1B,EAE0C,KAAK,CAF/C,CAAV;;AAGAE,EAAAA,UAAU,CAAC,CACPc,SAAS,CAAC,uBAAD,CADF,CAAD,EAEPY,qBAAqB,CAAC5B,SAFf,EAE0B,uBAF1B,EAEmD,KAAK,CAFxD,CAAV;;AAGAE,EAAAA,UAAU,CAAC,CACPc,SAAS,CAAC,WAAD,CADF,CAAD,EAEPY,qBAAqB,CAAC5B,SAFf,EAE0B,WAF1B,EAEuC,KAAK,CAF5C,CAAV;;AAGAE,EAAAA,UAAU,CAAC,CACPc,SAAS,CAAC,SAAD,CADF,CAAD,EAEPY,qBAAqB,CAAC5B,SAFf,EAE0B,SAF1B,EAEqC,KAAK,CAF1C,CAAV;;AAGAE,EAAAA,UAAU,CAAC,CACPc,SAAS,CAAC,iBAAD,CADF,CAAD,EAEPY,qBAAqB,CAAC5B,SAFf,EAE0B,iBAF1B,EAE6C,KAAK,CAFlD,CAAV;;AAGAE,EAAAA,UAAU,CAAC,CACPc,SAAS,CAAC,UAAD,CADF,CAAD,EAEPY,qBAAqB,CAAC5B,SAFf,EAE0B,UAF1B,EAEsC,KAAK,CAF3C,CAAV;;AAGAE,EAAAA,UAAU,CAAC,CACPc,SAAS,CAAC,2BAAD,CADF,CAAD,EAEPY,qBAAqB,CAAC5B,SAFf,EAE0B,cAF1B,EAE0C,KAAK,CAF/C,CAAV;;AAGAE,EAAAA,UAAU,CAAC,CACPc,SAAS,CAAC,aAAD,CADF,CAAD,EAEPY,qBAAqB,CAAC5B,SAFf,EAE0B,aAF1B,EAEyC,KAAK,CAF9C,CAAV;;AAGAE,EAAAA,UAAU,CAAC,CACPc,SAAS,CAAC,aAAD,CADF,CAAD,EAEPY,qBAAqB,CAAC5B,SAFf,EAE0B,aAF1B,EAEyC,KAAK,CAF9C,CAAV;;AAGAE,EAAAA,UAAU,CAAC,CACPe,aADO,CAAD,EAEPW,qBAAqB,CAAC5B,SAFf,EAE0B,eAF1B,EAE2C,IAF3C,CAAV;;AAGA,SAAO4B,qBAAP;AACH,CAtb0C,CAsbzCV,QAtbyC,CAA3C;;AAubA,SAASU,qBAAT","sourcesContent":["/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v26.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Autowired, PostConstruct } from \"../context/context\";\nimport { BeanStub } from \"../context/beanStub\";\nimport { getInnerHeight, getScrollLeft, isRtlNegativeScroll, setScrollLeft } from \"../utils/dom\";\nimport { Events } from \"../eventKeys\";\nimport { debounce } from \"../utils/function\";\nimport { isIOSUserAgent } from \"../utils/browser\";\nimport { Constants } from \"../constants/constants\";\nimport { assign } from \"../utils/object\";\nvar GridBodyScrollFeature = /** @class */ (function (_super) {\n    __extends(GridBodyScrollFeature, _super);\n    function GridBodyScrollFeature(eBodyViewport) {\n        var _this = _super.call(this) || this;\n        _this.scrollLeft = -1;\n        _this.nextScrollTop = -1;\n        _this.scrollTop = -1;\n        _this.eBodyViewport = eBodyViewport;\n        _this.resetLastHorizontalScrollElementDebounced = debounce(_this.resetLastHorizontalScrollElement.bind(_this), 500);\n        return _this;\n    }\n    GridBodyScrollFeature.prototype.postConstruct = function () {\n        var _this = this;\n        this.enableRtl = this.gridOptionsWrapper.isEnableRtl();\n        this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onDisplayedColumnsWidthChanged.bind(this));\n        this.ctrlsService.whenReady(function (p) {\n            _this.centerRowContainerCon = p.centerRowContainerCtrl;\n            _this.onDisplayedColumnsWidthChanged();\n            _this.addScrollListener();\n        });\n    };\n    GridBodyScrollFeature.prototype.addScrollListener = function () {\n        var fakeHScroll = this.ctrlsService.getFakeHScrollCtrl();\n        this.addManagedListener(this.centerRowContainerCon.getViewportElement(), 'scroll', this.onCenterViewportScroll.bind(this));\n        this.addManagedListener(fakeHScroll.getViewport(), 'scroll', this.onFakeHorizontalScroll.bind(this));\n        var onVerticalScroll = this.gridOptionsWrapper.isDebounceVerticalScrollbar() ?\n            debounce(this.onVerticalScroll.bind(this), 100)\n            : this.onVerticalScroll.bind(this);\n        this.addManagedListener(this.eBodyViewport, 'scroll', onVerticalScroll);\n    };\n    GridBodyScrollFeature.prototype.onDisplayedColumnsWidthChanged = function () {\n        if (this.enableRtl) {\n            // because RTL is all backwards, a change in the width of the row\n            // can cause a change in the scroll position, without a scroll event,\n            // because the scroll position in RTL is a function that depends on\n            // the width. to be convinced of this, take out this line, enable RTL,\n            // scroll all the way to the left and then resize a column\n            this.horizontallyScrollHeaderCenterAndFloatingCenter();\n        }\n    };\n    GridBodyScrollFeature.prototype.horizontallyScrollHeaderCenterAndFloatingCenter = function (scrollLeft) {\n        if (scrollLeft === undefined) {\n            scrollLeft = this.centerRowContainerCon.getCenterViewportScrollLeft();\n        }\n        var offset = this.enableRtl ? scrollLeft : -scrollLeft;\n        var topCenterContainer = this.ctrlsService.getTopCenterRowContainerCtrl();\n        var bottomCenterContainer = this.ctrlsService.getBottomCenterRowContainerCtrl();\n        var fakeHScroll = this.ctrlsService.getFakeHScrollCtrl();\n        var centerHeaderContainer = this.ctrlsService.getHeaderRowContainerCtrl();\n        centerHeaderContainer.setHorizontalScroll(offset);\n        bottomCenterContainer.setContainerTranslateX(offset);\n        topCenterContainer.setContainerTranslateX(offset);\n        var partner = this.lastHorizontalScrollElement === this.centerRowContainerCon.getViewportElement() ?\n            fakeHScroll.getViewport() : this.centerRowContainerCon.getViewportElement();\n        setScrollLeft(partner, Math.abs(scrollLeft), this.enableRtl);\n    };\n    GridBodyScrollFeature.prototype.isControllingScroll = function (eDiv) {\n        if (!this.lastHorizontalScrollElement) {\n            this.lastHorizontalScrollElement = eDiv;\n            return true;\n        }\n        return eDiv === this.lastHorizontalScrollElement;\n    };\n    GridBodyScrollFeature.prototype.onFakeHorizontalScroll = function () {\n        var fakeHScrollViewport = this.ctrlsService.getFakeHScrollCtrl().getViewport();\n        if (!this.isControllingScroll(fakeHScrollViewport)) {\n            return;\n        }\n        this.onBodyHorizontalScroll(fakeHScrollViewport);\n    };\n    GridBodyScrollFeature.prototype.onCenterViewportScroll = function () {\n        var centerContainerViewport = this.centerRowContainerCon.getViewportElement();\n        if (!this.isControllingScroll(centerContainerViewport)) {\n            return;\n        }\n        this.onBodyHorizontalScroll(centerContainerViewport);\n    };\n    GridBodyScrollFeature.prototype.onBodyHorizontalScroll = function (eSource) {\n        var centerContainerViewport = this.centerRowContainerCon.getViewportElement();\n        var scrollLeft = centerContainerViewport.scrollLeft;\n        if (this.shouldBlockScrollUpdate('horizontal', scrollLeft, true)) {\n            return;\n        }\n        // we do Math.round() rather than Math.floor(), to mirror how scroll values are applied.\n        // eg if a scale is applied (ie user has zoomed the browser), then applying scroll=200\n        // could result in 199.88, which then floor(199.88) = 199, however round(199.88) = 200.\n        // initially Math.floor() was used, however this caused (almost) infinite loop with aligned grids,\n        // as the scroll would move 1px at at time bouncing from one grid to the next (eg one grid would cause\n        // scroll to 200px, the next to 199px, then the first back to 198px and so on).\n        this.doHorizontalScroll(Math.round(getScrollLeft(eSource, this.enableRtl)));\n        this.resetLastHorizontalScrollElementDebounced();\n    };\n    GridBodyScrollFeature.prototype.onVerticalScroll = function () {\n        var scrollTop = this.eBodyViewport.scrollTop;\n        if (this.shouldBlockScrollUpdate('vertical', scrollTop, true)) {\n            return;\n        }\n        this.animationFrameService.setScrollTop(scrollTop);\n        this.nextScrollTop = scrollTop;\n        if (this.gridOptionsWrapper.isSuppressAnimationFrame()) {\n            this.scrollTop = this.nextScrollTop;\n            this.redrawRowsAfterScroll();\n        }\n        else {\n            this.animationFrameService.schedule();\n        }\n    };\n    GridBodyScrollFeature.prototype.resetLastHorizontalScrollElement = function () {\n        this.lastHorizontalScrollElement = null;\n    };\n    GridBodyScrollFeature.prototype.doHorizontalScroll = function (scrollLeft) {\n        var fakeHScrollViewport = this.ctrlsService.getFakeHScrollCtrl().getViewport();\n        var fakeScrollLeft = getScrollLeft(fakeHScrollViewport, this.enableRtl);\n        if (this.scrollLeft === scrollLeft && scrollLeft === fakeScrollLeft) {\n            return;\n        }\n        this.scrollLeft = scrollLeft;\n        this.fireScrollEvent('horizontal');\n        this.horizontallyScrollHeaderCenterAndFloatingCenter(scrollLeft);\n        this.onHorizontalViewportChanged();\n    };\n    GridBodyScrollFeature.prototype.fireScrollEvent = function (direction) {\n        var _this = this;\n        var bodyScrollEvent = {\n            type: Events.EVENT_BODY_SCROLL,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            direction: direction,\n            left: this.scrollLeft,\n            top: this.scrollTop\n        };\n        this.eventService.dispatchEvent(bodyScrollEvent);\n        window.clearTimeout(this.scrollTimer);\n        this.scrollTimer = undefined;\n        this.scrollTimer = window.setTimeout(function () {\n            var bodyScrollEndEvent = assign({}, bodyScrollEvent, {\n                type: Events.EVENT_BODY_SCROLL_END\n            });\n            _this.eventService.dispatchEvent(bodyScrollEndEvent);\n        }, 100);\n    };\n    GridBodyScrollFeature.prototype.shouldBlockScrollUpdate = function (direction, scrollTo, touchOnly) {\n        // touch devices allow elastic scroll - which temporally scrolls the panel outside of the viewport\n        // (eg user uses touch to go to the left of the grid, but drags past the left, the rows will actually\n        // scroll past the left until the user releases the mouse). when this happens, we want ignore the scroll,\n        // as otherwise it was causing the rows and header to flicker.\n        if (touchOnly === void 0) { touchOnly = false; }\n        // sometimes when scrolling, we got values that extended the maximum scroll allowed. we used to\n        // ignore these scrolls. problem is the max scroll position could be skipped (eg the previous scroll event\n        // could be 10px before the max position, and then current scroll event could be 20px after the max position).\n        // if we just ignored the last event, we would be setting the scroll to 10px before the max position, when in\n        // actual fact the user has exceeded the max scroll and thus scroll should be set to the max.\n        if (touchOnly && !isIOSUserAgent()) {\n            return false;\n        }\n        if (direction === 'vertical') {\n            var clientHeight = getInnerHeight(this.eBodyViewport);\n            var scrollHeight = this.eBodyViewport.scrollHeight;\n            if (scrollTo < 0 || (scrollTo + clientHeight > scrollHeight)) {\n                return true;\n            }\n        }\n        if (direction === 'horizontal') {\n            var clientWidth = this.centerRowContainerCon.getCenterWidth();\n            var scrollWidth = this.centerRowContainerCon.getViewportElement().scrollWidth;\n            if (this.enableRtl && isRtlNegativeScroll()) {\n                if (scrollTo > 0) {\n                    return true;\n                }\n            }\n            else if (scrollTo < 0) {\n                return true;\n            }\n            if (Math.abs(scrollTo) + clientWidth > scrollWidth) {\n                return true;\n            }\n        }\n        return false;\n    };\n    GridBodyScrollFeature.prototype.redrawRowsAfterScroll = function () {\n        this.fireScrollEvent('vertical');\n    };\n    GridBodyScrollFeature.prototype.onHorizontalViewportChanged = function () {\n        this.centerRowContainerCon.onHorizontalViewportChanged();\n    };\n    // this is to cater for AG-3274, where grid is removed from the dom and then inserted back in again.\n    // (which happens with some implementations of tabbing). this can result in horizontal scroll getting\n    // reset back to the left, however no scroll event is fired. so we need to get header to also scroll\n    // back to the left to be kept in sync.\n    // adding and removing the grid from the DOM both resets the scroll position and\n    // triggers a resize event, so notify listeners if the scroll position has changed\n    GridBodyScrollFeature.prototype.checkScrollLeft = function () {\n        if (this.scrollLeft !== this.centerRowContainerCon.getCenterViewportScrollLeft()) {\n            this.onBodyHorizontalScroll(this.centerRowContainerCon.getViewportElement());\n        }\n    };\n    GridBodyScrollFeature.prototype.executeAnimationFrameScroll = function () {\n        var frameNeeded = this.scrollTop != this.nextScrollTop;\n        if (frameNeeded) {\n            this.scrollTop = this.nextScrollTop;\n            this.redrawRowsAfterScroll();\n        }\n        return frameNeeded;\n    };\n    // called by scrollHorizontally method and alignedGridsService\n    GridBodyScrollFeature.prototype.setHorizontalScrollPosition = function (hScrollPosition) {\n        var minScrollLeft = 0;\n        var maxScrollLeft = this.centerRowContainerCon.getViewportElement().scrollWidth - this.centerRowContainerCon.getCenterWidth();\n        if (this.shouldBlockScrollUpdate('horizontal', hScrollPosition)) {\n            if (this.enableRtl && isRtlNegativeScroll()) {\n                hScrollPosition = hScrollPosition > 0 ? 0 : maxScrollLeft;\n            }\n            else {\n                hScrollPosition = Math.min(Math.max(hScrollPosition, minScrollLeft), maxScrollLeft);\n            }\n        }\n        setScrollLeft(this.centerRowContainerCon.getViewportElement(), Math.abs(hScrollPosition), this.enableRtl);\n        // we need to manually do the event handling (rather than wait for the event)\n        // for the alignedGridsService, as if we don't, the aligned grid service gets\n        // notified async, and then it's 'consuming' flag doesn't get used right, and\n        // we can end up with an infinite loop\n        this.doHorizontalScroll(hScrollPosition);\n    };\n    GridBodyScrollFeature.prototype.setVerticalScrollPosition = function (vScrollPosition) {\n        this.eBodyViewport.scrollTop = vScrollPosition;\n    };\n    GridBodyScrollFeature.prototype.getVScrollPosition = function () {\n        var result = {\n            top: this.eBodyViewport.scrollTop,\n            bottom: this.eBodyViewport.scrollTop + this.eBodyViewport.offsetHeight\n        };\n        return result;\n    };\n    GridBodyScrollFeature.prototype.getHScrollPosition = function () {\n        return this.centerRowContainerCon.getHScrollPosition();\n    };\n    GridBodyScrollFeature.prototype.isHorizontalScrollShowing = function () {\n        return this.centerRowContainerCon.isHorizontalScrollShowing();\n    };\n    // called by the headerRootComp and moveColumnController\n    GridBodyScrollFeature.prototype.scrollHorizontally = function (pixels) {\n        var oldScrollPosition = this.centerRowContainerCon.getViewportElement().scrollLeft;\n        this.setHorizontalScrollPosition(oldScrollPosition + pixels);\n        return this.centerRowContainerCon.getViewportElement().scrollLeft - oldScrollPosition;\n    };\n    // gets called by rowRenderer when new data loaded, as it will want to scroll to the top\n    GridBodyScrollFeature.prototype.scrollToTop = function () {\n        this.eBodyViewport.scrollTop = 0;\n    };\n    // Valid values for position are bottom, middle and top\n    GridBodyScrollFeature.prototype.ensureNodeVisible = function (comparator, position) {\n        if (position === void 0) { position = null; }\n        // look for the node index we want to display\n        var rowCount = this.rowModel.getRowCount();\n        var comparatorIsAFunction = typeof comparator === 'function';\n        var indexToSelect = -1;\n        // go through all the nodes, find the one we want to show\n        for (var i = 0; i < rowCount; i++) {\n            var node = this.rowModel.getRow(i);\n            if (comparatorIsAFunction) {\n                if (comparator(node)) {\n                    indexToSelect = i;\n                    break;\n                }\n            }\n            else {\n                // check object equality against node and data\n                if (comparator === node || comparator === node.data) {\n                    indexToSelect = i;\n                    break;\n                }\n            }\n        }\n        if (indexToSelect >= 0) {\n            this.ensureIndexVisible(indexToSelect, position);\n        }\n    };\n    // Valid values for position are bottom, middle and top\n    // position should be {'top','middle','bottom', or undefined/null}.\n    // if undefined/null, then the grid will to the minimal amount of scrolling,\n    // eg if grid needs to scroll up, it scrolls until row is on top,\n    //    if grid needs to scroll down, it scrolls until row is on bottom,\n    //    if row is already in view, grid does not scroll\n    GridBodyScrollFeature.prototype.ensureIndexVisible = function (index, position) {\n        // if for print or auto height, everything is always visible\n        if (this.gridOptionsWrapper.getDomLayout() === Constants.DOM_LAYOUT_PRINT) {\n            return;\n        }\n        var rowCount = this.paginationProxy.getRowCount();\n        if (typeof index !== 'number' || index < 0 || index >= rowCount) {\n            console.warn('invalid row index for ensureIndexVisible: ' + index);\n            return;\n        }\n        var isPaging = this.gridOptionsWrapper.isPagination();\n        var paginationPanelEnabled = isPaging && !this.gridOptionsWrapper.isSuppressPaginationPanel();\n        if (!paginationPanelEnabled) {\n            this.paginationProxy.goToPageWithIndex(index);\n        }\n        var rowNode = this.paginationProxy.getRow(index);\n        var rowGotShiftedDuringOperation;\n        do {\n            var startingRowTop = rowNode.rowTop;\n            var startingRowHeight = rowNode.rowHeight;\n            var paginationOffset = this.paginationProxy.getPixelOffset();\n            var rowTopPixel = rowNode.rowTop - paginationOffset;\n            var rowBottomPixel = rowTopPixel + rowNode.rowHeight;\n            var scrollPosition = this.getVScrollPosition();\n            var heightOffset = this.heightScaler.getDivStretchOffset();\n            var vScrollTop = scrollPosition.top + heightOffset;\n            var vScrollBottom = scrollPosition.bottom + heightOffset;\n            var viewportHeight = vScrollBottom - vScrollTop;\n            // work out the pixels for top, middle and bottom up front,\n            // make the if/else below easier to read\n            var pxTop = this.heightScaler.getScrollPositionForPixel(rowTopPixel);\n            var pxBottom = this.heightScaler.getScrollPositionForPixel(rowBottomPixel - viewportHeight);\n            // make sure if middle, the row is not outside the top of the grid\n            var pxMiddle = Math.min((pxTop + pxBottom) / 2, rowTopPixel);\n            var rowBelowViewport = vScrollTop > rowTopPixel;\n            var rowAboveViewport = vScrollBottom < rowBottomPixel;\n            var newScrollPosition = null;\n            if (position === 'top') {\n                newScrollPosition = pxTop;\n            }\n            else if (position === 'bottom') {\n                newScrollPosition = pxBottom;\n            }\n            else if (position === 'middle') {\n                newScrollPosition = pxMiddle;\n            }\n            else if (rowBelowViewport) {\n                // if row is before, scroll up with row at top\n                newScrollPosition = pxTop;\n            }\n            else if (rowAboveViewport) {\n                // if row is below, scroll down with row at bottom\n                newScrollPosition = pxBottom;\n            }\n            if (newScrollPosition !== null) {\n                this.eBodyViewport.scrollTop = newScrollPosition;\n                this.rowRenderer.redrawAfterScroll();\n            }\n            // the row can get shifted if during the rendering (during rowRenderer.redrawAfterScroll()),\n            // the height of a row changes due to lazy calculation of row heights when using\n            // colDef.autoHeight or gridOptions.getRowHeight.\n            // if row was shifted, then the position we scrolled to is incorrect.\n            rowGotShiftedDuringOperation = (startingRowTop !== rowNode.rowTop)\n                || (startingRowHeight !== rowNode.rowHeight);\n        } while (rowGotShiftedDuringOperation);\n        // so when we return back to user, the cells have rendered\n        this.animationFrameService.flushAllFrames();\n    };\n    GridBodyScrollFeature.prototype.ensureColumnVisible = function (key) {\n        var column = this.columnModel.getGridColumn(key);\n        if (!column) {\n            return;\n        }\n        // calling ensureColumnVisible on a pinned column doesn't make sense\n        if (column.isPinned()) {\n            return;\n        }\n        // defensive\n        if (!this.columnModel.isColumnDisplayed(column)) {\n            return;\n        }\n        var colLeftPixel = column.getLeft();\n        var colRightPixel = colLeftPixel + column.getActualWidth();\n        var viewportWidth = this.centerRowContainerCon.getCenterWidth();\n        var scrollPosition = this.centerRowContainerCon.getCenterViewportScrollLeft();\n        var bodyWidth = this.columnModel.getBodyContainerWidth();\n        var viewportLeftPixel;\n        var viewportRightPixel;\n        // the logic of working out left and right viewport px is both here and in the ColumnController,\n        // need to refactor it out to one place\n        if (this.enableRtl) {\n            viewportLeftPixel = bodyWidth - scrollPosition - viewportWidth;\n            viewportRightPixel = bodyWidth - scrollPosition;\n        }\n        else {\n            viewportLeftPixel = scrollPosition;\n            viewportRightPixel = viewportWidth + scrollPosition;\n        }\n        var viewportScrolledPastCol = viewportLeftPixel > colLeftPixel;\n        var viewportScrolledBeforeCol = viewportRightPixel < colRightPixel;\n        var colToSmallForViewport = viewportWidth < column.getActualWidth();\n        var alignColToLeft = viewportScrolledPastCol || colToSmallForViewport;\n        var alignColToRight = viewportScrolledBeforeCol;\n        if (alignColToLeft || alignColToRight) {\n            var newScrollPosition = void 0;\n            if (this.enableRtl) {\n                newScrollPosition = alignColToLeft ? (bodyWidth - viewportWidth - colLeftPixel) : (bodyWidth - colRightPixel);\n            }\n            else {\n                newScrollPosition = alignColToLeft ? colLeftPixel : (colRightPixel - viewportWidth);\n            }\n            this.centerRowContainerCon.setCenterViewportScrollLeft(newScrollPosition);\n        }\n        else {\n            // otherwise, col is already in view, so do nothing\n        }\n        // this will happen anyway, as the move will cause a 'scroll' event on the body, however\n        // it is possible that the ensureColumnVisible method is called from within AG Grid and\n        // the caller will need to have the columns rendered to continue, which will be before\n        // the event has been worked on (which is the case for cell navigation).\n        this.centerRowContainerCon.onHorizontalViewportChanged();\n        // so when we return back to user, the cells have rendered\n        this.animationFrameService.flushAllFrames();\n    };\n    __decorate([\n        Autowired('ctrlsService')\n    ], GridBodyScrollFeature.prototype, \"ctrlsService\", void 0);\n    __decorate([\n        Autowired('animationFrameService')\n    ], GridBodyScrollFeature.prototype, \"animationFrameService\", void 0);\n    __decorate([\n        Autowired('columnApi')\n    ], GridBodyScrollFeature.prototype, \"columnApi\", void 0);\n    __decorate([\n        Autowired('gridApi')\n    ], GridBodyScrollFeature.prototype, \"gridApi\", void 0);\n    __decorate([\n        Autowired('paginationProxy')\n    ], GridBodyScrollFeature.prototype, \"paginationProxy\", void 0);\n    __decorate([\n        Autowired('rowModel')\n    ], GridBodyScrollFeature.prototype, \"rowModel\", void 0);\n    __decorate([\n        Autowired('rowContainerHeightService')\n    ], GridBodyScrollFeature.prototype, \"heightScaler\", void 0);\n    __decorate([\n        Autowired('rowRenderer')\n    ], GridBodyScrollFeature.prototype, \"rowRenderer\", void 0);\n    __decorate([\n        Autowired('columnModel')\n    ], GridBodyScrollFeature.prototype, \"columnModel\", void 0);\n    __decorate([\n        PostConstruct\n    ], GridBodyScrollFeature.prototype, \"postConstruct\", null);\n    return GridBodyScrollFeature;\n}(BeanStub));\nexport { GridBodyScrollFeature };\n"]},"metadata":{},"sourceType":"module"}