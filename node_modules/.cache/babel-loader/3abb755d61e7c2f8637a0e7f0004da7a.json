{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _isString = _interopRequireDefault(require(\"lodash/isString.js\"));\n\nvar _isArray = _interopRequireDefault(require(\"lodash/isArray\"));\n\nvar _StringUtil = _interopRequireDefault(require(\"@terrestris/base-util/dist/StringUtil/StringUtil\"));\n/**\n * Helper class for working with OpenLayers features.\n *\n * @class FeatureUtil\n */\n\n\nvar FeatureUtil = /*#__PURE__*/function () {\n  function FeatureUtil() {\n    (0, _classCallCheck2[\"default\"])(this, FeatureUtil);\n  }\n\n  (0, _createClass2[\"default\"])(FeatureUtil, null, [{\n    key: \"getFeatureTypeName\",\n    value:\n    /**\n     * Returns the featureType name out of a given feature. It assumes that\n     * the feature has an ID in the following structure FEATURETYPE.FEATUREID.\n     *\n     * @param {ol.Feature} feature The feature to obtain the featureType\n     *                             name from.\n     * @return {string} The (unqualified) name of the featureType or undefined if\n     *                  the name could not be picked.\n     */\n    function getFeatureTypeName(feature) {\n      var featureId = feature.getId();\n      var featureIdParts = featureId ? featureId.split('.') : featureId;\n      return (0, _isArray[\"default\"])(featureIdParts) ? featureIdParts[0] : undefined;\n    }\n    /**\n     * Extracts the featureType name from given GetFeatureInfo URL.\n     * This method is mostly useful for raster layers which features could have\n     * no ID set.\n     *\n     * @param {string} url GetFeatureInfo URL possibly containing featureType name.\n     * @param {boolean} qualified Whether the qualified featureType name should be\n     *   returned or not. Default is true.\n     *\n     * @return {string} Obtained featureType name as string.\n     */\n\n  }, {\n    key: \"getFeatureTypeNameFromGetFeatureInfoUrl\",\n    value: function getFeatureTypeNameFromGetFeatureInfoUrl(url) {\n      var qualified = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var regex = /query_layers=(.*?)(&|$)/i;\n      var match = url.match(regex);\n      var featureTypeName;\n\n      if (match && match[1]) {\n        featureTypeName = decodeURIComponent(match[1]);\n\n        if (!qualified && featureTypeName.indexOf(':') > 0) {\n          featureTypeName = featureTypeName.split(':')[1];\n        }\n      }\n\n      return featureTypeName;\n    }\n    /**\n     * Resolves the given template string with the given feature attributes, e.g.\n     * the template \"Size of area is {{AREA_SIZE}} km²\" would be to resolved\n     * to \"Size of area is 1909 km²\" (assuming the feature's attribute AREA_SIZE\n     * really exists).\n     *\n     * @param {ol.Feature} feature The feature to get the attributes from.\n     * @param {string} template The template string to resolve.\n     * @param {string} [noValueFoundText] The text to apply, if the templated value\n     *   could not be found, default is to 'n.v.'.\n     * @param {Function} [valueAdjust] A method that will be called with each\n     *   key/value match, we'll use what this function returns for the actual\n     *   replacement. Optional, defaults to a function which will return the raw\n     *   value it received. This can be used for last minute adjustments before\n     *   replacing happens, e.g. to filter out falsy values or to do number\n     *   formatting and such.\n     * @param {boolean} leaveAsUrl If set to true, template won't be wrapped into\n     *   <a>-tag and will be returned as URL. Default is false.\n     * @return {string} The resolved template string.\n     */\n\n  }, {\n    key: \"resolveAttributeTemplate\",\n    value: function resolveAttributeTemplate(feature, template) {\n      var noValueFoundText = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'n.v.';\n      var valueAdjust = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function (key, val) {\n        return val;\n      };\n      var leaveAsUrl = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      var attributeTemplatePrefix = '\\\\{\\\\{';\n      var attributeTemplateSuffix = '\\\\}\\\\}';\n      var resolved = ''; // Find any character between two braces (including the braces in the result)\n\n      var regExp = new RegExp(attributeTemplatePrefix + '(.*?)' + attributeTemplateSuffix, 'g');\n      var regExpRes = (0, _isString[\"default\"])(template) ? template.match(regExp) : null; // If we have a regex result, it means we found a placeholder in the\n      // template and have to replace the placeholder with its appropriate value.\n\n      if (regExpRes) {\n        // Iterate over all regex match results and find the proper attribute\n        // for the given placeholder, finally set the desired value to the hover.\n        // field text\n        regExpRes.forEach(function (res) {\n          // We count every non matching candidate. If this count is equal to\n          // the objects length, we assume that there is no match at all and\n          // set the output value to the value of \"noValueFoundText\".\n          var noMatchCnt = 0;\n\n          for (var _i = 0, _Object$entries = Object.entries(feature.getProperties()); _i < _Object$entries.length; _i++) {\n            var _Object$entries$_i = (0, _slicedToArray2[\"default\"])(_Object$entries[_i], 2),\n                key = _Object$entries$_i[0],\n                value = _Object$entries$_i[1]; // Remove the suffixes and find the matching attribute column.\n\n\n            var attributeName = res.slice(2, res.length - 2);\n\n            if (attributeName.toLowerCase() === key.toLowerCase()) {\n              template = template.replace(res, valueAdjust(key, value));\n              break;\n            } else {\n              noMatchCnt++;\n            }\n          } // No key match found for this feature (e.g. if key not\n          // present or value is null).\n\n\n          if (noMatchCnt === Object.keys(feature.getProperties()).length) {\n            template = template.replace(res, noValueFoundText);\n          }\n        });\n      }\n\n      resolved = template; // Fallback if no feature attribute is found.\n\n      if (!resolved) {\n        resolved = feature.getId();\n      }\n\n      if (!leaveAsUrl) {\n        // Replace any HTTP url with an <a> element.\n        resolved = _StringUtil[\"default\"].urlify(resolved); // Replace all newline breaks with a html <br> tag.\n\n        resolved = resolved.replace(/\\n/g, '<br>');\n      }\n\n      return resolved;\n    }\n  }]);\n  return FeatureUtil;\n}();\n\nvar _default = FeatureUtil;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["/Users/rongxuan/Desktop/reactmap/reactmap/node_modules/@terrestris/ol-util/dist/FeatureUtil/FeatureUtil.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","_slicedToArray2","_classCallCheck2","_createClass2","_isString","_isArray","_StringUtil","FeatureUtil","key","getFeatureTypeName","feature","featureId","getId","featureIdParts","split","undefined","getFeatureTypeNameFromGetFeatureInfoUrl","url","qualified","arguments","length","regex","match","featureTypeName","decodeURIComponent","indexOf","resolveAttributeTemplate","template","noValueFoundText","valueAdjust","val","leaveAsUrl","attributeTemplatePrefix","attributeTemplateSuffix","resolved","regExp","RegExp","regExpRes","forEach","res","noMatchCnt","_i","_Object$entries","entries","getProperties","_Object$entries$_i","attributeName","slice","toLowerCase","replace","keys","urlify","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _isString = _interopRequireDefault(require(\"lodash/isString.js\"));\n\nvar _isArray = _interopRequireDefault(require(\"lodash/isArray\"));\n\nvar _StringUtil = _interopRequireDefault(require(\"@terrestris/base-util/dist/StringUtil/StringUtil\"));\n\n/**\n * Helper class for working with OpenLayers features.\n *\n * @class FeatureUtil\n */\nvar FeatureUtil = /*#__PURE__*/function () {\n  function FeatureUtil() {\n    (0, _classCallCheck2[\"default\"])(this, FeatureUtil);\n  }\n\n  (0, _createClass2[\"default\"])(FeatureUtil, null, [{\n    key: \"getFeatureTypeName\",\n    value:\n    /**\n     * Returns the featureType name out of a given feature. It assumes that\n     * the feature has an ID in the following structure FEATURETYPE.FEATUREID.\n     *\n     * @param {ol.Feature} feature The feature to obtain the featureType\n     *                             name from.\n     * @return {string} The (unqualified) name of the featureType or undefined if\n     *                  the name could not be picked.\n     */\n    function getFeatureTypeName(feature) {\n      var featureId = feature.getId();\n      var featureIdParts = featureId ? featureId.split('.') : featureId;\n      return (0, _isArray[\"default\"])(featureIdParts) ? featureIdParts[0] : undefined;\n    }\n    /**\n     * Extracts the featureType name from given GetFeatureInfo URL.\n     * This method is mostly useful for raster layers which features could have\n     * no ID set.\n     *\n     * @param {string} url GetFeatureInfo URL possibly containing featureType name.\n     * @param {boolean} qualified Whether the qualified featureType name should be\n     *   returned or not. Default is true.\n     *\n     * @return {string} Obtained featureType name as string.\n     */\n\n  }, {\n    key: \"getFeatureTypeNameFromGetFeatureInfoUrl\",\n    value: function getFeatureTypeNameFromGetFeatureInfoUrl(url) {\n      var qualified = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var regex = /query_layers=(.*?)(&|$)/i;\n      var match = url.match(regex);\n      var featureTypeName;\n\n      if (match && match[1]) {\n        featureTypeName = decodeURIComponent(match[1]);\n\n        if (!qualified && featureTypeName.indexOf(':') > 0) {\n          featureTypeName = featureTypeName.split(':')[1];\n        }\n      }\n\n      return featureTypeName;\n    }\n    /**\n     * Resolves the given template string with the given feature attributes, e.g.\n     * the template \"Size of area is {{AREA_SIZE}} km²\" would be to resolved\n     * to \"Size of area is 1909 km²\" (assuming the feature's attribute AREA_SIZE\n     * really exists).\n     *\n     * @param {ol.Feature} feature The feature to get the attributes from.\n     * @param {string} template The template string to resolve.\n     * @param {string} [noValueFoundText] The text to apply, if the templated value\n     *   could not be found, default is to 'n.v.'.\n     * @param {Function} [valueAdjust] A method that will be called with each\n     *   key/value match, we'll use what this function returns for the actual\n     *   replacement. Optional, defaults to a function which will return the raw\n     *   value it received. This can be used for last minute adjustments before\n     *   replacing happens, e.g. to filter out falsy values or to do number\n     *   formatting and such.\n     * @param {boolean} leaveAsUrl If set to true, template won't be wrapped into\n     *   <a>-tag and will be returned as URL. Default is false.\n     * @return {string} The resolved template string.\n     */\n\n  }, {\n    key: \"resolveAttributeTemplate\",\n    value: function resolveAttributeTemplate(feature, template) {\n      var noValueFoundText = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'n.v.';\n      var valueAdjust = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function (key, val) {\n        return val;\n      };\n      var leaveAsUrl = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      var attributeTemplatePrefix = '\\\\{\\\\{';\n      var attributeTemplateSuffix = '\\\\}\\\\}';\n      var resolved = ''; // Find any character between two braces (including the braces in the result)\n\n      var regExp = new RegExp(attributeTemplatePrefix + '(.*?)' + attributeTemplateSuffix, 'g');\n      var regExpRes = (0, _isString[\"default\"])(template) ? template.match(regExp) : null; // If we have a regex result, it means we found a placeholder in the\n      // template and have to replace the placeholder with its appropriate value.\n\n      if (regExpRes) {\n        // Iterate over all regex match results and find the proper attribute\n        // for the given placeholder, finally set the desired value to the hover.\n        // field text\n        regExpRes.forEach(function (res) {\n          // We count every non matching candidate. If this count is equal to\n          // the objects length, we assume that there is no match at all and\n          // set the output value to the value of \"noValueFoundText\".\n          var noMatchCnt = 0;\n\n          for (var _i = 0, _Object$entries = Object.entries(feature.getProperties()); _i < _Object$entries.length; _i++) {\n            var _Object$entries$_i = (0, _slicedToArray2[\"default\"])(_Object$entries[_i], 2),\n                key = _Object$entries$_i[0],\n                value = _Object$entries$_i[1];\n\n            // Remove the suffixes and find the matching attribute column.\n            var attributeName = res.slice(2, res.length - 2);\n\n            if (attributeName.toLowerCase() === key.toLowerCase()) {\n              template = template.replace(res, valueAdjust(key, value));\n              break;\n            } else {\n              noMatchCnt++;\n            }\n          } // No key match found for this feature (e.g. if key not\n          // present or value is null).\n\n\n          if (noMatchCnt === Object.keys(feature.getProperties()).length) {\n            template = template.replace(res, noValueFoundText);\n          }\n        });\n      }\n\n      resolved = template; // Fallback if no feature attribute is found.\n\n      if (!resolved) {\n        resolved = feature.getId();\n      }\n\n      if (!leaveAsUrl) {\n        // Replace any HTTP url with an <a> element.\n        resolved = _StringUtil[\"default\"].urlify(resolved); // Replace all newline breaks with a html <br> tag.\n\n        resolved = resolved.replace(/\\n/g, '<br>');\n      }\n\n      return resolved;\n    }\n  }]);\n  return FeatureUtil;\n}();\n\nvar _default = FeatureUtil;\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"script"}