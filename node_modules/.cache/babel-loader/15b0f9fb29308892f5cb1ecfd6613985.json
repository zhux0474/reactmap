{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _filter = require(\"ol/format/filter\");\n\nvar _WFS = _interopRequireDefault(require(\"ol/format/WFS\"));\n/**\n * Helper class for building filters to be used with WFS GetFeature requests.\n *\n * @class WfsFilterUtil\n */\n\n\nvar WfsFilterUtil = /*#__PURE__*/function () {\n  function WfsFilterUtil() {\n    (0, _classCallCheck2[\"default\"])(this, WfsFilterUtil);\n  }\n\n  (0, _createClass2[\"default\"])(WfsFilterUtil, null, [{\n    key: \"createWfsFilter\",\n    value:\n    /**\n     * Creates a filter for a given feature type considering configured\n     * search attributes, mapped features types to an array of attribute details and the\n     * current search term.\n     * Currently supports EQUALTO and LIKE filters only, which can be combined with\n     * OR filter if searchAttributes array contains multiple values though.\n     *\n     * @param {string} featureType Name of feature type to be used in filter.\n     * @param {string} searchTerm Search value.\n     * @param {Object} searchAttributes An object mapping feature types to an array of\n     *   attributes that should be searched through.\n     * @param {Object} attributeDetails An object mapping feature types to an\n     *   array of attribute details.\n     * @return {OlFormatFilter} Filter to be used with WFS GetFeature requests.\n     * @private\n     */\n    function createWfsFilter(featureType, searchTerm, searchAttributes, attributeDetails) {\n      var attributes = searchAttributes && searchAttributes[featureType];\n\n      if (!attributes) {\n        return null;\n      }\n\n      var details = attributeDetails && attributeDetails[featureType];\n      var propertyFilters = attributes.map(function (attribute) {\n        var filterDetails = details && details[attribute];\n\n        if (filterDetails) {\n          var type = filterDetails.type;\n\n          if (type && (type === 'int' || type === 'number') && searchTerm.match(/[^.\\d]/)) {\n            return undefined;\n          }\n\n          if (filterDetails.exactSearch) {\n            return (0, _filter.equalTo)(attribute, searchTerm, filterDetails.exactSearch);\n          } else {\n            return (0, _filter.like)(attribute, \"*\".concat(searchTerm, \"*\"), '*', '.', '!', filterDetails.matchCase || false);\n          }\n        } else {\n          return (0, _filter.like)(attribute, \"*\".concat(searchTerm, \"*\"), '*', '.', '!', false);\n        }\n      }).filter(function (filter) {\n        return filter !== undefined;\n      });\n\n      if (attributes.length > 1 && Object.keys(propertyFilters).length > 1) {\n        return _filter.or.apply(void 0, (0, _toConsumableArray2[\"default\"])(propertyFilters));\n      } else {\n        return propertyFilters[0];\n      }\n    }\n    /**\n     * Creates GetFeature request body for all provided featureTypes and\n     * applies related filter encoding on it.\n     *\n     * @param {Object} searchOpts Search options object which has the following\n     * keys (see also https://github.com/terrestris/react-geo/blob/master/src/Field/WfsSearch/\n     * for further options explanations and examples):\n     *   * featureNS        {String}   The namespace URI used for features\n     *   * featurePrefix    {String}   The prefix for the feature namespace.\n     *   * featureTypes     {String[]} The feature type names to search through.\n     *   * geometryName     {String}   Geometry name to use in a BBOX filter.\n     *   * maxFeatures      {Number}   Maximum number of features to fetch.\n     *   * outputFormat     {String}   The output format of the response.\n     *   * propertyNames    {String[]} Optional list of property names to serialize.\n     *   * srsName          {String}   SRS name.\n     *   * wfsFormatOptions {Object}   Options which are passed to the constructor of the ol.format.WFS\n     *                                 (compare: https://openlayers.org/en/latest/apidoc/ol.format.WFS.html)\n     *   * searchAttributes {Object}   An object mapping feature types to an array\n     *                                 of attributes that should be searched through.\n     *   * attributeDetails {Object}   A nested object mapping feature types to an\n     *                                 object of attribute details, which are also\n     *                                 mapped by search attribute name.\n     * @param {string} searchTerm Search string to be used with filter.\n     */\n\n  }, {\n    key: \"getCombinedRequests\",\n    value: function getCombinedRequests(searchOpts, searchTerm) {\n      var featureNS = searchOpts.featureNS,\n          featurePrefix = searchOpts.featurePrefix,\n          featureTypes = searchOpts.featureTypes,\n          geometryName = searchOpts.geometryName,\n          maxFeatures = searchOpts.maxFeatures,\n          outputFormat = searchOpts.outputFormat,\n          propertyNames = searchOpts.propertyNames,\n          srsName = searchOpts.srsName,\n          wfsFormatOptions = searchOpts.wfsFormatOptions,\n          searchAttributes = searchOpts.searchAttributes,\n          attributeDetails = searchOpts.attributeDetails;\n      var requests = featureTypes.map(function (featureType) {\n        var filter = WfsFilterUtil.createWfsFilter(featureType, searchTerm, searchAttributes, attributeDetails);\n        var options = {\n          featureNS: featureNS,\n          featurePrefix: featurePrefix,\n          featureTypes: [featureType],\n          geometryName: geometryName,\n          maxFeatures: maxFeatures,\n          outputFormat: outputFormat,\n          propertyNames: propertyNames,\n          srsName: srsName,\n          filter: filter\n        };\n        var wfsFormat = new _WFS[\"default\"](wfsFormatOptions);\n        return wfsFormat.writeGetFeature(options);\n      });\n      var request = requests[0];\n      requests.forEach(function (req) {\n        if (req !== request) {\n          var query = req.querySelector('Query');\n          request.append(query);\n        }\n      });\n      return request;\n    }\n  }]);\n  return WfsFilterUtil;\n}();\n\nvar _default = WfsFilterUtil;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["/Users/rongxuan/Desktop/reactmap/reactmap/node_modules/@terrestris/ol-util/dist/WfsFilterUtil/WfsFilterUtil.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","_toConsumableArray2","_classCallCheck2","_createClass2","_filter","_WFS","WfsFilterUtil","key","createWfsFilter","featureType","searchTerm","searchAttributes","attributeDetails","attributes","details","propertyFilters","map","attribute","filterDetails","type","match","undefined","exactSearch","equalTo","like","concat","matchCase","filter","length","keys","or","apply","getCombinedRequests","searchOpts","featureNS","featurePrefix","featureTypes","geometryName","maxFeatures","outputFormat","propertyNames","srsName","wfsFormatOptions","requests","options","wfsFormat","writeGetFeature","request","forEach","req","query","querySelector","append","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _filter = require(\"ol/format/filter\");\n\nvar _WFS = _interopRequireDefault(require(\"ol/format/WFS\"));\n\n/**\n * Helper class for building filters to be used with WFS GetFeature requests.\n *\n * @class WfsFilterUtil\n */\nvar WfsFilterUtil = /*#__PURE__*/function () {\n  function WfsFilterUtil() {\n    (0, _classCallCheck2[\"default\"])(this, WfsFilterUtil);\n  }\n\n  (0, _createClass2[\"default\"])(WfsFilterUtil, null, [{\n    key: \"createWfsFilter\",\n    value:\n    /**\n     * Creates a filter for a given feature type considering configured\n     * search attributes, mapped features types to an array of attribute details and the\n     * current search term.\n     * Currently supports EQUALTO and LIKE filters only, which can be combined with\n     * OR filter if searchAttributes array contains multiple values though.\n     *\n     * @param {string} featureType Name of feature type to be used in filter.\n     * @param {string} searchTerm Search value.\n     * @param {Object} searchAttributes An object mapping feature types to an array of\n     *   attributes that should be searched through.\n     * @param {Object} attributeDetails An object mapping feature types to an\n     *   array of attribute details.\n     * @return {OlFormatFilter} Filter to be used with WFS GetFeature requests.\n     * @private\n     */\n    function createWfsFilter(featureType, searchTerm, searchAttributes, attributeDetails) {\n      var attributes = searchAttributes && searchAttributes[featureType];\n\n      if (!attributes) {\n        return null;\n      }\n\n      var details = attributeDetails && attributeDetails[featureType];\n      var propertyFilters = attributes.map(function (attribute) {\n        var filterDetails = details && details[attribute];\n\n        if (filterDetails) {\n          var type = filterDetails.type;\n\n          if (type && (type === 'int' || type === 'number') && searchTerm.match(/[^.\\d]/)) {\n            return undefined;\n          }\n\n          if (filterDetails.exactSearch) {\n            return (0, _filter.equalTo)(attribute, searchTerm, filterDetails.exactSearch);\n          } else {\n            return (0, _filter.like)(attribute, \"*\".concat(searchTerm, \"*\"), '*', '.', '!', filterDetails.matchCase || false);\n          }\n        } else {\n          return (0, _filter.like)(attribute, \"*\".concat(searchTerm, \"*\"), '*', '.', '!', false);\n        }\n      }).filter(function (filter) {\n        return filter !== undefined;\n      });\n\n      if (attributes.length > 1 && Object.keys(propertyFilters).length > 1) {\n        return _filter.or.apply(void 0, (0, _toConsumableArray2[\"default\"])(propertyFilters));\n      } else {\n        return propertyFilters[0];\n      }\n    }\n    /**\n     * Creates GetFeature request body for all provided featureTypes and\n     * applies related filter encoding on it.\n     *\n     * @param {Object} searchOpts Search options object which has the following\n     * keys (see also https://github.com/terrestris/react-geo/blob/master/src/Field/WfsSearch/\n     * for further options explanations and examples):\n     *   * featureNS        {String}   The namespace URI used for features\n     *   * featurePrefix    {String}   The prefix for the feature namespace.\n     *   * featureTypes     {String[]} The feature type names to search through.\n     *   * geometryName     {String}   Geometry name to use in a BBOX filter.\n     *   * maxFeatures      {Number}   Maximum number of features to fetch.\n     *   * outputFormat     {String}   The output format of the response.\n     *   * propertyNames    {String[]} Optional list of property names to serialize.\n     *   * srsName          {String}   SRS name.\n     *   * wfsFormatOptions {Object}   Options which are passed to the constructor of the ol.format.WFS\n     *                                 (compare: https://openlayers.org/en/latest/apidoc/ol.format.WFS.html)\n     *   * searchAttributes {Object}   An object mapping feature types to an array\n     *                                 of attributes that should be searched through.\n     *   * attributeDetails {Object}   A nested object mapping feature types to an\n     *                                 object of attribute details, which are also\n     *                                 mapped by search attribute name.\n     * @param {string} searchTerm Search string to be used with filter.\n     */\n\n  }, {\n    key: \"getCombinedRequests\",\n    value: function getCombinedRequests(searchOpts, searchTerm) {\n      var featureNS = searchOpts.featureNS,\n          featurePrefix = searchOpts.featurePrefix,\n          featureTypes = searchOpts.featureTypes,\n          geometryName = searchOpts.geometryName,\n          maxFeatures = searchOpts.maxFeatures,\n          outputFormat = searchOpts.outputFormat,\n          propertyNames = searchOpts.propertyNames,\n          srsName = searchOpts.srsName,\n          wfsFormatOptions = searchOpts.wfsFormatOptions,\n          searchAttributes = searchOpts.searchAttributes,\n          attributeDetails = searchOpts.attributeDetails;\n      var requests = featureTypes.map(function (featureType) {\n        var filter = WfsFilterUtil.createWfsFilter(featureType, searchTerm, searchAttributes, attributeDetails);\n        var options = {\n          featureNS: featureNS,\n          featurePrefix: featurePrefix,\n          featureTypes: [featureType],\n          geometryName: geometryName,\n          maxFeatures: maxFeatures,\n          outputFormat: outputFormat,\n          propertyNames: propertyNames,\n          srsName: srsName,\n          filter: filter\n        };\n        var wfsFormat = new _WFS[\"default\"](wfsFormatOptions);\n        return wfsFormat.writeGetFeature(options);\n      });\n      var request = requests[0];\n      requests.forEach(function (req) {\n        if (req !== request) {\n          var query = req.querySelector('Query');\n          request.append(query);\n        }\n      });\n      return request;\n    }\n  }]);\n  return WfsFilterUtil;\n}();\n\nvar _default = WfsFilterUtil;\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"script"}