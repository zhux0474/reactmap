{"ast":null,"code":"/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v26.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { Autowired, PostConstruct } from \"../../context/context\";\nimport { Constants } from \"../../constants/constants\";\nimport { DragAndDropService, DragSourceType, HorizontalDirection } from \"../../dragAndDrop/dragAndDropService\";\nimport { missing, exists } from \"../../utils/generic\";\nimport { sortNumerically, last, includes } from \"../../utils/array\";\n\nvar MoveColumnFeature =\n/** @class */\nfunction () {\n  function MoveColumnFeature(pinned, eContainer) {\n    this.needToMoveLeft = false;\n    this.needToMoveRight = false;\n    this.pinned = pinned;\n    this.eContainer = eContainer;\n    this.centerContainer = !exists(pinned);\n  }\n\n  MoveColumnFeature.prototype.init = function () {\n    var _this = this;\n\n    this.ctrlsService.whenReady(function () {\n      _this.gridBodyCon = _this.ctrlsService.getGridBodyCtrl();\n    });\n  };\n\n  MoveColumnFeature.prototype.getIconName = function () {\n    return this.pinned ? DragAndDropService.ICON_PINNED : DragAndDropService.ICON_MOVE;\n  };\n\n  MoveColumnFeature.prototype.onDragEnter = function (draggingEvent) {\n    // we do dummy drag, so make sure column appears in the right location when first placed\n    var columns = draggingEvent.dragItem.columns;\n    var dragCameFromToolPanel = draggingEvent.dragSource.type === DragSourceType.ToolPanel;\n\n    if (dragCameFromToolPanel) {\n      // the if statement doesn't work if drag leaves grid, then enters again\n      this.setColumnsVisible(columns, true, \"uiColumnDragged\");\n    } else {\n      // restore previous state of visible columns upon re-entering. this means if the user drags\n      // a group out, and then drags the group back in, only columns that were originally visible\n      // will be visible again. otherwise a group with three columns (but only two visible) could\n      // be dragged out, then when it's dragged in again, all three are visible. this stops that.\n      var visibleState_1 = draggingEvent.dragItem.visibleState;\n      var visibleColumns = (columns || []).filter(function (column) {\n        return visibleState_1[column.getId()];\n      });\n      this.setColumnsVisible(visibleColumns, true, \"uiColumnDragged\");\n    }\n\n    this.setColumnsPinned(columns, this.pinned, \"uiColumnDragged\");\n    this.onDragging(draggingEvent, true);\n  };\n\n  MoveColumnFeature.prototype.onDragLeave = function (draggingEvent) {\n    var hideColumnOnExit = !this.gridOptionsWrapper.isSuppressDragLeaveHidesColumns() && !draggingEvent.fromNudge;\n\n    if (hideColumnOnExit) {\n      var dragItem = draggingEvent.dragSource.getDragItem();\n      var columns = dragItem.columns;\n      this.setColumnsVisible(columns, false, \"uiColumnDragged\");\n    }\n\n    this.ensureIntervalCleared();\n  };\n\n  MoveColumnFeature.prototype.setColumnsVisible = function (columns, visible, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    if (columns) {\n      var allowedCols = columns.filter(function (c) {\n        return !c.getColDef().lockVisible;\n      });\n      this.columnModel.setColumnsVisible(allowedCols, visible, source);\n    }\n  };\n\n  MoveColumnFeature.prototype.setColumnsPinned = function (columns, pinned, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    if (columns) {\n      var allowedCols = columns.filter(function (c) {\n        return !c.getColDef().lockPinned;\n      });\n      this.columnModel.setColumnsPinned(allowedCols, pinned, source);\n    }\n  };\n\n  MoveColumnFeature.prototype.onDragStop = function () {\n    this.ensureIntervalCleared();\n  };\n\n  MoveColumnFeature.prototype.normaliseX = function (x) {\n    // flip the coordinate if doing RTL\n    if (this.gridOptionsWrapper.isEnableRtl()) {\n      var clientWidth = this.eContainer.clientWidth;\n      x = clientWidth - x;\n    } // adjust for scroll only if centre container (the pinned containers don't scroll)\n\n\n    if (this.centerContainer) {\n      x += this.ctrlsService.getCenterRowContainerCtrl().getCenterViewportScrollLeft();\n    }\n\n    return x;\n  };\n\n  MoveColumnFeature.prototype.checkCenterForScrolling = function (xAdjustedForScroll) {\n    if (this.centerContainer) {\n      // scroll if the mouse has gone outside the grid (or just outside the scrollable part if pinning)\n      // putting in 50 buffer, so even if user gets to edge of grid, a scroll will happen\n      var firstVisiblePixel = this.ctrlsService.getCenterRowContainerCtrl().getCenterViewportScrollLeft();\n      var lastVisiblePixel = firstVisiblePixel + this.ctrlsService.getCenterRowContainerCtrl().getCenterWidth();\n\n      if (this.gridOptionsWrapper.isEnableRtl()) {\n        this.needToMoveRight = xAdjustedForScroll < firstVisiblePixel + 50;\n        this.needToMoveLeft = xAdjustedForScroll > lastVisiblePixel - 50;\n      } else {\n        this.needToMoveLeft = xAdjustedForScroll < firstVisiblePixel + 50;\n        this.needToMoveRight = xAdjustedForScroll > lastVisiblePixel - 50;\n      }\n\n      if (this.needToMoveLeft || this.needToMoveRight) {\n        this.ensureIntervalStarted();\n      } else {\n        this.ensureIntervalCleared();\n      }\n    }\n  };\n\n  MoveColumnFeature.prototype.onDragging = function (draggingEvent, fromEnter) {\n    var _this = this;\n\n    if (fromEnter === void 0) {\n      fromEnter = false;\n    }\n\n    this.lastDraggingEvent = draggingEvent; // if moving up or down (ie not left or right) then do nothing\n\n    if (missing(draggingEvent.hDirection)) {\n      return;\n    }\n\n    var mouseXNormalised = this.normaliseX(draggingEvent.x); // if the user is dragging into the panel, ie coming from the side panel into the main grid,\n    // we don't want to scroll the grid this time, it would appear like the table is jumping\n    // each time a column is dragged in.\n\n    if (!fromEnter) {\n      this.checkCenterForScrolling(mouseXNormalised);\n    }\n\n    var hDirectionNormalised = this.normaliseDirection(draggingEvent.hDirection);\n    var dragSourceType = draggingEvent.dragSource.type;\n    var columnsToMove = draggingEvent.dragSource.getDragItem().columns;\n    columnsToMove = columnsToMove.filter(function (col) {\n      if (col.getColDef().lockPinned) {\n        // if locked return true only if both col and container are same pin type.\n        // double equals (==) here on purpose so that null==undefined is true (for not pinned options)\n        return col.getPinned() == _this.pinned;\n      } // if not pin locked, then always allowed to be in this container\n\n\n      return true;\n    });\n    this.attemptMoveColumns(dragSourceType, columnsToMove, hDirectionNormalised, mouseXNormalised, fromEnter);\n  };\n\n  MoveColumnFeature.prototype.normaliseDirection = function (hDirection) {\n    if (this.gridOptionsWrapper.isEnableRtl()) {\n      switch (hDirection) {\n        case HorizontalDirection.Left:\n          return HorizontalDirection.Right;\n\n        case HorizontalDirection.Right:\n          return HorizontalDirection.Left;\n\n        default:\n          console.error(\"AG Grid: Unknown direction \" + hDirection);\n      }\n    } else {\n      return hDirection;\n    }\n  }; // returns the index of the first column in the list ONLY if the cols are all beside\n  // each other. if the cols are not beside each other, then returns null\n\n\n  MoveColumnFeature.prototype.calculateOldIndex = function (movingCols) {\n    var gridCols = this.columnModel.getAllGridColumns();\n    var indexes = sortNumerically(movingCols.map(function (col) {\n      return gridCols.indexOf(col);\n    }));\n    var firstIndex = indexes[0];\n    var lastIndex = last(indexes);\n    var spread = lastIndex - firstIndex;\n    var gapsExist = spread !== indexes.length - 1;\n    return gapsExist ? null : firstIndex;\n  };\n\n  MoveColumnFeature.prototype.attemptMoveColumns = function (dragSourceType, allMovingColumns, hDirection, mouseX, fromEnter) {\n    var draggingLeft = hDirection === HorizontalDirection.Left;\n    var draggingRight = hDirection === HorizontalDirection.Right; // it is important to sort the moving columns as they are in grid columns, as the list of moving columns\n    // could themselves be part of 'married children' groups, which means we need to maintain the order within\n    // the moving list.\n\n    var allMovingColumnsOrdered = allMovingColumns.slice();\n    this.columnModel.sortColumnsLikeGridColumns(allMovingColumnsOrdered);\n    var validMoves = this.calculateValidMoves(allMovingColumnsOrdered, draggingRight, mouseX); // if cols are not adjacent, then this returns null. when moving, we constrain the direction of the move\n    // (ie left or right) to the mouse direction. however\n\n    var oldIndex = this.calculateOldIndex(allMovingColumnsOrdered);\n\n    if (validMoves.length === 0) {\n      return;\n    }\n\n    var firstValidMove = validMoves[0]; // the two check below stop an error when the user grabs a group my a middle column, then\n    // it is possible the mouse pointer is to the right of a column while been dragged left.\n    // so we need to make sure that the mouse pointer is actually left of the left most column\n    // if moving left, and right of the right most column if moving right\n    // we check 'fromEnter' below so we move the column to the new spot if the mouse is coming from\n    // outside the grid, eg if the column is moving from side panel, mouse is moving left, then we should\n    // place the column to the RHS even if the mouse is moving left and the column is already on\n    // the LHS. otherwise we stick to the rule described above.\n\n    var constrainDirection = oldIndex !== null && !fromEnter; // don't consider 'fromEnter' when dragging header cells, otherwise group can jump to opposite direction of drag\n\n    if (dragSourceType == DragSourceType.HeaderCell) {\n      constrainDirection = oldIndex !== null;\n    }\n\n    if (constrainDirection) {\n      // only allow left drag if this column is moving left\n      if (draggingLeft && firstValidMove >= oldIndex) {\n        return;\n      } // only allow right drag if this column is moving right\n\n\n      if (draggingRight && firstValidMove <= oldIndex) {\n        return;\n      }\n    }\n\n    for (var i = 0; i < validMoves.length; i++) {\n      var move = validMoves[i];\n\n      if (!this.columnModel.doesMovePassRules(allMovingColumnsOrdered, move)) {\n        continue;\n      }\n\n      this.columnModel.moveColumns(allMovingColumnsOrdered, move, \"uiColumnDragged\"); // important to return here, so once we do the first valid move, we don't try do any more\n\n      return;\n    }\n  };\n\n  MoveColumnFeature.prototype.calculateValidMoves = function (movingCols, draggingRight, mouseX) {\n    var isMoveBlocked = this.gridOptionsWrapper.isSuppressMovableColumns() || movingCols.some(function (col) {\n      return col.getColDef().suppressMovable;\n    });\n\n    if (isMoveBlocked) {\n      return [];\n    } // this is the list of cols on the screen, so it's these we use when comparing the x mouse position\n\n\n    var allDisplayedCols = this.columnModel.getDisplayedColumns(this.pinned); // but this list is the list of all cols, when we move a col it's the index within this list that gets used,\n    // so the result we return has to be and index location for this list\n\n    var allGridCols = this.columnModel.getAllGridColumns();\n    var movingDisplayedCols = allDisplayedCols.filter(function (col) {\n      return includes(movingCols, col);\n    });\n    var otherDisplayedCols = allDisplayedCols.filter(function (col) {\n      return !includes(movingCols, col);\n    });\n    var otherGridCols = allGridCols.filter(function (col) {\n      return !includes(movingCols, col);\n    }); // work out how many DISPLAYED columns fit before the 'x' position. this gives us the displayIndex.\n    // for example, if cols are a,b,c,d and we find a,b fit before 'x', then we want to place the moving\n    // col between b and c (so that it is under the mouse position).\n\n    var displayIndex = 0;\n    var availableWidth = mouseX; // if we are dragging right, then the columns will be to the left of the mouse, so we also want to\n    // include the width of the moving columns\n\n    if (draggingRight) {\n      var widthOfMovingDisplayedCols_1 = 0;\n      movingDisplayedCols.forEach(function (col) {\n        return widthOfMovingDisplayedCols_1 += col.getActualWidth();\n      });\n      availableWidth -= widthOfMovingDisplayedCols_1;\n    }\n\n    if (availableWidth > 0) {\n      // now count how many of the displayed columns will fit to the left\n      for (var i = 0; i < otherDisplayedCols.length; i++) {\n        var col = otherDisplayedCols[i];\n        availableWidth -= col.getActualWidth();\n\n        if (availableWidth < 0) {\n          break;\n        }\n\n        displayIndex++;\n      } // trial and error, if going right, we adjust by one, i didn't manage to quantify why, but it works\n\n\n      if (draggingRight) {\n        displayIndex++;\n      }\n    } // the display index is with respect to all the showing columns, however when we move, it's with\n    // respect to all grid columns, so we need to translate from display index to grid index\n\n\n    var firstValidMove;\n\n    if (displayIndex > 0) {\n      var leftColumn = otherDisplayedCols[displayIndex - 1];\n      firstValidMove = otherGridCols.indexOf(leftColumn) + 1;\n    } else {\n      firstValidMove = otherGridCols.indexOf(otherDisplayedCols[0]);\n\n      if (firstValidMove === -1) {\n        firstValidMove = 0;\n      }\n    }\n\n    var validMoves = [firstValidMove];\n\n    var numberComparator = function (a, b) {\n      return a - b;\n    }; // add in other valid moves due to hidden columns and married children. for example, a particular\n    // move might break a group that has married children (so move isn't valid), however there could\n    // be hidden columns (not displayed) that we could jump over to make the move valid. because\n    // they are hidden, user doesn't see any different, however it allows moves that would otherwise\n    // not work. for example imagine a group with 9 columns and all columns are hidden except the\n    // middle one (so 4 hidden to left, 4 hidden to right), then when moving 'firstValidMove' will\n    // be relative to the not-shown column, however we need to consider the move jumping over all the\n    // hidden children. if we didn't do this, then if the group just described was at the end (RHS) of the\n    // grid, there would be no way to put a column after it (as the grid would only consider beside the\n    // visible column, which would fail valid move rules).\n\n\n    if (draggingRight) {\n      // if dragging right, then we add all the additional moves to the right. so in other words\n      // if the next move is not valid, find the next move to the right that is valid.\n      var pointer = firstValidMove + 1;\n      var lastIndex = allGridCols.length - 1;\n\n      while (pointer <= lastIndex) {\n        validMoves.push(pointer);\n        pointer++;\n      } // adding columns here means the order is now messed up\n\n\n      validMoves.sort(numberComparator);\n    } else {\n      // if dragging left we do the reverse of dragging right, we add in all the valid moves to the\n      // left. however we also have to consider moves to the right for all hidden columns first.\n      // (this logic is hard to reason with, it was worked out with trial and error,\n      // more observation rather than science).\n      // add moves to the right\n      var pointer = firstValidMove;\n      var lastIndex = allGridCols.length - 1;\n      var displacedCol = allGridCols[pointer];\n\n      while (pointer <= lastIndex && this.isColumnHidden(allDisplayedCols, displacedCol)) {\n        pointer++;\n        validMoves.push(pointer);\n        displacedCol = allGridCols[pointer];\n      } // add moves to the left\n\n\n      pointer = firstValidMove - 1;\n      var firstDisplayIndex = 0;\n\n      while (pointer >= firstDisplayIndex) {\n        validMoves.push(pointer);\n        pointer--;\n      } // adding columns here means the order is now messed up\n\n\n      validMoves.sort(numberComparator).reverse();\n    }\n\n    return validMoves;\n  }; // isHidden takes into account visible=false and group=closed, ie it is not displayed\n\n\n  MoveColumnFeature.prototype.isColumnHidden = function (displayedColumns, col) {\n    return displayedColumns.indexOf(col) < 0;\n  };\n\n  MoveColumnFeature.prototype.ensureIntervalStarted = function () {\n    if (!this.movingIntervalId) {\n      this.intervalCount = 0;\n      this.failedMoveAttempts = 0;\n      this.movingIntervalId = window.setInterval(this.moveInterval.bind(this), 100);\n\n      if (this.needToMoveLeft) {\n        this.dragAndDropService.setGhostIcon(DragAndDropService.ICON_LEFT, true);\n      } else {\n        this.dragAndDropService.setGhostIcon(DragAndDropService.ICON_RIGHT, true);\n      }\n    }\n  };\n\n  MoveColumnFeature.prototype.ensureIntervalCleared = function () {\n    if (this.movingIntervalId) {\n      window.clearInterval(this.movingIntervalId);\n      this.movingIntervalId = null;\n      this.dragAndDropService.setGhostIcon(DragAndDropService.ICON_MOVE);\n    }\n  };\n\n  MoveColumnFeature.prototype.moveInterval = function () {\n    // the amounts we move get bigger at each interval, so the speed accelerates, starting a bit slow\n    // and getting faster. this is to give smoother user experience. we max at 100px to limit the speed.\n    var pixelsToMove;\n    this.intervalCount++;\n    pixelsToMove = 10 + this.intervalCount * 5;\n\n    if (pixelsToMove > 100) {\n      pixelsToMove = 100;\n    }\n\n    var pixelsMoved = null;\n    var scrollFeature = this.gridBodyCon.getScrollFeature();\n\n    if (this.needToMoveLeft) {\n      pixelsMoved = scrollFeature.scrollHorizontally(-pixelsToMove);\n    } else if (this.needToMoveRight) {\n      pixelsMoved = scrollFeature.scrollHorizontally(pixelsToMove);\n    }\n\n    if (pixelsMoved !== 0) {\n      this.onDragging(this.lastDraggingEvent);\n      this.failedMoveAttempts = 0;\n    } else {\n      // we count the failed move attempts. if we fail to move 7 times, then we pin the column.\n      // this is how we achieve pining by dragging the column to the edge of the grid.\n      this.failedMoveAttempts++;\n      var columns = this.lastDraggingEvent.dragItem.columns;\n      var columnsThatCanPin = columns.filter(function (c) {\n        return !c.getColDef().lockPinned;\n      });\n\n      if (columnsThatCanPin.length > 0) {\n        this.dragAndDropService.setGhostIcon(DragAndDropService.ICON_PINNED);\n\n        if (this.failedMoveAttempts > 7) {\n          var pinType = this.needToMoveLeft ? Constants.PINNED_LEFT : Constants.PINNED_RIGHT;\n          this.setColumnsPinned(columnsThatCanPin, pinType, \"uiColumnDragged\");\n          this.dragAndDropService.nudge();\n        }\n      }\n    }\n  };\n\n  __decorate([Autowired('columnModel')], MoveColumnFeature.prototype, \"columnModel\", void 0);\n\n  __decorate([Autowired('dragAndDropService')], MoveColumnFeature.prototype, \"dragAndDropService\", void 0);\n\n  __decorate([Autowired('gridOptionsWrapper')], MoveColumnFeature.prototype, \"gridOptionsWrapper\", void 0);\n\n  __decorate([Autowired('ctrlsService')], MoveColumnFeature.prototype, \"ctrlsService\", void 0);\n\n  __decorate([PostConstruct], MoveColumnFeature.prototype, \"init\", null);\n\n  return MoveColumnFeature;\n}();\n\nexport { MoveColumnFeature };","map":{"version":3,"sources":["/Users/rongxuan/Desktop/reactmap/reactmap/node_modules/@ag-grid-community/core/dist/es6/headerRendering/columnDrag/moveColumnFeature.js"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","Autowired","PostConstruct","Constants","DragAndDropService","DragSourceType","HorizontalDirection","missing","exists","sortNumerically","last","includes","MoveColumnFeature","pinned","eContainer","needToMoveLeft","needToMoveRight","centerContainer","prototype","init","_this","ctrlsService","whenReady","gridBodyCon","getGridBodyCtrl","getIconName","ICON_PINNED","ICON_MOVE","onDragEnter","draggingEvent","columns","dragItem","dragCameFromToolPanel","dragSource","type","ToolPanel","setColumnsVisible","visibleState_1","visibleState","visibleColumns","filter","column","getId","setColumnsPinned","onDragging","onDragLeave","hideColumnOnExit","gridOptionsWrapper","isSuppressDragLeaveHidesColumns","fromNudge","getDragItem","ensureIntervalCleared","visible","source","allowedCols","getColDef","lockVisible","columnModel","lockPinned","onDragStop","normaliseX","x","isEnableRtl","clientWidth","getCenterRowContainerCtrl","getCenterViewportScrollLeft","checkCenterForScrolling","xAdjustedForScroll","firstVisiblePixel","lastVisiblePixel","getCenterWidth","ensureIntervalStarted","fromEnter","lastDraggingEvent","hDirection","mouseXNormalised","hDirectionNormalised","normaliseDirection","dragSourceType","columnsToMove","col","getPinned","attemptMoveColumns","Left","Right","console","error","calculateOldIndex","movingCols","gridCols","getAllGridColumns","indexes","map","indexOf","firstIndex","lastIndex","spread","gapsExist","allMovingColumns","mouseX","draggingLeft","draggingRight","allMovingColumnsOrdered","slice","sortColumnsLikeGridColumns","validMoves","calculateValidMoves","oldIndex","firstValidMove","constrainDirection","HeaderCell","move","doesMovePassRules","moveColumns","isMoveBlocked","isSuppressMovableColumns","some","suppressMovable","allDisplayedCols","getDisplayedColumns","allGridCols","movingDisplayedCols","otherDisplayedCols","otherGridCols","displayIndex","availableWidth","widthOfMovingDisplayedCols_1","forEach","getActualWidth","leftColumn","numberComparator","a","b","pointer","push","sort","displacedCol","isColumnHidden","firstDisplayIndex","reverse","displayedColumns","movingIntervalId","intervalCount","failedMoveAttempts","window","setInterval","moveInterval","bind","dragAndDropService","setGhostIcon","ICON_LEFT","ICON_RIGHT","clearInterval","pixelsToMove","pixelsMoved","scrollFeature","getScrollFeature","scrollHorizontally","columnsThatCanPin","pinType","PINNED_LEFT","PINNED_RIGHT","nudge"],"mappings":"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","sourcesContent":["/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v26.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Autowired, PostConstruct } from \"../../context/context\";\nimport { Constants } from \"../../constants/constants\";\nimport { DragAndDropService, DragSourceType, HorizontalDirection } from \"../../dragAndDrop/dragAndDropService\";\nimport { missing, exists } from \"../../utils/generic\";\nimport { sortNumerically, last, includes } from \"../../utils/array\";\nvar MoveColumnFeature = /** @class */ (function () {\n    function MoveColumnFeature(pinned, eContainer) {\n        this.needToMoveLeft = false;\n        this.needToMoveRight = false;\n        this.pinned = pinned;\n        this.eContainer = eContainer;\n        this.centerContainer = !exists(pinned);\n    }\n    MoveColumnFeature.prototype.init = function () {\n        var _this = this;\n        this.ctrlsService.whenReady(function () {\n            _this.gridBodyCon = _this.ctrlsService.getGridBodyCtrl();\n        });\n    };\n    MoveColumnFeature.prototype.getIconName = function () {\n        return this.pinned ? DragAndDropService.ICON_PINNED : DragAndDropService.ICON_MOVE;\n    };\n    MoveColumnFeature.prototype.onDragEnter = function (draggingEvent) {\n        // we do dummy drag, so make sure column appears in the right location when first placed\n        var columns = draggingEvent.dragItem.columns;\n        var dragCameFromToolPanel = draggingEvent.dragSource.type === DragSourceType.ToolPanel;\n        if (dragCameFromToolPanel) {\n            // the if statement doesn't work if drag leaves grid, then enters again\n            this.setColumnsVisible(columns, true, \"uiColumnDragged\");\n        }\n        else {\n            // restore previous state of visible columns upon re-entering. this means if the user drags\n            // a group out, and then drags the group back in, only columns that were originally visible\n            // will be visible again. otherwise a group with three columns (but only two visible) could\n            // be dragged out, then when it's dragged in again, all three are visible. this stops that.\n            var visibleState_1 = draggingEvent.dragItem.visibleState;\n            var visibleColumns = (columns || []).filter(function (column) { return visibleState_1[column.getId()]; });\n            this.setColumnsVisible(visibleColumns, true, \"uiColumnDragged\");\n        }\n        this.setColumnsPinned(columns, this.pinned, \"uiColumnDragged\");\n        this.onDragging(draggingEvent, true);\n    };\n    MoveColumnFeature.prototype.onDragLeave = function (draggingEvent) {\n        var hideColumnOnExit = !this.gridOptionsWrapper.isSuppressDragLeaveHidesColumns() && !draggingEvent.fromNudge;\n        if (hideColumnOnExit) {\n            var dragItem = draggingEvent.dragSource.getDragItem();\n            var columns = dragItem.columns;\n            this.setColumnsVisible(columns, false, \"uiColumnDragged\");\n        }\n        this.ensureIntervalCleared();\n    };\n    MoveColumnFeature.prototype.setColumnsVisible = function (columns, visible, source) {\n        if (source === void 0) { source = \"api\"; }\n        if (columns) {\n            var allowedCols = columns.filter(function (c) { return !c.getColDef().lockVisible; });\n            this.columnModel.setColumnsVisible(allowedCols, visible, source);\n        }\n    };\n    MoveColumnFeature.prototype.setColumnsPinned = function (columns, pinned, source) {\n        if (source === void 0) { source = \"api\"; }\n        if (columns) {\n            var allowedCols = columns.filter(function (c) { return !c.getColDef().lockPinned; });\n            this.columnModel.setColumnsPinned(allowedCols, pinned, source);\n        }\n    };\n    MoveColumnFeature.prototype.onDragStop = function () {\n        this.ensureIntervalCleared();\n    };\n    MoveColumnFeature.prototype.normaliseX = function (x) {\n        // flip the coordinate if doing RTL\n        if (this.gridOptionsWrapper.isEnableRtl()) {\n            var clientWidth = this.eContainer.clientWidth;\n            x = clientWidth - x;\n        }\n        // adjust for scroll only if centre container (the pinned containers don't scroll)\n        if (this.centerContainer) {\n            x += this.ctrlsService.getCenterRowContainerCtrl().getCenterViewportScrollLeft();\n        }\n        return x;\n    };\n    MoveColumnFeature.prototype.checkCenterForScrolling = function (xAdjustedForScroll) {\n        if (this.centerContainer) {\n            // scroll if the mouse has gone outside the grid (or just outside the scrollable part if pinning)\n            // putting in 50 buffer, so even if user gets to edge of grid, a scroll will happen\n            var firstVisiblePixel = this.ctrlsService.getCenterRowContainerCtrl().getCenterViewportScrollLeft();\n            var lastVisiblePixel = firstVisiblePixel + this.ctrlsService.getCenterRowContainerCtrl().getCenterWidth();\n            if (this.gridOptionsWrapper.isEnableRtl()) {\n                this.needToMoveRight = xAdjustedForScroll < (firstVisiblePixel + 50);\n                this.needToMoveLeft = xAdjustedForScroll > (lastVisiblePixel - 50);\n            }\n            else {\n                this.needToMoveLeft = xAdjustedForScroll < (firstVisiblePixel + 50);\n                this.needToMoveRight = xAdjustedForScroll > (lastVisiblePixel - 50);\n            }\n            if (this.needToMoveLeft || this.needToMoveRight) {\n                this.ensureIntervalStarted();\n            }\n            else {\n                this.ensureIntervalCleared();\n            }\n        }\n    };\n    MoveColumnFeature.prototype.onDragging = function (draggingEvent, fromEnter) {\n        var _this = this;\n        if (fromEnter === void 0) { fromEnter = false; }\n        this.lastDraggingEvent = draggingEvent;\n        // if moving up or down (ie not left or right) then do nothing\n        if (missing(draggingEvent.hDirection)) {\n            return;\n        }\n        var mouseXNormalised = this.normaliseX(draggingEvent.x);\n        // if the user is dragging into the panel, ie coming from the side panel into the main grid,\n        // we don't want to scroll the grid this time, it would appear like the table is jumping\n        // each time a column is dragged in.\n        if (!fromEnter) {\n            this.checkCenterForScrolling(mouseXNormalised);\n        }\n        var hDirectionNormalised = this.normaliseDirection(draggingEvent.hDirection);\n        var dragSourceType = draggingEvent.dragSource.type;\n        var columnsToMove = draggingEvent.dragSource.getDragItem().columns;\n        columnsToMove = columnsToMove.filter(function (col) {\n            if (col.getColDef().lockPinned) {\n                // if locked return true only if both col and container are same pin type.\n                // double equals (==) here on purpose so that null==undefined is true (for not pinned options)\n                return col.getPinned() == _this.pinned;\n            }\n            // if not pin locked, then always allowed to be in this container\n            return true;\n        });\n        this.attemptMoveColumns(dragSourceType, columnsToMove, hDirectionNormalised, mouseXNormalised, fromEnter);\n    };\n    MoveColumnFeature.prototype.normaliseDirection = function (hDirection) {\n        if (this.gridOptionsWrapper.isEnableRtl()) {\n            switch (hDirection) {\n                case HorizontalDirection.Left: return HorizontalDirection.Right;\n                case HorizontalDirection.Right: return HorizontalDirection.Left;\n                default: console.error(\"AG Grid: Unknown direction \" + hDirection);\n            }\n        }\n        else {\n            return hDirection;\n        }\n    };\n    // returns the index of the first column in the list ONLY if the cols are all beside\n    // each other. if the cols are not beside each other, then returns null\n    MoveColumnFeature.prototype.calculateOldIndex = function (movingCols) {\n        var gridCols = this.columnModel.getAllGridColumns();\n        var indexes = sortNumerically(movingCols.map(function (col) { return gridCols.indexOf(col); }));\n        var firstIndex = indexes[0];\n        var lastIndex = last(indexes);\n        var spread = lastIndex - firstIndex;\n        var gapsExist = spread !== indexes.length - 1;\n        return gapsExist ? null : firstIndex;\n    };\n    MoveColumnFeature.prototype.attemptMoveColumns = function (dragSourceType, allMovingColumns, hDirection, mouseX, fromEnter) {\n        var draggingLeft = hDirection === HorizontalDirection.Left;\n        var draggingRight = hDirection === HorizontalDirection.Right;\n        // it is important to sort the moving columns as they are in grid columns, as the list of moving columns\n        // could themselves be part of 'married children' groups, which means we need to maintain the order within\n        // the moving list.\n        var allMovingColumnsOrdered = allMovingColumns.slice();\n        this.columnModel.sortColumnsLikeGridColumns(allMovingColumnsOrdered);\n        var validMoves = this.calculateValidMoves(allMovingColumnsOrdered, draggingRight, mouseX);\n        // if cols are not adjacent, then this returns null. when moving, we constrain the direction of the move\n        // (ie left or right) to the mouse direction. however\n        var oldIndex = this.calculateOldIndex(allMovingColumnsOrdered);\n        if (validMoves.length === 0) {\n            return;\n        }\n        var firstValidMove = validMoves[0];\n        // the two check below stop an error when the user grabs a group my a middle column, then\n        // it is possible the mouse pointer is to the right of a column while been dragged left.\n        // so we need to make sure that the mouse pointer is actually left of the left most column\n        // if moving left, and right of the right most column if moving right\n        // we check 'fromEnter' below so we move the column to the new spot if the mouse is coming from\n        // outside the grid, eg if the column is moving from side panel, mouse is moving left, then we should\n        // place the column to the RHS even if the mouse is moving left and the column is already on\n        // the LHS. otherwise we stick to the rule described above.\n        var constrainDirection = oldIndex !== null && !fromEnter;\n        // don't consider 'fromEnter' when dragging header cells, otherwise group can jump to opposite direction of drag\n        if (dragSourceType == DragSourceType.HeaderCell) {\n            constrainDirection = oldIndex !== null;\n        }\n        if (constrainDirection) {\n            // only allow left drag if this column is moving left\n            if (draggingLeft && firstValidMove >= oldIndex) {\n                return;\n            }\n            // only allow right drag if this column is moving right\n            if (draggingRight && firstValidMove <= oldIndex) {\n                return;\n            }\n        }\n        for (var i = 0; i < validMoves.length; i++) {\n            var move = validMoves[i];\n            if (!this.columnModel.doesMovePassRules(allMovingColumnsOrdered, move)) {\n                continue;\n            }\n            this.columnModel.moveColumns(allMovingColumnsOrdered, move, \"uiColumnDragged\");\n            // important to return here, so once we do the first valid move, we don't try do any more\n            return;\n        }\n    };\n    MoveColumnFeature.prototype.calculateValidMoves = function (movingCols, draggingRight, mouseX) {\n        var isMoveBlocked = this.gridOptionsWrapper.isSuppressMovableColumns() || movingCols.some(function (col) { return col.getColDef().suppressMovable; });\n        if (isMoveBlocked) {\n            return [];\n        }\n        // this is the list of cols on the screen, so it's these we use when comparing the x mouse position\n        var allDisplayedCols = this.columnModel.getDisplayedColumns(this.pinned);\n        // but this list is the list of all cols, when we move a col it's the index within this list that gets used,\n        // so the result we return has to be and index location for this list\n        var allGridCols = this.columnModel.getAllGridColumns();\n        var movingDisplayedCols = allDisplayedCols.filter(function (col) { return includes(movingCols, col); });\n        var otherDisplayedCols = allDisplayedCols.filter(function (col) { return !includes(movingCols, col); });\n        var otherGridCols = allGridCols.filter(function (col) { return !includes(movingCols, col); });\n        // work out how many DISPLAYED columns fit before the 'x' position. this gives us the displayIndex.\n        // for example, if cols are a,b,c,d and we find a,b fit before 'x', then we want to place the moving\n        // col between b and c (so that it is under the mouse position).\n        var displayIndex = 0;\n        var availableWidth = mouseX;\n        // if we are dragging right, then the columns will be to the left of the mouse, so we also want to\n        // include the width of the moving columns\n        if (draggingRight) {\n            var widthOfMovingDisplayedCols_1 = 0;\n            movingDisplayedCols.forEach(function (col) { return widthOfMovingDisplayedCols_1 += col.getActualWidth(); });\n            availableWidth -= widthOfMovingDisplayedCols_1;\n        }\n        if (availableWidth > 0) {\n            // now count how many of the displayed columns will fit to the left\n            for (var i = 0; i < otherDisplayedCols.length; i++) {\n                var col = otherDisplayedCols[i];\n                availableWidth -= col.getActualWidth();\n                if (availableWidth < 0) {\n                    break;\n                }\n                displayIndex++;\n            }\n            // trial and error, if going right, we adjust by one, i didn't manage to quantify why, but it works\n            if (draggingRight) {\n                displayIndex++;\n            }\n        }\n        // the display index is with respect to all the showing columns, however when we move, it's with\n        // respect to all grid columns, so we need to translate from display index to grid index\n        var firstValidMove;\n        if (displayIndex > 0) {\n            var leftColumn = otherDisplayedCols[displayIndex - 1];\n            firstValidMove = otherGridCols.indexOf(leftColumn) + 1;\n        }\n        else {\n            firstValidMove = otherGridCols.indexOf(otherDisplayedCols[0]);\n            if (firstValidMove === -1) {\n                firstValidMove = 0;\n            }\n        }\n        var validMoves = [firstValidMove];\n        var numberComparator = function (a, b) { return a - b; };\n        // add in other valid moves due to hidden columns and married children. for example, a particular\n        // move might break a group that has married children (so move isn't valid), however there could\n        // be hidden columns (not displayed) that we could jump over to make the move valid. because\n        // they are hidden, user doesn't see any different, however it allows moves that would otherwise\n        // not work. for example imagine a group with 9 columns and all columns are hidden except the\n        // middle one (so 4 hidden to left, 4 hidden to right), then when moving 'firstValidMove' will\n        // be relative to the not-shown column, however we need to consider the move jumping over all the\n        // hidden children. if we didn't do this, then if the group just described was at the end (RHS) of the\n        // grid, there would be no way to put a column after it (as the grid would only consider beside the\n        // visible column, which would fail valid move rules).\n        if (draggingRight) {\n            // if dragging right, then we add all the additional moves to the right. so in other words\n            // if the next move is not valid, find the next move to the right that is valid.\n            var pointer = firstValidMove + 1;\n            var lastIndex = allGridCols.length - 1;\n            while (pointer <= lastIndex) {\n                validMoves.push(pointer);\n                pointer++;\n            }\n            // adding columns here means the order is now messed up\n            validMoves.sort(numberComparator);\n        }\n        else {\n            // if dragging left we do the reverse of dragging right, we add in all the valid moves to the\n            // left. however we also have to consider moves to the right for all hidden columns first.\n            // (this logic is hard to reason with, it was worked out with trial and error,\n            // more observation rather than science).\n            // add moves to the right\n            var pointer = firstValidMove;\n            var lastIndex = allGridCols.length - 1;\n            var displacedCol = allGridCols[pointer];\n            while (pointer <= lastIndex && this.isColumnHidden(allDisplayedCols, displacedCol)) {\n                pointer++;\n                validMoves.push(pointer);\n                displacedCol = allGridCols[pointer];\n            }\n            // add moves to the left\n            pointer = firstValidMove - 1;\n            var firstDisplayIndex = 0;\n            while (pointer >= firstDisplayIndex) {\n                validMoves.push(pointer);\n                pointer--;\n            }\n            // adding columns here means the order is now messed up\n            validMoves.sort(numberComparator).reverse();\n        }\n        return validMoves;\n    };\n    // isHidden takes into account visible=false and group=closed, ie it is not displayed\n    MoveColumnFeature.prototype.isColumnHidden = function (displayedColumns, col) {\n        return displayedColumns.indexOf(col) < 0;\n    };\n    MoveColumnFeature.prototype.ensureIntervalStarted = function () {\n        if (!this.movingIntervalId) {\n            this.intervalCount = 0;\n            this.failedMoveAttempts = 0;\n            this.movingIntervalId = window.setInterval(this.moveInterval.bind(this), 100);\n            if (this.needToMoveLeft) {\n                this.dragAndDropService.setGhostIcon(DragAndDropService.ICON_LEFT, true);\n            }\n            else {\n                this.dragAndDropService.setGhostIcon(DragAndDropService.ICON_RIGHT, true);\n            }\n        }\n    };\n    MoveColumnFeature.prototype.ensureIntervalCleared = function () {\n        if (this.movingIntervalId) {\n            window.clearInterval(this.movingIntervalId);\n            this.movingIntervalId = null;\n            this.dragAndDropService.setGhostIcon(DragAndDropService.ICON_MOVE);\n        }\n    };\n    MoveColumnFeature.prototype.moveInterval = function () {\n        // the amounts we move get bigger at each interval, so the speed accelerates, starting a bit slow\n        // and getting faster. this is to give smoother user experience. we max at 100px to limit the speed.\n        var pixelsToMove;\n        this.intervalCount++;\n        pixelsToMove = 10 + (this.intervalCount * 5);\n        if (pixelsToMove > 100) {\n            pixelsToMove = 100;\n        }\n        var pixelsMoved = null;\n        var scrollFeature = this.gridBodyCon.getScrollFeature();\n        if (this.needToMoveLeft) {\n            pixelsMoved = scrollFeature.scrollHorizontally(-pixelsToMove);\n        }\n        else if (this.needToMoveRight) {\n            pixelsMoved = scrollFeature.scrollHorizontally(pixelsToMove);\n        }\n        if (pixelsMoved !== 0) {\n            this.onDragging(this.lastDraggingEvent);\n            this.failedMoveAttempts = 0;\n        }\n        else {\n            // we count the failed move attempts. if we fail to move 7 times, then we pin the column.\n            // this is how we achieve pining by dragging the column to the edge of the grid.\n            this.failedMoveAttempts++;\n            var columns = this.lastDraggingEvent.dragItem.columns;\n            var columnsThatCanPin = columns.filter(function (c) { return !c.getColDef().lockPinned; });\n            if (columnsThatCanPin.length > 0) {\n                this.dragAndDropService.setGhostIcon(DragAndDropService.ICON_PINNED);\n                if (this.failedMoveAttempts > 7) {\n                    var pinType = this.needToMoveLeft ? Constants.PINNED_LEFT : Constants.PINNED_RIGHT;\n                    this.setColumnsPinned(columnsThatCanPin, pinType, \"uiColumnDragged\");\n                    this.dragAndDropService.nudge();\n                }\n            }\n        }\n    };\n    __decorate([\n        Autowired('columnModel')\n    ], MoveColumnFeature.prototype, \"columnModel\", void 0);\n    __decorate([\n        Autowired('dragAndDropService')\n    ], MoveColumnFeature.prototype, \"dragAndDropService\", void 0);\n    __decorate([\n        Autowired('gridOptionsWrapper')\n    ], MoveColumnFeature.prototype, \"gridOptionsWrapper\", void 0);\n    __decorate([\n        Autowired('ctrlsService')\n    ], MoveColumnFeature.prototype, \"ctrlsService\", void 0);\n    __decorate([\n        PostConstruct\n    ], MoveColumnFeature.prototype, \"init\", null);\n    return MoveColumnFeature;\n}());\nexport { MoveColumnFeature };\n"]},"metadata":{},"sourceType":"module"}