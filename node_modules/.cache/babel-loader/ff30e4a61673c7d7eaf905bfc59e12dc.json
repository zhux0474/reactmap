{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _sphere = require(\"ol/sphere\");\n/**\n * This class provides some static methods which might be helpful when working\n * with measurements.\n *\n * @class MeasureUtil\n */\n\n\nvar MeasureUtil = /*#__PURE__*/function () {\n  function MeasureUtil() {\n    (0, _classCallCheck2[\"default\"])(this, MeasureUtil);\n  }\n\n  (0, _createClass2[\"default\"])(MeasureUtil, null, [{\n    key: \"getLength\",\n    value:\n    /**\n     * Get the length of a OlGeomLineString.\n     *\n     * @param {OlGeomLineString} line The drawn line.\n     * @param {OlMap} map An OlMap.\n     * @param {boolean} geodesic Is the measurement geodesic (default is true).\n     * @param {number} radius Sphere radius. By default, the radius of the earth\n     *                        is used (Clarke 1866 Authalic Sphere, 6371008.8).\n     *\n     * @return {number} The length of line in meters.\n     */\n    function getLength(line, map) {\n      var geodesic = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var radius = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 6371008.8;\n\n      if (geodesic) {\n        var opts = {\n          projection: map.getView().getProjection().getCode(),\n          radius: radius\n        };\n        return (0, _sphere.getLength)(line, opts);\n      } else {\n        return Math.round(line.getLength() * 100) / 100;\n      }\n    }\n    /**\n     * Format length output for the tooltip.\n     *\n     * @param {OlGeomLineString} line The drawn line.\n     * @param {OlMap} map An OlMap.\n     * @param {number} decimalPlacesInToolTips How many decimal places will be\n     *   allowed for the measure tooltips\n     * @param {boolean} geodesic Is the measurement geodesic (default is true).\n     *\n     * @return {string} The formatted length of the line.\n     */\n\n  }, {\n    key: \"formatLength\",\n    value: function formatLength(line, map, decimalPlacesInToolTips) {\n      var geodesic = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      var decimalHelper = Math.pow(10, decimalPlacesInToolTips);\n      var length = MeasureUtil.getLength(line, map, geodesic);\n      var output;\n\n      if (length > 1000) {\n        output = Math.round(length / 1000 * decimalHelper) / decimalHelper + ' km';\n      } else {\n        output = Math.round(length * decimalHelper) / decimalHelper + ' m';\n      }\n\n      return output;\n    }\n    /**\n     * Get the area of a OlGeomPolygon.\n     *\n     * @param {OlGeomPolygon} polygon The drawn polygon.\n     * @param {OlMap} map An OlMap.\n     * @param {boolean} geodesic Is the measurement geodesic (default is true).\n     * @param {number} radius Sphere radius. By default, the radius of the earth\n     *                        is used (Clarke 1866 Authalic Sphere, 6371008.8).\n     *\n     * @return {number} The area of the polygon in square meter.\n     */\n\n  }, {\n    key: \"getArea\",\n    value: function getArea(polygon, map) {\n      var geodesic = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var radius = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 6371008.8;\n\n      if (geodesic) {\n        var opts = {\n          projection: map.getView().getProjection().getCode(),\n          radius: radius\n        };\n        return (0, _sphere.getArea)(polygon, opts);\n      } else {\n        return polygon.getArea();\n      }\n    }\n    /**\n     * Format length output for the tooltip.\n     *\n     * @param {OlGeomPolygon} polygon The drawn polygon.\n     * @param {OlMap} map An OlMap.\n     * @param {number} decimalPlacesInToolTips How many decimal places will be\n     *   allowed for the measure tooltips.\n     * @param {boolean} geodesic Is the measurement geodesic.\n     *\n     * @return {string} The formatted area of the polygon.\n     */\n\n  }, {\n    key: \"formatArea\",\n    value: function formatArea(polygon, map, decimalPlacesInToolTips) {\n      var geodesic = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      var decimalHelper = Math.pow(10, decimalPlacesInToolTips);\n      var area = MeasureUtil.getArea(polygon, map, geodesic);\n      var output;\n\n      if (area > 10000) {\n        output = Math.round(area / 1000000 * decimalHelper) / decimalHelper + ' km<sup>2</sup>';\n      } else {\n        output = Math.round(area * decimalHelper) / decimalHelper + ' m<sup>2</sup>';\n      }\n\n      return output;\n    }\n    /**\n     * Determine the angle between two coordinates. The angle will be between\n     * -180° and 180°, with 0° being in the east. The angle will increase\n     * counter-clockwise.\n     *\n     * Inspired by https://stackoverflow.com/a/31136507\n     *\n     * @param {Array<number>} start The start coordinates of the line with the\n     *     x-coordinate being at index `0` and y-coordinate being at index `1`.\n     * @param {Array<number>} end The end coordinates of the line with the\n     *     x-coordinate being at index `0` and y-coordinate being at index `1`.\n     *\n     * @return {number} the angle in degrees, ranging from -180° to 180°.\n     */\n\n  }, {\n    key: \"angle\",\n    value: function angle(start, end) {\n      var dx = start[0] - end[0];\n      var dy = start[1] - end[1]; // range (-PI, PI]\n\n      var theta = Math.atan2(dy, dx); // rads to degs, range (-180, 180]\n\n      theta *= 180 / Math.PI;\n      return theta;\n    }\n    /**\n     * Determine the angle between two coordinates. The angle will be between\n     * 0° and 360°, with 0° being in the east. The angle will increase\n     * counter-clockwise.\n     *\n     * Inspired by https://stackoverflow.com/a/31136507\n     *\n     * @param {Array<number>} start The start coordinates of the line with the\n     *     x-coordinate being at index `0` and y-coordinate being at index `1`.\n     * @param {Array<number>} end The end coordinates of the line with the\n     *     x-coordinate being at index `0` and y-coordinate being at index `1`.\n     *\n     * @return {number} the angle in degrees, ranging from 0° and 360°.\n     */\n\n  }, {\n    key: \"angle360\",\n    value: function angle360(start, end) {\n      // range (-180, 180]\n      var theta = MeasureUtil.angle(start, end);\n\n      if (theta < 0) {\n        // range [0, 360)\n        theta = 360 + theta;\n      }\n\n      return theta;\n    }\n    /**\n     * Given an angle between 0° and 360° this angle returns the exact opposite\n     * of the angle, e.g. for 90° you'll get back 270°. This effectively turns\n     * the direction of the angle from counter-clockwise to clockwise.\n     *\n     * @param {number} angle360 The input angle obtained counter-clockwise.\n     *\n     * @return {number} The clockwise angle.\n     */\n\n  }, {\n    key: \"makeClockwise\",\n    value: function makeClockwise(angle360) {\n      return 360 - angle360;\n    }\n    /**\n     * This methods adds an offset of 90° to an counter-clockwise increasing\n     * angle of a line so that the origin (0°) lies at the top (in the north).\n     *\n     * @param {number} angle360 The input angle obtained counter-clockwise, with\n     *     0° degrees being in the east.\n     *\n     * @return {number} The adjusted angle, with 0° being in the north.\n     */\n\n  }, {\n    key: \"makeZeroDegreesAtNorth\",\n    value: function makeZeroDegreesAtNorth(angle360) {\n      var corrected = angle360 + 90;\n\n      if (corrected > 360) {\n        corrected = corrected - 360;\n      }\n\n      return corrected;\n    }\n    /**\n     * Returns the angle of the passed linestring in degrees, with 'N' being the\n     * 0°-line and the angle increases in clockwise direction.\n     *\n     * @param {OlGeomLineString} line The linestring to get the\n     *   angle from. As this line is coming from our internal draw\n     *   interaction, we know that it will only consist of two points.\n     * @param {number} decimalPlacesInToolTips How many decimal places will be\n     *   allowed for the measure tooltips.\n     *\n     * @return {string} The formatted angle of the line.\n     */\n\n  }, {\n    key: \"formatAngle\",\n    value: function formatAngle(line) {\n      var decimalPlacesInToolTips = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n      var coords = line.getCoordinates();\n      var numCoords = coords.length;\n\n      if (numCoords < 2) {\n        return '';\n      }\n\n      var lastPoint = coords[numCoords - 1];\n      var prevPoint = coords[numCoords - 2];\n      var angle = MeasureUtil.angle360(prevPoint, lastPoint);\n      angle = MeasureUtil.makeZeroDegreesAtNorth(angle);\n      angle = MeasureUtil.makeClockwise(angle);\n      angle = angle.toFixed(decimalPlacesInToolTips);\n      return \"\".concat(angle, \"\\xB0\");\n    }\n  }]);\n  return MeasureUtil;\n}();\n\nvar _default = MeasureUtil;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["/Users/rongxuan/Desktop/reactmap/reactmap/node_modules/@terrestris/ol-util/dist/MeasureUtil/MeasureUtil.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","_classCallCheck2","_createClass2","_sphere","MeasureUtil","key","getLength","line","map","geodesic","arguments","length","undefined","radius","opts","projection","getView","getProjection","getCode","Math","round","formatLength","decimalPlacesInToolTips","decimalHelper","pow","output","getArea","polygon","formatArea","area","angle","start","end","dx","dy","theta","atan2","PI","angle360","makeClockwise","makeZeroDegreesAtNorth","corrected","formatAngle","coords","getCoordinates","numCoords","lastPoint","prevPoint","toFixed","concat","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _sphere = require(\"ol/sphere\");\n\n/**\n * This class provides some static methods which might be helpful when working\n * with measurements.\n *\n * @class MeasureUtil\n */\nvar MeasureUtil = /*#__PURE__*/function () {\n  function MeasureUtil() {\n    (0, _classCallCheck2[\"default\"])(this, MeasureUtil);\n  }\n\n  (0, _createClass2[\"default\"])(MeasureUtil, null, [{\n    key: \"getLength\",\n    value:\n    /**\n     * Get the length of a OlGeomLineString.\n     *\n     * @param {OlGeomLineString} line The drawn line.\n     * @param {OlMap} map An OlMap.\n     * @param {boolean} geodesic Is the measurement geodesic (default is true).\n     * @param {number} radius Sphere radius. By default, the radius of the earth\n     *                        is used (Clarke 1866 Authalic Sphere, 6371008.8).\n     *\n     * @return {number} The length of line in meters.\n     */\n    function getLength(line, map) {\n      var geodesic = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var radius = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 6371008.8;\n\n      if (geodesic) {\n        var opts = {\n          projection: map.getView().getProjection().getCode(),\n          radius: radius\n        };\n        return (0, _sphere.getLength)(line, opts);\n      } else {\n        return Math.round(line.getLength() * 100) / 100;\n      }\n    }\n    /**\n     * Format length output for the tooltip.\n     *\n     * @param {OlGeomLineString} line The drawn line.\n     * @param {OlMap} map An OlMap.\n     * @param {number} decimalPlacesInToolTips How many decimal places will be\n     *   allowed for the measure tooltips\n     * @param {boolean} geodesic Is the measurement geodesic (default is true).\n     *\n     * @return {string} The formatted length of the line.\n     */\n\n  }, {\n    key: \"formatLength\",\n    value: function formatLength(line, map, decimalPlacesInToolTips) {\n      var geodesic = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      var decimalHelper = Math.pow(10, decimalPlacesInToolTips);\n      var length = MeasureUtil.getLength(line, map, geodesic);\n      var output;\n\n      if (length > 1000) {\n        output = Math.round(length / 1000 * decimalHelper) / decimalHelper + ' km';\n      } else {\n        output = Math.round(length * decimalHelper) / decimalHelper + ' m';\n      }\n\n      return output;\n    }\n    /**\n     * Get the area of a OlGeomPolygon.\n     *\n     * @param {OlGeomPolygon} polygon The drawn polygon.\n     * @param {OlMap} map An OlMap.\n     * @param {boolean} geodesic Is the measurement geodesic (default is true).\n     * @param {number} radius Sphere radius. By default, the radius of the earth\n     *                        is used (Clarke 1866 Authalic Sphere, 6371008.8).\n     *\n     * @return {number} The area of the polygon in square meter.\n     */\n\n  }, {\n    key: \"getArea\",\n    value: function getArea(polygon, map) {\n      var geodesic = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var radius = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 6371008.8;\n\n      if (geodesic) {\n        var opts = {\n          projection: map.getView().getProjection().getCode(),\n          radius: radius\n        };\n        return (0, _sphere.getArea)(polygon, opts);\n      } else {\n        return polygon.getArea();\n      }\n    }\n    /**\n     * Format length output for the tooltip.\n     *\n     * @param {OlGeomPolygon} polygon The drawn polygon.\n     * @param {OlMap} map An OlMap.\n     * @param {number} decimalPlacesInToolTips How many decimal places will be\n     *   allowed for the measure tooltips.\n     * @param {boolean} geodesic Is the measurement geodesic.\n     *\n     * @return {string} The formatted area of the polygon.\n     */\n\n  }, {\n    key: \"formatArea\",\n    value: function formatArea(polygon, map, decimalPlacesInToolTips) {\n      var geodesic = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      var decimalHelper = Math.pow(10, decimalPlacesInToolTips);\n      var area = MeasureUtil.getArea(polygon, map, geodesic);\n      var output;\n\n      if (area > 10000) {\n        output = Math.round(area / 1000000 * decimalHelper) / decimalHelper + ' km<sup>2</sup>';\n      } else {\n        output = Math.round(area * decimalHelper) / decimalHelper + ' m<sup>2</sup>';\n      }\n\n      return output;\n    }\n    /**\n     * Determine the angle between two coordinates. The angle will be between\n     * -180° and 180°, with 0° being in the east. The angle will increase\n     * counter-clockwise.\n     *\n     * Inspired by https://stackoverflow.com/a/31136507\n     *\n     * @param {Array<number>} start The start coordinates of the line with the\n     *     x-coordinate being at index `0` and y-coordinate being at index `1`.\n     * @param {Array<number>} end The end coordinates of the line with the\n     *     x-coordinate being at index `0` and y-coordinate being at index `1`.\n     *\n     * @return {number} the angle in degrees, ranging from -180° to 180°.\n     */\n\n  }, {\n    key: \"angle\",\n    value: function angle(start, end) {\n      var dx = start[0] - end[0];\n      var dy = start[1] - end[1]; // range (-PI, PI]\n\n      var theta = Math.atan2(dy, dx); // rads to degs, range (-180, 180]\n\n      theta *= 180 / Math.PI;\n      return theta;\n    }\n    /**\n     * Determine the angle between two coordinates. The angle will be between\n     * 0° and 360°, with 0° being in the east. The angle will increase\n     * counter-clockwise.\n     *\n     * Inspired by https://stackoverflow.com/a/31136507\n     *\n     * @param {Array<number>} start The start coordinates of the line with the\n     *     x-coordinate being at index `0` and y-coordinate being at index `1`.\n     * @param {Array<number>} end The end coordinates of the line with the\n     *     x-coordinate being at index `0` and y-coordinate being at index `1`.\n     *\n     * @return {number} the angle in degrees, ranging from 0° and 360°.\n     */\n\n  }, {\n    key: \"angle360\",\n    value: function angle360(start, end) {\n      // range (-180, 180]\n      var theta = MeasureUtil.angle(start, end);\n\n      if (theta < 0) {\n        // range [0, 360)\n        theta = 360 + theta;\n      }\n\n      return theta;\n    }\n    /**\n     * Given an angle between 0° and 360° this angle returns the exact opposite\n     * of the angle, e.g. for 90° you'll get back 270°. This effectively turns\n     * the direction of the angle from counter-clockwise to clockwise.\n     *\n     * @param {number} angle360 The input angle obtained counter-clockwise.\n     *\n     * @return {number} The clockwise angle.\n     */\n\n  }, {\n    key: \"makeClockwise\",\n    value: function makeClockwise(angle360) {\n      return 360 - angle360;\n    }\n    /**\n     * This methods adds an offset of 90° to an counter-clockwise increasing\n     * angle of a line so that the origin (0°) lies at the top (in the north).\n     *\n     * @param {number} angle360 The input angle obtained counter-clockwise, with\n     *     0° degrees being in the east.\n     *\n     * @return {number} The adjusted angle, with 0° being in the north.\n     */\n\n  }, {\n    key: \"makeZeroDegreesAtNorth\",\n    value: function makeZeroDegreesAtNorth(angle360) {\n      var corrected = angle360 + 90;\n\n      if (corrected > 360) {\n        corrected = corrected - 360;\n      }\n\n      return corrected;\n    }\n    /**\n     * Returns the angle of the passed linestring in degrees, with 'N' being the\n     * 0°-line and the angle increases in clockwise direction.\n     *\n     * @param {OlGeomLineString} line The linestring to get the\n     *   angle from. As this line is coming from our internal draw\n     *   interaction, we know that it will only consist of two points.\n     * @param {number} decimalPlacesInToolTips How many decimal places will be\n     *   allowed for the measure tooltips.\n     *\n     * @return {string} The formatted angle of the line.\n     */\n\n  }, {\n    key: \"formatAngle\",\n    value: function formatAngle(line) {\n      var decimalPlacesInToolTips = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n      var coords = line.getCoordinates();\n      var numCoords = coords.length;\n\n      if (numCoords < 2) {\n        return '';\n      }\n\n      var lastPoint = coords[numCoords - 1];\n      var prevPoint = coords[numCoords - 2];\n      var angle = MeasureUtil.angle360(prevPoint, lastPoint);\n      angle = MeasureUtil.makeZeroDegreesAtNorth(angle);\n      angle = MeasureUtil.makeClockwise(angle);\n      angle = angle.toFixed(decimalPlacesInToolTips);\n      return \"\".concat(angle, \"\\xB0\");\n    }\n  }]);\n  return MeasureUtil;\n}();\n\nvar _default = MeasureUtil;\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"script"}