{"version":3,"sources":["../../src/ts/styling/stylingService.ts"],"names":[],"mappings":"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","file":"stylingService.js","sourcesContent":["import { CellClassParams, ColDef } from \"../entities/colDef\";\nimport { Autowired, Bean } from \"../context/context\";\nimport { ExpressionService } from \"../valueService/expressionService\";\nimport { BeanStub } from \"../context/beanStub\";\nimport { getAllKeysInObjects, isNonNullObject } from \"../utils/object\";\nimport { RowClassParams } from \"../entities/gridOptions\";\n\n@Bean('stylingService')\nexport class StylingService extends BeanStub {\n\n    @Autowired('expressionService') private expressionService: ExpressionService;\n\n    public processAllCellClasses(colDef: ColDef, params: CellClassParams, onApplicableClass: (className: string) => void, onNotApplicableClass?: (className: string) => void) {\n        this.processClassRules(colDef.cellClassRules, params, onApplicableClass, onNotApplicableClass);\n        this.processStaticCellClasses(colDef, params, onApplicableClass);\n    }\n\n    public processClassRules(classRules: { [cssClassName: string]: (Function | string) } | undefined, params: RowClassParams | CellClassParams, onApplicableClass: (className: string) => void, onNotApplicableClass?: (className: string) => void) {\n        if (classRules == null)  { return; }\n\n        const classNames = Object.keys(classRules!);\n        const classesToApply: {[name: string]: boolean} = {};\n        const classesToRemove: {[name: string]: boolean} = {};\n\n        for (let i = 0; i < classNames.length; i++) {\n            const className = classNames[i];\n            const rule = classRules![className];\n            let resultOfRule: any;\n            if (typeof rule === 'string') {\n                resultOfRule = this.expressionService.evaluate(rule, params);\n            } else if (typeof rule === 'function') {\n                resultOfRule = rule(params);\n            }\n\n            // in case className = 'my-class1 my-class2', we need to split into individual class names\n            className.split(' ').forEach( singleClass => {\n                if (singleClass == null || singleClass.trim() == '') { return; }\n                resultOfRule ? classesToApply[singleClass] = true : classesToRemove[singleClass] = true;\n            });\n\n            // we remove all classes first, then add all classes second,\n            // in case a class appears in more than one rule, this means it will be added\n            // if appears in at least one truthy rule\n            if (onNotApplicableClass) {\n                Object.keys(classesToRemove).forEach(onNotApplicableClass);\n            }\n            Object.keys(classesToApply).forEach(onApplicableClass);\n        }\n    }\n\n    public getStaticCellClasses(colDef: ColDef, params: CellClassParams): string[] {\n        const cellClass = colDef.cellClass;\n\n        if (!cellClass) { return []; }\n\n        let classOrClasses: string | string[];\n\n        if (typeof cellClass === 'function') {\n            const cellClassFunc = colDef.cellClass as (cellClassParams: CellClassParams) => string | string[];\n            classOrClasses = cellClassFunc(params);\n        } else {\n            classOrClasses = cellClass;\n        }\n\n        if (typeof classOrClasses === 'string') {\n            classOrClasses = [classOrClasses];\n        }\n\n        return classOrClasses;\n    }\n\n    private processStaticCellClasses(colDef: ColDef, params: CellClassParams, onApplicableClass: (className: string) => void) {\n        const classOrClasses = this.getStaticCellClasses(colDef, params);\n\n        classOrClasses.forEach((cssClassItem: string) => {\n            onApplicableClass(cssClassItem);\n        });\n    }\n\n}\n"]}