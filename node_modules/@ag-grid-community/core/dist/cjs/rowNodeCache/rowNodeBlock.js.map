{"version":3,"sources":["../../src/ts/rowNodeCache/rowNodeBlock.ts"],"names":[],"mappings":"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","file":"rowNodeBlock.js","sourcesContent":["import { AgEvent } from \"../events\";\nimport { BeanStub } from \"../context/beanStub\";\n\nexport interface LoadCompleteEvent extends AgEvent {\n    success: boolean;\n    block: RowNodeBlock;\n}\n\nexport interface LoadSuccessParams {\n    /**\n     * Data retrieved from the server as requested by the grid.\n     */\n    rowData: any[];\n    /**\n     * The last row, if known, to help Infinite Scroll (i.e Partial Store) and Pagination. \n     */\n    rowCount?: number;\n    /**\n     * Any extra information for the grid to associate with this load.\n     */\n    storeInfo?: any;\n}\n\nexport abstract class RowNodeBlock extends BeanStub {\n\n    public static EVENT_LOAD_COMPLETE = 'loadComplete';\n\n    public static STATE_WAITING_TO_LOAD = 'needsLoading';\n    public static STATE_LOADING = 'loading';\n    public static STATE_LOADED = 'loaded';\n    public static STATE_FAILED = 'failed';\n\n    private readonly id: number;\n\n    private state = RowNodeBlock.STATE_WAITING_TO_LOAD;\n\n    private version = 0;\n\n    public abstract getBlockStateJson(): { id: string, state: any };\n\n    protected abstract loadFromDatasource(): void;\n\n    protected abstract processServerResult(params: LoadSuccessParams): void;\n\n    protected abstract processServerFail(): void;\n\n    protected constructor(id: number) {\n        super();\n        this.id = id;\n    }\n\n    public getId(): number {\n        return this.id;\n    }\n\n    public load(): void {\n        this.state = RowNodeBlock.STATE_LOADING;\n        this.loadFromDatasource();\n    }\n\n    public getVersion(): number {\n        return this.version;\n    }\n\n    public setStateWaitingToLoad(): void {\n        // in case any current loads in progress, this will have their results ignored\n        this.version++;\n        this.state = RowNodeBlock.STATE_WAITING_TO_LOAD;\n    }\n\n    public getState(): string {\n        return this.state;\n    }\n\n    protected pageLoadFailed(version: number) {\n        const requestMostRecentAndLive = this.isRequestMostRecentAndLive(version);\n        if (requestMostRecentAndLive) {\n            this.state = RowNodeBlock.STATE_FAILED;\n            this.processServerFail();\n        }\n\n        this.dispatchLoadCompleted(false);\n    }\n\n    protected success(version: number, params: LoadSuccessParams): void {\n        this.successCommon(version, params);\n    }\n\n    protected pageLoaded(version: number, rows: any[], lastRow: number) {\n        this.successCommon(version, {rowData: rows, rowCount: lastRow});\n    }\n\n    private isRequestMostRecentAndLive(version: number): boolean {\n        // thisIsMostRecentRequest - if block was refreshed, then another request\n        // could of been sent after this one.\n        const thisIsMostRecentRequest = version === this.version;\n\n        // weAreNotDestroyed - if InfiniteStore is purged, then blocks are destroyed\n        // and new blocks created. so data loads of old blocks are discarded.\n        const weAreNotDestroyed = this.isAlive();\n\n        return thisIsMostRecentRequest && weAreNotDestroyed;\n    }\n\n    protected successCommon(version: number, params: LoadSuccessParams) {\n\n        // need to dispatch load complete before processing the data, as PaginationComp checks\n        // RowNodeBlockLoader to see if it is still loading, so the RowNodeBlockLoader needs to\n        // be updated first (via LoadComplete event) before PaginationComp updates (via processServerResult method)\n        this.dispatchLoadCompleted();\n\n        const requestMostRecentAndLive = this.isRequestMostRecentAndLive(version);\n\n        if (requestMostRecentAndLive) {\n            this.state = RowNodeBlock.STATE_LOADED;\n            this.processServerResult(params);\n        }\n    }\n\n    private dispatchLoadCompleted(success = true) {\n        // we fire event regardless of processing data or now, as we want\n        // the concurrentLoadRequests count to be reduced in BlockLoader\n        const event: LoadCompleteEvent = {\n            type: RowNodeBlock.EVENT_LOAD_COMPLETE,\n            success: success,\n            block: this\n        };\n\n        this.dispatchEvent(event);\n    }\n}\n"]}