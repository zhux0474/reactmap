{"version":3,"sources":["../../src/ts/utils/rowNode.ts"],"names":[],"mappings":";;;;;;;;AAEA;;;;;;;GAOG;AACH,SAAgB,mBAAmB,CAAC,QAAmB,EAAE,YAAuC;IAC5F,IAAI,CAAC,QAAQ,EAAE;QAAE,OAAO;KAAE;IAE1B,IAAM,UAAU,GAAG,UAAC,KAAc,EAAE,KAAc;QAC9C,IAAM,SAAS,GAAG,YAAY,CAAC,KAAK,CAAC,EAAG,CAAC,CAAC;QAC1C,IAAM,SAAS,GAAG,YAAY,CAAC,KAAK,CAAC,EAAG,CAAC,CAAC;QAE1C,IAAM,SAAS,GAAG,SAAS,KAAK,SAAS,CAAC;QAC1C,IAAM,SAAS,GAAG,SAAS,KAAK,SAAS,CAAC;QAE1C,IAAM,qBAAqB,GAAG,SAAS,IAAI,SAAS,CAAC;QACrD,IAAM,uBAAuB,GAAG,CAAC,SAAS,IAAI,CAAC,SAAS,CAAC;QAEzD,IAAI,qBAAqB,EAAE;YACvB,8DAA8D;YAC9D,eAAe;YACf,OAAO,SAAS,GAAG,SAAS,CAAC;SAChC;QAED,IAAI,uBAAuB,EAAE;YACzB,oEAAoE;YACpE,qEAAqE;YACrE,mEAAmE;YACnE,iFAAiF;YACjF,2EAA2E;YAC3E,iEAAiE;YACjE,0EAA0E;YAC1E,8EAA8E;YAC9E,uCAAuC;YACvC,OAAO,KAAK,CAAC,UAAU,GAAG,KAAK,CAAC,UAAU,CAAC;SAC9C;QAED,IAAI,SAAS,EAAE;YACX,OAAO,CAAC,CAAC;SACZ;QAED,OAAO,CAAC,CAAC,CAAC;IACd,CAAC,CAAC;IAEF,wCAAwC;IACxC,IAAI,QAAiB,CAAC;IACtB,IAAI,QAAiB,CAAC;IACtB,IAAI,oBAAoB,GAAG,KAAK,CAAC;IAEjC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;QAC1C,QAAQ,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;QACvB,QAAQ,GAAG,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;QAE3B,IAAI,UAAU,CAAC,QAAQ,EAAE,QAAQ,CAAC,GAAG,CAAC,EAAE;YACpC,oBAAoB,GAAG,IAAI,CAAC;YAC5B,MAAM;SACT;KACJ;IAED,IAAI,oBAAoB,EAAE;QACtB,QAAQ,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;KAC7B;AACL,CAAC;AAzDD,kDAyDC;AAED,SAAgB,oBAAoB,CAAC,KAAuB,EAAE,QAA8C;IACxG,IAAM,QAAQ,GAAU,EAAE,CAAC;IAE3B,oBAAoB,CAAC,KAAK,CAAC,CAAC;IAE5B,SAAS,oBAAoB,CAAC,YAA8B;QACxD,IAAI,CAAC,YAAY,EAAE;YAAE,OAAO;SAAE;QAE9B,YAAY,CAAC,OAAO,CAAC,UAAC,IAAa;YAE/B,2CAA2C;YAC3C,IAAI,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,WAAW,EAAE,EAAE;gBAClC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;gBACxB,IAAM,GAAG,GAAG,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;gBAC/B,QAAQ,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;gBACpB,oBAAoB,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;gBAC9C,QAAQ,CAAC,GAAG,EAAE,CAAC;aAClB;QACL,CAAC,CAAC,CAAC;IACP,CAAC;AACL,CAAC;AApBD,oDAoBC","file":"rowNode.js","sourcesContent":["import { RowNode } from '../entities/rowNode';\n\n/**\n * Gets called by: a) ClientSideNodeManager and b) GroupStage to do sorting.\n * when in ClientSideNodeManager we always have indexes (as this sorts the items the\n * user provided) but when in GroupStage, the nodes can contain filler nodes that\n * don't have order id's\n * @param {RowNode[]} rowNodes\n * @param {Object} rowNodeOrder\n */\nexport function sortRowNodesByOrder(rowNodes: RowNode[], rowNodeOrder: { [id: string]: number; }): void {\n    if (!rowNodes) { return; }\n\n    const comparator = (nodeA: RowNode, nodeB: RowNode) => {\n        const positionA = rowNodeOrder[nodeA.id!];\n        const positionB = rowNodeOrder[nodeB.id!];\n\n        const aHasIndex = positionA !== undefined;\n        const bHasIndex = positionB !== undefined;\n\n        const bothNodesAreUserNodes = aHasIndex && bHasIndex;\n        const bothNodesAreFillerNodes = !aHasIndex && !bHasIndex;\n\n        if (bothNodesAreUserNodes) {\n            // when comparing two nodes the user has provided, they always\n            // have indexes\n            return positionA - positionB;\n        }\n\n        if (bothNodesAreFillerNodes) {\n            // when comparing two filler nodes, we have no index to compare them\n            // against, however we want this sorting to be deterministic, so that\n            // the rows don't jump around as the user does delta updates. so we\n            // want the same sort result. so we use the __objectId - which doesn't make sense\n            // from a sorting point of view, but does give consistent behaviour between\n            // calls. otherwise groups jump around as delta updates are done.\n            // note: previously here we used nodeId, however this gave a strange order\n            // as string ordering of numbers is wrong, so using id based on creation order\n            // as least gives better looking order.\n            return nodeA.__objectId - nodeB.__objectId;\n        }\n\n        if (aHasIndex) {\n            return 1;\n        }\n\n        return -1;\n    };\n\n    // check if the list first needs sorting\n    let rowNodeA: RowNode;\n    let rowNodeB: RowNode;\n    let atLeastOneOutOfOrder = false;\n\n    for (let i = 0; i < rowNodes.length - 1; i++) {\n        rowNodeA = rowNodes[i];\n        rowNodeB = rowNodes[i + 1];\n\n        if (comparator(rowNodeA, rowNodeB) > 0) {\n            atLeastOneOutOfOrder = true;\n            break;\n        }\n    }\n\n    if (atLeastOneOutOfOrder) {\n        rowNodes.sort(comparator);\n    }\n}\n\nexport function traverseNodesWithKey(nodes: RowNode[] | null, callback: (node: RowNode, key: string) => void): void {\n    const keyParts: any[] = [];\n\n    recursiveSearchNodes(nodes);\n\n    function recursiveSearchNodes(currentNodes: RowNode[] | null): void {\n        if (!currentNodes) { return; }\n\n        currentNodes.forEach((node: RowNode) => {\n\n            // also checking for children for tree data\n            if (node.group || node.hasChildren()) {\n                keyParts.push(node.key);\n                const key = keyParts.join('|');\n                callback(node, key);\n                recursiveSearchNodes(node.childrenAfterGroup);\n                keyParts.pop();\n            }\n        });\n    }\n}\n"]}