{"version":3,"sources":["../../src/ts/utils/object.ts"],"names":[],"mappings":"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","file":"object.js","sourcesContent":["import { missing, exists, values } from './generic';\nimport { forEach } from './array';\n\nexport function iterateObject<T>(object: { [p: string]: T; } | T[] | null | undefined, callback: (key: string, value: T) => void) {\n    if (object == null) { return; }\n\n    if (Array.isArray(object)) {\n        forEach(object, (value, index) => callback(`${index}`, value));\n    } else {\n        forEach(Object.keys(object), key => callback(key, object[key]));\n    }\n}\n\nexport function cloneObject<T extends {}>(object: T): T {\n    const copy = {} as T;\n    const keys = Object.keys(object);\n\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = (object as any)[key];\n        (copy as any)[key] = value;\n    }\n\n    return copy;\n}\n\nexport function deepCloneObject<T>(object: T): T {\n    return JSON.parse(JSON.stringify(object));\n}\n\n// returns copy of an object, doing a deep clone of any objects with that object.\n// this is used for eg creating copies of Column Definitions, where we want to\n// deep copy all objects, but do not want to deep copy functions (eg when user provides\n// a function or class for colDef.cellRenderer)\nexport function deepCloneDefinition<T>(object: T, keysToSkip?: string[]): T | undefined {\n    if (!object) { return; }\n\n    const obj = object as any;\n    const res: any = {};\n\n    Object.keys(obj).forEach(key => {\n\n        if (keysToSkip && keysToSkip.indexOf(key) >= 0) { return; }\n\n        const value = obj[key];\n\n        // 'simple object' means a bunch of key/value pairs, eg {filter: 'myFilter'}. it does\n        // NOT include the following:\n        // 1) arrays\n        // 2) functions or classes (eg ColumnAPI instance)\n        const sourceIsSimpleObject = isNonNullObject(value) && value.constructor === Object;\n\n        if (sourceIsSimpleObject) {\n            res[key] = deepCloneDefinition(value);\n        } else {\n            res[key] = value;\n        }\n    });\n\n    return res;\n}\n\nexport function getProperty<T, K extends keyof T>(object: T, key: K): any {\n    return object[key];\n}\n\nexport function setProperty<T, K extends keyof T>(object: T, key: K, value: any): void {\n    object[key] = value;\n}\n\n/**\n * Will copy the specified properties from `source` into the equivalent properties on `target`, ignoring properties with\n * a value of `undefined`.\n */\nexport function copyPropertiesIfPresent<S, T extends S, K extends keyof S>(source: S, target: T, ...properties: K[]) {\n    forEach(properties, p => copyPropertyIfPresent(source, target, p));\n}\n\n/**\n * Will copy the specified property from `source` into the equivalent property on `target`, unless the property has a\n * value of `undefined`. If a transformation is provided, it will be applied to the value before being set on `target`.\n */\nexport function copyPropertyIfPresent<S, T extends S, K extends keyof S>(source: S, target: T, property: K, transform?: (value: S[K]) => any) {\n    const value = getProperty(source, property);\n\n    if (value !== undefined) {\n        setProperty(target, property, transform ? transform(value) : value);\n    }\n}\n\nexport function getAllKeysInObjects(objects: any[]): string[] {\n    const allValues: any = {};\n\n    objects.filter(obj => obj != null).forEach(obj => {\n        forEach(Object.keys(obj), key => allValues[key] = null);\n    });\n\n    return Object.keys(allValues);\n}\n\nexport function getAllValuesInObject<T extends Object>(obj: T): any[] {\n    if (!obj) { return []; }\n    const anyObject = Object as any;\n    if (typeof anyObject.values === 'function') {\n        return anyObject.values(obj);\n    }\n\n    const ret: any[] = [];\n    for (const key in obj) {\n        if (obj.hasOwnProperty(key) && obj.propertyIsEnumerable(key)) {\n            ret.push(obj[key]);\n        }\n    }\n\n    return ret;\n}\n\nexport function mergeDeep(dest: any, source: any, copyUndefined = true, makeCopyOfSimpleObjects = false): void {\n    if (!exists(source)) { return; }\n\n    iterateObject(source, (key: string, sourceValue: any) => {\n        let destValue: any = dest[key];\n\n        if (destValue === sourceValue) { return; }\n\n        // when creating params, we don't want to just copy objects over. otherwise merging ColDefs (eg DefaultColDef\n        // and Column Types) would result in params getting shared between objects.\n        // by putting an empty value into destValue first, it means we end up copying over values from\n        // the source object, rather than just copying in the source object in it's entirety.\n        if (makeCopyOfSimpleObjects) {\n            const objectIsDueToBeCopied = destValue == null && sourceValue != null;\n\n            if (objectIsDueToBeCopied) {\n                // 'simple object' means a bunch of key/value pairs, eg {filter: 'myFilter'}, as opposed\n                // to a Class instance (such as ColumnAPI instance).\n                const sourceIsSimpleObject = typeof sourceValue === 'object' && sourceValue.constructor === Object;\n                const dontCopy = sourceIsSimpleObject;\n\n                if (dontCopy) {\n                    destValue = {};\n                    dest[key] = destValue;\n                }\n            }\n        }\n\n        if (isNonNullObject(sourceValue) && isNonNullObject(destValue) && !Array.isArray(destValue)) {\n            mergeDeep(destValue, sourceValue, copyUndefined, makeCopyOfSimpleObjects);\n        } else if (copyUndefined || sourceValue !== undefined) {\n            dest[key] = sourceValue;\n        }\n    });\n}\n\nexport function assign<T, U>(target: T, source: U): T & U;\nexport function assign<T, U, V>(target: T, source1: U, source2: V): T & U & V;\nexport function assign<T, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W;\nexport function assign(object: any, ...sources: any[]): any {\n    forEach(sources, source => iterateObject(source, (key: string, value: any) => object[key] = value));\n\n    return object;\n}\n\nexport function missingOrEmptyObject(value: any): boolean {\n    return missing(value) || Object.keys(value).length === 0;\n}\n\nexport function get(source: any, expression: string, defaultValue: any): any {\n    if (source == null) { return defaultValue; }\n\n    const keys = expression.split('.');\n    let objectToRead = source;\n\n    while (keys.length > 1) {\n        objectToRead = objectToRead[keys.shift()!];\n\n        if (objectToRead == null) {\n            return defaultValue;\n        }\n    }\n\n    const value = objectToRead[keys[0]];\n\n    return value != null ? value : defaultValue;\n}\n\nexport function set(target: any, expression: string, value: any) {\n    if (target == null) { return; }\n\n    const keys = expression.split('.');\n    let objectToUpdate = target;\n\n    while (keys.length > 1) {\n        objectToUpdate = objectToUpdate[keys.shift()!];\n\n        if (objectToUpdate == null) {\n            return;\n        }\n    }\n\n    objectToUpdate[keys[0]] = value;\n}\n\nexport function deepFreeze(object: any): any {\n    Object.freeze(object);\n\n    forEach(values(object), v => {\n        if (isNonNullObject(v) || typeof v === 'function') {\n            deepFreeze(v);\n        }\n    });\n\n    return object;\n}\n\nexport function getValueUsingField(data: any, field: string, fieldContainsDots: boolean): any {\n    if (!field || !data) { return; }\n\n    // if no '.', then it's not a deep value\n    if (!fieldContainsDots) {\n        return data[field];\n    }\n\n    // otherwise it is a deep value, so need to dig for it\n    const fields = field.split('.');\n    let currentObject = data;\n\n    for (let i = 0; i < fields.length; i++) {\n        if (currentObject == null) {\n            return undefined;\n        }\n        currentObject = currentObject[fields[i]];\n    }\n\n    return currentObject;\n}\n\n// used by ColumnAPI and GridAPI to remove all references, so keeping grid in memory resulting in a\n// memory leak if user is not disposing of the GridAPI or ColumnApi references\nexport function removeAllReferences(obj: any, objectName: string): void {\n    Object.keys(obj).forEach(key => {\n        const value = obj[key];\n        // we want to replace all the @autowired services, which are objects. any simple types (boolean, string etc)\n        // we don't care about\n        if (typeof value === 'object') {\n            obj[key] = undefined;\n        }\n    });\n    const proto = Object.getPrototypeOf(obj);\n    const properties: any = {};\n\n    Object.keys(proto).forEach(key => {\n        const value = proto[key];\n        // leave all basic types - this is needed for GridAPI to leave the \"destroyed: boolean\" attribute alone\n        if (typeof value === 'function') {\n            const func = () => {\n                console.warn(\n                    `AG Grid: ${objectName} function ${key}() cannot be called as the grid has been destroyed.\n                     Please don't call grid API functions on destroyed grids - as a matter of fact you shouldn't\n                     be keeping the API reference, your application has a memory leak! Remove the API reference\n                     when the grid is destroyed.`\n                );\n            };\n            properties[key] = { value: func, writable: true };\n        }\n    });\n\n    Object.defineProperties(obj, properties);\n}\n\nexport function isNonNullObject(value: any): boolean {\n    return typeof value === 'object' && value !== null;\n}\n"]}