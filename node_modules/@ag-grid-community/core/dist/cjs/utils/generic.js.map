{"version":3,"sources":["../../src/ts/utils/generic.ts"],"names":[],"mappings":"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","file":"generic.js","sourcesContent":["/**\n * If value is undefined, null or blank, returns null, otherwise returns the value\n * @param {T} value\n * @returns {T | null}\n */\nexport function makeNull<T extends unknown>(value?: T): T | null {\n    if (value == null || value === '') {\n        return null;\n    }\n    return value;\n}\n\nexport function exists(value: string | null | undefined, allowEmptyString?: boolean): value is string;\nexport function exists<T>(value: T): value is NonNullable<T>;\nexport function exists(value: any, allowEmptyString = false): boolean {\n    return value != null && (value !== '' || allowEmptyString);\n}\n\nexport function missing<T>(value: T | null | undefined): value is Exclude<undefined | null, T>;\nexport function missing(value: any): boolean {\n    return !exists(value);\n}\n\nexport function missingOrEmpty<T>(value?: T[] | string | null): boolean {\n    return value == null || value.length === 0;\n}\n\nexport function toStringOrNull(value: any): string | null {\n    return value != null && typeof value.toString === 'function' ? value.toString() : null;\n}\n\n// for parsing html attributes, where we want empty strings and missing attributes to be undefined\nexport function attrToNumber(value?: number | string | null): number | null | undefined {\n    if (value === undefined) {\n        // undefined or empty means ignore the value\n        return;\n    }\n\n    if (value === null || value === '') {\n        // null or blank means clear\n        return null;\n    }\n\n    if (typeof value === 'number') {\n        return isNaN(value) ? undefined : value;\n    }\n\n    const valueParsed = parseInt(value, 10);\n\n    return isNaN(valueParsed) ? undefined : valueParsed;\n}\n\n// for parsing html attributes, where we want empty strings and missing attributes to be undefined\nexport function attrToBoolean(value?: boolean | string | null): boolean | undefined {\n    if (value === undefined) {\n        // undefined or empty means ignore the value\n        return;\n    }\n\n    if (value === null || value === '') {\n        // null means clear\n        return false;\n    }\n\n    if (typeof value === 'boolean') {\n        // if simple boolean, return the boolean\n        return value;\n    }\n\n    // if equal to the string 'true' (ignoring case) then return true\n    return (/true/i).test(value);\n}\n\n// for parsing html attributes, where we want empty strings and missing attributes to be undefined\nexport function attrToString(value?: string): string | undefined {\n    if (value == null || value === '') { return; }\n\n    return value;\n}\n\n/** @deprecated */\nexport function referenceCompare<T>(left: T, right: T): boolean {\n    if (left == null && right == null) {\n        return true;\n    }\n\n    if (left == null && right != null) {\n        return false;\n    }\n\n    if (left != null && right == null) {\n        return false;\n    }\n\n    return left === right;\n}\n\nexport function jsonEquals<T1, T2>(val1: T1, val2: T2): boolean {\n    const val1Json = val1 ? JSON.stringify(val1) : null;\n    const val2Json = val2 ? JSON.stringify(val2) : null;\n\n    return val1Json === val2Json;\n}\n\nexport function defaultComparator(valueA: any, valueB: any, accentedCompare: boolean = false): number {\n    const valueAMissing = valueA == null;\n    const valueBMissing = valueB == null;\n\n    // this is for aggregations sum and avg, where the result can be a number that is wrapped.\n    // if we didn't do this, then the toString() value would be used, which would result in\n    // the strings getting used instead of the numbers.\n    if (valueA && valueA.toNumber) {\n        valueA = valueA.toNumber();\n    }\n\n    if (valueB && valueB.toNumber) {\n        valueB = valueB.toNumber();\n    }\n\n    if (valueAMissing && valueBMissing) {\n        return 0;\n    }\n\n    if (valueAMissing) {\n        return -1;\n    }\n\n    if (valueBMissing) {\n        return 1;\n    }\n\n    function doQuickCompare<T>(a: T, b: T): number {\n        return (a > b ? 1 : (a < b ? -1 : 0));\n    }\n\n    if (typeof valueA !== 'string') {\n        return doQuickCompare(valueA, valueB);\n    }\n\n    if (!accentedCompare) {\n        return doQuickCompare(valueA, valueB);\n    }\n\n    try {\n        // using local compare also allows chinese comparisons\n        return valueA.localeCompare(valueB);\n    } catch (e) {\n        // if something wrong with localeCompare, eg not supported\n        // by browser, then just continue with the quick one\n        return doQuickCompare(valueA, valueB);\n    }\n\n}\n\nexport function find<T>(collection: T[] | { [id: string]: T; } | null, predicate: string | boolean | ((item: T) => boolean), value?: any): T | null {\n    if (collection === null || collection === undefined) { return null; }\n\n    if (!Array.isArray(collection)) {\n        const objToArray = values(collection);\n        return find(objToArray, predicate, value);\n    }\n\n    const collectionAsArray = collection;\n\n    let firstMatchingItem: T | null = null;\n    for (let i = 0; i < collectionAsArray.length; i++) {\n        const item: T = collectionAsArray[i];\n\n        if (typeof predicate === 'string') {\n            if ((item as any)[predicate] === value) {\n                firstMatchingItem = item;\n                break;\n            }\n        } else {\n            const callback = predicate as (item: T) => boolean;\n            if (callback(item)) {\n                firstMatchingItem = item;\n                break;\n            }\n        }\n    }\n\n    return firstMatchingItem;\n}\n\nexport function values<T>(object: { [key: string]: T; } | Set<T> | Map<any, T>): T[] {\n    if (object instanceof Set || object instanceof Map) {\n        const arr: T[] = [];\n\n        object.forEach((value: T) => arr.push(value));\n\n        return arr;\n    }\n\n    return Object.keys(object).map(key => object[key]);\n}\n"]}