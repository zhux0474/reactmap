{"version":3,"sources":["../../src/ts/utils/function.ts"],"names":[],"mappings":"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","file":"function.js","sourcesContent":["const FUNCTION_STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\nconst FUNCTION_ARGUMENT_NAMES = /([^\\s,]+)/g;\nconst doOnceFlags: { [key: string]: boolean; } = {};\n\n/**\n * If the key was passed before, then doesn't execute the func\n * @param {Function} func\n * @param {string} key\n */\nexport function doOnce(func: () => void, key: string) {\n    if (doOnceFlags[key]) { return; }\n\n    func();\n    doOnceFlags[key] = true;\n}\n\nexport function getFunctionName(funcConstructor: any) {\n    // for every other browser in the world\n    if (funcConstructor.name) {\n        return funcConstructor.name;\n    }\n\n    // for the pestilence that is ie11\n    const matches = /function\\s+([^\\(]+)/.exec(funcConstructor.toString());\n    return matches && matches.length === 2 ? matches[1].trim() : null;\n}\n\n/** @deprecated */\nexport function getFunctionParameters(func: any) {\n    const fnStr = func.toString().replace(FUNCTION_STRIP_COMMENTS, '');\n\n    return fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(FUNCTION_ARGUMENT_NAMES) || [];\n}\n\nexport function isFunction(val: any): boolean {\n    return !!(val && val.constructor && val.call && val.apply);\n}\n\nexport function executeInAWhile(funcs: Function[]): void {\n    executeAfter(funcs, 400);\n}\n\nconst executeNextVMTurnFuncs: Function[] = [];\nlet executeNextVMTurnPending = false;\n\nexport function executeNextVMTurn(func: () => void): void {\n    executeNextVMTurnFuncs.push(func);\n\n    if (executeNextVMTurnPending) { return; }\n\n    executeNextVMTurnPending = true;\n    window.setTimeout(() => {\n        const funcsCopy = executeNextVMTurnFuncs.slice();\n        executeNextVMTurnFuncs.length = 0;\n        executeNextVMTurnPending = false;\n        funcsCopy.forEach(func => func());\n    }, 0);\n}\n\nexport function executeAfter(funcs: Function[], milliseconds = 0): void {\n    if (funcs.length > 0) {\n        window.setTimeout(() => funcs.forEach(func => func()), milliseconds);\n    }\n}\n\n/**\n * from https://stackoverflow.com/questions/24004791/can-someone-explain-the-debounce-function-in-javascript\n * @param {Function} func The function to be debounced\n * @param {number} wait The time in ms to debounce\n * @param {boolean} immediate If it should run immediately or wait for the initial debounce delay\n * @return {Function} The debounced function\n */\nexport function debounce(func: (...args: any[]) => void, wait: number, immediate: boolean = false) {\n    // 'private' variable for instance\n    // The returned function will be able to reference this due to closure.\n    // Each call to the returned function will share this common timer.\n    let timeout: any;\n\n    // Calling debounce returns a new anonymous function\n    return function(...args: any[]) {\n        // reference the context and args for the setTimeout function\n        const context = this;\n\n        // Should the function be called now? If immediate is true\n        //   and not already in a timeout then the answer is: Yes\n        const callNow = immediate && !timeout;\n\n        // This is the basic debounce behaviour where you can call this\n        //   function several times, but it will only execute once\n        //   [before or after imposing a delay].\n        //   Each time the returned function is called, the timer starts over.\n        window.clearTimeout(timeout);\n\n        // Set the new timeout\n        timeout = window.setTimeout(function() {\n            // Inside the timeout function, clear the timeout variable\n            // which will let the next execution run when in 'immediate' mode\n            timeout = null;\n\n            // Check if the function already ran with the immediate flag\n            if (!immediate) {\n                // Call the original function with apply\n                // apply lets you define the 'this' object as well as the arguments\n                //    (both captured before setTimeout)\n                func.apply(context, args);\n            }\n        }, wait);\n\n        // Immediate mode and no wait timer? Execute the function..\n        if (callNow) {\n            func.apply(context, args);\n        }\n    };\n}\n\nexport function waitUntil(condition: () => boolean, callback: () => void, timeout: number = 100, timeoutMessage?: string) {\n    const timeStamp = new Date().getTime();\n\n    let interval: number | null = null;\n    let executed: boolean = false;\n\n    const internalCallback = () => {\n        const reachedTimeout = ((new Date().getTime()) - timeStamp) > timeout;\n        if (condition() || reachedTimeout) {\n            callback();\n            executed = true;\n            if (interval != null) {\n                window.clearInterval(interval);\n                interval = null;\n            }\n\n            if (reachedTimeout && timeoutMessage) {\n                console.warn(timeoutMessage);\n            }\n        }\n    };\n\n    internalCallback();\n\n    if (!executed) {\n        interval = window.setInterval(internalCallback, 10);\n    }\n}\n\nexport function compose(...fns: Function[]) {\n    return (arg: any) => fns.reduce((composed, f) => f(composed), arg);\n}\n\nexport function callIfPresent(func: Function): void {\n    if (func) { func(); }\n}\n"]}