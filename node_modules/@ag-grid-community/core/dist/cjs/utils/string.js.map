{"version":3,"sources":["../../src/ts/utils/string.ts"],"names":[],"mappings":"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","file":"string.js","sourcesContent":["const reUnescapedHtml = /[&<>\"']/g;\n\n/**\n * HTML Escapes.\n */\nconst HTML_ESCAPES: { [id: string]: string; } = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n};\n\n/**\n * It encodes any string in UTF-8 format\n * taken from https://github.com/mathiasbynens/utf8.js\n * @param {string} s\n * @returns {string}\n */\nexport function utf8_encode(s: string | null): string {\n    const stringFromCharCode = String.fromCharCode;\n\n    function ucs2decode(string: string | null): number[] {\n        const output: number[] = [];\n\n        if (!string) { return []; }\n\n        const len = string.length;\n\n        let counter = 0;\n        let value;\n        let extra;\n\n        while (counter < len) {\n            value = string.charCodeAt(counter++);\n            if (value >= 0xD800 && value <= 0xDBFF && counter < len) {\n                // high surrogate, and there is a next character\n                extra = string.charCodeAt(counter++);\n                if ((extra & 0xFC00) == 0xDC00) { // low surrogate\n                    output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n                } else {\n                    // unmatched surrogate; only append this code unit, in case the next\n                    // code unit is the high surrogate of a surrogate pair\n                    output.push(value);\n                    counter--;\n                }\n            } else {\n                output.push(value);\n            }\n        }\n        return output;\n    }\n\n    function checkScalarValue(point: number) {\n        if (point >= 0xD800 && point <= 0xDFFF) {\n            throw Error(\n                'Lone surrogate U+' + point.toString(16).toUpperCase() +\n                ' is not a scalar value'\n            );\n        }\n    }\n\n    function createByte(point: number, shift: number) {\n        return stringFromCharCode(((point >> shift) & 0x3F) | 0x80);\n    }\n\n    function encodeCodePoint(point: number): string {\n        if ((point >= 0 && point <= 31 && point !== 10)) {\n            const convertedCode = point.toString(16).toUpperCase();\n            const paddedCode = padStart(convertedCode, 4, '0');\n\n            return `_x${paddedCode}_`;\n        }\n\n        if ((point & 0xFFFFFF80) == 0) { // 1-byte sequence\n            return stringFromCharCode(point);\n        }\n\n        let symbol = '';\n\n        if ((point & 0xFFFFF800) == 0) { // 2-byte sequence\n            symbol = stringFromCharCode(((point >> 6) & 0x1F) | 0xC0);\n        } else if ((point & 0xFFFF0000) == 0) { // 3-byte sequence\n            checkScalarValue(point);\n            symbol = stringFromCharCode(((point >> 12) & 0x0F) | 0xE0);\n            symbol += createByte(point, 6);\n        } else if ((point & 0xFFE00000) == 0) { // 4-byte sequence\n            symbol = stringFromCharCode(((point >> 18) & 0x07) | 0xF0);\n            symbol += createByte(point, 12);\n            symbol += createByte(point, 6);\n        }\n        symbol += stringFromCharCode((point & 0x3F) | 0x80);\n        return symbol;\n    }\n\n    const codePoints = ucs2decode(s);\n    const length = codePoints.length;\n    let index = -1;\n    let codePoint;\n    let byteString = '';\n\n    while (++index < length) {\n        codePoint = codePoints[index];\n        byteString += encodeCodePoint(codePoint);\n    }\n\n    return byteString;\n}\n\n/**\n * @param str The string to be repeated\n * @param len The size of the output string\n * @returns A string with size len created from repeated `str`.\n */\nexport function stringRepeat(str: string, len: number): string {\n    len = Math.floor(len);\n    if (str.length === 0 || len === 0) { return ''; }\n\n    const maxCount = str.length * len;\n    len = Math.floor(Math.log(len) / Math.log(2));\n    while (len) {\n       str += str;\n       len--;\n    }\n    str += str.substring(0, maxCount - str.length);\n    return str;\n}\n\n/**\n * @param str The string to be padded\n * @param totalLength The final length needed\n * @param padStr The string to generate the padding\n * @returns The padded string\n */\nexport function padStart(str: string, totalLength: number, padStr: string): string {\n    if (str.length > totalLength) {\n      return str;\n    }\n\n    totalLength -=  str.length;\n\n    if (totalLength > padStr.length) {\n        padStr += stringRepeat(padStr, totalLength / padStr.length);\n    }\n\n    return padStr.slice(0, totalLength) + str;\n}\n\n/**\n * Converts a camelCase string into hyphenated string\n * from https://gist.github.com/youssman/745578062609e8acac9f\n * @param {string} str\n * @return {string}\n */\nexport function camelCaseToHyphen(str: string): string | null {\n    if (str === null || str === undefined) { return null; }\n\n    return str.replace(/([A-Z])/g, (g) => '-' + g[0].toLowerCase());\n}\n\n/**\n * Converts a hyphenated string into camelCase string\n * from https://stackoverflow.com/questions/6660977/convert-hyphens-to-camel-case-camelcase\n * @param {string} str\n * @return {string}\n */\nexport function hyphenToCamelCase(str: string): string | null {\n    if (str === null || str === undefined) {\n        return null;\n    }\n    return str.replace(/-([a-z])/g, (g) => g[1].toUpperCase());\n}\n\nexport function capitalise(str: string): string {\n    return str[0].toUpperCase() + str.substr(1).toLowerCase();\n}\n\nexport function escapeString(toEscape?: string | null): string | null {\n    // we call toString() twice, in case value is an object, where user provides\n    // a toString() method, and first call to toString() returns back something other\n    // than a string (eg a number to render)\n    return toEscape == null ? null : toEscape.toString().toString().replace(reUnescapedHtml, chr => HTML_ESCAPES[chr]);\n}\n\n/**\n * Converts a camelCase string into regular text\n * from: https://stackoverflow.com/questions/15369566/putting-space-in-camel-case-string-using-regular-expression\n * @param {string} camelCase\n * @return {string}\n */\nexport function camelCaseToHumanText(camelCase: string | undefined): string | null {\n    if (!camelCase || camelCase == null) { return null; }\n\n    const rex = /([A-Z])([A-Z])([a-z])|([a-z])([A-Z])/g;\n    const words: string[] = camelCase.replace(rex, '$1$4 $2$3$5').replace('.', ' ').split(' ');\n\n    return words.map(word => word.substring(0, 1).toUpperCase() + ((word.length > 1) ? word.substring(1, word.length) : '')).join(' ');\n}\n\nexport function startsWith(str: string, matchStart: string): boolean {\n    if (str === matchStart) { return true; }\n\n    return str != null && str.slice(0, matchStart.length) === matchStart;\n}\n"]}