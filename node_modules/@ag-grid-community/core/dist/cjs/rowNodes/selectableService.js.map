{"version":3,"sources":["../../src/ts/rowNodes/selectableService.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,8CAAyD;AAEzD,gDAA+C;AAC/C,4CAAgD;AAGhD;IAAuC,qCAAQ;IAA/C;;IAmDA,CAAC;IA7CU,gCAAI,GAAX;QACI,IAAI,CAAC,oBAAoB,GAAG,IAAI,CAAC,kBAAkB,CAAC,sBAAsB,EAAE,CAAC;QAC7E,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC,kBAAkB,CAAC,sBAAsB,EAAE,CAAC;IAChF,CAAC;IAEM,yDAA6B,GAApC,UAAqC,OAAgB;QACjD,IAAI,IAAI,CAAC,mBAAmB,EAAE;YAC1B,IAAM,gBAAgB,GAAG,UAAC,IAAa,IAAK,OAAA,IAAI,CAAC,kBAAkB,EAAvB,CAAuB,CAAC;YACpE,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,kBAAkB,EAAE,gBAAgB,CAAC,CAAC;SAClE;IACL,CAAC;IAEM,0DAA8B,GAArC,UAAsC,OAAgB;QAClD,IAAI,IAAI,CAAC,mBAAmB,EAAE;YAC1B,IAAM,gBAAgB,GAAG,UAAC,IAAa,IAAK,OAAA,IAAI,CAAC,mBAAmB,EAAxB,CAAwB,CAAC;YACrE,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,kBAAkB,EAAE,gBAAgB,CAAC,CAAC;SAClE;IACL,CAAC;IAEO,uCAAW,GAAnB,UAAoB,QAA0B,EAAE,gBAA0D;QAA1G,iBAwBC;QAvBG,IAAI,CAAC,QAAQ,EAAE;YAAE,OAAO;SAAE;QAE1B,QAAQ,CAAC,OAAO,CAAC,UAAC,KAAc;YAE5B,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE;gBAAE,OAAO;aAAE,CAAC,4BAA4B;YAE1D,IAAI,KAAK,CAAC,WAAW,EAAE,EAAE;gBACrB,KAAI,CAAC,WAAW,CAAC,gBAAgB,CAAC,KAAK,CAAC,EAAE,gBAAgB,CAAC,CAAC;aAC/D;YAED,IAAI,aAAsB,CAAC;YAE3B,IAAI,KAAI,CAAC,oBAAoB,EAAE;gBAC3B,wEAAwE;gBACxE,IAAM,eAAe,GAAG,cAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,EAAE,YAAY,EAAE,IAAI,CAAC,CAAC;gBAC1E,aAAa,GAAG,gBAAM,CAAC,eAAe,CAAC,CAAC;aAC3C;iBAAM;gBACH,wDAAwD;gBACxD,aAAa,GAAG,KAAI,CAAC,mBAAmB,CAAC,CAAC,CAAC,KAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;aACtF;YAED,KAAK,CAAC,gBAAgB,CAAC,aAAa,CAAC,CAAC;QAC1C,CAAC,CAAC,CAAC;IACP,CAAC;IA3CD;QADC,uBAAa;iDAIb;IATQ,iBAAiB;QAD7B,cAAI,CAAC,mBAAmB,CAAC;OACb,iBAAiB,CAmD7B;IAAD,wBAAC;CAnDD,AAmDC,CAnDsC,mBAAQ,GAmD9C;AAnDY,8CAAiB","file":"selectableService.js","sourcesContent":["import { RowNode } from \"../entities/rowNode\";\nimport { Bean, PostConstruct } from \"../context/context\";\nimport { IsRowSelectable } from \"../entities/gridOptions\";\nimport { BeanStub } from \"../context/beanStub\";\nimport { find, exists } from \"../utils/generic\";\n\n@Bean('selectableService')\nexport class SelectableService extends BeanStub {\n\n    private groupSelectsChildren: boolean;\n    private isRowSelectableFunc?: IsRowSelectable;\n\n    @PostConstruct\n    public init(): void {\n        this.groupSelectsChildren = this.gridOptionsWrapper.isGroupSelectsChildren();\n        this.isRowSelectableFunc = this.gridOptionsWrapper.getIsRowSelectableFunc();\n    }\n\n    public updateSelectableAfterGrouping(rowNode: RowNode): void {\n        if (this.isRowSelectableFunc) {\n            const nextChildrenFunc = (node: RowNode) => node.childrenAfterGroup;\n            this.recurseDown(rowNode.childrenAfterGroup, nextChildrenFunc);\n        }\n    }\n\n    public updateSelectableAfterFiltering(rowNode: RowNode): void {\n        if (this.isRowSelectableFunc) {\n            const nextChildrenFunc = (node: RowNode) => node.childrenAfterFilter;\n            this.recurseDown(rowNode.childrenAfterGroup, nextChildrenFunc);\n        }\n    }\n\n    private recurseDown(children: RowNode[] | null, nextChildrenFunc: ((rowNode: RowNode) => RowNode[] | null)): void {\n        if (!children) { return; }\n\n        children.forEach((child: RowNode) => {\n\n            if (!child.group) { return; } // only interested in groups\n\n            if (child.hasChildren()) {\n                this.recurseDown(nextChildrenFunc(child), nextChildrenFunc);\n            }\n\n            let rowSelectable: boolean;\n\n            if (this.groupSelectsChildren) {\n                // have this group selectable if at least one direct child is selectable\n                const firstSelectable = find(nextChildrenFunc(child), 'selectable', true);\n                rowSelectable = exists(firstSelectable);\n            } else {\n                // directly retrieve selectable value from user callback\n                rowSelectable = this.isRowSelectableFunc ? this.isRowSelectableFunc(child) : false;\n            }\n\n            child.setRowSelectable(rowSelectable);\n        });\n    }\n\n}\n"]}