{"version":3,"sources":["../../src/ts/valueService/valueService.ts"],"names":[],"mappings":"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","file":"valueService.js","sourcesContent":["import { ExpressionService } from \"./expressionService\";\nimport { ColumnModel } from \"../columns/columnModel\";\nimport { NewValueParams, ValueGetterParams, KeyCreatorParams } from \"../entities/colDef\";\nimport { Autowired, Bean, PostConstruct } from \"../context/context\";\nimport { RowNode } from \"../entities/rowNode\";\nimport { Column } from \"../entities/column\";\nimport { CellValueChangedEvent, Events } from \"../events\";\nimport { ValueCache } from \"./valueCache\";\nimport { BeanStub } from \"../context/beanStub\";\nimport { getValueUsingField } from \"../utils/object\";\nimport { missing, exists } from \"../utils/generic\";\nimport { doOnce } from \"../utils/function\";\n\n@Bean('valueService')\nexport class ValueService extends BeanStub {\n\n    @Autowired('expressionService') private expressionService: ExpressionService;\n    @Autowired('columnModel') private columnModel: ColumnModel;\n    @Autowired('valueCache') private valueCache: ValueCache;\n\n    private cellExpressions: boolean;\n\n    private initialised = false;\n\n    @PostConstruct\n    public init(): void {\n        this.cellExpressions = this.gridOptionsWrapper.isEnableCellExpressions();\n        this.initialised = true;\n    }\n\n    public getValue(column: Column,\n        rowNode?: RowNode | null,\n        forFilter = false,\n        ignoreAggData = false): any {\n\n        // hack - the grid is getting refreshed before this bean gets initialised, race condition.\n        // really should have a way so they get initialised in the right order???\n        if (!this.initialised) {\n            this.init();\n        }\n\n        if (!rowNode) {\n            return;\n        }\n\n        // pull these out to make code below easier to read\n        const colDef = column.getColDef();\n        const field = colDef.field;\n        const colId = column.getId();\n        const data = rowNode.data;\n\n        let result: any;\n\n        // if there is a value getter, this gets precedence over a field\n        const groupDataExists = rowNode.groupData && rowNode.groupData[colId] !== undefined;\n        const aggDataExists = !ignoreAggData && rowNode.aggData && rowNode.aggData[colId] !== undefined;\n\n        if (forFilter && colDef.filterValueGetter) {\n            result = this.executeFilterValueGetter(colDef.filterValueGetter, data, column, rowNode);\n        } else if (this.gridOptionsWrapper.isTreeData() && aggDataExists) {\n            result = rowNode.aggData[colId];\n        } else if (this.gridOptionsWrapper.isTreeData() && colDef.valueGetter) {\n            result = this.executeValueGetter(colDef.valueGetter, data, column, rowNode);\n        } else if (this.gridOptionsWrapper.isTreeData() && (field && data)) {\n            result = getValueUsingField(data, field, column.isFieldContainsDots());\n        } else if (groupDataExists) {\n            result = rowNode.groupData![colId];\n        } else if (aggDataExists) {\n            result = rowNode.aggData[colId];\n        } else if (colDef.valueGetter) {\n            result = this.executeValueGetter(colDef.valueGetter, data, column, rowNode);\n        } else if (field && data) {\n            result = getValueUsingField(data, field, column.isFieldContainsDots());\n        }\n\n        // the result could be an expression itself, if we are allowing cell values to be expressions\n        if (this.cellExpressions && (typeof result === 'string') && result.indexOf('=') === 0) {\n            const cellValueGetter = result.substring(1);\n            result = this.executeValueGetter(cellValueGetter, data, column, rowNode);\n        }\n\n        if (result == null) {\n            const openedGroup = this.getOpenedGroup(rowNode, column);\n            if (openedGroup != null) {\n                return openedGroup;\n            }\n        }\n\n        return result;\n    }\n\n    private getOpenedGroup(rowNode: RowNode, column: Column): any {\n\n        if (!this.gridOptionsWrapper.isShowOpenedGroup()) { return; }\n\n        const colDef = column.getColDef();\n        if (!colDef.showRowGroup) { return; }\n\n        const showRowGroup = column.getColDef().showRowGroup;\n\n        let pointer = rowNode.parent;\n\n        while (pointer != null) {\n            if (pointer.rowGroupColumn && (showRowGroup === true || showRowGroup === pointer.rowGroupColumn.getId())) {\n                return pointer.key;\n            }\n            pointer = pointer.parent;\n        }\n\n        return undefined;\n    }\n\n    public setValue(rowNode: RowNode, colKey: string | Column, newValue: any, eventSource?: string): void {\n        const column = this.columnModel.getPrimaryColumn(colKey);\n\n        if (!rowNode || !column) {\n            return;\n        }\n        // this will only happen if user is trying to paste into a group row, which doesn't make sense\n        // the user should not be trying to paste into group rows\n        if (missing(rowNode.data)) {\n            rowNode.data = {};\n        }\n\n        // for backwards compatibility we are also retrieving the newValueHandler as well as the valueSetter\n        const { field, newValueHandler, valueSetter } = column.getColDef();\n\n        // need either a field or a newValueHandler for this to work\n        if (missing(field) && missing(newValueHandler) && missing(valueSetter)) {\n            // we don't tell user about newValueHandler, as that is deprecated\n            console.warn(`AG Grid: you need either field or valueSetter set on colDef for editing to work`);\n            return;\n        }\n\n        const params: NewValueParams = {\n            node: rowNode,\n            data: rowNode.data,\n            oldValue: this.getValue(column, rowNode),\n            newValue: newValue,\n            colDef: column.getColDef(),\n            column: column,\n            api: this.gridOptionsWrapper.getApi()!,\n            columnApi: this.gridOptionsWrapper.getColumnApi()!,\n            context: this.gridOptionsWrapper.getContext()\n        };\n\n        params.newValue = newValue;\n\n        let valueWasDifferent: boolean;\n\n        if (newValueHandler && exists(newValueHandler)) {\n            valueWasDifferent = newValueHandler(params);\n        } else if (exists(valueSetter)) {\n            valueWasDifferent = this.expressionService.evaluate(valueSetter, params);\n        } else {\n            valueWasDifferent = this.setValueUsingField(rowNode.data, field, newValue, column.isFieldContainsDots());\n        }\n\n        // in case user forgot to return something (possible if they are not using TypeScript\n        // and just forgot, or using an old newValueHandler we didn't always expect a return\n        // value here), we default the return value to true, so we always refresh.\n        if (valueWasDifferent === undefined) {\n            valueWasDifferent = true;\n        }\n\n        // if no change to the value, then no need to do the updating, or notifying via events.\n        // otherwise the user could be tabbing around the grid, and cellValueChange would get called\n        // all the time.\n        if (!valueWasDifferent) {\n            return;\n        }\n\n        // reset quick filter on this row\n        rowNode.resetQuickFilterAggregateText();\n\n        this.valueCache.onDataChanged();\n\n        params.newValue = this.getValue(column, rowNode);\n\n        const onCellValueChanged = column.getColDef().onCellValueChanged;\n        if (typeof onCellValueChanged === 'function') {\n            // to make callback async, do in a timeout\n            setTimeout(() => onCellValueChanged(params), 0);\n        }\n\n        const event: CellValueChangedEvent = {\n            type: Events.EVENT_CELL_VALUE_CHANGED,\n            event: null,\n            rowIndex: rowNode.rowIndex!,\n            rowPinned: rowNode.rowPinned,\n            column: params.column,\n            api: params.api!,\n            columnApi: params.columnApi!,\n            colDef: params.colDef,\n            context: params.context,\n            data: rowNode.data,\n            node: rowNode,\n            oldValue: params.oldValue,\n            newValue: params.newValue,\n            value: params.newValue,\n            source: eventSource\n        };\n\n        this.eventService.dispatchEvent(event);\n    }\n\n    private setValueUsingField(data: any, field: string | undefined, newValue: any, isFieldContainsDots: boolean): boolean {\n        if (!field) {\n            return false;\n        }\n\n        // if no '.', then it's not a deep value\n        const valuesAreSame: boolean = false;\n        if (!isFieldContainsDots) {\n            data[field] = newValue;\n        } else {\n            // otherwise it is a deep value, so need to dig for it\n            const fieldPieces = field.split('.');\n            let currentObject = data;\n            while (fieldPieces.length > 0 && currentObject) {\n                const fieldPiece: any = fieldPieces.shift();\n                if (fieldPieces.length === 0) {\n                    currentObject[fieldPiece] = newValue;\n                } else {\n                    currentObject = currentObject[fieldPiece];\n                }\n            }\n        }\n        return !valuesAreSame;\n    }\n\n    private executeFilterValueGetter(valueGetter: string | Function, data: any, column: Column, rowNode: RowNode): any {\n        const params: ValueGetterParams = {\n            data: data,\n            node: rowNode,\n            column: column,\n            colDef: column.getColDef(),\n            api: this.gridOptionsWrapper.getApi()!,\n            columnApi: this.gridOptionsWrapper.getColumnApi()!,\n            context: this.gridOptionsWrapper.getContext(),\n            getValue: this.getValueCallback.bind(this, rowNode)\n        };\n\n        return this.expressionService.evaluate(valueGetter, params);\n    }\n\n    private executeValueGetter(valueGetter: string | Function, data: any, column: Column, rowNode: RowNode): any {\n\n        const colId = column.getId();\n\n        // if inside the same turn, just return back the value we got last time\n        const valueFromCache = this.valueCache.getValue(rowNode, colId);\n\n        if (valueFromCache !== undefined) {\n            return valueFromCache;\n        }\n\n        const params: ValueGetterParams = {\n            data: data,\n            node: rowNode,\n            column: column,\n            colDef: column.getColDef(),\n            api: this.gridOptionsWrapper.getApi()!,\n            columnApi: this.gridOptionsWrapper.getColumnApi()!,\n            context: this.gridOptionsWrapper.getContext(),\n            getValue: this.getValueCallback.bind(this, rowNode)\n        };\n\n        const result = this.expressionService.evaluate(valueGetter, params);\n\n        // if a turn is active, store the value in case the grid asks for it again\n        this.valueCache.setValue(rowNode, colId, result);\n\n        return result;\n    }\n\n    private getValueCallback(node: RowNode, field: string | Column): any {\n        const otherColumn = this.columnModel.getPrimaryColumn(field);\n\n        if (otherColumn) {\n            return this.getValue(otherColumn, node);\n        }\n\n        return null;\n    }\n\n    // used by row grouping and pivot, to get key for a row. col can be a pivot col or a row grouping col\n    public getKeyForNode(col: Column, rowNode: RowNode): any {\n        const value = this.getValue(col, rowNode);\n        const keyCreator = col.getColDef().keyCreator;\n\n        let result = value;\n        if (keyCreator) {\n            const keyParams: KeyCreatorParams = {\n                value: value,\n                colDef: col.getColDef(),\n                column: col,\n                node: rowNode,\n                data: rowNode.data,\n                api: this.gridOptionsWrapper.getApi()!,\n                columnApi: this.gridOptionsWrapper.getColumnApi()!,\n                context: this.gridOptionsWrapper.getContext()\n            };\n            result = keyCreator(keyParams);\n        }\n\n        // if already a string, or missing, just return it\n        if (typeof result === 'string' || result == null) {\n            return result;\n        }\n\n        result = String(result);\n\n        if (result === '[object Object]') {\n            doOnce(() => {\n                console.warn('AG Grid: a column you are grouping or pivoting by has objects as values. If you want to group by complex objects then either a) use a colDef.keyCreator (se AG Grid docs) or b) to toString() on the object to return a key');\n            }, 'getKeyForNode - warn about [object,object]');\n        }\n\n        return result;\n    }\n}\n"]}