{"version":3,"sources":["../../src/ts/filter/floating/provided/simpleFloatingFilter.ts"],"names":[],"mappings":"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","file":"simpleFloatingFilter.js","sourcesContent":["import { Component } from '../../../widgets/component';\nimport { IFloatingFilterComp, IFloatingFilterParams } from '../floatingFilter';\nimport { IFilterOptionDef, ProvidedFilterModel } from '../../../interfaces/iFilter';\nimport { ICombinedSimpleModel, ISimpleFilterModel, SimpleFilter } from '../../provided/simpleFilter';\nimport { OptionsFactory } from '../../provided/optionsFactory';\nimport { IScalarFilterParams } from '../../provided/scalarFilter';\nimport { FilterChangedEvent } from '../../../events';\nimport { IProvidedFilterParams } from '../../provided/providedFilter';\n\nexport abstract class SimpleFloatingFilter extends Component implements IFloatingFilterComp {\n\n    // this method is on IFloatingFilterComp. because it's not implemented at this level, we have to\n    // define it as an abstract method. it gets implemented in sub classes.\n    public abstract onParentModelChanged(model: ProvidedFilterModel, event: FilterChangedEvent): void;\n\n    // creates text equivalent of FilterModel. if it's a combined model, this takes just one condition.\n    protected abstract conditionToString(condition: ProvidedFilterModel, opts?: IFilterOptionDef): string;\n    protected abstract getDefaultFilterOptions(): string[];\n    protected abstract setEditable(editable: boolean): void;\n\n    private lastType: string | null | undefined;\n\n    private optionsFactory: OptionsFactory;\n\n    private readOnly: boolean;\n\n    protected getDefaultDebounceMs(): number {\n        return 0;\n    }\n\n    // this is a user component, and IComponent has \"public destroy()\" as part of the interface.\n    // so we need to override destroy() just to make the method public.\n    public destroy(): void {\n        super.destroy();\n    }\n\n    // used by:\n    // 1) NumberFloatingFilter & TextFloatingFilter: Always, for both when editable and read only.\n    // 2) DateFloatingFilter: Only when read only (as we show text rather than a date picker when read only)\n    protected getTextFromModel(model: ProvidedFilterModel): string | null {\n        if (!model) { return null; }\n\n        const isCombined = (model as any).operator != null;\n        if (isCombined) {\n            const combinedModel = model as ICombinedSimpleModel<ISimpleFilterModel>;\n            const { condition1, condition2 } = combinedModel || {};\n            const customOption1 = this.optionsFactory.getCustomOption(condition1.type);\n            const customOption2 = this.optionsFactory.getCustomOption(condition2.type);\n\n            return [\n                this.conditionToString(condition1, customOption1),\n                combinedModel.operator,\n                this.conditionToString(condition2, customOption2),\n            ].join(' ');\n        } else {\n            const condition = model as ISimpleFilterModel;\n            const customOption = this.optionsFactory.getCustomOption(condition.type);\n\n            // For custom filter options we display the Name of the filter instead\n            // of displaying the `from` value, as it wouldn't be relevant\n            const { displayKey, displayName, numberOfInputs } = customOption || {};\n            if (displayKey && displayName && numberOfInputs === 0) {\n                this.gridOptionsWrapper.getLocaleTextFunc()(displayKey, displayName);\n                return displayName;\n            }\n            return this.conditionToString(condition, customOption);\n        }\n    }\n\n    protected isEventFromFloatingFilter(event: FilterChangedEvent): boolean | undefined {\n        return event && event.afterFloatingFilter;\n    }\n\n    protected getLastType(): string | null | undefined {\n        return this.lastType;\n    }\n\n    protected isReadOnly(): boolean {\n        return this.readOnly;\n    }\n\n    protected setLastTypeFromModel(model: ProvidedFilterModel): void {\n        // if no model provided by the parent filter use default\n        if (!model) {\n            this.lastType = this.optionsFactory.getDefaultOption();\n            return;\n        }\n\n        const isCombined = (model as any).operator;\n\n        let condition: ISimpleFilterModel;\n\n        if (isCombined) {\n            const combinedModel = model as ICombinedSimpleModel<ISimpleFilterModel>;\n            condition = combinedModel.condition1;\n        } else {\n            condition = model as ISimpleFilterModel;\n        }\n\n        this.lastType = condition.type;\n    }\n\n    protected canWeEditAfterModelFromParentFilter(model: ProvidedFilterModel): boolean {\n        if (!model) {\n            // if no model, then we can edit as long as the lastType is something we can edit, as this\n            // is the type we will provide to the parent filter if the user decides to use the floating filter.\n            return this.isTypeEditable(this.lastType);\n        }\n\n        // never allow editing if the filter is combined (ie has two parts)\n        const isCombined = (model as any).operator;\n\n        if (isCombined) {\n            return false;\n        }\n\n        const simpleModel = model as ISimpleFilterModel;\n\n        return this.isTypeEditable(simpleModel.type);\n    }\n\n    public init(params: IFloatingFilterParams): void {\n        this.optionsFactory = new OptionsFactory();\n        this.optionsFactory.init(params.filterParams as IScalarFilterParams, this.getDefaultFilterOptions());\n        this.lastType = this.optionsFactory.getDefaultOption();\n\n        // readOnly is a property of IProvidedFilterParams - we need to find a better (type-safe)\n        // way to support reading this in the future.\n        this.readOnly = !!(params.filterParams as IProvidedFilterParams).readOnly;\n\n        // we are editable if:\n        // 1) there is a type (user has configured filter wrong if not type)\n        //  AND\n        // 2) the default type is not 'in range'\n        const editable = this.isTypeEditable(this.lastType);\n        this.setEditable(editable);\n    }\n\n    private doesFilterHaveSingleInput(filterType: string) {\n        const customFilterOption = this.optionsFactory.getCustomOption(filterType);\n        const { numberOfInputs } = customFilterOption || {};\n        return numberOfInputs == null || numberOfInputs == 1;\n    }\n\n    private isTypeEditable(type?: string | null): boolean {\n        return !!type &&\n            !this.isReadOnly() &&\n            this.doesFilterHaveSingleInput(type) &&\n            type !== SimpleFilter.IN_RANGE &&\n            type !== SimpleFilter.EMPTY;\n    }\n}\n"]}