{"version":3,"sources":["../../src/ts/interfaces/IRangeService.ts"],"names":[],"mappings":";;;;;;;;AAwCA,IAAY,mBAAmC;AAA/C,WAAY,mBAAmB;IAAG,6DAAI,CAAA;IAAE,+DAAK,CAAA;AAAC,CAAC,EAAnC,mBAAmB,GAAnB,2BAAmB,KAAnB,2BAAmB,QAAgB;AAE/C,IAAY,aAAkC;AAA9C,WAAY,aAAa;IAAG,mDAAK,CAAA;IAAE,2DAAS,CAAA;AAAC,CAAC,EAAlC,aAAa,GAAb,qBAAa,KAAb,qBAAa,QAAqB","file":"IRangeService.js","sourcesContent":["import { Column } from \"../entities/column\";\nimport { CellPosition } from \"../entities/cellPosition\";\nimport { RowPosition } from \"../entities/rowPosition\";\nimport { CellCtrl } from \"../rendering/cell/cellCtrl\";\n\nexport interface IRangeService {\n    isEmpty(): boolean;\n    removeAllCellRanges(): void;\n    getCellRangeCount(cell: CellPosition): number;\n    isCellInAnyRange(cell: CellPosition): boolean;\n    isCellInSpecificRange(cell: CellPosition, range: CellRange): boolean;\n    isBottomRightCell(cellRange: CellRange, cell: CellPosition): boolean;\n    isContiguousRange(cellRange: CellRange): boolean;\n    isMoreThanOneCell(): boolean;\n    onDragStart(mouseEvent: MouseEvent): void;\n    onDragStop(): void;\n    onDragging(mouseEvent: MouseEvent): void;\n    getCellRanges(): CellRange[];\n    setRangeToCell(cell: CellPosition, appendRange?: boolean): void;\n    setCellRange(params: CellRangeParams): void;\n    addCellRange(params: CellRangeParams): void;\n    extendLatestRangeInDirection(key: number): CellPosition | undefined;\n    extendLatestRangeToCell(cell: CellPosition): void;\n    updateRangeEnd(cellRange: CellRange, cellPosition: CellPosition, silent?: boolean): void;\n    getRangeStartRow(cellRange: CellRange): RowPosition;\n    getRangeEndRow(cellRange: CellRange): RowPosition;\n    createCellRangeFromCellRangeParams(params: CellRangeParams): CellRange | undefined;\n    setCellRanges(cellRanges: CellRange[]): void;\n}\n\nexport interface ISelectionHandle {\n    getGui(): HTMLElement;\n    getType(): SelectionHandleType;\n    refresh(cellCtrl: CellCtrl): void;\n}\n\nexport interface ISelectionHandleFactory {\n    createSelectionHandle(type: SelectionHandleType): ISelectionHandle;\n}\n\nexport enum SelectionHandleType { FILL, RANGE }\n\nexport enum CellRangeType { VALUE, DIMENSION }\n\nexport interface CellRange {\n    id?: string;\n    type?: CellRangeType;\n    /** The start row of the range */\n    startRow?: RowPosition;\n    /** The end row of the range */\n    endRow?: RowPosition;\n    /** The columns in the range */\n    columns: Column[];\n    /** The start column for the range */\n    startColumn: Column;\n}\n\nexport interface CellRangeParams {\n    /** Start row index */\n    rowStartIndex: number | null;\n    /** Pinned state of start row. Either 'top', 'bottom' or null */\n    rowStartPinned?: string | null;\n    /** End row index */\n    rowEndIndex: number | null;\n    /** Pinned state of end row. Either 'top', 'bottom' or null */\n    rowEndPinned?: string | null;\n\n    /** Starting column for range */\n    columnStart?: string | Column;\n    /** End column for range */\n    columnEnd?: string | Column;\n    /** Specify Columns to include instead of using `columnStart` and `columnEnd` */\n    columns?: (string | Column)[];\n}\n\n/** @deprecated */\n// instead of this, we now use CellRange\nexport interface RangeSelection {\n    start: CellPosition;\n    end: CellPosition;\n    columns: Column[] | null;\n}\n\n/** @deprecated */\n// instead of this, we now use AddCellRangeParams\nexport interface AddRangeSelectionParams {\n    rowStart: number;\n    floatingStart: string;\n    rowEnd: number;\n    floatingEnd: string;\n    columnStart: string | Column;\n    columnEnd: string | Column;\n}\n"]}