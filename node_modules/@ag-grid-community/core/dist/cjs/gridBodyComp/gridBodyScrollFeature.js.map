{"version":3,"sources":["../../src/ts/gridBodyComp/gridBodyScrollFeature.ts"],"names":[],"mappings":"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","file":"gridBodyScrollFeature.js","sourcesContent":["import { Autowired, PostConstruct } from \"../context/context\";\nimport { BeanStub } from \"../context/beanStub\";\nimport { getInnerHeight, getScrollLeft, isRtlNegativeScroll, setScrollLeft } from \"../utils/dom\";\nimport { CtrlsService } from \"../ctrlsService\";\nimport { Events } from \"../eventKeys\";\nimport { debounce } from \"../utils/function\";\nimport { BodyScrollEvent, BodyScrollEndEvent } from \"../events\";\nimport { isIOSUserAgent } from \"../utils/browser\";\nimport { AnimationFrameService } from \"../misc/animationFrameService\";\nimport { ColumnApi } from \"../columns/columnApi\";\nimport { GridApi } from \"../gridApi\";\nimport { Constants } from \"../constants/constants\";\nimport { PaginationProxy } from \"../pagination/paginationProxy\";\nimport { IRowModel } from \"../interfaces/iRowModel\";\nimport { RowContainerHeightService } from \"../rendering/rowContainerHeightService\";\nimport { RowRenderer } from \"../rendering/rowRenderer\";\nimport { ColumnModel } from \"../columns/columnModel\";\nimport { RowContainerCtrl } from \"./rowContainer/rowContainerCtrl\";\nimport { assign } from \"../utils/object\";\n\ntype ScrollDirection = 'horizontal' | 'vertical';\n\nexport class GridBodyScrollFeature extends BeanStub {\n\n    @Autowired('ctrlsService') public ctrlsService: CtrlsService;\n    @Autowired('animationFrameService') private animationFrameService: AnimationFrameService;\n    @Autowired('columnApi') private columnApi: ColumnApi;\n    @Autowired('gridApi') private gridApi: GridApi;\n    @Autowired('paginationProxy') private paginationProxy: PaginationProxy;\n    @Autowired('rowModel') private rowModel: IRowModel;\n    @Autowired('rowContainerHeightService') private heightScaler: RowContainerHeightService;\n    @Autowired('rowRenderer') private rowRenderer: RowRenderer;\n    @Autowired('columnModel') private columnModel: ColumnModel;\n\n    private enableRtl: boolean;\n\n    private lastHorizontalScrollElement: HTMLElement | undefined | null;\n\n    private eBodyViewport: HTMLElement;\n\n    private scrollLeft = -1;\n    private nextScrollTop = -1;\n    private scrollTop = -1;\n\n    private scrollTimer: number | undefined;\n\n    private readonly resetLastHorizontalScrollElementDebounced: () => void;\n\n    private centerRowContainerCon: RowContainerCtrl;\n\n    constructor(eBodyViewport: HTMLElement) {\n        super();\n        this.eBodyViewport = eBodyViewport;\n        this.resetLastHorizontalScrollElementDebounced = debounce(this.resetLastHorizontalScrollElement.bind(this), 500);\n    }\n\n    @PostConstruct\n    private postConstruct(): void {\n        this.enableRtl = this.gridOptionsWrapper.isEnableRtl();\n        this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onDisplayedColumnsWidthChanged.bind(this));\n\n        this.ctrlsService.whenReady(p => {\n            this.centerRowContainerCon = p.centerRowContainerCtrl;\n            this.onDisplayedColumnsWidthChanged();\n            this.addScrollListener();\n        });\n    }\n\n    private addScrollListener() {\n        const fakeHScroll = this.ctrlsService.getFakeHScrollCtrl();\n\n        this.addManagedListener(this.centerRowContainerCon.getViewportElement(), 'scroll', this.onCenterViewportScroll.bind(this));\n        this.addManagedListener(fakeHScroll.getViewport(), 'scroll', this.onFakeHorizontalScroll.bind(this));\n\n        const onVerticalScroll = this.gridOptionsWrapper.isDebounceVerticalScrollbar() ?\n            debounce(this.onVerticalScroll.bind(this), 100)\n            : this.onVerticalScroll.bind(this);\n\n        this.addManagedListener(this.eBodyViewport, 'scroll', onVerticalScroll);\n    }\n\n    private onDisplayedColumnsWidthChanged(): void {\n        if (this.enableRtl) {\n            // because RTL is all backwards, a change in the width of the row\n            // can cause a change in the scroll position, without a scroll event,\n            // because the scroll position in RTL is a function that depends on\n            // the width. to be convinced of this, take out this line, enable RTL,\n            // scroll all the way to the left and then resize a column\n            this.horizontallyScrollHeaderCenterAndFloatingCenter();\n        }\n    }\n\n    public horizontallyScrollHeaderCenterAndFloatingCenter(scrollLeft?: number): void {\n        if (scrollLeft === undefined) {\n            scrollLeft = this.centerRowContainerCon.getCenterViewportScrollLeft();\n        }\n\n        const offset = this.enableRtl ? scrollLeft : -scrollLeft;\n        const topCenterContainer = this.ctrlsService.getTopCenterRowContainerCtrl();\n        const bottomCenterContainer = this.ctrlsService.getBottomCenterRowContainerCtrl();\n        const fakeHScroll = this.ctrlsService.getFakeHScrollCtrl();\n        const centerHeaderContainer = this.ctrlsService.getHeaderRowContainerCtrl();\n\n        centerHeaderContainer.setHorizontalScroll(offset);\n        bottomCenterContainer.setContainerTranslateX(offset);\n        topCenterContainer.setContainerTranslateX(offset);\n\n        const partner = this.lastHorizontalScrollElement === this.centerRowContainerCon.getViewportElement() ?\n                fakeHScroll.getViewport() : this.centerRowContainerCon.getViewportElement();\n\n        setScrollLeft(partner, Math.abs(scrollLeft), this.enableRtl);\n    }\n\n    private isControllingScroll(eDiv: HTMLElement): boolean {\n        if (!this.lastHorizontalScrollElement) {\n            this.lastHorizontalScrollElement = eDiv;\n            return true;\n        }\n\n        return eDiv === this.lastHorizontalScrollElement;\n    }\n\n    private onFakeHorizontalScroll(): void {\n        const fakeHScrollViewport = this.ctrlsService.getFakeHScrollCtrl().getViewport();\n        if (!this.isControllingScroll(fakeHScrollViewport)) { return; }\n        this.onBodyHorizontalScroll(fakeHScrollViewport);\n    }\n\n    private onCenterViewportScroll(): void {\n        const centerContainerViewport = this.centerRowContainerCon.getViewportElement();\n        if (!this.isControllingScroll(centerContainerViewport)) { return; }\n        this.onBodyHorizontalScroll(centerContainerViewport);\n    }\n\n    private onBodyHorizontalScroll(eSource: HTMLElement): void {\n        const centerContainerViewport = this.centerRowContainerCon.getViewportElement();\n        const { scrollLeft } = centerContainerViewport;\n\n        if (this.shouldBlockScrollUpdate('horizontal', scrollLeft, true)) {\n            return;\n        }\n\n        // we do Math.round() rather than Math.floor(), to mirror how scroll values are applied.\n        // eg if a scale is applied (ie user has zoomed the browser), then applying scroll=200\n        // could result in 199.88, which then floor(199.88) = 199, however round(199.88) = 200.\n        // initially Math.floor() was used, however this caused (almost) infinite loop with aligned grids,\n        // as the scroll would move 1px at at time bouncing from one grid to the next (eg one grid would cause\n        // scroll to 200px, the next to 199px, then the first back to 198px and so on).\n        this.doHorizontalScroll(Math.round(getScrollLeft(eSource, this.enableRtl)));\n        this.resetLastHorizontalScrollElementDebounced();\n    }\n\n    private onVerticalScroll(): void {\n        const scrollTop: number = this.eBodyViewport.scrollTop;\n\n        if (this.shouldBlockScrollUpdate('vertical', scrollTop, true)) { return; }\n        this.animationFrameService.setScrollTop(scrollTop);\n        this.nextScrollTop = scrollTop;\n\n        if (this.gridOptionsWrapper.isSuppressAnimationFrame()) {\n            this.scrollTop = this.nextScrollTop;\n            this.redrawRowsAfterScroll();\n        } else {\n            this.animationFrameService.schedule();\n        }\n    }\n\n    private resetLastHorizontalScrollElement() {\n        this.lastHorizontalScrollElement = null;\n    }\n\n    private doHorizontalScroll(scrollLeft: number): void {\n        const fakeHScrollViewport = this.ctrlsService.getFakeHScrollCtrl().getViewport();\n        const fakeScrollLeft = getScrollLeft(fakeHScrollViewport, this.enableRtl);\n\n        if (this.scrollLeft === scrollLeft && scrollLeft === fakeScrollLeft) { return; }\n\n        this.scrollLeft = scrollLeft;\n\n        this.fireScrollEvent('horizontal');\n        this.horizontallyScrollHeaderCenterAndFloatingCenter(scrollLeft);\n        this.onHorizontalViewportChanged();\n    }\n\n    private fireScrollEvent(direction: 'horizontal' | 'vertical'): void {\n        const bodyScrollEvent: BodyScrollEvent = {\n            type: Events.EVENT_BODY_SCROLL,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            direction,\n            left: this.scrollLeft,\n            top: this.scrollTop\n        };\n\n        this.eventService.dispatchEvent(bodyScrollEvent);\n\n        window.clearTimeout(this.scrollTimer);\n        this.scrollTimer = undefined;\n\n        this.scrollTimer = window.setTimeout(() => {\n            const bodyScrollEndEvent: BodyScrollEndEvent = assign({}, bodyScrollEvent, {\n                type: Events.EVENT_BODY_SCROLL_END\n            });\n            this.eventService.dispatchEvent(bodyScrollEndEvent);\n        }, 100);\n    }\n\n    private shouldBlockScrollUpdate(direction: ScrollDirection, scrollTo: number, touchOnly: boolean = false): boolean {\n        // touch devices allow elastic scroll - which temporally scrolls the panel outside of the viewport\n        // (eg user uses touch to go to the left of the grid, but drags past the left, the rows will actually\n        // scroll past the left until the user releases the mouse). when this happens, we want ignore the scroll,\n        // as otherwise it was causing the rows and header to flicker.\n\n        // sometimes when scrolling, we got values that extended the maximum scroll allowed. we used to\n        // ignore these scrolls. problem is the max scroll position could be skipped (eg the previous scroll event\n        // could be 10px before the max position, and then current scroll event could be 20px after the max position).\n        // if we just ignored the last event, we would be setting the scroll to 10px before the max position, when in\n        // actual fact the user has exceeded the max scroll and thus scroll should be set to the max.\n\n        if (touchOnly && !isIOSUserAgent()) { return false; }\n\n        if (direction === 'vertical') {\n            const clientHeight = getInnerHeight(this.eBodyViewport);\n            const { scrollHeight } = this.eBodyViewport;\n            if (scrollTo < 0 || (scrollTo + clientHeight > scrollHeight)) {\n                return true;\n            }\n        }\n\n        if (direction === 'horizontal') {\n            const clientWidth = this.centerRowContainerCon.getCenterWidth();\n            const { scrollWidth } = this.centerRowContainerCon.getViewportElement();\n\n            if (this.enableRtl && isRtlNegativeScroll()) {\n                if (scrollTo > 0) { return true; }\n            } else if (scrollTo < 0) { return true; }\n\n            if (Math.abs(scrollTo) + clientWidth > scrollWidth) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private redrawRowsAfterScroll(): void {\n        this.fireScrollEvent('vertical');\n    }\n\n    private onHorizontalViewportChanged(): void {\n        this.centerRowContainerCon.onHorizontalViewportChanged();\n    }\n\n    // this is to cater for AG-3274, where grid is removed from the dom and then inserted back in again.\n    // (which happens with some implementations of tabbing). this can result in horizontal scroll getting\n    // reset back to the left, however no scroll event is fired. so we need to get header to also scroll\n    // back to the left to be kept in sync.\n    // adding and removing the grid from the DOM both resets the scroll position and\n    // triggers a resize event, so notify listeners if the scroll position has changed\n    public checkScrollLeft(): void {\n        if (this.scrollLeft !== this.centerRowContainerCon.getCenterViewportScrollLeft()) {\n            this.onBodyHorizontalScroll(this.centerRowContainerCon.getViewportElement());\n        }\n    }\n\n    public executeAnimationFrameScroll(): boolean {\n        const frameNeeded = this.scrollTop != this.nextScrollTop;\n\n        if (frameNeeded) {\n            this.scrollTop = this.nextScrollTop;\n            this.redrawRowsAfterScroll();\n        }\n\n        return frameNeeded;\n    }\n\n    // called by scrollHorizontally method and alignedGridsService\n    public setHorizontalScrollPosition(hScrollPosition: number): void {\n        const minScrollLeft = 0;\n        const maxScrollLeft = this.centerRowContainerCon.getViewportElement().scrollWidth - this.centerRowContainerCon.getCenterWidth();\n\n        if (this.shouldBlockScrollUpdate('horizontal', hScrollPosition)) {\n            if (this.enableRtl && isRtlNegativeScroll()) {\n                hScrollPosition = hScrollPosition > 0 ? 0 : maxScrollLeft;\n            } else {\n                hScrollPosition = Math.min(Math.max(hScrollPosition, minScrollLeft), maxScrollLeft);\n            }\n        }\n\n        setScrollLeft(this.centerRowContainerCon.getViewportElement(), Math.abs(hScrollPosition), this.enableRtl);\n\n        // we need to manually do the event handling (rather than wait for the event)\n        // for the alignedGridsService, as if we don't, the aligned grid service gets\n        // notified async, and then it's 'consuming' flag doesn't get used right, and\n        // we can end up with an infinite loop\n        this.doHorizontalScroll(hScrollPosition);\n    }\n\n    public setVerticalScrollPosition(vScrollPosition: number): void {\n        this.eBodyViewport.scrollTop = vScrollPosition;\n    }\n\n    public getVScrollPosition(): { top: number, bottom: number; } {\n        const result = {\n            top: this.eBodyViewport.scrollTop,\n            bottom: this.eBodyViewport.scrollTop + this.eBodyViewport.offsetHeight\n        };\n        return result;\n    }\n\n    public getHScrollPosition(): { left: number, right: number; } {\n        return this.centerRowContainerCon.getHScrollPosition();\n    }\n\n    public isHorizontalScrollShowing(): boolean {\n        return this.centerRowContainerCon.isHorizontalScrollShowing();\n    }\n\n    // called by the headerRootComp and moveColumnController\n    public scrollHorizontally(pixels: number): number {\n        const oldScrollPosition = this.centerRowContainerCon.getViewportElement().scrollLeft;\n\n        this.setHorizontalScrollPosition(oldScrollPosition + pixels);\n        return this.centerRowContainerCon.getViewportElement().scrollLeft - oldScrollPosition;\n    }\n\n    // gets called by rowRenderer when new data loaded, as it will want to scroll to the top\n    public scrollToTop(): void {\n        this.eBodyViewport.scrollTop = 0;\n    }\n\n    // Valid values for position are bottom, middle and top\n    public ensureNodeVisible(comparator: any, position: string | null = null) {\n\n        // look for the node index we want to display\n        const rowCount = this.rowModel.getRowCount();\n        const comparatorIsAFunction = typeof comparator === 'function';\n        let indexToSelect = -1;\n        // go through all the nodes, find the one we want to show\n        for (let i = 0; i < rowCount; i++) {\n            const node = this.rowModel.getRow(i);\n            if (comparatorIsAFunction) {\n                if (comparator(node)) {\n                    indexToSelect = i;\n                    break;\n                }\n            } else {\n                // check object equality against node and data\n                if (comparator === node || comparator === node!.data) {\n                    indexToSelect = i;\n                    break;\n                }\n            }\n        }\n        if (indexToSelect >= 0) {\n            this.ensureIndexVisible(indexToSelect, position);\n        }\n    }\n\n    // Valid values for position are bottom, middle and top\n    // position should be {'top','middle','bottom', or undefined/null}.\n    // if undefined/null, then the grid will to the minimal amount of scrolling,\n    // eg if grid needs to scroll up, it scrolls until row is on top,\n    //    if grid needs to scroll down, it scrolls until row is on bottom,\n    //    if row is already in view, grid does not scroll\n    public ensureIndexVisible(index: any, position?: string | null) {\n        // if for print or auto height, everything is always visible\n        if (this.gridOptionsWrapper.getDomLayout() === Constants.DOM_LAYOUT_PRINT) { return; }\n\n        const rowCount = this.paginationProxy.getRowCount();\n\n        if (typeof index !== 'number' || index < 0 || index >= rowCount) {\n            console.warn('invalid row index for ensureIndexVisible: ' + index);\n            return;\n        }\n\n        const isPaging = this.gridOptionsWrapper.isPagination();\n        const paginationPanelEnabled = isPaging && !this.gridOptionsWrapper.isSuppressPaginationPanel();\n\n        if (!paginationPanelEnabled) {\n            this.paginationProxy.goToPageWithIndex(index);\n        }\n\n        const rowNode = this.paginationProxy.getRow(index);\n        let rowGotShiftedDuringOperation: boolean;\n\n        do {\n            const startingRowTop = rowNode!.rowTop;\n            const startingRowHeight = rowNode!.rowHeight;\n\n            const paginationOffset = this.paginationProxy.getPixelOffset();\n            const rowTopPixel = rowNode!.rowTop! - paginationOffset;\n            const rowBottomPixel = rowTopPixel + rowNode!.rowHeight!;\n\n            const scrollPosition = this.getVScrollPosition();\n            const heightOffset = this.heightScaler.getDivStretchOffset();\n\n            const vScrollTop = scrollPosition.top + heightOffset;\n            const vScrollBottom = scrollPosition.bottom + heightOffset;\n\n            const viewportHeight = vScrollBottom - vScrollTop;\n\n            // work out the pixels for top, middle and bottom up front,\n            // make the if/else below easier to read\n            const pxTop = this.heightScaler.getScrollPositionForPixel(rowTopPixel);\n            const pxBottom = this.heightScaler.getScrollPositionForPixel(rowBottomPixel - viewportHeight);\n            // make sure if middle, the row is not outside the top of the grid\n            const pxMiddle = Math.min((pxTop + pxBottom) / 2, rowTopPixel);\n\n            const rowBelowViewport = vScrollTop > rowTopPixel;\n            const rowAboveViewport = vScrollBottom < rowBottomPixel;\n\n            let newScrollPosition: number | null = null;\n\n            if (position === 'top') {\n                newScrollPosition = pxTop;\n            } else if (position === 'bottom') {\n                newScrollPosition = pxBottom;\n            } else if (position === 'middle') {\n                newScrollPosition = pxMiddle;\n            } else if (rowBelowViewport) {\n                // if row is before, scroll up with row at top\n                newScrollPosition = pxTop;\n            } else if (rowAboveViewport) {\n                // if row is below, scroll down with row at bottom\n                newScrollPosition = pxBottom;\n            }\n\n            if (newScrollPosition !== null) {\n                this.eBodyViewport.scrollTop = newScrollPosition;\n                this.rowRenderer.redrawAfterScroll();\n            }\n\n            // the row can get shifted if during the rendering (during rowRenderer.redrawAfterScroll()),\n            // the height of a row changes due to lazy calculation of row heights when using\n            // colDef.autoHeight or gridOptions.getRowHeight.\n            // if row was shifted, then the position we scrolled to is incorrect.\n            rowGotShiftedDuringOperation = (startingRowTop !== rowNode!.rowTop)\n                || (startingRowHeight !== rowNode!.rowHeight);\n\n        } while (rowGotShiftedDuringOperation);\n\n        // so when we return back to user, the cells have rendered\n        this.animationFrameService.flushAllFrames();\n    }\n\n    public ensureColumnVisible(key: any): void {\n        const column = this.columnModel.getGridColumn(key);\n\n        if (!column) { return; }\n\n        // calling ensureColumnVisible on a pinned column doesn't make sense\n        if (column.isPinned()) { return; }\n\n        // defensive\n        if (!this.columnModel.isColumnDisplayed(column)) { return; }\n\n        const colLeftPixel = column.getLeft();\n        const colRightPixel = colLeftPixel! + column.getActualWidth();\n\n        const viewportWidth = this.centerRowContainerCon.getCenterWidth();\n        const scrollPosition = this.centerRowContainerCon.getCenterViewportScrollLeft();\n\n        const bodyWidth = this.columnModel.getBodyContainerWidth();\n\n        let viewportLeftPixel: number;\n        let viewportRightPixel: number;\n\n        // the logic of working out left and right viewport px is both here and in the ColumnController,\n        // need to refactor it out to one place\n        if (this.enableRtl) {\n            viewportLeftPixel = bodyWidth - scrollPosition - viewportWidth;\n            viewportRightPixel = bodyWidth - scrollPosition;\n        } else {\n            viewportLeftPixel = scrollPosition;\n            viewportRightPixel = viewportWidth + scrollPosition;\n        }\n\n        const viewportScrolledPastCol = viewportLeftPixel > colLeftPixel!;\n        const viewportScrolledBeforeCol = viewportRightPixel < colRightPixel;\n        const colToSmallForViewport = viewportWidth < column.getActualWidth();\n\n        const alignColToLeft = viewportScrolledPastCol || colToSmallForViewport;\n        const alignColToRight = viewportScrolledBeforeCol;\n\n        if (alignColToLeft || alignColToRight) {\n            let newScrollPosition: number;\n            if (this.enableRtl) {\n                newScrollPosition = alignColToLeft ? (bodyWidth - viewportWidth - colLeftPixel!) : (bodyWidth - colRightPixel);\n            } else {\n                newScrollPosition = alignColToLeft ? colLeftPixel! : (colRightPixel - viewportWidth);\n            }\n            this.centerRowContainerCon.setCenterViewportScrollLeft(newScrollPosition);\n        } else {\n            // otherwise, col is already in view, so do nothing\n        }\n\n        // this will happen anyway, as the move will cause a 'scroll' event on the body, however\n        // it is possible that the ensureColumnVisible method is called from within AG Grid and\n        // the caller will need to have the columns rendered to continue, which will be before\n        // the event has been worked on (which is the case for cell navigation).\n        this.centerRowContainerCon.onHorizontalViewportChanged();\n\n        // so when we return back to user, the cells have rendered\n        this.animationFrameService.flushAllFrames();\n    }\n}"]}