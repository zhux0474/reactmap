{"version":3,"sources":["../../src/ts/columns/columnFactory.ts"],"names":[],"mappings":"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","file":"columnFactory.js","sourcesContent":["import { Logger, LoggerFactory } from '../logger';\nimport { ColumnUtils } from './columnUtils';\nimport { AbstractColDef, ColDef, ColGroupDef } from \"../entities/colDef\";\nimport { ColumnKeyCreator } from \"./columnKeyCreator\";\nimport { IProvidedColumn } from \"../entities/iProvidedColumn\";\nimport { ProvidedColumnGroup } from \"../entities/providedColumnGroup\";\nimport { Column } from \"../entities/column\";\nimport { Autowired, Bean, Qualifier } from \"../context/context\";\nimport { DefaultColumnTypes } from \"../entities/defaultColumnTypes\";\nimport { BeanStub } from \"../context/beanStub\";\nimport { Constants } from \"../constants/constants\";\nimport { assign, iterateObject, mergeDeep } from '../utils/object';\nimport { attrToNumber, attrToBoolean, find } from '../utils/generic';\nimport { removeFromArray } from '../utils/array';\n\n// takes ColDefs and ColGroupDefs and turns them into Columns and OriginalGroups\n@Bean('columnFactory')\nexport class ColumnFactory extends BeanStub {\n\n    @Autowired('columnUtils') private columnUtils: ColumnUtils;\n\n    private logger: Logger;\n\n    private setBeans(@Qualifier('loggerFactory') loggerFactory: LoggerFactory) {\n        this.logger = loggerFactory.create('ColumnFactory');\n    }\n\n    public createColumnTree(defs: (ColDef | ColGroupDef)[] | null, primaryColumns: boolean, existingTree?: IProvidedColumn[])\n        : { columnTree: IProvidedColumn[], treeDept: number; } {\n\n        // column key creator dishes out unique column id's in a deterministic way,\n        // so if we have two grids (that could be master/slave) with same column definitions,\n        // then this ensures the two grids use identical id's.\n        const columnKeyCreator = new ColumnKeyCreator();\n\n        const {existingCols, existingGroups, existingColKeys} = this.extractExistingTreeData(existingTree);\n        columnKeyCreator.addExistingKeys(existingColKeys);\n\n        // create am unbalanced tree that maps the provided definitions\n        const unbalancedTree = this.recursivelyCreateColumns(defs, 0, primaryColumns,\n            existingCols, columnKeyCreator, existingGroups);\n        const treeDept = this.findMaxDept(unbalancedTree, 0);\n        this.logger.log('Number of levels for grouped columns is ' + treeDept);\n        const columnTree = this.balanceColumnTree(unbalancedTree, 0, treeDept, columnKeyCreator);\n\n        const deptFirstCallback = (child: IProvidedColumn, parent: ProvidedColumnGroup) => {\n            if (child instanceof ProvidedColumnGroup) {\n                child.setupExpandable();\n            }\n            // we set the original parents at the end, rather than when we go along, as balancing the tree\n            // adds extra levels into the tree. so we can only set parents when balancing is done.\n            child.setOriginalParent(parent);\n        };\n\n        this.columnUtils.depthFirstOriginalTreeSearch(null, columnTree, deptFirstCallback);\n\n        return {\n            columnTree,\n            treeDept\n        };\n    }\n\n    private extractExistingTreeData(existingTree?: IProvidedColumn[]):\n        {\n            existingCols: Column[],\n            existingGroups: ProvidedColumnGroup[],\n            existingColKeys: string[]\n        }  {\n\n        const existingCols: Column[] = [];\n        const existingGroups: ProvidedColumnGroup[] = [];\n        const existingColKeys: string[] = [];\n\n        if (existingTree) {\n            this.columnUtils.depthFirstOriginalTreeSearch(null, existingTree, (item: IProvidedColumn) => {\n                if (item instanceof ProvidedColumnGroup) {\n                    const group = item;\n                    existingGroups.push(group);\n                } else {\n                    const col = item as Column;\n                    existingColKeys.push(col.getId());\n                    existingCols.push(col);\n                }\n            });\n        }\n\n        return {existingCols, existingGroups, existingColKeys};\n    }\n\n    public createForAutoGroups(autoGroupCols: Column[], gridBalancedTree: IProvidedColumn[]): IProvidedColumn[] {\n        const autoColBalancedTree: IProvidedColumn[] = [];\n\n        autoGroupCols.forEach(col => {\n            const fakeTreeItem = this.createAutoGroupTreeItem(gridBalancedTree, col);\n            autoColBalancedTree.push(fakeTreeItem);\n        });\n\n        return autoColBalancedTree;\n    }\n\n    private createAutoGroupTreeItem(balancedColumnTree: IProvidedColumn[], column: Column): IProvidedColumn {\n        const dept = this.findDepth(balancedColumnTree);\n\n        // at the end, this will be the top of the tree item.\n        let nextChild: IProvidedColumn = column;\n\n        for (let i = dept - 1; i >= 0; i--) {\n            const autoGroup = new ProvidedColumnGroup(\n                null,\n                `FAKE_PATH_${column.getId()}}_${i}`,\n                true,\n                i\n            );\n            this.context.createBean(autoGroup);\n            autoGroup.setChildren([nextChild]);\n            nextChild.setOriginalParent(autoGroup);\n            nextChild = autoGroup;\n        }\n\n        // at this point, the nextChild is the top most item in the tree\n        return nextChild;\n    }\n\n    private findDepth(balancedColumnTree: IProvidedColumn[]): number {\n        let dept = 0;\n        let pointer = balancedColumnTree;\n\n        while (pointer && pointer[0] && pointer[0] instanceof ProvidedColumnGroup) {\n            dept++;\n            pointer = (pointer[0] as ProvidedColumnGroup).getChildren();\n        }\n        return dept;\n    }\n\n    private balanceColumnTree(\n        unbalancedTree: IProvidedColumn[],\n        currentDept: number,\n        columnDept: number,\n        columnKeyCreator: ColumnKeyCreator\n    ): IProvidedColumn[] {\n\n        const result: IProvidedColumn[] = [];\n\n        // go through each child, for groups, recurse a level deeper,\n        // for columns we need to pad\n        for (let i = 0; i < unbalancedTree.length; i++) {\n            const child = unbalancedTree[i];\n            if (child instanceof ProvidedColumnGroup) {\n                // child is a group, all we do is go to the next level of recursion\n                const originalGroup = child;\n                const newChildren = this.balanceColumnTree(originalGroup.getChildren(),\n                    currentDept + 1, columnDept, columnKeyCreator);\n                originalGroup.setChildren(newChildren);\n                result.push(originalGroup);\n            } else {\n                // child is a column - so here we add in the padded column groups if needed\n                let firstPaddedGroup: ProvidedColumnGroup | undefined;\n                let currentPaddedGroup: ProvidedColumnGroup | undefined;\n\n                // this for loop will NOT run any loops if no padded column groups are needed\n                for (let j = columnDept - 1; j >= currentDept; j--) {\n                    const newColId = columnKeyCreator.getUniqueKey(null, null);\n                    const colGroupDefMerged = this.createMergedColGroupDef(null);\n\n                    const paddedGroup = new ProvidedColumnGroup(colGroupDefMerged, newColId, true, currentDept);\n                    this.context.createBean(paddedGroup);\n\n                    if (currentPaddedGroup) {\n                        currentPaddedGroup.setChildren([paddedGroup]);\n                    }\n\n                    currentPaddedGroup = paddedGroup;\n\n                    if (!firstPaddedGroup) {\n                        firstPaddedGroup = currentPaddedGroup;\n                    }\n                }\n\n                // likewise this if statement will not run if no padded groups\n                if (firstPaddedGroup && currentPaddedGroup) {\n                    result.push(firstPaddedGroup);\n                    const hasGroups = unbalancedTree.some(leaf => leaf instanceof ProvidedColumnGroup);\n\n                    if (hasGroups) {\n                        currentPaddedGroup.setChildren([child]);\n                        continue;\n                    } else {\n                        currentPaddedGroup.setChildren(unbalancedTree);\n                        break;\n                    }\n                }\n\n                result.push(child);\n            }\n        }\n\n        return result;\n    }\n\n    private findMaxDept(treeChildren: IProvidedColumn[], dept: number): number {\n        let maxDeptThisLevel = dept;\n\n        for (let i = 0; i < treeChildren.length; i++) {\n            const abstractColumn = treeChildren[i];\n            if (abstractColumn instanceof ProvidedColumnGroup) {\n                const originalGroup = abstractColumn;\n                const newDept = this.findMaxDept(originalGroup.getChildren(), dept + 1);\n                if (maxDeptThisLevel < newDept) {\n                    maxDeptThisLevel = newDept;\n                }\n            }\n        }\n\n        return maxDeptThisLevel;\n    }\n\n    private recursivelyCreateColumns(\n        defs: (ColDef | ColGroupDef)[] | null,\n        level: number,\n        primaryColumns: boolean,\n        existingColsCopy: Column[],\n        columnKeyCreator: ColumnKeyCreator,\n        existingGroups: ProvidedColumnGroup[]\n    ): IProvidedColumn[] {\n        const result: IProvidedColumn[] = [];\n\n        if (!defs) { return result; }\n\n        defs.forEach((def: ColDef | ColGroupDef) => {\n            let newGroupOrColumn: IProvidedColumn;\n\n            if (this.isColumnGroup(def)) {\n                newGroupOrColumn = this.createColumnGroup(primaryColumns, def as ColGroupDef, level, existingColsCopy,\n                    columnKeyCreator, existingGroups);\n            } else {\n                newGroupOrColumn = this.createColumn(primaryColumns, def as ColDef, existingColsCopy, columnKeyCreator);\n            }\n\n            result.push(newGroupOrColumn);\n        });\n\n        return result;\n    }\n\n    private createColumnGroup(\n        primaryColumns: boolean,\n        colGroupDef: ColGroupDef,\n        level: number,\n        existingColumns: Column[],\n        columnKeyCreator: ColumnKeyCreator,\n        existingGroups: ProvidedColumnGroup[]\n    ): ProvidedColumnGroup {\n        const colGroupDefMerged = this.createMergedColGroupDef(colGroupDef);\n        const groupId = columnKeyCreator.getUniqueKey(colGroupDefMerged.groupId || null, null);\n        const originalGroup = new ProvidedColumnGroup(colGroupDefMerged, groupId, false, level);\n\n        this.context.createBean(originalGroup);\n\n        const existingGroup = this.findExistingGroup(colGroupDef, existingGroups);\n        if (existingGroup && existingGroup.isExpanded()) {\n            originalGroup.setExpanded(true);\n        }\n\n        const children = this.recursivelyCreateColumns(colGroupDefMerged.children,\n            level + 1, primaryColumns, existingColumns, columnKeyCreator, existingGroups);\n\n        originalGroup.setChildren(children);\n\n        return originalGroup;\n    }\n\n    private createMergedColGroupDef(colGroupDef: ColGroupDef | null): ColGroupDef {\n        const colGroupDefMerged: ColGroupDef = {} as ColGroupDef;\n        assign(colGroupDefMerged, this.gridOptionsWrapper.getDefaultColGroupDef());\n        assign(colGroupDefMerged, colGroupDef);\n        this.checkForDeprecatedItems(colGroupDefMerged);\n\n        return colGroupDefMerged;\n    }\n\n    private createColumn(\n        primaryColumns: boolean,\n        colDef: ColDef,\n        existingColsCopy: Column[] | null,\n        columnKeyCreator: ColumnKeyCreator\n    ): Column {\n        const colDefMerged = this.mergeColDefs(colDef);\n\n        this.checkForDeprecatedItems(colDefMerged);\n\n        // see if column already exists\n        let column = this.findExistingColumn(colDef, existingColsCopy);\n\n        if (!column) {\n            // no existing column, need to create one\n            const colId = columnKeyCreator.getUniqueKey(colDefMerged.colId, colDefMerged.field);\n            column = new Column(colDefMerged, colDef, colId, primaryColumns);\n            this.context.createBean(column);\n        } else {\n            column.setColDef(colDefMerged, colDef);\n            this.applyColumnState(column, colDefMerged);\n        }\n\n        return column;\n    }\n\n    private applyColumnState(column: Column, colDef: ColDef): void {\n        // flex\n        const flex = attrToNumber(colDef.flex);\n        if (flex !== undefined) {\n            column.setFlex(flex);\n        }\n\n        // width - we only set width if column is not flexing\n        const noFlexThisCol = column.getFlex() <= 0;\n        if (noFlexThisCol) {\n            // both null and undefined means we skip, as it's not possible to 'clear' width (a column must have a width)\n            const width = attrToNumber(colDef.width);\n            if (width != null) {\n                column.setActualWidth(width);\n            } else {\n                // otherwise set the width again, in case min or max width has changed,\n                // and width needs to be adjusted.\n                const widthBeforeUpdate = column.getActualWidth();\n                column.setActualWidth(widthBeforeUpdate);\n            }\n        }\n\n        // sort - anything but undefined will set sort, thus null or empty string will clear the sort\n        if (colDef.sort !== undefined) {\n            if (colDef.sort == Constants.SORT_ASC || colDef.sort == Constants.SORT_DESC) {\n                column.setSort(colDef.sort);\n            } else {\n                column.setSort(undefined);\n            }\n        }\n\n        // sorted at - anything but undefined, thus null will clear the sortIndex\n        const sortIndex = attrToNumber(colDef.sortIndex);\n        if (sortIndex !== undefined) {\n            column.setSortIndex(sortIndex);\n        }\n\n        // hide - anything but undefined, thus null will clear the hide\n        const hide = attrToBoolean(colDef.hide);\n        if (hide !== undefined) {\n            column.setVisible(!hide);\n        }\n\n        // pinned - anything but undefined, thus null or empty string will remove pinned\n        if (colDef.pinned !== undefined) {\n            column.setPinned(colDef.pinned);\n        }\n    }\n\n    public findExistingColumn(newColDef: ColDef, existingColsCopy: Column[] | null): Column | null {\n        const res: Column | null = find(existingColsCopy, existingCol => {\n\n            const existingColDef = existingCol.getUserProvidedColDef();\n            if (!existingColDef) { return false; }\n\n            const newHasId = newColDef.colId != null;\n            const newHasField = newColDef.field != null;\n\n            if (newHasId) {\n                return existingCol.getId() === newColDef.colId;\n            }\n\n            if (newHasField) {\n                return existingColDef.field === newColDef.field;\n            }\n\n            // if no id or field present, then try object equivalence.\n            if (existingColDef === newColDef) { return true; }\n\n            return false;\n        });\n\n        // make sure we remove, so if user provided duplicate id, then we don't have more than\n        // one column instance for colDef with common id\n        if (existingColsCopy && res) {\n            removeFromArray(existingColsCopy, res);\n        }\n\n        return res;\n    }\n\n    public findExistingGroup(newGroupDef: ColGroupDef, existingGroups: ProvidedColumnGroup[]): ProvidedColumnGroup | null {\n        const res: ProvidedColumnGroup | null = find(existingGroups, existingGroup => {\n\n            const existingDef = existingGroup.getColGroupDef()\n            if (!existingDef) { return false; }\n\n            const newHasId = newGroupDef.groupId != null;\n\n            if (newHasId) {\n                return existingGroup.getId() === newGroupDef.groupId;\n            }\n\n            return false;\n        });\n\n        // make sure we remove, so if user provided duplicate id, then we don't have more than\n        // one column instance for colDef with common id\n        if (res) {\n            removeFromArray(existingGroups, res);\n        }\n\n        return res;\n    }\n\n    public mergeColDefs(colDef: ColDef) {\n        // start with empty merged definition\n        const colDefMerged: ColDef = {} as ColDef;\n\n        // merge properties from default column definitions\n        const defaultColDef = this.gridOptionsWrapper.getDefaultColDef();\n        mergeDeep(colDefMerged, defaultColDef, false, true);\n\n        // merge properties from column type properties\n        let columnType = colDef.type;\n\n        if (!columnType) {\n            columnType = defaultColDef && defaultColDef.type;\n        }\n\n        // if type of both colDef and defaultColDef, then colDef gets preference\n        if (columnType) {\n            this.assignColumnTypes(columnType, colDefMerged);\n        }\n\n        // merge properties from column definitions\n        mergeDeep(colDefMerged, colDef, false, true);\n\n        return colDefMerged;\n    }\n\n    private assignColumnTypes(type: string | string[], colDefMerged: ColDef) {\n        let typeKeys: string[] = [];\n\n        if (type instanceof Array) {\n            const invalidArray = type.some(a => typeof a !== 'string');\n            if (invalidArray) {\n                console.warn(\"ag-grid: if colDef.type is supplied an array it should be of type 'string[]'\");\n            } else {\n                typeKeys = type;\n            }\n        } else if (typeof type === 'string') {\n            typeKeys = type.split(',');\n        } else {\n            console.warn(\"ag-grid: colDef.type should be of type 'string' | 'string[]'\");\n            return;\n        }\n\n        // merge user defined with default column types\n        const allColumnTypes = assign({}, DefaultColumnTypes);\n        const userTypes = this.gridOptionsWrapper.getColumnTypes() || {};\n\n        iterateObject(userTypes, (key, value) => {\n            if (key in allColumnTypes) {\n                console.warn(`AG Grid: the column type '${key}' is a default column type and cannot be overridden.`);\n            } else {\n                allColumnTypes[key] = value;\n            }\n        });\n\n        typeKeys.forEach((t) => {\n            const typeColDef = allColumnTypes[t.trim()];\n            if (typeColDef) {\n                mergeDeep(colDefMerged, typeColDef, false, true);\n            } else {\n                console.warn(\"ag-grid: colDef.type '\" + t + \"' does not correspond to defined gridOptions.columnTypes\");\n            }\n        });\n    }\n\n    private checkForDeprecatedItems(colDef: AbstractColDef) {\n        if (colDef) {\n            const colDefNoType = colDef as any; // take out the type, so we can access attributes not defined in the type\n            if (colDefNoType.group !== undefined) {\n                console.warn('ag-grid: colDef.group is invalid, please check documentation on how to do grouping as it changed in version 3');\n            }\n            if (colDefNoType.headerGroup !== undefined) {\n                console.warn('ag-grid: colDef.headerGroup is invalid, please check documentation on how to do grouping as it changed in version 3');\n            }\n            if (colDefNoType.headerGroupShow !== undefined) {\n                console.warn('ag-grid: colDef.headerGroupShow is invalid, should be columnGroupShow, please check documentation on how to do grouping as it changed in version 3');\n            }\n\n            if (colDefNoType.suppressRowGroup !== undefined) {\n                console.warn('ag-grid: colDef.suppressRowGroup is deprecated, please use colDef.type instead');\n            }\n            if (colDefNoType.suppressAggregation !== undefined) {\n                console.warn('ag-grid: colDef.suppressAggregation is deprecated, please use colDef.type instead');\n            }\n\n            if (colDefNoType.suppressRowGroup || colDefNoType.suppressAggregation) {\n                console.warn('ag-grid: colDef.suppressAggregation and colDef.suppressRowGroup are deprecated, use allowRowGroup, allowPivot and allowValue instead');\n            }\n\n            if (colDefNoType.displayName) {\n                console.warn(\"ag-grid: Found displayName \" + colDefNoType.displayName + \", please use headerName instead, displayName is deprecated.\");\n                colDefNoType.headerName = colDefNoType.displayName;\n            }\n        }\n    }\n\n    // if object has children, we assume it's a group\n    private isColumnGroup(abstractColDef: ColDef | ColGroupDef): boolean {\n        return (abstractColDef as ColGroupDef).children !== undefined;\n    }\n}\n"]}