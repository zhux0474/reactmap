{"version":3,"sources":["../../src/ts/columns/displayedGroupCreator.ts"],"names":[],"mappings":"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","file":"displayedGroupCreator.js","sourcesContent":["import { Column } from \"../entities/column\";\nimport { IProvidedColumn } from \"../entities/iProvidedColumn\";\nimport { GroupInstanceIdCreator } from \"./groupInstanceIdCreator\";\nimport { IHeaderColumn } from \"../entities/iHeaderColumn\";\nimport { ColumnGroup } from \"../entities/columnGroup\";\nimport { ProvidedColumnGroup } from \"../entities/providedColumnGroup\";\nimport { Bean } from \"../context/context\";\nimport { BeanStub } from \"../context/beanStub\";\nimport { last } from \"../utils/array\";\nimport { exists } from \"../utils/generic\";\n\n// takes in a list of columns, as specified by the column definitions, and returns column groups\n@Bean('displayedGroupCreator')\nexport class DisplayedGroupCreator extends BeanStub {\n\n    public createDisplayedGroups(\n        // all displayed columns sorted - this is the columns the grid should show\n        sortedVisibleColumns: Column[],\n        // the tree of columns, as provided by the users, used to know what groups columns roll up into\n        balancedColumnTree: IProvidedColumn[],\n        // creates unique id's for the group\n        groupInstanceIdCreator: GroupInstanceIdCreator,\n        // whether it's left, right or center col\n        pinned: 'left' | 'right' | null,\n        // we try to reuse old groups if we can, to allow gui to do animation\n        oldDisplayedGroups?: IHeaderColumn[]): IHeaderColumn[] {\n\n        const result: IHeaderColumn[] = [];\n\n        let previousRealPath: ColumnGroup[];\n        let previousOriginalPath: ProvidedColumnGroup[];\n\n        const oldColumnsMapped = this.mapOldGroupsById(oldDisplayedGroups!);\n\n        // go through each column, then do a bottom up comparison to the previous column, and start\n        // to share groups if they converge at any point.\n        sortedVisibleColumns.forEach((currentColumn: Column) => {\n\n            const currentOriginalPath = this.getOriginalPathForColumn(balancedColumnTree, currentColumn)!;\n            const currentRealPath: ColumnGroup[] = [];\n            const firstColumn = !previousOriginalPath;\n\n            for (let i = 0; i < currentOriginalPath.length; i++) {\n                if (firstColumn || currentOriginalPath[i] !== previousOriginalPath[i]) {\n                    // new group needed\n                    const newGroup = this.createColumnGroup(\n                        currentOriginalPath[i],\n                        groupInstanceIdCreator,\n                        oldColumnsMapped,\n                        pinned);\n\n                    currentRealPath[i] = newGroup;\n                    // if top level, add to result, otherwise add to parent\n                    if (i == 0) {\n                        result.push(newGroup);\n                    } else {\n                        currentRealPath[i - 1].addChild(newGroup);\n                    }\n                } else {\n                    // reuse old group\n                    currentRealPath[i] = previousRealPath[i];\n                }\n            }\n\n            const noColumnGroups = currentRealPath.length === 0;\n            if (noColumnGroups) {\n                // if we are not grouping, then the result of the above is an empty\n                // path (no groups), and we just add the column to the root list.\n                result.push(currentColumn);\n            } else {\n                const leafGroup = last(currentRealPath);\n                leafGroup.addChild(currentColumn);\n            }\n\n            previousRealPath = currentRealPath;\n            previousOriginalPath = currentOriginalPath;\n        });\n\n        this.setupParentsIntoColumns(result, null);\n\n        return result;\n    }\n\n    private createColumnGroup(\n            originalGroup: ProvidedColumnGroup,\n            groupInstanceIdCreator: GroupInstanceIdCreator,\n            oldColumnsMapped: {[key: string]: ColumnGroup},\n            pinned: 'left' | 'right' | null\n        ): ColumnGroup {\n\n        const groupId = originalGroup.getGroupId();\n        const instanceId = groupInstanceIdCreator.getInstanceIdForKey(groupId);\n        const uniqueId = ColumnGroup.createUniqueId(groupId, instanceId);\n\n        let columnGroup: ColumnGroup | null = oldColumnsMapped[uniqueId];\n\n        // if the user is setting new colDefs, it is possible that the id's overlap, and we\n        // would have a false match from above. so we double check we are talking about the\n        // same original column group.\n        if (columnGroup && columnGroup.getOriginalColumnGroup() !== originalGroup) {\n            columnGroup = null;\n        }\n\n        if (exists(columnGroup)) {\n            // clean out the old column group here, as we will be adding children into it again\n            columnGroup.reset();\n        } else {\n            columnGroup = new ColumnGroup(originalGroup, groupId, instanceId, pinned);\n            this.context.createBean(columnGroup);\n        }\n\n        return columnGroup;\n    }\n\n    // returns back a 2d map of ColumnGroup as follows: groupId -> instanceId -> ColumnGroup\n    private mapOldGroupsById(displayedGroups: IHeaderColumn[]): {[uniqueId: string]: ColumnGroup} {\n        const result: {[uniqueId: string]: ColumnGroup} = {};\n\n        const recursive = (columnsOrGroups: IHeaderColumn[] | null) => {\n            columnsOrGroups!.forEach(columnOrGroup => {\n                if (columnOrGroup instanceof ColumnGroup) {\n                    const columnGroup = columnOrGroup;\n                    result[columnOrGroup.getUniqueId()] = columnGroup;\n                    recursive(columnGroup.getChildren());\n                }\n            });\n        };\n\n        if (displayedGroups) {\n            recursive(displayedGroups);\n        }\n\n        return result;\n    }\n\n    private setupParentsIntoColumns(columnsOrGroups: IHeaderColumn[] | null, parent: ColumnGroup | null): void {\n        columnsOrGroups!.forEach(columnsOrGroup => {\n            columnsOrGroup.setParent(parent);\n            if (columnsOrGroup instanceof ColumnGroup) {\n                const columnGroup = columnsOrGroup;\n                this.setupParentsIntoColumns(columnGroup.getChildren(), columnGroup);\n            }\n        });\n    }\n\n    private getOriginalPathForColumn(balancedColumnTree: IProvidedColumn[], column: Column): ProvidedColumnGroup[] | null {\n        const result: ProvidedColumnGroup[] = [];\n        let found = false;\n\n        const recursePath = (columnTree: IProvidedColumn[], dept: number): void => {\n            for (let i = 0; i < columnTree.length; i++) {\n                // quit the search, so 'result' is kept with the found result\n                if (found) { return; }\n\n                const node = columnTree[i];\n\n                if (node instanceof ProvidedColumnGroup) {\n                    const nextNode = node;\n                    recursePath(nextNode.getChildren(), dept + 1);\n                    result[dept] = node;\n                } else if (node === column) {\n                    found = true;\n                }\n            }\n        };\n\n        recursePath(balancedColumnTree, 0);\n\n        // it's possible we didn't find a path. this happens if the column is generated\n        // by the grid (auto-group), in that the definition didn't come from the client. in this case,\n        // we create a fake original path.\n        if (found) { return result; }\n\n        console.warn('could not get path');\n\n        return null;\n    }\n}\n"]}