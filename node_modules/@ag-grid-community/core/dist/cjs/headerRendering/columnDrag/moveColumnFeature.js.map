{"version":3,"sources":["../../src/ts/headerRendering/columnDrag/moveColumnFeature.ts"],"names":[],"mappings":"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","file":"moveColumnFeature.js","sourcesContent":["import { Autowired, PostConstruct } from \"../../context/context\";\nimport { Constants } from \"../../constants/constants\";\nimport { ColumnModel } from \"../../columns/columnModel\";\nimport { Column } from \"../../entities/column\";\nimport { DragAndDropService, DraggingEvent, DragSourceType, HorizontalDirection } from \"../../dragAndDrop/dragAndDropService\";\nimport { DropListener } from \"./bodyDropTarget\";\nimport { GridOptionsWrapper } from \"../../gridOptionsWrapper\";\nimport { Logger, LoggerFactory } from \"../../logger\";\nimport { ColumnEventType } from \"../../events\";\nimport { missing, exists } from \"../../utils/generic\";\nimport { sortNumerically, last, includes } from \"../../utils/array\";\nimport { CtrlsService } from \"../../ctrlsService\";\nimport { GridBodyCtrl } from \"../../gridBodyComp/gridBodyCtrl\";\n\nexport class MoveColumnFeature implements DropListener {\n\n    @Autowired('columnModel') private columnModel: ColumnModel;\n    @Autowired('dragAndDropService') private dragAndDropService: DragAndDropService;\n    @Autowired('gridOptionsWrapper') private gridOptionsWrapper: GridOptionsWrapper;\n    @Autowired('ctrlsService') public ctrlsService: CtrlsService;\n\n    private gridBodyCon: GridBodyCtrl;\n\n    private needToMoveLeft = false;\n    private needToMoveRight = false;\n    private movingIntervalId: number | null;\n    private intervalCount: number;\n\n    private pinned: string | null;\n    private centerContainer: boolean;\n\n    private lastDraggingEvent: DraggingEvent;\n\n    // this counts how long the user has been trying to scroll by dragging and failing,\n    // if they fail x amount of times, then the column will get pinned. this is what gives\n    // the 'hold and pin' functionality\n    private failedMoveAttempts: number;\n\n    private eContainer: HTMLElement;\n\n    constructor(pinned: string | null, eContainer: HTMLElement) {\n        this.pinned = pinned;\n        this.eContainer = eContainer;\n        this.centerContainer = !exists(pinned);\n    }\n\n    @PostConstruct\n    public init(): void {\n        this.ctrlsService.whenReady(() => {\n            this.gridBodyCon = this.ctrlsService.getGridBodyCtrl();\n        });\n    }\n\n    public getIconName(): string {\n        return this.pinned ? DragAndDropService.ICON_PINNED : DragAndDropService.ICON_MOVE;\n    }\n\n    public onDragEnter(draggingEvent: DraggingEvent): void {\n        // we do dummy drag, so make sure column appears in the right location when first placed\n\n        const columns = draggingEvent.dragItem.columns;\n        const dragCameFromToolPanel = draggingEvent.dragSource.type === DragSourceType.ToolPanel;\n\n        if (dragCameFromToolPanel) {\n            // the if statement doesn't work if drag leaves grid, then enters again\n            this.setColumnsVisible(columns, true, \"uiColumnDragged\");\n        } else {\n            // restore previous state of visible columns upon re-entering. this means if the user drags\n            // a group out, and then drags the group back in, only columns that were originally visible\n            // will be visible again. otherwise a group with three columns (but only two visible) could\n            // be dragged out, then when it's dragged in again, all three are visible. this stops that.\n            const visibleState = draggingEvent.dragItem.visibleState;\n            const visibleColumns: Column[] = (columns || []).filter(column => visibleState![column.getId()]);\n            this.setColumnsVisible(visibleColumns, true, \"uiColumnDragged\");\n        }\n\n        this.setColumnsPinned(columns, this.pinned, \"uiColumnDragged\");\n        this.onDragging(draggingEvent, true);\n    }\n\n    public onDragLeave(draggingEvent: DraggingEvent): void {\n        const hideColumnOnExit = !this.gridOptionsWrapper.isSuppressDragLeaveHidesColumns() && !draggingEvent.fromNudge;\n\n        if (hideColumnOnExit) {\n            const dragItem = draggingEvent.dragSource.getDragItem();\n            const columns = dragItem.columns;\n            this.setColumnsVisible(columns, false, \"uiColumnDragged\");\n        }\n\n        this.ensureIntervalCleared();\n    }\n\n    public setColumnsVisible(columns: Column[] | null | undefined, visible: boolean, source: ColumnEventType = \"api\") {\n        if (columns) {\n            const allowedCols = columns.filter(c => !c.getColDef().lockVisible);\n            this.columnModel.setColumnsVisible(allowedCols, visible, source);\n        }\n    }\n\n    public setColumnsPinned(columns: Column[] | null | undefined, pinned: string | null, source: ColumnEventType = \"api\") {\n        if (columns) {\n            const allowedCols = columns.filter(c => !c.getColDef().lockPinned);\n            this.columnModel.setColumnsPinned(allowedCols, pinned, source);\n        }\n    }\n\n    public onDragStop(): void {\n        this.ensureIntervalCleared();\n    }\n\n    private normaliseX(x: number): number {\n        // flip the coordinate if doing RTL\n        if (this.gridOptionsWrapper.isEnableRtl()) {\n            const clientWidth = this.eContainer.clientWidth;\n            x = clientWidth - x;\n        }\n\n        // adjust for scroll only if centre container (the pinned containers don't scroll)\n        if (this.centerContainer) {\n            x += this.ctrlsService.getCenterRowContainerCtrl().getCenterViewportScrollLeft();\n        }\n\n        return x;\n    }\n\n    private checkCenterForScrolling(xAdjustedForScroll: number): void {\n        if (this.centerContainer) {\n            // scroll if the mouse has gone outside the grid (or just outside the scrollable part if pinning)\n            // putting in 50 buffer, so even if user gets to edge of grid, a scroll will happen\n            const firstVisiblePixel = this.ctrlsService.getCenterRowContainerCtrl().getCenterViewportScrollLeft();\n            const lastVisiblePixel = firstVisiblePixel + this.ctrlsService.getCenterRowContainerCtrl().getCenterWidth();\n\n            if (this.gridOptionsWrapper.isEnableRtl()) {\n                this.needToMoveRight = xAdjustedForScroll < (firstVisiblePixel + 50);\n                this.needToMoveLeft = xAdjustedForScroll > (lastVisiblePixel - 50);\n            } else {\n                this.needToMoveLeft = xAdjustedForScroll < (firstVisiblePixel + 50);\n                this.needToMoveRight = xAdjustedForScroll > (lastVisiblePixel - 50);\n            }\n\n            if (this.needToMoveLeft || this.needToMoveRight) {\n                this.ensureIntervalStarted();\n            } else {\n                this.ensureIntervalCleared();\n            }\n        }\n    }\n\n    public onDragging(draggingEvent: DraggingEvent, fromEnter = false): void {\n\n        this.lastDraggingEvent = draggingEvent;\n\n        // if moving up or down (ie not left or right) then do nothing\n        if (missing(draggingEvent.hDirection)) {\n            return;\n        }\n\n        const mouseXNormalised = this.normaliseX(draggingEvent.x);\n\n        // if the user is dragging into the panel, ie coming from the side panel into the main grid,\n        // we don't want to scroll the grid this time, it would appear like the table is jumping\n        // each time a column is dragged in.\n        if (!fromEnter) {\n            this.checkCenterForScrolling(mouseXNormalised);\n        }\n\n        const hDirectionNormalised = this.normaliseDirection(draggingEvent.hDirection);\n\n        const dragSourceType: DragSourceType = draggingEvent.dragSource.type;\n        let columnsToMove = draggingEvent.dragSource.getDragItem().columns;\n\n        columnsToMove = columnsToMove!.filter(col => {\n            if (col.getColDef().lockPinned) {\n                // if locked return true only if both col and container are same pin type.\n                // double equals (==) here on purpose so that null==undefined is true (for not pinned options)\n                return col.getPinned() == this.pinned;\n            }\n            // if not pin locked, then always allowed to be in this container\n            return true;\n        });\n\n        this.attemptMoveColumns(dragSourceType, columnsToMove, hDirectionNormalised, mouseXNormalised, fromEnter);\n    }\n\n    private normaliseDirection(hDirection: HorizontalDirection): HorizontalDirection | undefined {\n        if (this.gridOptionsWrapper.isEnableRtl()) {\n            switch (hDirection) {\n                case HorizontalDirection.Left: return HorizontalDirection.Right;\n                case HorizontalDirection.Right: return HorizontalDirection.Left;\n                default: console.error(`AG Grid: Unknown direction ${hDirection}`);\n            }\n        } else {\n            return hDirection;\n        }\n    }\n\n    // returns the index of the first column in the list ONLY if the cols are all beside\n    // each other. if the cols are not beside each other, then returns null\n    private calculateOldIndex(movingCols: Column[]): number | null {\n        const gridCols: Column[] = this.columnModel.getAllGridColumns();\n        const indexes = sortNumerically(movingCols.map(col => gridCols.indexOf(col)));\n        const firstIndex = indexes[0];\n        const lastIndex = last(indexes);\n        const spread = lastIndex - firstIndex;\n        const gapsExist = spread !== indexes.length - 1;\n\n        return gapsExist ? null : firstIndex;\n    }\n\n    private attemptMoveColumns(dragSourceType: DragSourceType, allMovingColumns: Column[], hDirection: HorizontalDirection | undefined, mouseX: number, fromEnter: boolean): void {\n        const draggingLeft = hDirection === HorizontalDirection.Left;\n        const draggingRight = hDirection === HorizontalDirection.Right;\n\n        // it is important to sort the moving columns as they are in grid columns, as the list of moving columns\n        // could themselves be part of 'married children' groups, which means we need to maintain the order within\n        // the moving list.\n        const allMovingColumnsOrdered = allMovingColumns.slice();\n        this.columnModel.sortColumnsLikeGridColumns(allMovingColumnsOrdered);\n\n        const validMoves = this.calculateValidMoves(allMovingColumnsOrdered, draggingRight, mouseX);\n\n        // if cols are not adjacent, then this returns null. when moving, we constrain the direction of the move\n        // (ie left or right) to the mouse direction. however\n        const oldIndex = this.calculateOldIndex(allMovingColumnsOrdered);\n\n        if (validMoves.length === 0) { return; }\n\n        const firstValidMove = validMoves[0];\n\n        // the two check below stop an error when the user grabs a group my a middle column, then\n        // it is possible the mouse pointer is to the right of a column while been dragged left.\n        // so we need to make sure that the mouse pointer is actually left of the left most column\n        // if moving left, and right of the right most column if moving right\n\n        // we check 'fromEnter' below so we move the column to the new spot if the mouse is coming from\n        // outside the grid, eg if the column is moving from side panel, mouse is moving left, then we should\n        // place the column to the RHS even if the mouse is moving left and the column is already on\n        // the LHS. otherwise we stick to the rule described above.\n\n        let constrainDirection = oldIndex !== null && !fromEnter;\n\n        // don't consider 'fromEnter' when dragging header cells, otherwise group can jump to opposite direction of drag\n        if (dragSourceType == DragSourceType.HeaderCell) {\n            constrainDirection = oldIndex !== null;\n        }\n\n        if (constrainDirection) {\n            // only allow left drag if this column is moving left\n            if (draggingLeft && firstValidMove >= (oldIndex as number)) { return; }\n\n            // only allow right drag if this column is moving right\n            if (draggingRight && firstValidMove <= (oldIndex as number)) { return; }\n        }\n\n        for (let i = 0; i < validMoves.length; i++) {\n            const move: number = validMoves[i];\n\n            if (!this.columnModel.doesMovePassRules(allMovingColumnsOrdered, move)) {\n                continue;\n            }\n\n            this.columnModel.moveColumns(allMovingColumnsOrdered, move, \"uiColumnDragged\");\n\n            // important to return here, so once we do the first valid move, we don't try do any more\n            return;\n        }\n    }\n\n    private calculateValidMoves(movingCols: Column[], draggingRight: boolean, mouseX: number): number[] {\n        const isMoveBlocked = this.gridOptionsWrapper.isSuppressMovableColumns() || movingCols.some(col => col.getColDef().suppressMovable);\n\n        if (isMoveBlocked) { return []; }\n        // this is the list of cols on the screen, so it's these we use when comparing the x mouse position\n        const allDisplayedCols = this.columnModel.getDisplayedColumns(this.pinned);\n        // but this list is the list of all cols, when we move a col it's the index within this list that gets used,\n        // so the result we return has to be and index location for this list\n        const allGridCols = this.columnModel.getAllGridColumns();\n\n        const movingDisplayedCols = allDisplayedCols.filter(col => includes(movingCols, col));\n        const otherDisplayedCols = allDisplayedCols.filter(col => !includes(movingCols, col));\n        const otherGridCols = allGridCols.filter(col => !includes(movingCols, col));\n\n        // work out how many DISPLAYED columns fit before the 'x' position. this gives us the displayIndex.\n        // for example, if cols are a,b,c,d and we find a,b fit before 'x', then we want to place the moving\n        // col between b and c (so that it is under the mouse position).\n        let displayIndex = 0;\n        let availableWidth = mouseX;\n\n        // if we are dragging right, then the columns will be to the left of the mouse, so we also want to\n        // include the width of the moving columns\n        if (draggingRight) {\n            let widthOfMovingDisplayedCols = 0;\n            movingDisplayedCols.forEach(col => widthOfMovingDisplayedCols += col.getActualWidth());\n            availableWidth -= widthOfMovingDisplayedCols;\n        }\n\n        if (availableWidth > 0) {\n            // now count how many of the displayed columns will fit to the left\n            for (let i = 0; i < otherDisplayedCols.length; i++) {\n                const col = otherDisplayedCols[i];\n                availableWidth -= col.getActualWidth();\n                if (availableWidth < 0) { break; }\n                displayIndex++;\n            }\n            // trial and error, if going right, we adjust by one, i didn't manage to quantify why, but it works\n            if (draggingRight) {\n                displayIndex++;\n            }\n        }\n\n        // the display index is with respect to all the showing columns, however when we move, it's with\n        // respect to all grid columns, so we need to translate from display index to grid index\n\n        let firstValidMove: number;\n        if (displayIndex > 0) {\n            const leftColumn = otherDisplayedCols[displayIndex - 1];\n            firstValidMove = otherGridCols.indexOf(leftColumn) + 1;\n        } else {\n            firstValidMove = otherGridCols.indexOf(otherDisplayedCols[0]);\n            if (firstValidMove === -1) {\n                firstValidMove = 0;\n            }\n        }\n\n        const validMoves = [firstValidMove];\n        const numberComparator = (a: number, b:number) => a - b;\n\n        // add in other valid moves due to hidden columns and married children. for example, a particular\n        // move might break a group that has married children (so move isn't valid), however there could\n        // be hidden columns (not displayed) that we could jump over to make the move valid. because\n        // they are hidden, user doesn't see any different, however it allows moves that would otherwise\n        // not work. for example imagine a group with 9 columns and all columns are hidden except the\n        // middle one (so 4 hidden to left, 4 hidden to right), then when moving 'firstValidMove' will\n        // be relative to the not-shown column, however we need to consider the move jumping over all the\n        // hidden children. if we didn't do this, then if the group just described was at the end (RHS) of the\n        // grid, there would be no way to put a column after it (as the grid would only consider beside the\n        // visible column, which would fail valid move rules).\n        if (draggingRight) {\n            // if dragging right, then we add all the additional moves to the right. so in other words\n            // if the next move is not valid, find the next move to the right that is valid.\n            let pointer = firstValidMove + 1;\n            const lastIndex = allGridCols.length - 1;\n            while (pointer <= lastIndex) {\n                validMoves.push(pointer);\n                pointer++;\n            }\n\n            // adding columns here means the order is now messed up\n            validMoves.sort(numberComparator);\n        } else {\n            // if dragging left we do the reverse of dragging right, we add in all the valid moves to the\n            // left. however we also have to consider moves to the right for all hidden columns first.\n            // (this logic is hard to reason with, it was worked out with trial and error,\n            // more observation rather than science).\n\n            // add moves to the right\n            let pointer = firstValidMove;\n            const lastIndex = allGridCols.length - 1;\n            let displacedCol = allGridCols[pointer];\n            while (pointer <= lastIndex && this.isColumnHidden(allDisplayedCols, displacedCol)) {\n                pointer++;\n                validMoves.push(pointer);\n                displacedCol = allGridCols[pointer];\n            }\n\n            // add moves to the left\n            pointer = firstValidMove - 1;\n            const firstDisplayIndex = 0;\n            while (pointer >= firstDisplayIndex) {\n                validMoves.push(pointer);\n                pointer--;\n            }\n\n            // adding columns here means the order is now messed up\n            validMoves.sort(numberComparator).reverse();\n        }\n\n        return validMoves;\n    }\n\n    // isHidden takes into account visible=false and group=closed, ie it is not displayed\n    private isColumnHidden(displayedColumns: Column[], col: Column) {\n        return displayedColumns.indexOf(col) < 0;\n    }\n\n    private ensureIntervalStarted(): void {\n        if (!this.movingIntervalId) {\n            this.intervalCount = 0;\n            this.failedMoveAttempts = 0;\n            this.movingIntervalId = window.setInterval(this.moveInterval.bind(this), 100);\n            if (this.needToMoveLeft) {\n                this.dragAndDropService.setGhostIcon(DragAndDropService.ICON_LEFT, true);\n            } else {\n                this.dragAndDropService.setGhostIcon(DragAndDropService.ICON_RIGHT, true);\n            }\n        }\n    }\n\n    private ensureIntervalCleared(): void {\n        if (this.movingIntervalId) {\n            window.clearInterval(this.movingIntervalId);\n            this.movingIntervalId = null;\n            this.dragAndDropService.setGhostIcon(DragAndDropService.ICON_MOVE);\n        }\n    }\n\n    private moveInterval(): void {\n        // the amounts we move get bigger at each interval, so the speed accelerates, starting a bit slow\n        // and getting faster. this is to give smoother user experience. we max at 100px to limit the speed.\n        let pixelsToMove: number;\n        this.intervalCount++;\n        pixelsToMove = 10 + (this.intervalCount * 5);\n        if (pixelsToMove > 100) {\n            pixelsToMove = 100;\n        }\n\n        let pixelsMoved: number | null = null;\n        const scrollFeature = this.gridBodyCon.getScrollFeature();\n        if (this.needToMoveLeft) {\n            pixelsMoved = scrollFeature.scrollHorizontally(-pixelsToMove);\n        } else if (this.needToMoveRight) {\n            pixelsMoved = scrollFeature.scrollHorizontally(pixelsToMove);\n        }\n\n        if (pixelsMoved !== 0) {\n            this.onDragging(this.lastDraggingEvent);\n            this.failedMoveAttempts = 0;\n        } else {\n            // we count the failed move attempts. if we fail to move 7 times, then we pin the column.\n            // this is how we achieve pining by dragging the column to the edge of the grid.\n            this.failedMoveAttempts++;\n\n            const columns = this.lastDraggingEvent.dragItem.columns;\n            const columnsThatCanPin = columns!.filter(c => !c.getColDef().lockPinned);\n\n            if (columnsThatCanPin.length > 0) {\n                this.dragAndDropService.setGhostIcon(DragAndDropService.ICON_PINNED);\n                if (this.failedMoveAttempts > 7) {\n                    const pinType = this.needToMoveLeft ? Constants.PINNED_LEFT : Constants.PINNED_RIGHT;\n                    this.setColumnsPinned(columnsThatCanPin, pinType, \"uiColumnDragged\");\n                    this.dragAndDropService.nudge();\n                }\n            }\n        }\n    }\n}"]}