{"version":3,"sources":["../../src/ts/headerRendering/common/headerPosition.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,mDAAkD;AAClD,iDAAwD;AAGxD,0DAAyD;AACzD,sDAAqD;AAUrD;IAAyC,uCAAQ;IAAjD;;IAmDA,CAAC;IA9CU,wCAAU,GAAjB,UAAkB,aAA6B,EAAE,SAA6B;QAC1E,IAAI,UAAgC,CAAC;QACrC,IAAI,cAAoE,CAAC;QACzE,IAAI,YAA8D,CAAC;QAEnE,IAAI,aAAa,CAAC,MAAM,YAAY,yBAAW,EAAE;YAC7C,cAAc,GAAG,sBAAoB,SAAkB,CAAC;YACxD,UAAU,GAAG,IAAI,CAAC,WAAW,CAAC,cAAc,CAAC,CAAC,aAAa,CAAC,MAAM,CAAE,CAAC;SACxE;aAAM;YACH,YAAY,GAAG,oBAAkB,SAAkB,CAAC;YACpD,UAAU,GAAG,IAAI,CAAC,WAAW,CAAC,YAAY,CAAC,CAAC,aAAa,CAAC,MAAM,CAAE,CAAC;SACtE;QAED,IAAI,UAAU,EAAE;YACZ,OAAO;gBACH,MAAM,EAAE,UAAU;gBAClB,cAAc,EAAE,aAAa,CAAC,cAAc;aAC/C,CAAC;SACL;IACL,CAAC;IAEM,uDAAyB,GAAhC,UAAiC,KAAa,EAAE,QAAyB;QACrE,IAAM,gBAAgB,GAAG,IAAI,CAAC,WAAW,CAAC,sBAAsB,EAAE,CAAC;QACnE,IAAM,MAAM,GAAG,gBAAgB,CAAC,QAAQ,KAAK,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,gBAAgB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QAExF,IAAI,CAAC,MAAM,EAAE;YAAE,OAAO;SAAE;QAExB,IAAM,cAAc,GAAG,IAAI,CAAC,YAAY,CAAC,yBAAyB,CAAC,MAAM,CAAC,SAAS,EAAE,CAAC,CAAC;QACvF,IAAM,IAAI,GAAG,cAAc,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;QAE9C,OAAO,CAAC,GAAG,CAAC,WAAS,KAAK,gBAAW,IAAM,CAAC,CAAC;QAE7C,IAAI,IAAI,IAAI,6BAAa,CAAC,YAAY,EAAE;YACpC,IAAM,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC,qBAAqB,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;YAC1E,OAAO;gBACH,cAAc,EAAE,KAAK;gBACrB,MAAM,EAAE,WAAY;aACvB,CAAC;SACL;QAED,OAAO;YACH,qDAAqD;YACrD,cAAc,EAAE,IAAI,IAAE,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK;YACvC,MAAM,QAAA;SACT,CAAC;IACN,CAAC;IAhDyB;QAAzB,mBAAS,CAAC,aAAa,CAAC;4DAAkC;IAChC;QAA1B,mBAAS,CAAC,cAAc,CAAC;6DAAoC;IAHrD,mBAAmB;QAD/B,cAAI,CAAC,qBAAqB,CAAC;OACf,mBAAmB,CAmD/B;IAAD,0BAAC;CAnDD,AAmDC,CAnDwC,mBAAQ,GAmDhD;AAnDY,kDAAmB","file":"headerPosition.js","sourcesContent":["import { ColumnModel } from \"../../columns/columnModel\";\nimport { BeanStub } from \"../../context/beanStub\";\nimport { Autowired, Bean } from \"../../context/context\";\nimport { CtrlsService } from \"../../ctrlsService\";\nimport { Column } from \"../../entities/column\";\nimport { ColumnGroup } from \"../../entities/columnGroup\";\nimport { HeaderRowType } from \"../row/headerRowComp\";\n\nexport interface HeaderPosition {\n/** A number from 0 to n, where n is the last header row the grid is rendering */\n    headerRowIndex: number;\n/** The grid column or column group */\n    column: Column | ColumnGroup;\n}\n\n@Bean('headerPositionUtils')\nexport class HeaderPositionUtils extends BeanStub {\n\n    @Autowired('columnModel') private columnModel: ColumnModel;\n    @Autowired('ctrlsService') private ctrlsService: CtrlsService;\n\n    public findHeader(focusedHeader: HeaderPosition, direction: 'Before' | 'After'): HeaderPosition | undefined {\n        let nextColumn: Column | ColumnGroup;\n        let getGroupMethod: 'getDisplayedGroupBefore' | 'getDisplayedGroupAfter';\n        let getColMethod: 'getDisplayedColBefore' | 'getDisplayedColAfter';\n\n        if (focusedHeader.column instanceof ColumnGroup) {\n            getGroupMethod = `getDisplayedGroup${direction}` as any;\n            nextColumn = this.columnModel[getGroupMethod](focusedHeader.column)!;\n        } else {\n            getColMethod = `getDisplayedCol${direction}` as any;\n            nextColumn = this.columnModel[getColMethod](focusedHeader.column)!;\n        }\n\n        if (nextColumn) {\n            return {\n                column: nextColumn,\n                headerRowIndex: focusedHeader.headerRowIndex\n            };\n        }\n    }\n\n    public findColAtEdgeForHeaderRow(level: number, position: 'start' | 'end'): HeaderPosition | undefined {\n        const displayedColumns = this.columnModel.getAllDisplayedColumns();\n        const column = displayedColumns[position === 'start' ? 0 : displayedColumns.length - 1];\n\n        if (!column) { return; }\n\n        const childContainer = this.ctrlsService.getHeaderRowContainerCtrl(column.getPinned());\n        const type = childContainer.getRowType(level);\n\n        console.log(`level=${level} type = ${type}`);\n\n        if (type == HeaderRowType.COLUMN_GROUP) {\n            const columnGroup = this.columnModel.getColumnGroupAtLevel(column, level);\n            return {\n                headerRowIndex: level,\n                column: columnGroup!\n            };\n        }\n\n        return {\n            // if type==null, means the header level didn't exist\n            headerRowIndex: type==null ? -1 : level,\n            column\n        };\n    }\n}\n"]}