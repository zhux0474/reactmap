{"version":3,"sources":["../../src/ts/components/framework/frameworkComponentWrapper.ts"],"names":[],"mappings":";;;;;;;;AA0BA;IAAA;IA0CA,CAAC;IAzCU,mCAAI,GAAX,UAAuC,mBAAmC,EAC1C,mBAA6B,EAC7B,kBAAiC,EACjC,aAA4B,EAC5B,aAAsB;QAJtD,iBAiBC;QAf+B,mCAAA,EAAA,uBAAiC;QAG7D,IAAM,OAAO,GAAM,IAAI,CAAC,aAAa,CAAC,mBAAmB,EAAE,aAAa,EAAE,aAAa,CAAC,CAAC;QAEzF,mBAAmB,CAAC,OAAO,CAAC,CAAC,UAAA,UAAU;YACnC,KAAI,CAAC,YAAY,CAAC,OAAO,EAAE,UAAU,EAAE,IAAI,CAAC,CAAC;QACjD,CAAC,CAAC,CAAC,CAAC;QAEJ,kBAAkB,CAAC,OAAO,CAAC,CAAC,UAAA,UAAU;YAClC,KAAI,CAAC,YAAY,CAAC,OAAO,EAAE,UAAU,EAAE,KAAK,CAAC,CAAC;QAClD,CAAC,CAAC,CAAC,CAAC;QAEJ,OAAO,OAAmB,CAAC;IAE/B,CAAC;IAEM,qCAAM,GAAb,UAAc,IAAS;QACnB,OAAO,IAAI,CAAC;IAChB,CAAC;IAIO,2CAAY,GAApB,UAAqB,OAAU,EAAE,UAAkB,EAAE,SAAkB;QACnE,OAAO,CAAC,SAAS,CAAC,UAAU,EAAE,IAAI,CAAC,iBAAiB,CAAC,OAAO,EAAE,UAAU,EAAE,SAAS,CAAC,CAAC,CAAC;IAC1F,CAAC;IAES,gDAAiB,GAA3B,UAA4B,OAAU,EAAE,UAAkB,EAAE,SAAkB;QAC1E,OAAO;YACH,IAAI,OAAO,CAAC,SAAS,CAAC,UAAU,CAAC,EAAE;gBAC/B,OAAO,OAAO,CAAC,UAAU,CAAC,UAAU,EAAE,SAAS,CAAC,CAAC;aACpD;YAED,IAAI,SAAS,EAAE;gBACX,OAAO,CAAC,IAAI,CAAC,qDAAqD,GAAG,UAAU,GAAG,IAAI,CAAC,CAAC;aAC3F;YACD,OAAO,IAAI,CAAC;QAChB,CAAC,CAAC;IACN,CAAC;IACL,2BAAC;AAAD,CA1CA,AA0CC,IAAA;AA1CqB,oDAAoB","file":"frameworkComponentWrapper.js","sourcesContent":["import { IComponent } from \"../../interfaces/iComponent\";\nimport { ComponentType } from \"./componentTypes\";\n\n/**\n * B the business interface (ie IHeader)\n * A the agGridComponent interface (ie IHeaderComp). The final object acceptable by ag-grid\n */\nexport interface FrameworkComponentWrapper {\n    wrap<A extends IComponent<any>>(frameworkComponent: { new(): any } | null,\n                                    methodList: string[],\n                                    optionalMethodList: string[],\n                                    componentType: ComponentType,\n                                    componentName?: string | null\n    ): A;\n\n    unwrap(comp: any): any;\n}\n\nexport interface WrappableInterface {\n    hasMethod(name: string): boolean;\n\n    callMethod(name: string, args: IArguments): void;\n\n    addMethod(name: string, callback: Function): void;\n}\n\nexport abstract class BaseComponentWrapper<F extends WrappableInterface> implements FrameworkComponentWrapper {\n    public wrap<A extends IComponent<any>>(OriginalConstructor: { new(): any },\n                                    mandatoryMethodList: string[],\n                                    optionalMethodList: string[] = [],\n                                    componentType: ComponentType,\n                                    componentName?: string): A {\n        const wrapper: F = this.createWrapper(OriginalConstructor, componentType, componentName);\n\n        mandatoryMethodList.forEach((methodName => {\n            this.createMethod(wrapper, methodName, true);\n        }));\n\n        optionalMethodList.forEach((methodName => {\n            this.createMethod(wrapper, methodName, false);\n        }));\n\n        return wrapper as any as A;\n\n    }\n\n    public unwrap(comp: any): any {\n        return comp;\n    }\n\n    abstract createWrapper(OriginalConstructor: { new(): any }, componentType: ComponentType, componentName?: string): F;\n\n    private createMethod(wrapper: F, methodName: string, mandatory: boolean): void {\n        wrapper.addMethod(methodName, this.createMethodProxy(wrapper, methodName, mandatory));\n    }\n\n    protected createMethodProxy(wrapper: F, methodName: string, mandatory: boolean): Function {\n        return function() {\n            if (wrapper.hasMethod(methodName)) {\n                return wrapper.callMethod(methodName, arguments);\n            }\n\n            if (mandatory) {\n                console.warn('AG Grid: Framework component is missing the method ' + methodName + '()');\n            }\n            return null;\n        };\n    }\n}\n"]}