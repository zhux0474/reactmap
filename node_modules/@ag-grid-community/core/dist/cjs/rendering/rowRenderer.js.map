{"version":3,"sources":["../../src/ts/rendering/rowRenderer.ts"],"names":[],"mappings":"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","file":"rowRenderer.js","sourcesContent":["import { GridOptionsWrapper } from \"../gridOptionsWrapper\";\nimport { RowCtrl } from \"./row/rowCtrl\";\nimport { Column } from \"../entities/column\";\nimport { RowNode } from \"../entities/rowNode\";\nimport {\n    CellFocusedEvent,\n    DisplayedRowsChangedEvent,\n    Events,\n    FirstDataRenderedEvent,\n    ModelUpdatedEvent,\n    ViewportChangedEvent\n} from \"../events\";\nimport { Constants } from \"../constants/constants\";\nimport { Autowired, Bean, Optional, PostConstruct, Qualifier } from \"../context/context\";\nimport { ColumnApi } from \"../columns/columnApi\";\nimport { ColumnModel } from \"../columns/columnModel\";\nimport { FocusService } from \"../focusService\";\nimport { CellPosition } from \"../entities/cellPosition\";\nimport { BeanStub } from \"../context/beanStub\";\nimport { PaginationProxy } from \"../pagination/paginationProxy\";\nimport { FlashCellsParams, GetCellRendererInstancesParams, GridApi, RefreshCellsParams } from \"../gridApi\";\nimport { Beans } from \"./beans\";\nimport { RowContainerHeightService } from \"./rowContainerHeightService\";\nimport { ICellRenderer } from \"./cellRenderers/iCellRenderer\";\nimport { ICellEditor } from \"../interfaces/iCellEditor\";\nimport { IRowModel } from \"../interfaces/iRowModel\";\nimport { RowPosition } from \"../entities/rowPosition\";\nimport { PinnedRowModel } from \"../pinnedRowModel/pinnedRowModel\";\nimport { exists, missing } from \"../utils/generic\";\nimport { getAllValuesInObject, iterateObject } from \"../utils/object\";\nimport { createArrayOfNumbers } from \"../utils/number\";\nimport { executeInAWhile } from \"../utils/function\";\nimport { CtrlsService } from \"../ctrlsService\";\nimport { GridBodyCtrl } from \"../gridBodyComp/gridBodyCtrl\";\nimport { CellCtrl } from \"./cell/cellCtrl\";\nimport { removeFromArray } from \"../utils/array\";\n\nexport interface RowCtrlMap {\n    [key: string]: RowCtrl;\n}\n\n@Bean(\"rowRenderer\")\nexport class RowRenderer extends BeanStub {\n\n    @Autowired(\"paginationProxy\") private paginationProxy: PaginationProxy;\n    @Autowired(\"columnModel\") private columnModel: ColumnModel;\n    @Autowired(\"$scope\") private $scope: any;\n    @Autowired(\"pinnedRowModel\") private pinnedRowModel: PinnedRowModel;\n    @Autowired(\"rowModel\") private rowModel: IRowModel;\n    @Autowired(\"focusService\") private focusService: FocusService;\n    @Autowired(\"columnApi\") private columnApi: ColumnApi;\n    @Autowired(\"gridApi\") private gridApi: GridApi;\n    @Autowired(\"beans\") private beans: Beans;\n    @Autowired(\"rowContainerHeightService\") private rowContainerHeightService: RowContainerHeightService;\n    @Optional(\"ctrlsService\") private ctrlsService: CtrlsService;\n\n    private gridBodyCtrl: GridBodyCtrl;\n\n    private destroyFuncsForColumnListeners: (() => void)[] = [];\n\n    private firstRenderedRow: number;\n    private lastRenderedRow: number;\n\n    // map of row ids to row objects. keeps track of which elements\n    // are rendered for which rows in the dom.\n    private rowCtrlsByRowIndex: RowCtrlMap = {};\n    private zombieRowCtrls: RowCtrlMap = {};\n    private cachedRowCtrls: RowCtrlCache;\n    private allRowCtrls: RowCtrl[] = [];\n\n    private topRowCtrls: RowCtrl[] = [];\n    private bottomRowCtrls: RowCtrl[] = [];\n\n    private pinningLeft: boolean;\n    private pinningRight: boolean;\n\n    // we only allow one refresh at a time, otherwise the internal memory structure here\n    // will get messed up. this can happen if the user has a cellRenderer, and inside the\n    // renderer they call an API method that results in another pass of the refresh,\n    // then it will be trying to draw rows in the middle of a refresh.\n    private refreshInProgress = false;\n\n    private printLayout: boolean;\n    private embedFullWidthRows: boolean;\n\n    @PostConstruct\n    private postConstruct(): void {\n        this.ctrlsService.whenReady(() => {\n            this.gridBodyCtrl = this.ctrlsService.getGridBodyCtrl();\n            this.initialise();\n        });\n    }\n\n    private initialise(): void {\n        this.addManagedListener(this.eventService, Events.EVENT_PAGINATION_CHANGED, this.onPageLoaded.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_PINNED_ROW_DATA_CHANGED, this.onPinnedRowDataChanged.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_BODY_SCROLL, this.redrawAfterScroll.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_BODY_HEIGHT_CHANGED, this.redrawAfterScroll.bind(this));\n        this.addManagedListener(this.gridOptionsWrapper, GridOptionsWrapper.PROP_DOM_LAYOUT, this.onDomLayoutChanged.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, this.onNewColumnsLoaded.bind(this));\n\n        this.registerCellEventListeners();\n\n        this.initialiseCache();\n        this.printLayout = this.gridOptionsWrapper.getDomLayout() === Constants.DOM_LAYOUT_PRINT;\n        this.embedFullWidthRows = this.printLayout || this.gridOptionsWrapper.isEmbedFullWidthRows();\n\n        this.redrawAfterModelUpdate();\n    }\n\n    private initialiseCache(): void {\n        if (this.gridOptionsWrapper.isKeepDetailRows()) {\n            const countProp = this.gridOptionsWrapper.getKeepDetailRowsCount();\n            const count = countProp != null ? countProp : 3;\n            this.cachedRowCtrls = new RowCtrlCache(count);\n        }\n    }\n\n    public getRowCtrls(): RowCtrl[] {\n        return this.allRowCtrls;\n    }\n\n    private updateAllRowCtrls(): void {\n        const liveList = getAllValuesInObject(this.rowCtrlsByRowIndex);\n        if (this.beans.gridOptionsWrapper.isEnsureDomOrder()) {\n            liveList.sort( (a,b) => a.getRowNode().rowIndex - b.getRowNode.rowIndex );\n        }\n        const zombieList = getAllValuesInObject(this.zombieRowCtrls);\n        const cachedList = this.cachedRowCtrls ? this.cachedRowCtrls.getEntries() : [];\n        this.allRowCtrls = [...liveList, ...zombieList, ...cachedList];\n    }\n\n    // in a clean design, each cell would register for each of these events. however when scrolling, all the cells\n    // registering and de-registering for events is a performance bottleneck. so we register here once and inform\n    // all active cells.\n    private registerCellEventListeners(): void {\n        this.addManagedListener(this.eventService, Events.EVENT_CELL_FOCUSED, (event: CellFocusedEvent) => {\n            this.getAllCellCtrls().forEach(cellCtrl => cellCtrl.onCellFocused(event));\n            this.getAllRowCtrls().forEach(rowCtrl => {\n                if (rowCtrl.isFullWidth()) {\n                    rowCtrl.onFullWidthRowFocused(event);\n                }\n            });\n        });\n\n        this.addManagedListener(this.eventService, Events.EVENT_FLASH_CELLS, event => {\n            this.getAllCellCtrls().forEach(cellCtrl => cellCtrl.onFlashCells(event));\n        });\n\n        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_HOVER_CHANGED, () => {\n            this.getAllCellCtrls().forEach(cellCtrl => cellCtrl.onColumnHover());\n        });\n\n        // only for printLayout - because we are rendering all the cells in the same row, regardless of pinned state,\n        // then changing the width of the containers will impact left position. eg the center cols all have their\n        // left position adjusted by the width of the left pinned column, so if the pinned left column width changes,\n        // all the center cols need to be shifted to accommodate this. when in normal layout, the pinned cols are\n        // in different containers so doesn't impact.\n        this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, () => {\n            if (this.printLayout) {\n                this.getAllCellCtrls().forEach(cellCtrl => cellCtrl.onLeftChanged());\n            }\n        });\n\n        const rangeSelectionEnabled = this.gridOptionsWrapper.isEnableRangeSelection();\n        if (rangeSelectionEnabled) {\n\n            this.addManagedListener(this.eventService, Events.EVENT_RANGE_SELECTION_CHANGED, () => {\n                this.getAllCellCtrls().forEach(cellCtrl => cellCtrl.onRangeSelectionChanged());\n            });\n            this.addManagedListener(this.eventService, Events.EVENT_COLUMN_MOVED, () => {\n                this.getAllCellCtrls().forEach(cellCtrl => cellCtrl.updateRangeBordersIfRangeCount());\n            });\n            this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PINNED, () => {\n                this.getAllCellCtrls().forEach(cellCtrl => cellCtrl.updateRangeBordersIfRangeCount());\n            });\n            this.addManagedListener(this.eventService, Events.EVENT_COLUMN_VISIBLE, () => {\n                this.getAllCellCtrls().forEach(cellCtrl => cellCtrl.updateRangeBordersIfRangeCount());\n            });\n\n        }\n\n        // add listeners to the grid columns\n        this.refreshListenersToColumnsForCellComps();\n        // if the grid columns change, then refresh the listeners again\n        this.addManagedListener(this.eventService, Events.EVENT_GRID_COLUMNS_CHANGED, this.refreshListenersToColumnsForCellComps.bind(this));\n\n        this.addDestroyFunc(this.removeGridColumnListeners.bind(this));\n    }\n\n    // executes all functions in destroyFuncsForColumnListeners and then clears the list\n    private removeGridColumnListeners(): void {\n        this.destroyFuncsForColumnListeners.forEach(func => func());\n        this.destroyFuncsForColumnListeners.length = 0;\n    }\n\n    // this function adds listeners onto all the grid columns, which are the column that we could have cellComps for.\n    // when the grid columns change, we add listeners again. in an ideal design, each CellComp would just register to\n    // the column it belongs to on creation, however this was a bottleneck with the number of cells, so do it here\n    // once instead.\n    private refreshListenersToColumnsForCellComps(): void {\n        this.removeGridColumnListeners();\n\n        const cols = this.columnModel.getAllGridColumns();\n\n        if (!cols) { return; }\n\n        cols.forEach(col => {\n            const forEachCellWithThisCol = (callback: (cellCtrl: CellCtrl) => void) => {\n                this.getAllCellCtrls().forEach(cellCtrl => {\n                    if (cellCtrl.getColumn() === col) {\n                        callback(cellCtrl);\n                    }\n                });\n            };\n\n            const leftChangedListener = () => {\n                forEachCellWithThisCol(cellCtrl => cellCtrl.onLeftChanged());\n            };\n            const widthChangedListener = () => {\n                forEachCellWithThisCol(cellCtrl => cellCtrl.onWidthChanged());\n            };\n            const firstRightPinnedChangedListener = () => {\n                forEachCellWithThisCol(cellCtrl => cellCtrl.onFirstRightPinnedChanged());\n            };\n            const lastLeftPinnedChangedListener = () => {\n                forEachCellWithThisCol(cellCtrl => cellCtrl.onLastLeftPinnedChanged());\n            };\n\n            col.addEventListener(Column.EVENT_LEFT_CHANGED, leftChangedListener);\n            col.addEventListener(Column.EVENT_WIDTH_CHANGED, widthChangedListener);\n            col.addEventListener(Column.EVENT_FIRST_RIGHT_PINNED_CHANGED, firstRightPinnedChangedListener);\n            col.addEventListener(Column.EVENT_LAST_LEFT_PINNED_CHANGED, lastLeftPinnedChangedListener);\n\n            this.destroyFuncsForColumnListeners.push(() => {\n                col.removeEventListener(Column.EVENT_LEFT_CHANGED, leftChangedListener);\n                col.removeEventListener(Column.EVENT_WIDTH_CHANGED, widthChangedListener);\n                col.removeEventListener(Column.EVENT_FIRST_RIGHT_PINNED_CHANGED, firstRightPinnedChangedListener);\n                col.removeEventListener(Column.EVENT_LAST_LEFT_PINNED_CHANGED, lastLeftPinnedChangedListener);\n            });\n        });\n\n    }\n\n    private onDomLayoutChanged(): void {\n        const printLayout = this.gridOptionsWrapper.getDomLayout() === Constants.DOM_LAYOUT_PRINT;\n        const embedFullWidthRows = printLayout || this.gridOptionsWrapper.isEmbedFullWidthRows();\n\n        // if moving towards or away from print layout, means we need to destroy all rows, as rows are not laid\n        // out using absolute positioning when doing print layout\n        const destroyRows = embedFullWidthRows !== this.embedFullWidthRows || this.printLayout !== printLayout;\n\n        this.printLayout = printLayout;\n        this.embedFullWidthRows = embedFullWidthRows;\n\n        if (destroyRows) {\n            this.redrawAfterModelUpdate();\n        }\n    }\n\n    // for row models that have datasources, when we update the datasource, we need to force the rowRenderer\n    // to redraw all rows. otherwise the old rows from the old datasource will stay displayed.\n    public datasourceChanged(): void {\n        this.firstRenderedRow = 0;\n        this.lastRenderedRow = -1;\n        const rowIndexesToRemove = Object.keys(this.rowCtrlsByRowIndex);\n        this.removeRowCtrls(rowIndexesToRemove);\n    }\n\n    private onPageLoaded(event: ModelUpdatedEvent): void {\n        const params: RefreshViewParams = {\n            recycleRows: event.keepRenderedRows,\n            animate: event.animate,\n            newData: event.newData,\n            newPage: event.newPage,\n            // because this is a model updated event (not pinned rows), we\n            // can skip updating the pinned rows. this is needed so that if user\n            // is doing transaction updates, the pinned rows are not getting constantly\n            // trashed - or editing cells in pinned rows are not refreshed and put into read mode\n            onlyBody: true\n        };\n        this.redrawAfterModelUpdate(params);\n    }\n\n    public getAllCellsForColumn(column: Column): HTMLElement[] {\n        const res: HTMLElement[] = [];\n\n        this.getAllRowCtrls().forEach(rowCtrl => {\n            const eCell = rowCtrl.getCellElement(column);\n            if (eCell) { res.push(eCell); }\n        });\n\n        return res;\n    }\n\n    public refreshFloatingRowComps(): void {\n        this.refreshFloatingRows(\n            this.topRowCtrls,\n            this.pinnedRowModel.getPinnedTopRowData()\n        );\n\n        this.refreshFloatingRows(\n            this.bottomRowCtrls,\n            this.pinnedRowModel.getPinnedBottomRowData()\n        );\n    }\n\n    public getTopRowCtrls(): RowCtrl[] {\n        return this.topRowCtrls;\n    }\n\n    public getBottomRowCtrls(): RowCtrl[] {\n        return this.bottomRowCtrls;\n    }\n\n    private refreshFloatingRows(rowComps: RowCtrl[], rowNodes: RowNode[]): void {\n        rowComps.forEach((row: RowCtrl) => {\n            row.destroyFirstPass();\n            row.destroySecondPass();\n        });\n\n        rowComps.length = 0;\n\n        if (!rowNodes) { return; }\n\n        rowNodes.forEach(rowNode => {\n            const rowCon = new RowCtrl(\n                this.$scope,\n                rowNode,\n                this.beans,\n                false,\n                false,\n                this.printLayout\n            );\n\n            rowComps.push(rowCon);\n        });\n    }\n\n    private onPinnedRowDataChanged(): void {\n        // recycling rows in order to ensure cell editing is not cancelled\n        const params: RefreshViewParams = {\n            recycleRows: true\n        };\n\n        this.redrawAfterModelUpdate(params);\n    }\n\n    // if the row nodes are not rendered, no index is returned\n    private getRenderedIndexesForRowNodes(rowNodes: RowNode[]): string[] {\n        const result: string[] = [];\n\n        if (missing(rowNodes)) { return result; }\n\n        iterateObject(this.rowCtrlsByRowIndex, (index: string, renderedRow: RowCtrl) => {\n            const rowNode = renderedRow.getRowNode();\n            if (rowNodes.indexOf(rowNode) >= 0) {\n                result.push(index);\n            }\n        });\n\n        return result;\n    }\n\n    public redrawRows(rowNodes?: RowNode[]): void {\n        // if no row nodes provided, then refresh everything\n        const partialRefresh = rowNodes != null && rowNodes.length > 0;\n\n        if (partialRefresh) {\n            const indexesToRemove = this.getRenderedIndexesForRowNodes(rowNodes!);\n            // remove the rows\n            this.removeRowCtrls(indexesToRemove);\n        }\n\n        // add draw them again\n        this.redrawAfterModelUpdate({\n            recycleRows: partialRefresh\n        });\n    }\n\n    private getCellToRestoreFocusToAfterRefresh(params: RefreshViewParams): CellPosition | null {\n        const focusedCell = params.suppressKeepFocus ? null : this.focusService.getFocusCellToUseAfterRefresh();\n\n        if (focusedCell == null) { return null; }\n\n        // if the dom is not actually focused on a cell, then we don't try to refocus. the problem this\n        // solves is with editing - if the user is editing, eg focus is on a text field, and not on the\n        // cell itself, then the cell can be registered as having focus, however it's the text field that\n        // has the focus and not the cell div. therefore, when the refresh is finished, the grid will focus\n        // the cell, and not the textfield. that means if the user is in a text field, and the grid refreshes,\n        // the focus is lost from the text field. we do not want this.\n        const activeElement = document.activeElement;\n        const cellDomData = this.gridOptionsWrapper.getDomData(activeElement, CellCtrl.DOM_DATA_KEY_CELL_CTRL);\n        const rowDomData = this.gridOptionsWrapper.getDomData(activeElement, RowCtrl.DOM_DATA_KEY_ROW_CTRL);\n\n        const gridElementFocused = cellDomData || rowDomData;\n\n        return gridElementFocused ? focusedCell : null;\n    }\n\n    // gets called from:\n    // +) initialisation (in registerGridComp) params = null\n    // +) onDomLayoutChanged, params = null\n    // +) onPageLoaded, recycleRows, animate, newData, newPage from event, onlyBody=true\n    // +) onPinnedRowDataChanged, recycleRows = true\n    // +) redrawRows (from Grid API), recycleRows = true/false\n    private redrawAfterModelUpdate(params: RefreshViewParams = {}): void {\n        this.getLockOnRefresh();\n\n        const focusedCell: CellPosition | null = this.getCellToRestoreFocusToAfterRefresh(params);\n\n        this.updateContainerHeights();\n        this.scrollToTopIfNewData(params);\n\n        // never recycle rows when print layout, we draw each row again from scratch. this is because print layout\n        // uses normal dom layout to put cells into dom - it doesn't allow reordering rows.\n        const recycleRows = !this.printLayout && !!params.recycleRows;\n        const animate = params.animate && this.gridOptionsWrapper.isAnimateRows();\n\n        // after modelUpdate, row indexes can change, so we clear out the rowsByIndex map,\n        // however we can reuse the rows, so we keep them but index by rowNode.id\n        const rowsToRecycle = recycleRows ? this.recycleRows() : null;\n        if (!recycleRows) {\n            this.removeAllRowComps();\n        }\n\n        const isFocusedCellGettingRecycled = () => {\n            if (focusedCell == null || rowsToRecycle == null) { return false; }\n            let res = false;\n\n            iterateObject(rowsToRecycle, (key: string, rowComp: RowCtrl) => {\n                const rowNode = rowComp.getRowNode();\n                const rowIndexEqual = rowNode.rowIndex == focusedCell.rowIndex;\n                const pinnedEqual = rowNode.rowPinned == focusedCell.rowPinned;\n                if (rowIndexEqual && pinnedEqual) {\n                    res = true;\n                }\n            });\n\n            return res;\n        };\n\n        const focusedCellRecycled = isFocusedCellGettingRecycled();\n\n        this.redraw(rowsToRecycle, animate);\n\n        if (!params.onlyBody) {\n            this.refreshFloatingRowComps();\n        }\n\n        this.dispatchDisplayedRowsChanged();\n\n        // if we focus a cell that's already focused, then we get an unnecessary 'cellFocused' event fired.\n        // this was happening when user clicked 'expand' on a rowGroup, then cellFocused was getting fired twice.\n        if (!focusedCellRecycled) {\n            this.restoreFocusedCell(focusedCell);\n        }\n\n        this.releaseLockOnRefresh();\n    }\n\n    private scrollToTopIfNewData(params: RefreshViewParams): void {\n        const scrollToTop = params.newData || params.newPage;\n        const suppressScrollToTop = this.gridOptionsWrapper.isSuppressScrollOnNewData();\n\n        if (scrollToTop && !suppressScrollToTop) {\n            this.gridBodyCtrl.getScrollFeature().scrollToTop();\n        }\n    }\n\n    private updateContainerHeights(): void {\n        // when doing print layout, we don't explicitly set height on the containers\n        if (this.printLayout) {\n            this.rowContainerHeightService.setModelHeight(null);\n            return;\n        }\n\n        let containerHeight = this.paginationProxy.getCurrentPageHeight();\n        // we need at least 1 pixel for the horizontal scroll to work. so if there are now rows,\n        // we still want the scroll to be present, otherwise there would be no way to scroll the header\n        // which might be needed us user wants to access columns\n        // on the RHS - and if that was where the filter was that cause no rows to be presented, there\n        // is no way to remove the filter.\n        if (containerHeight === 0) {\n            containerHeight = 1;\n        }\n\n        this.rowContainerHeightService.setModelHeight(containerHeight);\n    }\n\n    private getLockOnRefresh(): void {\n        if (this.refreshInProgress) {\n            throw new Error(\n                \"AG Grid: cannot get grid to draw rows when it is in the middle of drawing rows. \" +\n                \"Your code probably called a grid API method while the grid was in the render stage. To overcome \" +\n                \"this, put the API call into a timeout, e.g. instead of api.refreshView(), \" +\n                \"call setTimeout(function() { api.refreshView(); }, 0). To see what part of your code \" +\n                \"that caused the refresh check this stacktrace.\"\n            );\n        }\n\n        this.refreshInProgress = true;\n    }\n\n    private releaseLockOnRefresh(): void {\n        this.refreshInProgress = false;\n    }\n\n    // sets the focus to the provided cell, if the cell is provided. this way, the user can call refresh without\n    // worry about the focus been lost. this is important when the user is using keyboard navigation to do edits\n    // and the cellEditor is calling 'refresh' to get other cells to update (as other cells might depend on the\n    // edited cell).\n    private restoreFocusedCell(cellPosition: CellPosition | null): void {\n        if (cellPosition) {\n            this.focusService.setFocusedCell(cellPosition.rowIndex, cellPosition.column, cellPosition.rowPinned, true);\n        }\n    }\n\n    public stopEditing(cancel: boolean = false) {\n        this.getAllRowCtrls().forEach(rowCtrl => {\n            rowCtrl.stopEditing(cancel);\n        });\n    }\n\n    private onNewColumnsLoaded(): void {\n        // we don't want each cellComp to register for events, as would increase rendering time.\n        // so for newColumnsLoaded, we register once here (in rowRenderer) and then inform\n        // each cell if / when event was fired.\n        this.getAllCellCtrls().forEach(cellCtrl => cellCtrl.onNewColumnsLoaded());\n    }\n\n    public getAllCellCtrls(): CellCtrl[] {\n        let res: CellCtrl[] = [];\n        this.getAllRowCtrls().forEach(rowCtrl => res = res.concat(rowCtrl.getAllCellCtrls()));\n        return res;\n    }\n\n    private getAllRowCtrls(): RowCtrl[] {\n        const res = [...this.topRowCtrls, ...this.bottomRowCtrls];\n        Object.keys(this.rowCtrlsByRowIndex).forEach(key => res.push(this.rowCtrlsByRowIndex[key]));\n        return res;\n    }\n\n    public addRenderedRowListener(eventName: string, rowIndex: number, callback: Function): void {\n        const rowComp = this.rowCtrlsByRowIndex[rowIndex];\n        if (rowComp) {\n            rowComp.addEventListener(eventName, callback);\n        }\n    }\n\n    public flashCells(params: FlashCellsParams = {}): void {\n        const { flashDelay, fadeDelay } = params;\n        this.getCellCtrls(params.rowNodes, params.columns)\n            .forEach(cellCtrl => cellCtrl.flashCell({ flashDelay, fadeDelay }));\n    }\n\n    public refreshCells(params: RefreshCellsParams = {}): void {\n        const refreshCellParams = {\n            forceRefresh: params.force,\n            newData: false,\n            suppressFlash: params.suppressFlash\n        };\n        this.getCellCtrls(params.rowNodes, params.columns)\n            .forEach(cellCtrl => {\n                if (cellCtrl.refreshShouldDestroy()) {\n                    const rowCtrl = cellCtrl.getRowCtrl();\n                    if (rowCtrl) {\n                        rowCtrl.refreshCell(cellCtrl);\n                    }\n                } else {\n                    cellCtrl.refreshCell(refreshCellParams);\n                }\n            });\n    }\n\n    public getCellRendererInstances(params: GetCellRendererInstancesParams): ICellRenderer[] {\n        const res = this.getCellCtrls(params.rowNodes, params.columns)\n            .map(cellCtrl => cellCtrl.getCellRenderer())\n            .filter(renderer => renderer != null) as ICellRenderer[];\n        return res;\n    }\n\n    public getCellEditorInstances(params: GetCellRendererInstancesParams): ICellEditor[] {\n\n        const res: ICellEditor[] = [];\n\n        this.getCellCtrls(params.rowNodes, params.columns).forEach(cellCtrl => {\n            const cellEditor = cellCtrl.getCellEditor() as ICellEditor;\n\n            if (cellEditor) {\n                res.push(cellEditor);\n            }\n        });\n\n        return res;\n    }\n\n    public getEditingCells(): CellPosition[] {\n        const res: CellPosition[] = [];\n\n        this.getAllCellCtrls().forEach(cellCtrl => {\n            if (cellCtrl.isEditing()) {\n                const cellPosition = cellCtrl.getCellPosition();\n                res.push(cellPosition);\n            }\n        });\n\n        return res;\n    }\n\n    // returns CellCtrl's that match the provided rowNodes and columns. eg if one row node\n    // and two columns provided, that identifies 4 cells, so 4 CellCtrl's returned.\n    private getCellCtrls(rowNodes?: RowNode[] | null, columns?: (string | Column)[]): CellCtrl[] {\n        let rowIdsMap: any;\n\n        const res: CellCtrl[] = [];\n\n        if (exists(rowNodes)) {\n            rowIdsMap = {\n                top: {},\n                bottom: {},\n                normal: {}\n            };\n\n            rowNodes.forEach(rowNode => {\n                const id = rowNode.id!;\n                if (rowNode.rowPinned === Constants.PINNED_TOP) {\n                    rowIdsMap.top[id] = true;\n                } else if (rowNode.rowPinned === Constants.PINNED_BOTTOM) {\n                    rowIdsMap.bottom[id] = true;\n                } else {\n                    rowIdsMap.normal[id] = true;\n                }\n            });\n        }\n\n        let colIdsMap: any;\n\n        if (exists(columns)) {\n            colIdsMap = {};\n            columns.forEach((colKey: string | Column) => {\n                const column: Column | null = this.columnModel.getGridColumn(colKey);\n                if (exists(column)) {\n                    colIdsMap[column.getId()] = true;\n                }\n            });\n        }\n\n        const processRow = (rowComp: RowCtrl) => {\n            const rowNode: RowNode = rowComp.getRowNode();\n            const id = rowNode.id!;\n            const floating = rowNode.rowPinned;\n\n            // skip this row if it is missing from the provided list\n            if (exists(rowIdsMap)) {\n                if (floating === Constants.PINNED_BOTTOM) {\n                    if (!rowIdsMap.bottom[id]) {\n                        return;\n                    }\n                } else if (floating === Constants.PINNED_TOP) {\n                    if (!rowIdsMap.top[id]) {\n                        return;\n                    }\n                } else {\n                    if (!rowIdsMap.normal[id]) {\n                        return;\n                    }\n                }\n            }\n\n            rowComp.getAllCellCtrls().forEach(cellCtrl => {\n                const colId: string = cellCtrl.getColumn().getId();\n                const excludeColFromRefresh = colIdsMap && !colIdsMap[colId];\n\n                if (excludeColFromRefresh) { return; }\n\n                res.push(cellCtrl);\n            });\n        };\n\n        iterateObject(this.rowCtrlsByRowIndex, (index: string, rowComp: RowCtrl) => {\n            processRow(rowComp);\n        });\n\n        if (this.topRowCtrls) {\n            this.topRowCtrls.forEach(processRow);\n        }\n\n        if (this.bottomRowCtrls) {\n            this.bottomRowCtrls.forEach(processRow);\n        }\n\n        return res;\n    }\n\n    protected destroy(): void {\n        this.removeAllRowComps();\n        super.destroy();\n    }\n\n    private removeAllRowComps(): void {\n        const rowIndexesToRemove = Object.keys(this.rowCtrlsByRowIndex);\n        this.removeRowCtrls(rowIndexesToRemove);\n    }\n\n    private recycleRows(): RowCtrlMap {\n        // remove all stub nodes, they can't be reused, as no rowNode id\n        const stubNodeIndexes: string[] = [];\n        iterateObject(this.rowCtrlsByRowIndex, (index: string, rowComp: RowCtrl) => {\n            const stubNode = rowComp.getRowNode().id == null;\n            if (stubNode) {\n                stubNodeIndexes.push(index);\n            }\n        });\n        this.removeRowCtrls(stubNodeIndexes);\n\n        // then clear out rowCompsByIndex, but before that take a copy, but index by id, not rowIndex\n        const nodesByIdMap: RowCtrlMap = {};\n        iterateObject(this.rowCtrlsByRowIndex, (index: string, rowComp: RowCtrl) => {\n            const rowNode = rowComp.getRowNode();\n            nodesByIdMap[rowNode.id!] = rowComp;\n        });\n        this.rowCtrlsByRowIndex = {};\n\n        return nodesByIdMap;\n    }\n\n    // takes array of row indexes\n    private removeRowCtrls(rowsToRemove: any[]) {\n        // if no fromIndex then set to -1, which will refresh everything\n        // let realFromIndex = -1;\n        rowsToRemove.forEach(indexToRemove => {\n            const rowCtrl = this.rowCtrlsByRowIndex[indexToRemove];\n            if (rowCtrl) {\n                rowCtrl.destroyFirstPass();\n                rowCtrl.destroySecondPass();\n            }\n            delete this.rowCtrlsByRowIndex[indexToRemove];\n        });\n    }\n\n    // gets called when rows don't change, but viewport does, so after:\n    // 1) height of grid body changes, ie number of displayed rows has changed\n    // 2) grid scrolled to new position\n    // 3) ensure index visible (which is a scroll)\n    public redrawAfterScroll() {\n        this.getLockOnRefresh();\n        this.redraw(null, false, true);\n        this.releaseLockOnRefresh();\n        this.dispatchDisplayedRowsChanged();\n    }\n\n    private removeRowCompsNotToDraw(indexesToDraw: number[]): void {\n        // for speedy lookup, dump into map\n        const indexesToDrawMap: { [index: string]: boolean; } = {};\n        indexesToDraw.forEach(index => (indexesToDrawMap[index] = true));\n\n        const existingIndexes = Object.keys(this.rowCtrlsByRowIndex);\n        const indexesNotToDraw: string[] = existingIndexes.filter(index => !indexesToDrawMap[index]);\n\n        this.removeRowCtrls(indexesNotToDraw);\n    }\n\n    private calculateIndexesToDraw(rowsToRecycle?: { [key: string]: RowCtrl; } | null): number[] {\n        // all in all indexes in the viewport\n        const indexesToDraw = createArrayOfNumbers(this.firstRenderedRow, this.lastRenderedRow);\n\n        const checkRowToDraw = (indexStr: string, rowComp: RowCtrl) => {\n            const index = rowComp.getRowNode().rowIndex;\n            if (index == null) { return; }\n            if (index < this.firstRenderedRow || index > this.lastRenderedRow) {\n                if (this.doNotUnVirtualiseRow(rowComp)) {\n                    indexesToDraw.push(index);\n                }\n            }\n        };\n\n        // if we are redrawing due to scrolling change, then old rows are in this.rowCompsByIndex\n        iterateObject(this.rowCtrlsByRowIndex, checkRowToDraw);\n\n        // if we are redrawing due to model update, then old rows are in rowsToRecycle\n        iterateObject(rowsToRecycle, checkRowToDraw);\n\n        indexesToDraw.sort((a: number, b: number) => a - b);\n\n        return indexesToDraw;\n    }\n\n    private redraw(rowsToRecycle?: { [key: string]: RowCtrl; } | null, animate = false, afterScroll = false) {\n        this.rowContainerHeightService.updateOffset();\n        this.workOutFirstAndLastRowsToRender();\n\n        // the row can already exist and be in the following:\n        // rowsToRecycle -> if model change, then the index may be different, however row may\n        //                         exist here from previous time (mapped by id).\n        // this.rowCompsByIndex -> if just a scroll, then this will contain what is currently in the viewport\n\n        // this is all the indexes we want, including those that already exist, so this method\n        // will end up going through each index and drawing only if the row doesn't already exist\n        const indexesToDraw = this.calculateIndexesToDraw(rowsToRecycle);\n\n        this.removeRowCompsNotToDraw(indexesToDraw);\n\n        // never animate when doing print layout - as we want to get things ready to print as quickly as possible,\n        // otherwise we risk the printer printing a row that's half faded (half way through fading in)\n        if (this.printLayout) {\n            animate = false;\n        }\n\n        // add in new rows\n        const rowCtrls: RowCtrl[] = [];\n\n        indexesToDraw.forEach(rowIndex => {\n            const rowCtrl = this.createOrUpdateRowCtrl(rowIndex, rowsToRecycle, animate, afterScroll);\n            if (exists(rowCtrl)) {\n                rowCtrls.push(rowCtrl);\n            }\n        });\n\n        if (rowsToRecycle) {\n            const useAnimationFrame = afterScroll && !this.gridOptionsWrapper.isSuppressAnimationFrame() && !this.printLayout;\n            if (useAnimationFrame) {\n                this.beans.animationFrameService.addDestroyTask(() => {\n                    this.destroyRowCtrls(rowsToRecycle, animate);\n                    this.updateAllRowCtrls();\n                    this.dispatchDisplayedRowsChanged();\n                });\n            } else {\n                this.destroyRowCtrls(rowsToRecycle, animate);\n            }\n        }\n\n        this.updateAllRowCtrls();\n        this.checkAngularCompile();\n        this.gridBodyCtrl.updateRowCount();\n    }\n\n    private dispatchDisplayedRowsChanged(): void {\n        const event: DisplayedRowsChangedEvent = {type: Events.EVENT_DISPLAYED_ROWS_CHANGED};\n        this.eventService.dispatchEvent(event);\n    }\n\n    private onDisplayedColumnsChanged(): void {\n        const pinningLeft = this.columnModel.isPinningLeft();\n        const pinningRight = this.columnModel.isPinningRight();\n        const atLeastOneChanged = this.pinningLeft !== pinningLeft || pinningRight !== this.pinningRight;\n\n        if (atLeastOneChanged) {\n            this.pinningLeft = pinningLeft;\n            this.pinningRight = pinningRight;\n\n            if (this.embedFullWidthRows) {\n                this.redrawFullWidthEmbeddedRows();\n            }\n        }\n    }\n\n    // when embedding, what gets showed in each section depends on what is pinned. eg if embedding group expand / collapse,\n    // then it should go into the pinned left area if pinning left, or the center area if not pinning.\n    private redrawFullWidthEmbeddedRows(): void {\n        // if either of the pinned panels has shown / hidden, then need to redraw the fullWidth bits when\n        // embedded, as what appears in each section depends on whether we are pinned or not\n        const rowsToRemove: string[] = [];\n\n        iterateObject(this.rowCtrlsByRowIndex, (id: string, rowComp: RowCtrl) => {\n            if (rowComp.isFullWidth()) {\n                const rowIndex = rowComp.getRowNode().rowIndex;\n\n                rowsToRemove.push(rowIndex!.toString());\n            }\n        });\n\n        this.refreshFloatingRowComps();\n        this.removeRowCtrls(rowsToRemove);\n        this.redrawAfterScroll();\n    }\n\n    public refreshFullWidthRows(rowNodesToRefresh?: RowNode[]): void {\n        const rowsToRemove: string[] = [];\n\n        const selectivelyRefreshing = !!rowNodesToRefresh;\n        const idsToRefresh: { [id: string]: boolean; } | undefined = selectivelyRefreshing ? {} : undefined;\n\n        if (selectivelyRefreshing && idsToRefresh) {\n            rowNodesToRefresh!.forEach(r => idsToRefresh[r.id!] = true);\n        }\n\n        iterateObject(this.rowCtrlsByRowIndex, (id: string, rowCtrl: RowCtrl) => {\n            if (!rowCtrl.isFullWidth()) { return; }\n\n            const rowNode = rowCtrl.getRowNode();\n\n            if (selectivelyRefreshing && idsToRefresh) {\n                // we refresh if a) this node is present or b) this parents nodes is present. checking parent\n                // node is important for master/detail, as we want detail to refresh on changes to parent node.\n                // it's also possible, if user is provider their own fullWidth, that details panels contain\n                // some info on the parent, eg if in tree data and child row shows some data from parent row also.\n                const parentId = (rowNode.level > 0 && rowNode.parent) ? rowNode.parent.id : undefined;\n                const skipThisNode = !idsToRefresh[rowNode.id!] && !idsToRefresh[parentId!];\n                if (skipThisNode) { return; }\n            }\n\n            const fullWidthRowsRefreshed = rowCtrl.refreshFullWidth();\n            if (!fullWidthRowsRefreshed) {\n                const rowIndex = rowCtrl.getRowNode().rowIndex;\n\n                rowsToRemove.push(rowIndex!.toString());\n            }\n        });\n\n        this.removeRowCtrls(rowsToRemove);\n        this.redrawAfterScroll();\n    }\n\n    private createOrUpdateRowCtrl(\n        rowIndex: number,\n        rowsToRecycle: { [key: string]: RowCtrl | null; } | null | undefined,\n        animate: boolean,\n        afterScroll: boolean\n    ): RowCtrl | null | undefined {\n        let rowNode: RowNode | undefined;\n        let rowCon: RowCtrl | null = this.rowCtrlsByRowIndex[rowIndex];\n\n        // if no row comp, see if we can get it from the previous rowComps\n        if (!rowCon) {\n            rowNode = this.paginationProxy.getRow(rowIndex);\n            if (exists(rowNode) && exists(rowsToRecycle) && rowsToRecycle[rowNode.id!] && rowNode.alreadyRendered) {\n                rowCon = rowsToRecycle[rowNode.id!];\n                rowsToRecycle[rowNode.id!] = null;\n            }\n        }\n\n        const creatingNewRowCon = !rowCon;\n\n        if (creatingNewRowCon) {\n            // create a new one\n            if (!rowNode) {\n                rowNode = this.paginationProxy.getRow(rowIndex);\n            }\n\n            if (exists(rowNode)) {\n                rowCon = this.createRowCon(rowNode, animate, afterScroll);\n            } else {\n                // this should never happen - if somehow we are trying to create\n                // a row for a rowNode that does not exist.\n                return;\n            }\n        }\n\n        if (rowNode) {\n            // set node as 'alreadyRendered' to ensure we only recycle rowComps that have been rendered, this ensures\n            // we don't reuse rowComps that have been removed and then re-added in the same batch transaction.\n            rowNode.alreadyRendered = true;\n        }\n\n        this.rowCtrlsByRowIndex[rowIndex] = rowCon!;\n\n        return rowCon;\n    }\n\n    private destroyRowCtrls(rowCtrlsMap: RowCtrlMap | null | undefined, animate: boolean): void {\n        const executeInAWhileFuncs: (() => void)[] = [];\n        iterateObject(rowCtrlsMap, (nodeId: string, rowCtrl: RowCtrl) => {\n            // if row was used, then it's null\n            if (!rowCtrl) { return; }\n\n            if (this.cachedRowCtrls && rowCtrl.isCacheable()) {\n                this.cachedRowCtrls.addRow(rowCtrl);\n                return;\n            }\n\n            rowCtrl.destroyFirstPass();\n            if (animate) {\n                this.zombieRowCtrls[rowCtrl.getInstanceId()] = rowCtrl;\n                executeInAWhileFuncs.push(() => {\n                    rowCtrl.destroySecondPass();\n                    delete this.zombieRowCtrls[rowCtrl.getInstanceId()];\n                });\n            } else {\n                rowCtrl.destroySecondPass();\n            }\n        });\n        if (animate) {\n            // this ensures we fire displayedRowsChanged AFTER all the 'executeInAWhileFuncs' get\n            // executed, as we added it to the end of the list.\n            executeInAWhileFuncs.push(() => {\n                this.updateAllRowCtrls();\n                this.dispatchDisplayedRowsChanged();\n            });\n            executeInAWhile(executeInAWhileFuncs);\n        }\n    }\n\n    private checkAngularCompile(): void {\n        // if we are doing angular compiling, then do digest the scope here\n        if (this.gridOptionsWrapper.isAngularCompileRows()) {\n            // we do it in a timeout, in case we are already in an apply\n            window.setTimeout(() => {\n                this.$scope.$apply();\n            }, 0);\n        }\n    }\n\n    private workOutFirstAndLastRowsToRender(): void {\n        let newFirst: number;\n        let newLast: number;\n\n        if (!this.paginationProxy.isRowsToRender()) {\n            newFirst = 0;\n            newLast = -1; // setting to -1 means nothing in range\n        } else if (this.printLayout) {\n            newFirst = this.paginationProxy.getPageFirstRow();\n            newLast = this.paginationProxy.getPageLastRow();\n        } else {\n            const bufferPixels = this.gridOptionsWrapper.getRowBufferInPixels();\n            const gridBodyCon = this.ctrlsService.getGridBodyCtrl();\n\n            let rowHeightsChanged = false;\n            let firstPixel: number;\n            let lastPixel: number;\n            do {\n                const paginationOffset = this.paginationProxy.getPixelOffset();\n                const {pageFirstPixel, pageLastPixel} = this.paginationProxy.getCurrentPagePixelRange();\n                const divStretchOffset = this.rowContainerHeightService.getDivStretchOffset();\n\n                const bodyVRange = gridBodyCon.getScrollFeature().getVScrollPosition();\n                const bodyTopPixel = bodyVRange.top;\n                const bodyBottomPixel = bodyVRange.bottom;\n\n                firstPixel = Math.max(bodyTopPixel + paginationOffset - bufferPixels, pageFirstPixel) + divStretchOffset;\n                lastPixel = Math.min(bodyBottomPixel + paginationOffset + bufferPixels, pageLastPixel) + divStretchOffset;\n\n                // if the rows we are about to display get their heights changed, then that upsets the calcs from above.\n                rowHeightsChanged = this.ensureAllRowsInRangeHaveHeightsCalculated(firstPixel, lastPixel);\n\n            } while (rowHeightsChanged);\n\n            let firstRowIndex = this.paginationProxy.getRowIndexAtPixel(firstPixel);\n            let lastRowIndex = this.paginationProxy.getRowIndexAtPixel(lastPixel);\n\n            const pageFirstRow = this.paginationProxy.getPageFirstRow();\n            const pageLastRow = this.paginationProxy.getPageLastRow();\n\n            // adjust, in case buffer extended actual size\n            if (firstRowIndex < pageFirstRow) {\n                firstRowIndex = pageFirstRow;\n            }\n\n            if (lastRowIndex > pageLastRow) {\n                lastRowIndex = pageLastRow;\n            }\n\n            newFirst = firstRowIndex;\n            newLast = lastRowIndex;\n        }\n\n        // sometimes user doesn't set CSS right and ends up with grid with no height and grid ends up\n        // trying to render all the rows, eg 10,000+ rows. this will kill the browser. so instead of\n        // killing the browser, we limit the number of rows. just in case some use case we didn't think\n        // of, we also have a property to not do this operation.\n        const rowLayoutNormal = this.gridOptionsWrapper.getDomLayout() === Constants.DOM_LAYOUT_NORMAL;\n        const suppressRowCountRestriction = this.gridOptionsWrapper.isSuppressMaxRenderedRowRestriction();\n        const rowBufferMaxSize = Math.max(this.gridOptionsWrapper.getRowBuffer(), 500);\n\n        if (rowLayoutNormal && !suppressRowCountRestriction) {\n            if (newLast - newFirst > rowBufferMaxSize) {\n                newLast = newFirst + rowBufferMaxSize;\n            }\n        }\n\n        const firstDiffers = newFirst !== this.firstRenderedRow;\n        const lastDiffers = newLast !== this.lastRenderedRow;\n\n        if (firstDiffers || lastDiffers) {\n            this.firstRenderedRow = newFirst;\n            this.lastRenderedRow = newLast;\n\n            const event: ViewportChangedEvent = {\n                type: Events.EVENT_VIEWPORT_CHANGED,\n                firstRow: newFirst,\n                lastRow: newLast,\n                api: this.gridApi,\n                columnApi: this.columnApi\n            };\n\n            this.eventService.dispatchEvent(event);\n        }\n\n        // only dispatch firstDataRendered if we have actually rendered some data\n        if (this.paginationProxy.isRowsToRender()) {\n            const event: FirstDataRenderedEvent = {\n                type: Events.EVENT_FIRST_DATA_RENDERED,\n                firstRow: newFirst,\n                lastRow: newLast,\n                api: this.gridApi,\n                columnApi: this.columnApi\n            };\n\n            // added a small delay here because in some scenarios this can be fired\n            // before the grid is actually rendered, causing component creation\n            // on EVENT_FIRST_DATA_RENDERED to fail.\n            window.setTimeout(() => this.eventService.dispatchEventOnce(event), 50);\n        }\n    }\n\n    private ensureAllRowsInRangeHaveHeightsCalculated(topPixel: number, bottomPixel: number): boolean {\n        // ensureRowHeightsVisible only works with CSRM, as it's the only row model that allows lazy row height calcs.\n        // all the other row models just hard code so the method just returns back false\n        const res = this.paginationProxy.ensureRowHeightsValid(topPixel, bottomPixel, -1, -1);\n\n        if (res) {\n            this.updateContainerHeights();\n        }\n\n        return res;\n    }\n\n    public getFirstVirtualRenderedRow() {\n        return this.firstRenderedRow;\n    }\n\n    public getLastVirtualRenderedRow() {\n        return this.lastRenderedRow;\n    }\n\n    // check that none of the rows to remove are editing or focused as:\n    // a) if editing, we want to keep them, otherwise the user will loose the context of the edit,\n    //    eg user starts editing, enters some text, then scrolls down and then up, next time row rendered\n    //    the edit is reset - so we want to keep it rendered.\n    // b) if focused, we want ot keep keyboard focus, so if user ctrl+c, it goes to clipboard,\n    //    otherwise the user can range select and drag (with focus cell going out of the viewport)\n    //    and then ctrl+c, nothing will happen if cell is removed from dom.\n    // c) if detail record of master detail, as users complained that the context of detail rows\n    //    was getting lost when detail row out of view. eg user expands to show detail row,\n    //    then manipulates the detail panel (eg sorts the detail grid), then context is lost\n    //    after detail panel is scrolled out of / into view.\n    private doNotUnVirtualiseRow(rowComp: RowCtrl): boolean {\n        const REMOVE_ROW: boolean = false;\n        const KEEP_ROW: boolean = true;\n        const rowNode = rowComp.getRowNode();\n\n        const rowHasFocus = this.focusService.isRowNodeFocused(rowNode);\n        const rowIsEditing = rowComp.isEditing();\n        const rowIsDetail = rowNode.detail;\n\n        const mightWantToKeepRow = rowHasFocus || rowIsEditing || rowIsDetail;\n\n        // if we deffo don't want to keep it,\n        if (!mightWantToKeepRow) {\n            return REMOVE_ROW;\n        }\n\n        // editing row, only remove if it is no longer rendered, eg filtered out or new data set.\n        // the reason we want to keep is if user is scrolling up and down, we don't want to loose\n        // the context of the editing in process.\n        const rowNodePresent = this.paginationProxy.isRowPresent(rowNode);\n        return rowNodePresent ? KEEP_ROW : REMOVE_ROW;\n    }\n\n    private createRowCon(rowNode: RowNode, animate: boolean, afterScroll: boolean): RowCtrl {\n\n        const rowCtrlFromCache = this.cachedRowCtrls ? this.cachedRowCtrls.getRow(rowNode) : null;\n        if (rowCtrlFromCache) { return rowCtrlFromCache; }\n        \n        // we don't use animations frames for printing, so the user can put the grid into print mode\n        // and immediately print - otherwise the user would have to wait for the rows to draw in the background\n        // (via the animation frames) which is awkward to do from code.\n        \n        // we only do the animation frames after scrolling, as this is where we want the smooth user experience.\n        // having animation frames for other times makes the grid look 'jumpy'.\n\n        const suppressAnimationFrame = this.gridOptionsWrapper.isSuppressAnimationFrame();\n        const useAnimationFrameForCreate = afterScroll && !suppressAnimationFrame && !this.printLayout;\n\n        const res = new RowCtrl(\n            this.$scope,\n            rowNode,\n            this.beans,\n            animate,\n            useAnimationFrameForCreate,\n            this.printLayout\n        );\n\n        return res;\n    }\n\n    public getRenderedNodes() {\n        const renderedRows = this.rowCtrlsByRowIndex;\n\n        return Object.keys(renderedRows).map(key => renderedRows[key]!.getRowNode());\n    }\n\n    public getRowByPosition(rowPosition: RowPosition): RowCtrl | null {\n        let rowComponent: RowCtrl | null;\n        switch (rowPosition.rowPinned) {\n            case Constants.PINNED_TOP:\n                rowComponent = this.topRowCtrls[rowPosition.rowIndex];\n                break;\n            case Constants.PINNED_BOTTOM:\n                rowComponent = this.bottomRowCtrls[rowPosition.rowIndex];\n                break;\n            default:\n                rowComponent = this.rowCtrlsByRowIndex[rowPosition.rowIndex];\n                break;\n        }\n\n        return rowComponent;\n    }\n\n    public getRowNode(gridRow: RowPosition): RowNode | undefined {\n        switch (gridRow.rowPinned) {\n            case Constants.PINNED_TOP:\n                return this.pinnedRowModel.getPinnedTopRowData()[gridRow.rowIndex];\n            case Constants.PINNED_BOTTOM:\n                return this.pinnedRowModel.getPinnedBottomRowData()[gridRow.rowIndex];\n            default:\n                return this.rowModel.getRow(gridRow.rowIndex);\n        }\n    }\n\n    // returns true if any row between startIndex and endIndex is rendered. used by\n    // SSRM or IRM, as they don't want to purge visible blocks from cache.\n    public isRangeInRenderedViewport(startIndex: number, endIndex: number): boolean {\n\n        // parent closed means the parent node is not expanded, thus these blocks are not visible\n        const parentClosed = startIndex == null || endIndex == null;\n        if (parentClosed) { return false; }\n\n        const blockAfterViewport = startIndex > this.lastRenderedRow;\n        const blockBeforeViewport = endIndex < this.firstRenderedRow;\n        const blockInsideViewport = !blockBeforeViewport && !blockAfterViewport;\n\n        return blockInsideViewport;\n    }\n}\n\nclass RowCtrlCache {\n\n    // map for fast access\n    private entriesMap: RowCtrlMap = {};\n\n    // list for keeping order\n    private entriesList: RowCtrl[] = [];\n\n    private readonly maxCount: number;\n\n    constructor(maxCount: number) {\n        this.maxCount = maxCount;\n    }\n\n    private toString(): string {\n        return this.entriesList.map(item => item.getRowNode().data.name).join(', ');\n    }\n\n    public addRow(rowCtrl: RowCtrl): void {\n        this.entriesMap[rowCtrl.getRowNode().id!] = rowCtrl;\n        this.entriesList.push(rowCtrl);\n        rowCtrl.setCached(true);\n\n        if (this.entriesList.length>this.maxCount) {\n            const rowCtrlToDestroy = this.entriesList[0];\n            rowCtrlToDestroy.destroyFirstPass();\n            rowCtrlToDestroy.destroySecondPass();\n            this.removeFromCache(rowCtrlToDestroy);\n        }\n    }\n\n    public getRow(rowNode: RowNode): RowCtrl | null {\n        if (rowNode==null || rowNode.id==null) { return null;}\n\n        const res = this.entriesMap[rowNode.id];\n\n        if (!res) { return null; }\n\n        this.removeFromCache(res);\n        res.setCached(false);\n\n        // this can happen if user reloads data, and a new RowNode is reusing\n        // the same ID as the old one\n        const rowNodeMismatch = res.getRowNode() != rowNode;\n\n        return rowNodeMismatch ? null : res;\n    }\n\n    private removeFromCache(rowCtrl: RowCtrl): void {\n        const rowNodeId = rowCtrl.getRowNode().id!;\n        delete this.entriesMap[rowNodeId];\n        removeFromArray(this.entriesList, rowCtrl);\n    }\n\n    public getEntries(): RowCtrl[] {\n        return this.entriesList;\n    }\n}\n\nexport interface RefreshViewParams {\n    recycleRows?: boolean;\n    animate?: boolean;\n    suppressKeepFocus?: boolean;\n    onlyBody?: boolean;\n    // when new data, grid scrolls back to top\n    newData?: boolean;\n    newPage?: boolean;\n}\n"]}