{"version":3,"sources":["shared/reactComponent.ts"],"names":[],"mappings":"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","file":"reactComponent.js","sourcesContent":["import { ReactPortal } from 'react';\nimport { _, ComponentType, IComponent, WrappableInterface } from '@ag-grid-community/core';\nimport { assignProperties } from './utils';\nimport { PortalManager } from './portalManager';\n\nabstract class BaseReactComponent implements IComponent<any>, WrappableInterface {\n    abstract getGui(): HTMLElement;\n\n    abstract getFrameworkComponentInstance(): any;\n\n    abstract rendered(): boolean;\n\n    abstract getReactComponentName(): string;\n\n    abstract hasMethod(name: string): boolean;\n\n    abstract callMethod(name: string, args: IArguments): void;\n\n    abstract addMethod(name: string, callback: Function): void;\n\n}\n\nexport abstract class ReactComponent extends BaseReactComponent {\n\n    protected eParentElement!: HTMLElement;\n    protected componentInstance: any;\n    protected reactComponent: any;\n    protected portalManager: PortalManager;\n    protected portal: ReactPortal | null = null;\n    protected statelessComponent: boolean;\n    protected componentType: ComponentType;\n\n    constructor(reactComponent: any, portalManager: PortalManager, componentType: ComponentType) {\n        super();\n\n        this.reactComponent = reactComponent;\n        this.portalManager = portalManager;\n        this.componentType = componentType;\n\n        this.statelessComponent = this.isStateless(this.reactComponent);\n    }\n\n    public getGui(): HTMLElement {\n        return this.eParentElement;\n    }\n\n    public destroy(): void {\n        if(this.componentInstance && typeof this.componentInstance.destroy == 'function') {\n            this.componentInstance.destroy();\n        }\n        return this.portalManager.destroyPortal(this.portal as ReactPortal);\n    }\n\n    protected createParentElement(params: any) {\n        const componentWrappingElement = this.portalManager.getComponentWrappingElement();\n        const eParentElement = document.createElement(componentWrappingElement || 'div');\n\n        _.addCssClass(eParentElement as HTMLElement, 'ag-react-container');\n\n        // DEPRECATED - use componentInstance.getReactContainerStyle or componentInstance.getReactContainerClasses instead\n        // so user can have access to the react container, to add css class or style\n        params.reactContainer = eParentElement;\n\n        return eParentElement;\n    }\n\n    protected addParentContainerStyleAndClasses() {\n        if (!this.componentInstance) {\n            return;\n        }\n\n        if (this.componentInstance.getReactContainerStyle && this.componentInstance.getReactContainerStyle()) {\n            assignProperties(this.eParentElement.style, this.componentInstance.getReactContainerStyle());\n        }\n\n        if (this.componentInstance.getReactContainerClasses && this.componentInstance.getReactContainerClasses()) {\n            const parentContainerClasses: string[] = this.componentInstance.getReactContainerClasses();\n            parentContainerClasses.forEach(className => _.addCssClass(this.eParentElement, className));\n        }\n    }\n\n    public statelessComponentRendered(): boolean {\n        // fixed fragmentsFuncRendererCreateDestroy funcRendererWithNan (changeDetectionService too for NaN)\n        return this.eParentElement.childElementCount > 0 || this.eParentElement.childNodes.length > 0;\n    }\n\n    public getFrameworkComponentInstance(): any {\n        return this.componentInstance;\n    }\n\n    public isStatelessComponent(): boolean {\n        return this.statelessComponent;\n    }\n\n    public getReactComponentName(): string {\n        return this.reactComponent.name;\n    }\n\n    public getMemoType() {\n        return this.hasSymbol() ? Symbol.for('react.memo') : 0xead3;\n    }\n\n    private hasSymbol() {\n        return typeof Symbol === 'function' && Symbol.for;\n    }\n\n    protected isStateless(Component: any) {\n        return (typeof Component === 'function' && !(Component.prototype && Component.prototype.isReactComponent))\n            || (typeof Component === 'object' && Component.$$typeof === this.getMemoType());\n    }\n\n    hasMethod(name: string): boolean {\n        const frameworkComponentInstance = this.getFrameworkComponentInstance();\n        return (!!frameworkComponentInstance && frameworkComponentInstance[name] !== null) ||\n            this.fallbackMethodAvailable(name);\n    }\n\n    callMethod(name: string, args: IArguments): void {\n        const frameworkComponentInstance = this.getFrameworkComponentInstance();\n\n        if(this.isStatelessComponent()) {\n            return this.fallbackMethod(name, !!args && args[0] ? args[0] : {});\n        } else if(!(!!frameworkComponentInstance)) {\n            // instance not ready yet - wait for it\n            setTimeout(() => this.callMethod(name, args));\n            return;\n        }\n\n        const method = frameworkComponentInstance[name];\n\n        if (!!method) {\n            return method.apply(frameworkComponentInstance, args);\n        }\n\n        if (this.fallbackMethodAvailable(name)) {\n            return this.fallbackMethod(name, !!args && args[0] ? args[0] : {});\n        }\n    }\n\n    addMethod(name: string, callback: Function): void {\n        (this as any)[name] = callback;\n    }\n\n    protected abstract fallbackMethod(name: string, params: any): any;\n\n    protected abstract fallbackMethodAvailable(name: string): boolean;\n\n    public abstract isNullValue(): boolean;\n}\n"]}